# args

# Entendendo o Atributo `args` da Chave `build` no Docker Compose

## Título da Explicação: Flexibilizando Construções de Imagens Docker: O Papel do Atributo `args` no Docker Compose

### Introdução

No universo do desenvolvimento de aplicações conteinerizadas com Docker e orquestradas com Docker Compose, a construção de imagens é um pilar fundamental. Frequentemente, é necessário que essa construção seja flexível e adaptável a diferentes ambientes ou configurações. É aqui que o atributo `args` da chave `build` no `docker-compose.yml` desempenha um papel crucial, permitindo a injeção de variáveis de ambiente diretamente no processo de build do Dockerfile, sem a necessidade de modificações no código-fonte da imagem.

### Sumário

Esta explicação detalhada abordará os seguintes pontos:

- **Conceitos Fundamentais:** O que são `build arguments` e sua importância.
- **Sintaxe Detalhada e Uso Prático:** Como declarar e utilizar `args` no Docker Compose com exemplos.
- **Cenários de Restrição ou Não Aplicação:** Quando o `args` pode não ser a melhor escolha.
- **Componentes Chave Associados:** A relação intrínseca entre `args` e a instrução `ARG` no Dockerfile.
- **Melhores Práticas e Padrões de Uso:** Recomendações para um uso eficiente e seguro.
- **Exemplo Prático Completo:** Um cenário de ponta a ponta demonstrando a aplicação real do `args`.

---

### Conceitos Fundamentais

O atributo `args` no `docker-compose.yml` está intrinsecamente ligado à instrução `ARG` dentro de um `Dockerfile`. Juntos, eles formam um mecanismo poderoso para parametrizar o processo de construção de uma imagem Docker.

**O que são Build Arguments?**
Build arguments (ou argumentos de construção) são variáveis que podem ser passadas para o Docker Engine durante o processo de construção de uma imagem. Diferentemente das variáveis de ambiente de tempo de execução (`ENV`), os `ARG`s são apenas acessíveis durante o processo de *build* e não persistem na imagem final, a menos que sejam explicitamente passados para `ENV` dentro do Dockerfile.

**Propósito e Importância do `args`:**
O principal propósito do `args` é permitir a criação de imagens Docker mais genéricas e reutilizáveis. Ele elimina a necessidade de criar vários Dockerfiles ligeiramente diferentes para atender a variações ambientais ou de configuração. Por exemplo, você pode usar `args` para:

- **Definir versões de software:** Baixar uma versão específica de uma dependência.
- **Controlar o ambiente de build:** Ligar/desligar funcionalidades de depuração.
- **Injetar informações de construção:** Como um hash de commit Git ou um número de build.
- **Gerenciar segredos (com cautela):** Embora não recomendado para segredos sensíveis, pode ser usado para chaves públicas ou tokens de API que não precisam de alta segurança (com ressalvas, veja seção de restrições).

A importância reside na flexibilidade e na aderência ao princípio "Don't Repeat Yourself" (DRY), centralizando a lógica de construção no Dockerfile e externalizando as variáveis voláteis para o arquivo Compose.

---

### Sintaxe Detalhada e Uso Prático

O atributo `args` é aninhado sob a chave `build` de um serviço no `docker-compose.yml`. Ele pode ser especificado de duas formas principais: como um mapeamento (dicionário) ou como uma lista.

**1. Sintaxe como Mapeamento (Dicionário):**
Esta é a forma mais comum e recomendada por sua clareza e legibilidade. Cada par chave-valor no mapeamento representa o nome do argumento de build e seu respectivo valor.

```yaml
# docker-compose.yml
version: '3.8'
services:
  minha-app:
    build:
      context: . # Onde o Dockerfile está localizado
      dockerfile: Dockerfile.minha-app # Opcional: especifica um Dockerfile diferente
      args:
        # Chave: Nome do argumento no Dockerfile
        # Valor: Valor a ser passado para o argumento
        APP_VERSION: 1.0.0
        BUILD_ENV: production
        API_BASE_URL: <https://api.exemplo.com/v1>

```

**Exemplo Prático com Dockerfile:**

Considere o seguinte `Dockerfile` (`Dockerfile.minha-app`):

```
# Dockerfile.minha-app
# Definindo argumentos que podem ser passados durante o build
ARG APP_VERSION
ARG BUILD_ENV
ARG API_BASE_URL=http://localhost:8080 # Valor padrão, pode ser sobrescrito

FROM alpine:latest

# Utilizando os argumentos no processo de build
RUN echo "Construindo a aplicação versão: $APP_VERSION para o ambiente: $BUILD_ENV" > /build_info.txt
RUN echo "URL da API base: $API_BASE_URL" >> /build_info.txt

# Copiando arquivos (exemplo)
COPY . /app

WORKDIR /app

# Exemplo de como converter um ARG em ENV (persiste na imagem final)
ENV RUNTIME_API_BASE_URL=${API_BASE_URL}

CMD ["sh", "-c", "cat /build_info.txt && sleep infinity"]

```

Ao executar `docker compose build minha-app` ou `docker compose up`, o Docker Compose passará os valores definidos em `args` para o `Dockerfile.minha-app`.

**2. Sintaxe como Lista:**
Esta sintaxe é mais concisa e útil quando os valores dos argumentos são simples ou vêm de variáveis de ambiente do próprio shell. Cada item da lista é uma string no formato `KEY=VALUE`.

```yaml
# docker-compose.yml
version: '3.8'
services:
  minha-outra-app:
    build:
      context: .
      args:
        - DB_HOST=db.producao.com
        - DEBUG_MODE=false
        - COMMIT_SHA=${GIT_COMMIT_SHA:-unknown} # Pode referenciar variáveis de ambiente do shell

```

**Exemplo Prático com Dockerfile:**

Considere o seguinte `Dockerfile` (nome padrão `Dockerfile`):

```
# Dockerfile
ARG DB_HOST
ARG DEBUG_MODE
ARG COMMIT_SHA

FROM ubuntu:latest

# Instalando pacotes com base em argumentos
RUN if [ "$DEBUG_MODE" = "true" ]; then apt-get update && apt-get install -y curl; fi

# Exibindo informações dos argumentos
RUN echo "Conectando ao banco de dados em: $DB_HOST" > /config.txt
RUN echo "SHA do Commit: $COMMIT_SHA" >> /config.txt

CMD ["sh", "-c", "cat /config.txt && sleep infinity"]

```

Neste caso, você poderia definir a variável `GIT_COMMIT_SHA` no seu ambiente shell antes de executar o Docker Compose: `export GIT_COMMIT_SHA=$(git rev-parse HEAD)`.

**Variações de Sintaxe e Comportamento:**

- **Argumentos Sem Valor (Lista):** É possível listar um argumento sem um valor explícito, como `ARG_NAME`. Neste caso, o Docker esperará que o valor seja fornecido de outras formas (ex: via `docker build --build-arg ARG_NAME=value`) ou usará o valor padrão definido no Dockerfile. Se não houver valor padrão e nenhum valor for fornecido, o argumento ficará vazio.
    
    ```yaml
    build:
      context: .
      args:
        - FOO
    
    ```
    
    Se `FOO` não tiver um valor padrão no Dockerfile e não for passado de outra forma, ele será `null` ou uma string vazia no build.
    
- **Precedência:** Se um argumento de build for definido em múltiplas fontes (e.g., no `Dockerfile` com um valor padrão, no `docker-compose.yml` via `args`, e na linha de comando via `docker build --build-arg`), a precedência segue a ordem:
    1. Linha de comando (`-build-arg`)
    2. `docker-compose.yml` (`args`)
    3. `Dockerfile` (`ARG` com valor padrão)

---

### Cenários de Restrição ou Não Aplicação

Embora `args` seja uma ferramenta poderosa, existem situações em que seu uso pode ser inadequado ou apresentar limitações:

- **Segurança (Senhas e Chaves Sensíveis):** **NÃO use `args` para passar senhas, chaves de API, tokens ou quaisquer outras informações altamente sensíveis.** Os valores passados via `args` são gravados no histórico de camadas da imagem Docker. Isso significa que, se alguém tiver acesso à sua imagem, poderá inspecionar o histórico e extrair esses segredos. Para gerenciamento de segredos, utilize:
    - Docker Secrets (para tempo de execução).
    - Sistemas de gerenciamento de segredos externos (HashiCorp Vault, AWS Secrets Manager).
    - Docker BuildKit `secret` mounts para build time secrets (necessita de BuildKit habilitado e não é diretamente suportado pelo `args` do Compose, mas sim por instruções no Dockerfile com `RUN --mount=type=secret`).
- **Impacto no Cache de Build:** Alterar o valor de um `ARG` invalida o cache de build a partir do ponto onde o `ARG` é declarado no Dockerfile. Isso pode ser benéfico se você *quiser* que a build seja refeita, mas pode ser um problema se as mudanças forem frequentes e apenas um pequeno detalhe do `ARG` foi alterado, levando a builds desnecessariamente longas.
- **Excesso de Complexidade:** Se você precisa de um número muito grande de argumentos ou se a lógica para determinar esses argumentos se torna excessivamente complexa, isso pode indicar que o Dockerfile está tentando fazer "demais". Nesses casos, pode ser mais apropriado dividir o Dockerfile em múltiplos estágios de build ou refatorar a lógica de sua aplicação.
- **Informações que Dependem do Ambiente de Tempo de Execução:** `args` são para o *build time*. Se a informação só for conhecida no *runtime* (ex: nome de host dinâmico, variáveis de ambiente de um orquestrador), use variáveis de ambiente com `environment` no Compose ou passe-as diretamente no comando `docker run`.

---

### Componentes Chave Associados

A compreensão completa do `args` no Docker Compose exige um conhecimento da instrução `ARG` no Dockerfile.

**`ARG` no Dockerfile:**
A instrução `ARG` no Dockerfile é usada para definir uma variável que os usuários podem passar para o construtor no tempo de construção da imagem.

- **Sintaxe:** `ARG <nome_do_argumento>[=<valor_padrao>]`
- **Comportamento:**
    - Se um `ARG` é declarado sem um valor padrão, ele deve ser fornecido via `args` no Compose ou `-build-arg` na linha de comando, ou ele resultará em um erro (dependendo da versão do Docker/Compose, pode ser uma string vazia).
    - Se um `ARG` é declarado com um valor padrão, este valor será usado a menos que seja sobrescrito por `args` ou `-build-arg`.
    - Os argumentos de build são acessíveis a partir de qualquer instrução do Dockerfile que venha *depois* de sua declaração (como `RUN`, `COPY`, `ADD`, `ENV`, etc.).
    - Um `ARG` pode ser usado para definir o valor de uma variável `ENV`. Neste caso, a variável `ENV` persistirá na imagem final.

**Exemplo da Interação `ARG` e `ENV`:**

```
# Dockerfile
ARG MY_VERSION=1.0.0
ENV APP_VERSION=${MY_VERSION} # MY_VERSION é um ARG, APP_VERSION é um ENV

FROM alpine:latest

# MY_VERSION pode ser usado aqui
RUN echo "Versão intermediária: ${MY_VERSION}"

# APP_VERSION estará disponível na imagem final e durante o runtime
CMD ["echo", "A aplicação está na versão: $APP_VERSION"]

```

No `docker-compose.yml`:

```yaml
services:
  minha-app:
    build:
      context: .
      args:
        MY_VERSION: 2.0.0 # Sobrescreve o valor padrão de MY_VERSION

```

Neste exemplo, `MY_VERSION` será `2.0.0` durante o build, e `APP_VERSION` também será definido como `2.0.0` na imagem final.

---

### Melhores Práticas e Padrões de Uso

Para otimizar o uso do `args` e garantir builds robustas e seguras:

1. **Use Nomes Descritivos:** Dê nomes claros e autoexplicativos aos seus argumentos (ex: `APP_VERSION`, `GIT_COMMIT_SHA`).
2. **Defina Valores Padrão no Dockerfile:** Sempre que possível, forneça um valor padrão para seus `ARG`s no Dockerfile. Isso torna o Dockerfile mais autônomo e facilita o desenvolvimento local, além de garantir que a build não falhe se um argumento não for fornecido.
3. **Evite Segredos:** **Nunca use `args` para segredos sensíveis.** Como já mencionado, eles ficam no histórico de camadas da imagem.
4. **Minimizar o Impacto no Cache:** Organize seu Dockerfile de forma que as instruções que dependem de `ARG`s que mudam com frequência venham depois das instruções que não mudam. Isso permite que o Docker utilize o cache para as camadas anteriores.
5. **Documente seus `ARG`s:** Adicione comentários no seu Dockerfile explicando o propósito de cada `ARG` e como ele deve ser usado.
6. **Use Variáveis de Ambiente do Shell:** Para valores que mudam por ambiente de deploy ou por execução, como hashes de commit ou IDs de build, utilize a sintaxe `${VAR_NAME}` no seu `docker-compose.yml` para puxar valores do ambiente shell.
    
    ```yaml
    services:
      app:
        build:
          context: .
          args:
            BUILD_DATE: ${DATE_STAMP:-$(date +%F)} # Pega do shell ou gera dinamicamente
    
    ```
    
7. **Validação e Sanitização:** Se os valores dos argumentos de build forem críticos, considere adicionar lógica de validação ou sanitização dentro do seu Dockerfile (ex: usando scripts `RUN` complexos) para garantir que os valores recebidos são válidos antes de serem usados.

---

### Exemplo Prático Completo: Aplicação Web Multi-Ambiente

Vamos construir um exemplo completo de uma aplicação web simples que precisa de diferentes configurações de build para ambientes de desenvolvimento e produção, usando o atributo `args`.

**Estrutura do Projeto:**

```
.
├── docker-compose.yml
├── app/
│   ├── Dockerfile
│   └── main.py
└── scripts/
    └── generate_version_info.sh

```

**1. `app/main.py` (Simulação de Aplicação Python):**

```python
# app/main.py
import os

def get_build_info():
    version = os.getenv("APP_VERSION", "N/A")
    env = os.getenv("BUILD_ENVIRONMENT", "N/A")
    message = os.getenv("BUILD_MESSAGE", "N/A")
    return f"App Version: {version}\\nEnvironment: {env}\\nBuild Message: {message}"

if __name__ == "__main__":
    print(get_build_info())

```

**2. `scripts/generate_version_info.sh` (Script auxiliar para o build):**

```bash
# scripts/generate_version_info.sh
#!/bin/bash
echo "BUILD_DATE=$(date +%Y-%m-%d %H:%M:%S)"
echo "GIT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo 'unknown')"
echo "USER_BUILDING=$USER"

```

*Observação: Para que `git rev-parse HEAD` funcione, você precisaria de um repositório Git inicializado na raiz do seu projeto. Se não houver, ele retornará 'unknown'.*

**3. `app/Dockerfile`:**

```
# app/Dockerfile
# Definindo argumentos de build
ARG PYTHON_VERSION=3.9-alpine
ARG BUILD_ENVIRONMENT=development
ARG CUSTOM_BUILD_MESSAGE="Standard build for local development."

# Usando um ARG para definir a imagem base
FROM python:${PYTHON_VERSION}

WORKDIR /app

# Copiando o script de geração de informações
COPY scripts/generate_version_info.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/generate_version_info.sh

# Gerando informações dinâmicas de build
RUN /usr/local/bin/generate_version_info.sh > /build_info.txt

# Usando ARGs para definir ENVs que persistem na imagem final
ENV APP_VERSION="1.0.0"
ENV BUILD_ENVIRONMENT=${BUILD_ENVIRONMENT}
ENV BUILD_MESSAGE=${CUSTOM_BUILD_MESSAGE}

# Adicionando informações geradas pelo script ao ambiente
RUN while IFS= read -r line; do export "$line"; done < /build_info.txt && \\
    echo "BUILD_DATE=${BUILD_DATE}" >> /etc/environment && \\
    echo "GIT_COMMIT=${GIT_COMMIT}" >> /etc/environment && \\
    echo "USER_BUILDING=${USER_BUILDING}" >> /etc/environment

# Expondo a porta (exemplo, não usado nesta aplicação simples)
EXPOSE 8000

COPY app/main.py .

CMD ["python", "main.py"]

```

**4. `docker-compose.yml` (Configurações para diferentes ambientes):**

```yaml
# docker-compose.yml
version: '3.8'

services:
  app-dev:
    build:
      context: .
      dockerfile: app/Dockerfile
      args:
        # Configurações para ambiente de desenvolvimento
        PYTHON_VERSION: 3.10-alpine # Usar uma versão mais recente para dev
        BUILD_ENVIRONMENT: development
        CUSTOM_BUILD_MESSAGE: "Development build - for local testing."
    container_name: my_app_dev
    # volumes:
    #   - ./app:/app # Montar código para hot-reloading em dev

  app-prod:
    build:
      context: .
      dockerfile: app/Dockerfile
      args:
        # Configurações para ambiente de produção
        PYTHON_VERSION: 3.9-alpine # Usar uma versão estável e testada para prod
        BUILD_ENVIRONMENT: production
        CUSTOM_BUILD_MESSAGE: "Production release build - deployed to servers."
        # Exemplo de ARG vindo do ambiente do shell:
        # PODE_SER_ENV: ${VAR_DO_SHELL:-PADRAO}
    container_name: my_app_prod
    # restart: always # Configuração de restart para produção

```

**Como Executar:**

1. **Navegue até a raiz do seu projeto** no terminal.
2. **Para construir e executar a versão de desenvolvimento:**
    
    ```bash
    docker compose up --build app-dev
    
    ```
    
    Você verá a saída:
    
    ```
    App Version: 1.0.0
    Environment: development
    Build Message: Development build - for local testing.
    
    ```
    
    E também as informações geradas pelo script (`BUILD_DATE`, `GIT_COMMIT`, `USER_BUILDING`) estarão disponíveis no ambiente do contêiner.
    
3. **Para construir e executar a versão de produção:**
    
    ```bash
    docker compose up --build app-prod
    
    ```
    
    Você verá a saída:
    
    ```
    App Version: 1.0.0
    Environment: production
    Build Message: Production release build - deployed to servers.
    
    ```
    

Este exemplo demonstra como o `args` permite que um único Dockerfile sirva para diferentes cenários, sendo configurado dinamicamente através do `docker-compose.yml`, o que é uma prática poderosa para CI/CD e gerenciamento de ambientes.

---

**Sugestões para Aprofundamento:**

- **Docker BuildKit:** Explore as capacidades do BuildKit, que oferece recursos avançados para builds, incluindo gerenciamento de cache aprimorado e suporte a segredos de build (com `RUN --mount=type=secret`). Embora não diretamente ligado a `args` no Compose, é a próxima fronteira para builds Docker. [Documentação Docker BuildKit](https://docs.docker.com/build/buildkit/)
- **Docker Secrets:** Para variáveis de ambiente sensíveis em tempo de execução, estude o uso de Docker Secrets com Docker Compose ou Swarm. [Documentação Docker Secrets](https://docs.docker.com/engine/swarm/secrets/)
- **Variáveis de Ambiente no Compose:** Aprofunde-se no uso da chave `environment` no Docker Compose para variáveis de ambiente em tempo de execução e a diferença clara entre `ARG` e `ENV`. [Documentação Docker Compose Environment](https://www.google.com/search?q=https://docs.docker.com/compose/compose-file/05-services/%23environment)
- **Melhores Práticas de Dockerfile:** Estude as melhores práticas para a criação de Dockerfiles eficientes, pequenos e seguros. [Melhores Práticas para Escrever Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)