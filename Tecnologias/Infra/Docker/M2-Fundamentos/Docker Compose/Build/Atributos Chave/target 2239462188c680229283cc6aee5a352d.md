# target

**Entendendo o atributo `target` na chave `build` do Docker Compose**

---

## Introdução

No Docker Compose, o atributo `build` permite descrever como construir uma imagem Docker para um serviço diretamente no arquivo `docker-compose.yml`. Dentre suas várias opções, o atributo **`target`** é essencial para projetos que usam *multi-stage builds* em seu `Dockerfile`. Ele indica exatamente **qual estágio** do *Dockerfile* deve ser construído, possibilitando otimizar tempo e tamanho de imagem ao focar apenas no estágio desejado([docs.docker.com](https://docs.docker.com/reference/compose-file/build/)).

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#sintaxe-detalhada-e-uso-pr%C3%A1tico)
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#componentes-chave-associados)
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#sugest%C3%B5es-para-aprofundamento)

---

## Conceitos Fundamentais

- **Multi-Stage Builds**
    
    Um *multi-stage build* é uma técnica no Dockerfile onde múltiplos estágios (`FROM … AS <nome>`) são encadeados. Cada estágio pode preparar artefatos diferentes (compilar, testar, empacotar), mas somente o estágio final normalmente gera a imagem entregue em produção.
    
- **Propósito do `target`**
    
    O `target` indica **qual estágio nomeado** do Dockerfile deve ser construído e utilizado como artefato de saída. Isso permite, por exemplo, construir apenas o estágio de *desenvolvimento* ou somente o estágio de *produção* em diferentes contextos, sem precisar manter Dockerfiles separados ou reconstruir estágios intermediários desnecessários([warp.dev](https://www.warp.dev/terminus/docker-compose-target?utm_source=chatgpt.com), [docs.docker.com](https://docs.docker.com/reference/compose-file/build/)).
    

---

## Sintaxe Detalhada e Uso Prático

No `docker-compose.yml`, dentro de um serviço, o `build` pode ser:

- **String simples**
    
    ```yaml
    services:
      app:
        build: ./caminho/para/contexto
    
    ```
    
- **Objeto detalhado**
    
    ```yaml
    services:
      app:
        build:
          context: ./caminho/para/contexto
          dockerfile: Dockerfile            # opcional: nome/ localização
          target: <nome_do_estagio>         # define o estágio a ser construído
    
    ```
    

### Exemplo de Dockerfile com Multi-Stage

```
# Estágio base
FROM node:14-alpine AS base
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install

# Estágio de desenvolvimento
FROM base AS development
COPY . .
CMD ["yarn", "start"]

# Estágio de produção
FROM node:14-alpine AS production
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production
COPY --from=development /app/dist ./dist
CMD ["node", "dist/index.js"]

```

### Especificando `target` no Compose

Para construir apenas o estágio de produção:

```yaml
version: '3.8'

services:
  webapp:
    build:
      context: .
      dockerfile: Dockerfile
      target: production   # constrói só até o estágio "production"
    image: minha-imagem:prod

```

Nesse caso, o Compose interrompe o build assim que termina o estágio `production`, ignorando quaisquer etapas definidas após ele([docs.docker.com](https://docs.docker.com/reference/compose-file/build/)).

---

## Cenários de Restrição ou Não Aplicação

- **Dockerfiles *single-stage***
    
    Se seu Dockerfile não usa múltiplos estágios, o `target` é irrelevante. O Compose simplesmente ignora esse atributo.
    
- **Estágios não nomeados ou inexistentes**
    
    Se você especificar um `target` que não existe, o build falhará. Certifique-se de que o nome corresponda exatamente ao alias do estágio (`AS <nome>`).
    
- **Cenários de cache e build incremental**
    
    Em etapas onde cache de camadas é crítico, usar `target` pode pular camadas de cache importantes. Use com cautela se precisar de todo o histórico de camadas para otimizações futuras.
    

---

## Componentes Chave Associados

Dentro do objeto `build`, vários atributos interagem com o `target`:

- **`context`**: diretório ou repositório Git usado como contexto de build.
- **`dockerfile`**: caminho/nome do arquivo Dockerfile (resolvido relativo ao `context`).
- **`args`**: *build arguments* para `ARG` statements no Dockerfile.
- **`cache_from` / `cache_to`**: configurações de cache que podem acelerar builds de estágios intermediários.
- **`platforms`**: define quais plataformas (ex: `linux/arm64`) devem ser usadas, afetando as camadas até o `target`.
- **`pull`**, **`no_cache`**, **`secrets`**, **`ssh`**, etc.: impactam diretamente como cada estágio (até o `target`) será executado pelo Docker Engine.

---

## Melhores Práticas e Padrões de Uso

1. **Nomeie estágios de forma clara**
    
    Use nomes como `development`, `test`, `production` para facilitar a referência no Compose.
    
2. **Centralize variáveis de ambiente**
    
    Se múltiplos estágios compartilham variáveis, declare-as no estágio `base` com `ARG` e `ENV`.
    
3. **Use `target` para perfis diferentes**
    - Perfil dev: `target: development`, mapeie volumes e expanda portas.
    - Perfil prod: `target: production`, minimize imagem final.
4. **Combine com profiles do Compose**
    
    Use *profiles* para habilitar ou desabilitar serviços que usam diferentes `target`s conforme ambiente.
    
5. **Aproveite cache de camadas**
    
    Ordem de instruções (`COPY`, `RUN`) até o `target` influencia fortemente no uso de cache e, consequentemente, na velocidade do build.
    

---

## Exemplo Prático Completo

Imagine um monorepo com frontend e backend, ambos usando multi-stage:

```yaml
version: '3.9'
services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: production
    image: minha-registry/frontend:prod
    ports:
      - "3000:80"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: production
    image: minha-registry/backend:prod
    ports:
      - "4000:4000"

```

- Cada serviço aponta para seu próprio Dockerfile com estágios nomeados.
- Em um perfil de desenvolvimento, você poderia sobrescrever `target` para `development`, expor volumes e habilitar *hot-reload*.
- Para produção, `target: production` garante que a imagem seja leve, contendo apenas o artefato final.

---

## Sugestões para Aprofundamento

- Explore a [Compose Specification completa](https://docs.docker.com/reference/compose-file/build/#attributes) para entender todos os atributos do `build`([docs.docker.com](https://docs.docker.com/reference/compose-file/build/)).
- Experimente combinar `target` com [profiles do Docker Compose](https://docs.docker.com/compose/profiles/) para gerenciar configurações específicas de ambiente.
- Leia sobre *buildx* e *multi-platform* builds para usar `target` em cenários de CI/CD que geram imagens para várias arquiteturas.

---

> Conclusão: O atributo target é uma ferramenta poderosa para controlar exatamente até onde um multi-stage build deve ir, otimizando velocidade, tamanho de imagem e flexibilidade entre ambientes de desenvolvimento e produção.
>