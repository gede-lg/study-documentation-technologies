# tags

# Explicação Detalhada do Atributo `tags` na Chave `build` do Docker Compose

## Introdução

No universo do Docker, a construção e o gerenciamento de imagens são tarefas fundamentais. O Docker Compose, uma ferramenta para definir e executar aplicações Docker multi-container, simplifica esse processo ao permitir que você especifique como suas imagens devem ser construídas diretamente no arquivo `docker-compose.yml`. Dentro da chave `build`, que dita o processo de construção de uma imagem a partir de um `Dockerfile`, o atributo `tags` surge como uma funcionalidade poderosa para atribuir múltiplos rótulos a uma imagem recém-construída.

Este documento fornecerá uma explicação abrangente sobre o atributo `tags`, abordando sua finalidade, sintaxe, casos de uso e melhores práticas, garantindo que Gedê e Ju compreendam plenamente seu potencial no fluxo de trabalho de desenvolvimento com Docker.

## Sumário

- **Conceitos Fundamentais:** Entendimento do que são tags de imagem Docker e a importância da chave `build` no Docker Compose.
- **Sintaxe Detalhada e Uso Prático:** Como usar o atributo `tags` no `docker-compose.yml`, incluindo exemplos de código.
- **Cenários de Restrição ou Não Aplicação:** Limitações e alternativas para o uso de `tags`.
- **Componentes Chave Associados:** Relação com o atributo `image` e a versão do Docker Compose.
- **Melhores Práticas e Padrões de Uso:** Recomendações para otimizar a atribuição de tags.
- **Exemplo Prático Completo:** Um cenário demonstrando a aplicação do atributo `tags`.

## Conceitos Fundamentais

### O que são Tags de Imagem Docker?

No Docker, uma "tag" é um rótulo anexado a uma imagem que serve como um identificador para uma versão específica ou uma variante dessa imagem. Pense nas tags como etiquetas que ajudam a organizar e diferenciar suas imagens. Por exemplo, `minha-app:latest`, `minha-app:1.0.0`, e `minha-app:dev` são todas tags diferentes para a imagem `minha-app`. Se nenhuma tag for explicitamente fornecida, o Docker atribui por padrão a tag `latest`.

As tags são cruciais para:

- **Controle de Versão:** Marcar diferentes versões de uma aplicação (ex: `v1.0`, `v1.1`, `v2.0`).
- **Ambientes:** Identificar imagens para diferentes ambientes (ex: `dev`, `staging`, `production`).
- **Variantes:** Distinguir variações de uma imagem (ex: `alpine`, `ubuntu`).
- **Publicação:** Especificar o nome e a versão ao enviar imagens para um registro (Registry) como o Docker Hub.

### A Chave `build` no Docker Compose

A chave `build` em um serviço no arquivo `docker-compose.yml` informa ao Docker Compose que a imagem para esse serviço deve ser construída a partir de um `Dockerfile` e um contexto de construção, em vez de ser puxada de um registro de imagens. É o local onde você especifica o caminho para o seu `Dockerfile`, argumentos de construção, e outras configurações relacionadas ao processo de criação da imagem.

Tradicionalmente, a tag principal de uma imagem construída pelo Docker Compose era determinada pelo atributo `image` do serviço. Se o atributo `image` fosse `meuservico:1.0`, a imagem construída seria automaticamente tagueada como `meuservico:1.0`. No entanto, often, é desejável atribuir múltiplas tags a uma única imagem construída para diferentes propósitos (por exemplo, `meu-app:latest` e `meu-app:1.2.3`). É aqui que o atributo `tags` se torna útil.

## Sintaxe Detalhada e Uso Prático

O atributo `tags` é uma funcionalidade mais recente, disponível a partir do **Docker Compose versão 2.6.0**. Ele permite que você especifique uma lista de tags que serão aplicadas à imagem construída, além de qualquer tag definida no atributo `image` do serviço (se presente).

### Sintaxe

O atributo `tags` é um sub-atributo da chave `build` e aceita uma lista de strings, onde cada string representa uma tag completa para a imagem.

```yaml
version: '3.8' # Ou superior, para garantir compatibilidade com 'tags'
services:
  meu-app:
    build:
      context: . # Caminho para o contexto de construção (onde o Dockerfile está)
      dockerfile: Dockerfile # Nome do Dockerfile, se não for o padrão
      tags:
        - meu-app:latest       # Tag 'latest' para a imagem
        - meu-app:v1.0.0      # Tag de versão específica
        - meu-app:build-xyz   # Tag para um build específico (ex: hash do commit, ID de CI/CD)
    image: meu-app:producao # Opcional: tag principal se você quiser uma default
    ports:
      - "80:80"

```

### Uso Prático e Exemplos Comentados

### Exemplo 1: Múltiplas Tags para Controle de Versão

Imagine que você está desenvolvendo uma aplicação e deseja taguear suas imagens com a versão mais recente e também com uma tag de `latest`.

```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.web
      tags:
        - minha-app-web:1.2.3   # Tag para a versão específica
        - minha-app-web:latest # Tag 'latest'
    image: minha-app-web:producao # Esta tag será adicionada junto com as outras
    ports:
      - "80:80"

```

Ao executar `docker compose build web`, a imagem resultante será tagueada com `minha-app-web:1.2.3`, `minha-app-web:latest` e `minha-app-web:producao`.

### Exemplo 2: Tags para Ambientes e Rastreamento de Builds

Você pode usar o atributo `tags` para diferenciar imagens para ambientes de desenvolvimento e produção, ou para incluir informações de rastreamento de build (como um ID de CI/CD ou hash de commit).

```yaml
# docker-compose.yml
version: '3.8'
services:
  api:
    build:
      context: ./api
      dockerfile: Dockerfile
      tags:
        - meu-servico-api:dev-build-${CI_COMMIT_SHORT_SHA:-local} # Tag dinâmica para dev/CI
        - meu-servico-api:latest # Tag genérica
    image: meu-servico-api:producao # Tag principal para produção, se desejar
    ports:
      - "3000:3000"

```

Neste exemplo, `CI_COMMIT_SHORT_SHA` é uma variável de ambiente que pode ser injetada por um sistema de CI/CD, adicionando uma tag única a cada build. Se a variável não estiver definida (por exemplo, em um ambiente de desenvolvimento local), ela usará `local`.

### Exemplo 3: Apenas Tags Definidas no `build`

Se você deseja que as tags sejam *apenas* as definidas dentro do atributo `tags` e não quer que o Docker Compose infira uma tag do nome do serviço ou do atributo `image` (a menos que seja uma das tags listadas), você pode omitir o atributo `image` no nível do serviço.

```yaml
# docker-compose.yml
version: '3.8'
services:
  worker:
    build:
      context: ./worker
      tags:
        - meu-worker:queue-processor
        - meu-worker:v2
    # image: meu-worker:default-tag # Omitir este atributo se você só quer as tags acima

```

Nesse caso, a imagem construída terá as tags `meu-worker:queue-processor` e `meu-worker:v2`.

## Cenários de Restrição ou Não Aplicação

- **Versão do Docker Compose:** O atributo `tags` só é suportado a partir do Docker Compose **versão 2.6.0**. Se você estiver usando uma versão mais antiga, o Docker Compose ignorará ou reportará um erro sobre o uso de `tags` na chave `build`. Nesses casos, você teria que usar o atributo `image` para definir uma única tag e, se necessário, taguear a imagem manualmente após a construção com `docker tag`.
- **Alternativas para Versões Antigas:** Para versões anteriores do Docker Compose que não suportam o atributo `tags`, a abordagem comum era:
    1. Definir uma tag principal usando o atributo `image` no serviço.
    2. Após a construção (`docker compose build`), usar o comando `docker tag` para adicionar tags adicionais à imagem.
    3. Automatizar o processo de tagueamento em scripts de CI/CD.
- **Conflito com `image` (Comportamento de `pull_policy`):** Se tanto `build` quanto `image` forem especificados para um serviço, e a imagem já existir localmente ou remotamente com a tag especificada em `image`, o Docker Compose pode preferir puxar a imagem existente em vez de construí-la, dependendo da configuração `pull_policy`. O atributo `tags` *adiciona* tags à imagem *construída*, mas não altera o comportamento de `pull_policy` ou a precedência entre `build` e `image` para a origem da imagem principal.

## Componentes Chave Associados

### `build` (Chave Principal)

O atributo `tags` reside dentro da chave `build`. A chave `build` é um objeto que define as configurações de construção da imagem para um serviço. Outros sub-atributos importantes dentro de `build` incluem:

- `context`: O caminho para o diretório de construção do Docker.
- `dockerfile`: O nome do `Dockerfile` (se não for o padrão `Dockerfile`).
- `args`: Argumentos de construção que podem ser passados para o `Dockerfile` (ex: `ARG`).
- `target`: Permite especificar um estágio de build específico em um `Dockerfile` multi-stage.

### `image` (Atributo do Serviço)

O atributo `image` no nível superior do serviço (irmão de `build`) também é relevante. Historicamente, ele era a principal forma de taguear uma imagem construída pelo Docker Compose. Quando `build` e `image` são usados juntos:

- O Docker Compose tentará construir a imagem conforme especificado em `build`.
- A imagem construída será tagueada com o valor especificado em `image` (se presente) **e** com todas as tags listadas no atributo `tags` dentro de `build`.
- Se `image` não for especificado, o Docker Compose ainda pode gerar um nome de imagem padrão (geralmente `<nome_do_projeto>-<nome_do_servico>:<latest>`), e as tags definidas em `tags` serão adicionadas a esta imagem.

### Versão do Docker Compose (Especificação)

A introdução do atributo `tags` é um reflexo da evolução da especificação do Docker Compose. É fundamental que sua versão do Docker Compose (CLI) seja `2.6.0` ou superior para utilizar esta funcionalidade. Você pode verificar sua versão com `docker compose version`.

## Melhores Práticas e Padrões de Uso

1. **Consistência de Nomenclatura:** Mantenha um padrão consistente para seus nomes de imagem e tags. Isso facilita a identificação e o gerenciamento das imagens. Ex: `meu-app/minha-api:1.0.0`, `meu-app/minha-api:latest`.
2. **Uso de Variáveis de Ambiente:** Para tags dinâmicas (como versões, hashes de commit ou IDs de build), utilize variáveis de ambiente. Isso mantém seu `docker-compose.yml` genérico e permite que seu pipeline de CI/CD injete os valores apropriados.
    
    ```yaml
    # docker-compose.yml
    version: '3.8'
    services:
      app:
        build:
          context: .
          tags:
            - "minha-app:${APP_VERSION}"
            - "minha-app:latest"
    
    ```
    
    Você pode então executar `APP_VERSION=1.2.3 docker compose build app`.
    
3. **Tags Específicas vs. `latest`:** Use tags específicas de versão para builds de produção ou para garantir imutabilidade. Use a tag `latest` para o build mais recente do seu branch principal de desenvolvimento ou para facilitar a pull da versão mais atual. É uma boa prática ter ambas as tags: uma tag específica de versão e a tag `latest` apontando para a mesma imagem.
4. **Minimizar Reconstruções Desnecessárias:** O uso de `tags` afeta apenas o tagueamento da imagem após a construção. Para otimizar o processo de construção em si, utilize o cache do Docker (`-no-cache` para ignorar o cache) e os estágios de multi-stage builds em seus Dockerfiles.
5. **Documentação:** Documente claramente as convenções de tagueamento que sua equipe utiliza.

## Exemplo Prático Completo: Aplicação Multi-Serviço com Tags Dinâmicas

Vamos criar um exemplo de uma aplicação web simples com um frontend (Node.js) e um backend (Python), onde usamos o atributo `tags` para gerenciar as versões e ambientes.

**Estrutura de Arquivos:**

```
.
├── docker-compose.yml
├── frontend/
│   ├── Dockerfile
│   └── package.json
│   └── server.js
└── backend/
    ├── Dockerfile
    └── requirements.txt
    └── app.py

```

**`frontend/Dockerfile`:**

```
# Stage de build
FROM node:18-alpine as builder
WORKDIR /app
COPY package.json .
RUN npm install
COPY . .
RUN npm run build # Supondo um script de build para o frontend

# Stage de produção
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist # Copia os artefatos de build
COPY server.js .
EXPOSE 80
CMD ["node", "server.js"]

```

**`backend/Dockerfile`:**

```
# Stage de build
FROM python:3.9-slim-buster as builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .

# Stage de produção
FROM python:3.9-slim-buster
WORKDIR /app
COPY --from=builder /app .
EXPOSE 5000
CMD ["python", "app.py"]

```

**`docker-compose.yml`:**

```yaml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      tags:
        - "minha-app/frontend:${APP_VERSION:-latest}" # Tag de versão dinâmica ou 'latest'
        - "minha-app/frontend:build-${CI_COMMIT_SHORT_SHA:-local}" # Tag de build para rastreamento
    image: minha-app/frontend:dev # Tag default para desenvolvimento se pull_policy permitir
    ports:
      - "80:80"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      tags:
        - "minha-app/backend:${API_VERSION:-latest}" # Tag de versão dinâmica ou 'latest'
        - "minha-app/backend:build-${CI_COMMIT_SHORT_SHA:-local}" # Tag de build para rastreamento
    image: minha-app/backend:dev # Tag default para desenvolvimento
    ports:
      - "5000:5000"

```

**Como Usar:**

1. **Construção Básica (Desenvolvimento Local):**
    
    ```bash
    docker compose build
    
    ```
    
    Isso construirá as imagens com as tags `minha-app/frontend:latest`, `minha-app/frontend:build-local`, `minha-app/frontend:dev` e, para o backend, `minha-app/backend:latest`, `minha-app/backend:build-local`, `minha-app/backend:dev`.
    
2. **Construção com Versão Específica (Simulando CI/CD):**
    
    ```bash
    export APP_VERSION=1.0.0
    export API_VERSION=1.0.0
    export CI_COMMIT_SHORT_SHA=abc123def456
    docker compose build frontend backend
    
    ```
    
    Neste caso, as imagens do frontend terão as tags `minha-app/frontend:1.0.0`, `minha-app/frontend:latest`, `minha-app/frontend:build-abc123def456` e `minha-app/frontend:dev`. O mesmo se aplica ao backend com `API_VERSION`.
    
3. **Verificar as Imagens Construídas:**
Após a construção, você pode listar suas imagens para ver as tags aplicadas:
    
    ```bash
    docker images | grep minha-app
    
    ```
    
    Você verá entradas como:
    
    ```
    minha-app/frontend    1.0.0             <IMAGE_ID>   ...
    minha-app/frontend    latest            <IMAGE_ID>   ...
    minha-app/frontend    build-abc123def456 <IMAGE_ID>   ...
    minha-app/frontend    dev               <IMAGE_ID>   ...
    minha-app/backend     1.0.0             <IMAGE_ID>   ...
    minha-app/backend     latest            <IMAGE_ID>   ...
    minha-app/backend     build-abc123def456 <IMAGE_ID>   ...
    minha-app/backend     dev               <IMAGE_ID>   ...
    
    ```
    
    Observe que todas essas tags apontam para o mesmo `IMAGE_ID`, indicando que são apenas diferentes rótulos para a mesma imagem.
    

Este exemplo demonstra como o atributo `tags` oferece uma maneira flexível e declarativa de aplicar múltiplos identificadores às suas imagens Docker diretamente do seu arquivo Compose, simplificando o gerenciamento de versões e o rastreamento em diferentes estágios do ciclo de vida do desenvolvimento.

---

Espero que esta explicação detalhada, A.R.I.A, seja útil para você, Gedê, e para a Ju\! Se tiver mais alguma dúvida, é só perguntar.

**Referências Adicionais:**

- [Compose Build Specification - Docker Docs](https://docs.docker.com/reference/compose-file/build/)
- [docker image tag - Docker Docs](https://docs.docker.com/reference/cli/docker/image/tag/)
- [docker compose build - Docker Docs](https://docs.docker.com/reference/cli/docker/compose/build/)