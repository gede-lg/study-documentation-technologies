# Secrets

**Título da Explicação:**

***Gerenciamento de Secrets no Docker Compose: Guia Completo***

---

## 1. Introdução

No contexto de contêineres Docker, **Secrets** são pequenos pedaços de dados sensíveis (como senhas, chaves de API ou certificados) que precisam ser gerenciados de forma segura, evitando exposição acidental no código, em imagens ou em volumes de dados persistentes. O Docker Compose oferece suporte integrado para orquestrar esses segredos entre múltiplos serviços, garantindo que cada contêiner receba apenas o que precisa, no momento certo.

---

## 2. Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#3-conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#4-sintaxe-detalhada-e-uso-pr%C3%A1tico)
    1. Declaração de Secrets
    2. Montagem em Services
    3. Variações de Sintaxe (arquivos locais vs. Docker Swarm)
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#5-cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes-Chave Associados](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#6-componentes-chave-associados)
    - `external`
    - `file` / `name`
    - `mode`
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#7-melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#8-exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#9-sugest%C3%B5es-para-aprofundamento)

---

## 3. Conceitos Fundamentais

- **O que são Secrets?**
    
    Dados sensíveis que não devem ser armazenados em texto puro no código ou em imagens Docker.
    
- **Por que usar Secrets?**
    1. **Segurança**: evita exposição de credenciais.
    2. **Controle de acesso**: cada serviço recebe apenas os segredos necessários.
    3. **Rotação e Auditoria**: facilita atualização de segredos sem rebuild de imagens.
- **Contextos de uso**:
    - Docker Compose em standalone (modo *legacy*): fornece montagens de arquivos contendo segredos, mas sem criptografia nativa.
    - Docker Swarm: armazena e distribui segredos de forma criptografada pelo cluster.

---

## 4. Sintaxe Detalhada e Uso Prático

### 4.1. Declaração de Secrets

No nível raiz de `docker-compose.yml`, define-se a seção `secrets:`:

```yaml
version: "3.9"
secrets:
  db_password:
    file: ./secrets/db_password.txt   # Carrega de um arquivo local
  api_key:
    external: true                    # Referencia um secret já criado no Swarm

```

- `file`: caminho relativo (ou absoluto) para o arquivo contendo o valor do secret.
- `external`: quando `true`, espera-se que o secret já exista no Docker Swarm (via `docker secret create api_key ...`).

Caso deseje outro nome interno (diferente do arquivo), use:

```yaml
secrets:
  segredo_custom:
    name: meu_secret_custom
    file: ./secrets/custom.txt

```

### 4.2. Montagem em Services

Cada serviço que precisa acessar o secret faz referência na sua seção:

```yaml
services:
  db:
    image: mysql:8
    secrets:
      - db_password
    environment:
      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_password
  web:
    image: myapp:latest
    secrets:
      - source: api_key
        target: app_api_key.txt
        uid: '1000'
        gid: '1000'
        mode: 0440

```

- `source`: nome do secret declarado em `secrets:`.
- `target` (opcional): nome/ caminho de montagem dentro do contêiner (subdiretório de `/run/secrets/`).
- `uid`, `gid`, `mode`: usuário, grupo e permissões de arquivo (modos numéricos UNIX).

Por padrão, segredos são montados em `/run/secrets/<nome_do_secret>` com permissão `0400`.

### 4.3. Variações de Sintaxe

- **Standalone Compose (sem Swarm)**
    - Apenas `file:` é suportado.
    - O Compose copia o arquivo local para a pasta anônima de volumes no host e o monta no contêiner.
- **Docker Swarm Mode**
    - Suporta `external: true` e criação de secrets via CLI (`docker secret create ...`).
    - Os segredos são armazenados criptografados no Raft store do Swarm.

---

## 5. Cenários de Restrição ou Não Aplicação

- **Ambientes sem Docker Swarm**: recursos de `external` não funcionam.
- **Ciência de dados local**: para simples passagem de senhas em dev, montar variáveis de ambiente pode ser mais prático, embora menos seguro.
- **Limitações de performance**: múltiplos segredos grandes podem adicionar overhead de I/O.

---

## 6. Componentes-Chave Associados

| Componente | Descrição | Uso / Sintaxe |
| --- | --- | --- |
| `external` | Indica secret existente em Swarm | `external: true` |
| `file` | Caminho do arquivo de secret local | `file: ./secrets/secret.txt` |
| `name` | Nome interno alternativo do secret | `name: meu_secret` |
| `mode` | Permissões de arquivo (UNIX) | `mode: 0440` |
| `uid`/`gid` | Dono do arquivo dentro do contêiner | `uid: '1000'` |

---

## 7. Melhores Práticas e Padrões de Uso

1. **Nunca versionar** arquivos de secrets em repositórios Git (usar `.gitignore`).
2. **Criptografar em trânsito**: use Docker Swarm ou ferramentas externas (Vault, AWS Secrets Manager).
3. **Menor privilégio**: monte apenas o secret estritamente necessário para cada serviço.
4. **Controle de acesso**: defina `uid`, `gid` e `mode` adequados.
5. **Rotação periódica**: teste processos de criação/atualização sem downtime.
6. **Integração CI/CD**: utilize plugins ou scripts que injetem secrets no deploy, sem exposições.

---

## 8. Exemplo Prático Completo

Imagine um cenário com dois serviços: um banco MySQL e uma aplicação Node.js que consome uma API externa.

```yaml
version: "3.9"

secrets:
  mysql_root_password:
    file: ./secrets/mysql_root_password.txt
  external_api_key:
    external: true

services:
  db:
    image: mysql:8
    restart: always
    secrets:
      - mysql_root_password
    environment:
      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/mysql_root_password
    volumes:
      - db_data:/var/lib/mysql

  app:
    image: node:16
    depends_on:
      - db
    build: ./app
    secrets:
      - source: external_api_key
        target: api_key.txt
        uid: '1000'
        gid: '1000'
        mode: 0440
    environment:
      API_KEY_FILE: /run/secrets/api_key.txt
      DB_HOST: db
      DB_PASSWORD_FILE: /run/secrets/mysql_root_password

volumes:
  db_data:

```

**Fluxo de trabalho:**

1. **Criar secret externo** no Swarm (uma única vez):
    
    ```bash
    docker secret create external_api_key ./secrets/external_api_key.txt
    
    ```
    
2. **Executar `docker stack deploy`** (modo Swarm) ou `docker-compose up` (standalone).
3. **Acessar**:
    - No contêiner `db`, o MySQL lê a senha via `MYSQL_ROOT_PASSWORD_FILE`.
    - No contêiner `app`, a aplicação lê a API key de `/run/secrets/api_key.txt`.

---

## 9. Sugestões para Aprofundamento

- **Docker Secrets vs. Docker Configs**: entenda diferenças e casos de uso.
- **Integração com HashiCorp Vault**: orquestração de segredos de forma centralizada.
- **Rotação automática de segredos** usando ferramentas como `docker secret rotate`.
- **Comparar com Kubernetes Secrets**: vantagens e desvantagens.
- **Segurança de runtime**: uso de `tmpfs` e montagem apenas durante o build.

---

Com este guia, você tem uma visão completa e detalhada sobre o gerenciamento de **Secrets** no Docker Compose, desde conceitos teóricos até exemplos práticos e recomendações para implementação segura em ambientes de produção. Caso queira explorar tópicos avançados (como integração com Vault ou automação de rotação), basta sinalizar que podemos aprofundar ainda mais!