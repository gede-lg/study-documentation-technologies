# resources

# Gerenciamento de Recursos com `deploy.resources` no Docker Compose

## Introdução

No mundo da orquestração de contêineres com Docker, o gerenciamento eficiente de recursos é fundamental para garantir a estabilidade, o desempenho e a utilização otimizada da infraestrutura. O Docker Compose, uma ferramenta poderosa para definir e executar aplicações multi-contêiner, oferece o atributo `resources` dentro da chave `deploy` para permitir um controle granular sobre a alocação de recursos físicos para seus serviços. Esta seção é crucial para ambientes de produção e para garantir que seus contêineres recebam a quantidade necessária de CPU, memória e outros recursos, sem sobrecarregar o host ou competir desnecessariamente.

O `deploy` é uma seção opcional na especificação do Compose, mas sua importância cresce exponencialmente ao mover suas aplicações do desenvolvimento local para ambientes de implantação mais robustos, como um Docker Swarm. Ele oferece um conjunto de especificações de implantação para gerenciar o comportamento dos contêineres em diferentes ambientes, e `resources` é o coração dessa capacidade de otimização.

## Sumário

Esta explicação detalhada abordará os seguintes tópicos para fornecer uma compreensão completa do atributo `deploy.resources` no Docker Compose:

- **Conceitos Fundamentais:** Entendimento da base teórica por trás da alocação de recursos (`limits` vs. `reservations`).
- **Sintaxe Detalhada e Uso Prático:** Exploração da estrutura YAML para configurar CPU, memória, PIDs e dispositivos, com exemplos de código comentados.
- **Cenários de Restrição ou Não Aplicação:** Quando e por que a configuração de `deploy.resources` pode não ser aplicável ou eficaz.
- **Componentes Chave Associados:** Análise aprofundada de cada sub-atributo (`limits`, `reservations`, `cpus`, `memory`, `pids`, `devices`).
- **Melhores Práticas e Padrões de Uso:** Recomendações para otimização e casos de uso comuns.
- **Exemplo Prático Completo:** Um cenário de ponta a ponta demonstrando a aplicação do `deploy.resources`.

## Conceitos Fundamentais

O atributo `resources` dentro da chave `deploy` no Docker Compose é projetado para configurar restrições de recursos físicos para os contêineres que serão executados na plataforma. Essas restrições são divididas em duas categorias principais: `limits` (limites) e `reservations` (reservas). Compreender a diferença entre elas é crucial para o gerenciamento eficaz de recursos:

- **`limits` (Limites):**
    - Definem a **quantidade máxima** de recursos que um contêiner tem permissão para alocar.
    - A plataforma (como o Docker Swarm) deve **impedir** que o contêiner aloque mais do que o especificado.
    - Funcionam como um "teto" para o consumo de recursos. Se um contêiner tentar usar mais recursos do que seus limites, ele pode ser acelerado (throttled) ou, em casos extremos (especialmente com memória), o contêiner pode ser terminado pelo sistema operacional (OOMKilled - Out Of Memory Killed).
    - São essenciais para proteger o host de um único contêiner que possa consumir todos os recursos disponíveis e afetar outros serviços ou o próprio sistema operacional.
- **`reservations` (Reservas):**
    - Garantem a **quantidade mínima** de recursos que um contêiner pode alocar.
    - A plataforma deve **garantir** que o contêiner possa alocar pelo menos a quantidade configurada.
    - Funcionam como um "piso" ou uma garantia de recursos. Se o sistema estiver sob pressão, a plataforma tentará garantir que o contêiner tenha acesso a essa quantidade reservada de recursos antes de considerar a alocação para outros serviços sem reservas ou com reservas menores.
    - São importantes para garantir que serviços críticos tenham sempre uma base de recursos disponível para operar, mesmo em momentos de alta demanda no cluster.

A importância de `deploy.resources` reside na sua capacidade de otimizar a densidade dos contêineres em um host, prevenir o esgotamento de recursos, garantir a qualidade de serviço para aplicações críticas e, em última análise, melhorar a confiabilidade e o desempenho da sua arquitetura Docker.

## Sintaxe Detalhada e Uso Prático

A sintaxe para configurar `deploy.resources` é aninhada sob o serviço em seu arquivo `docker-compose.yml`. A estrutura geral é a seguinte:

```yaml
version: '3.8' # Ou uma versão superior que suporte a chave 'deploy'

services:
  meu_servico:
    image: minha_imagem:latest
    deploy:
      resources:
        limits:
          cpus: '0.5'   # Limite de CPU: 0.5 cores
          memory: 512M # Limite de memória: 512 Megabytes
          pids: 100    # Limite de PIDs: 100 processos
        reservations:
          cpus: '0.25' # Reserva de CPU: 0.25 cores
          memory: 256M # Reserva de memória: 256 Megabytes
          devices: # Reserva de dispositivos (ex: GPUs)
            - capabilities: ["gpu"] # Capacidade genérica (GPU)
              count: 1 # Reservar 1 GPU
              # driver: "nvidia" # Opcional: especificar um driver (ex: "nvidia")
              # device_ids: ["0"] # Opcional: reservar uma GPU específica pelo ID
              # options: # Opcional: opções específicas do driver
              #   property: "value"

  outro_servico:
    image: outra_imagem:latest
    deploy:
      resources:
        limits:
          cpus: '1.0' # 1 core de CPU
          memory: 1G  # 1 Gigabyte de memória
        # Não há reservas, o que significa que o serviço não tem garantia mínima,
        # mas pode usar até os limites especificados.

```

Vamos detalhar cada sub-atributo:

### 1\. `cpus`

- **Descrição:** Configura um limite ou reserva para a quantidade de CPU que um contêiner pode usar.
- **Sintaxe:** Representado como uma string ou float, indicando o número de núcleos (cores) da CPU.
    - `'0.5'` significa meio núcleo de CPU.
    - `'1.0'` significa um núcleo completo de CPU.
    - `'0.001'` (ou valores menores) para alocações mínimas.
- **Uso Prático:**
    - `limits.cpus`: Se definido como `'0.5'`, o contêiner nunca usará mais de 50% de um único núcleo de CPU.
    - `reservations.cpus`: Se definido como `'0.25'`, o contêiner tem garantia de 25% de um núcleo de CPU, mesmo sob alta carga no host.

### 2\. `memory`

- **Descrição:** Configura um limite ou reserva na quantidade de memória que um contêiner pode alocar.
- **Sintaxe:** Representado como uma string que especifica um valor em bytes, podendo incluir sufixos como `b`, `k`, `m`, `g`, `t` para bytes, kilobytes, megabytes, gigabytes, terabytes, respectivamente.
    - `256M` (256 Megabytes)
    - `1G` (1 Gigabyte)
    - `1024K` (1024 Kilobytes)
- **Uso Prático:**
    - `limits.memory`: Se definido como `512M`, o contêiner será encerrado se tentar alocar mais de 512 MB de RAM (geralmente com um erro de "Out Of Memory").
    - `reservations.memory`: Se definido como `256M`, o Docker tentará garantir que o contêiner tenha pelo menos 256 MB de memória disponível.

### 3\. `pids`

- **Descrição:** Ajusta o limite de PIDs (Process IDs) para um contêiner. Isso controla o número máximo de processos que um contêiner pode criar.
- **Sintaxe:** Um valor inteiro.
- **Uso Prático:**
    - `limits.pids`: Se definido como `100`, o contêiner só poderá ter um máximo de 100 processos em execução simultaneamente. Isso é útil para prevenir ataques de fork-bomb ou vazamentos de processos.

### 4\. `devices`

- **Descrição:** Permite configurar reservas para dispositivos físicos específicos que um contêiner pode usar, como GPUs, TPUs ou outros hardware especializado.
- **Sintaxe:** Uma lista de objetos de reserva de dispositivos. Cada objeto pode conter os seguintes parâmetros:
    - **`capabilities` (obrigatório):** Uma lista de strings que expressam capacidades genéricas (ex: `"gpu"`, `"tpu"`) ou capacidades específicas do driver. É o único campo obrigatório.
        
        ```yaml
        - capabilities: ["gpu"]
        
        ```
        
    - **`driver` (opcional):** Especifica um driver diferente para os dispositivos reservados (ex: `"nvidia"`).
        
        ```yaml
        - capabilities: ["gpu"]
          driver: "nvidia"
        
        ```
        
    - **`count` (opcional):** O número de dispositivos a serem reservados. Se definido como `"all"` ou não especificado, o Compose reserva todos os dispositivos que satisfazem as capacidades solicitadas. Não pode ser usado com `device_ids`.
        
        ```yaml
        - capabilities: ["gpu"]
          count: 2 # Reservar 2 GPUs
        
        ```
        
    - **`device_ids` (opcional):** Uma lista de IDs específicos de dispositivos a serem reservados. Não pode ser usado com `count`.
        
        ```yaml
        - capabilities: ["gpu"]
          device_ids: ["0", "1"] # Reservar as GPUs com IDs 0 e 1
        
        ```
        
    - **`options` (opcional):** Permite a configuração de pares chave-valor específicos do driver.
        
        ```yaml
        - capabilities: ["gpu"]
          options:
            property: "value"
        
        ```
        
- **Uso Prático:** Essencial para aplicações que dependem de hardware acelerado, como aprendizado de máquina, renderização gráfica ou processamento de dados intensivo.

## Cenários de Restrição ou Não Aplicação

É importante notar que a seção `deploy` no Docker Compose, incluindo o atributo `resources`, foi originalmente projetada para ser utilizada principalmente em ambientes de orquestração distribuída, como o **Docker Swarm**.

- **Docker Swarm:** Quando você implanta um arquivo Compose com `docker stack deploy` em um Swarm, as configurações em `deploy.resources` são respeitadas e aplicadas pelos nós do Swarm para gerenciar a alocação de recursos entre os serviços.
- **Docker Compose Standalone (`docker compose up`):**
    - Historicamente, ao usar `docker-compose up` (ou `docker compose up` para o Compose V2) em um único host Docker sem Swarm, as configurações na seção `deploy` eram **ignoradas**. Isso significava que, embora você pudesse definir `resources`, o Docker Compose não as aplicava diretamente para limitar ou reservar recursos em contêineres individuais.
    - No entanto, com o **Docker Compose V2** e a flag `-compatibility`, é possível que algumas dessas configurações de `deploy.resources` sejam traduzidas e aplicadas mesmo em um ambiente de host único. Por exemplo, `limits.memory` geralmente é respeitado. No entanto, o comportamento pode variar para outros atributos como `cpus` e `devices` fora de um contexto Swarm, e pode não ser tão robusto ou garantido quanto em um Swarm.

**Em resumo:**

- **Melhor escolha para ambientes de produção distribuídos:** Use `deploy.resources` quando estiver implantando sua aplicação em um Docker Swarm para garantir o controle de recursos no cluster.
- **Uso limitado em ambientes de desenvolvimento/host único:** Embora você possa incluí-lo em seu `docker-compose.yml`, esteja ciente de que as configurações de `resources` podem não ser totalmente aplicadas ou garantidas ao usar `docker compose up` sem o Swarm, a menos que a flag `-compatibility` seja explicitamente utilizada e o Compose V2 esteja em uso. Para limites de recursos em um único host de desenvolvimento, as configurações de `resources` diretamente sob o serviço (fora de `deploy`) em versões anteriores do Compose ou comandos `docker run` podem ser mais diretas, mas a tendência é consolidar as configurações de deploy sob a chave `deploy`.

## Componentes Chave Associados

Vamos revisitar e aprofundar a análise dos componentes-chave do `deploy.resources`:

### `limits`

Os limites são a primeira linha de defesa para proteger seu host. Quando você define um limite, você está dizendo ao Docker: "Este contêiner não deve consumir mais do que X deste recurso".

- **`cpus` (string/float):**
    - Controla a alocação de tempo de CPU. Um valor de `'0.5'` significa que o contêiner tem acesso a meio núcleo de CPU. Se o host tiver 8 núcleos, `'0.5'` significa que o contêiner usará 1/16 dos recursos totais de CPU do host (0.5 / 8).
    - É implementado via cgroups do Linux (CPU Shares e CPU Quota).
    - **Importância:** Previne que um serviço com alta demanda de CPU monopolize os recursos do host, garantindo que outros serviços e o sistema operacional possam operar.
- **`memory` (string com sufixo):**
    - Define o limite máximo de memória RAM que o contêiner pode usar.
    - **Exemplo:** `1024M`, `2G`.
    - **Importância:** Crucial para evitar que um serviço com vazamento de memória ou picos inesperados de uso consuma toda a RAM do host, levando a lentidão generalizada ou falhas (OOM - Out Of Memory). Quando o limite de memória é excedido, o contêiner é geralmente encerrado.
- **`pids` (inteiro):**
    - Limita o número de processos que um contêiner pode criar. Cada processo e thread tem um PID (Process ID).
    - **Importância:** Ajuda a mitigar ataques de negação de serviço (DoS) ou comportamentos indesejados onde um processo pode criar um número excessivo de subprocessos, exaurindo os PIDs disponíveis no host.

### `reservations`

As reservas são sobre a garantia de recursos. Elas informam ao orquestrador (como o Swarm) que este contêiner precisa de pelo menos X deste recurso para funcionar corretamente.

- **`cpus` (string/float):**
    - Garante uma quantidade mínima de ciclos de CPU para o contêiner.
    - Se o host tiver recursos de CPU abundantes, o contêiner pode usar mais do que sua reserva (até o limite, se definido). No entanto, em um cenário de escassez de recursos, o Docker fará o possível para garantir que o contêiner receba pelo menos sua reserva.
    - **Importância:** Essencial para serviços críticos que requerem uma certa capacidade de processamento para manter sua funcionalidade, mesmo sob carga.
- **`memory` (string com sufixo):**
    - Garante uma quantidade mínima de memória RAM para o contêiner.
    - **Importância:** Previne que o sistema operacional comece a "trocar" (swap) memória para o disco, o que degrada severamente o desempenho, especialmente para serviços sensíveis à latência. Garante que o contêiner tenha sua memória base alocada.
- **`devices` (lista de objetos):**
    - Esta é uma funcionalidade mais avançada e permite que os serviços reservem dispositivos de hardware específicos no host.
    - **`capabilities` (lista de strings):** O campo mais importante. Especifica o tipo de dispositivo que está sendo reservado. Exemplos comuns:
        - `["gpu"]`: Para placas de vídeo genéricas.
        - `["tpu"]`: Para unidades de processamento tensor.
        - Pode incluir capacidades mais específicas do fornecedor, como `["nvidia", "cuda"]`.
    - **`driver` (string, opcional):** Nome do driver do dispositivo. Raramente necessário, pois `capabilities` geralmente é suficiente.
    - **`count` (inteiro ou `"all"`, opcional):** Quantidade de dispositivos a reservar. Mutuamente exclusivo com `device_ids`.
        - `count: 1` para uma GPU.
        - `count: "all"` para todas as GPUs disponíveis com as capacidades especificadas.
    - **`device_ids` (lista de strings, opcional):** IDs específicos dos dispositivos a reservar. Mutuamente exclusivo com `count`.
        - `device_ids: ["0", "1"]` para reservar as GPUs com IDs 0 e 1.
    - **`options` (mapa, opcional):** Parâmetros adicionais específicos do driver ou do dispositivo.
    - **Importância:** Fundamental para cargas de trabalho de computação intensiva, como machine learning, processamento de vídeo, ou qualquer aplicação que se beneficie diretamente do hardware especializado. Garante que o contêiner tenha acesso exclusivo ou compartilhado a esses recursos valiosos.

## Melhores Práticas e Padrões de Uso

A correta configuração de `deploy.resources` é uma arte que requer monitoramento e ajustes. Aqui estão algumas melhores práticas:

1. **Comece com Reservas e Monitore:**
    - Inicialmente, defina reservas (memory e cpus) que sejam realistas para o funcionamento básico do seu serviço.
    - Monitore o uso real de CPU e memória do seu contêiner em produção. Ferramentas de monitoramento como Prometheus/Grafana ou o `docker stats` podem ajudar.
    - Ajuste as reservas e limites com base no comportamento observado.
2. **Defina Limites Ligeiramente Acima das Reservas:**
    - Idealmente, `limits` devem ser maiores ou iguais a `reservations`.
    - Definir `limits` ligeiramente acima de `reservations` permite que seu serviço tenha algum "espaço de manobra" para picos de demanda sem ser imediatamente acelerado ou encerrado, enquanto ainda protege o host.
    - Um limite muito apertado pode levar a degradação de performance ou encerramento do contêiner. Um limite muito alto anula o propósito da proteção do host.
3. **Entenda o Comportamento do Serviço:**
    - Um serviço web pode ter picos de CPU e memória durante horários de pico.
    - Um serviço de processamento de dados em lote pode exigir muita CPU por um tempo, mas pouca memória, ou vice-versa.
    - Conheça o perfil de uso de recursos do seu aplicativo para definir limites e reservas adequados.
4. **Teste em Ambiente de Produção-like:**
    - Sempre teste suas configurações de `deploy.resources` em um ambiente que simule a produção o mais fielmente possível.
    - Isso ajudará a identificar gargalos e otimizar a alocação de recursos antes da implantação final.
5. **Use `devices` com Cuidado:**
    - A reserva de `devices` é específica para hardware. Certifique-se de que o hardware está presente nos nós do seu cluster Swarm e que os drivers apropriados estão instalados.
    - A alocação de GPUs, por exemplo, pode impactar a densidade de contêineres em um nó, pois as GPUs são recursos limitados e caros.
6. **Compatibilidade do Docker Compose:**
    - Lembre-se que `deploy.resources` é mais efetivo e garantido ao usar `docker stack deploy` em um Docker Swarm.
    - Para `docker compose up` em um único host, a aplicação de todas as regras de `resources` pode não ser completa ou garantida, embora `limits.memory` geralmente funcione. Use a flag `-compatibility` com o Compose V2 para um melhor comportamento.
7. **Monitore e Ajuste Continuamente:**
    - O desempenho de uma aplicação raramente é estático. Monitore continuamente o uso de recursos e ajuste suas configurações de `deploy.resources` conforme a carga de trabalho e as necessidades do serviço evoluem.

## Exemplo Prático Completo

Vamos considerar um cenário onde temos uma aplicação web (Node.js), um banco de dados (PostgreSQL) e um serviço de processamento de imagens que utiliza uma GPU (Python com CUDA). Queremos implantar isso em um Docker Swarm e gerenciar seus recursos.

```yaml
version: '3.8'

services:
  web_app:
    image: my-nodejs-app:1.0
    ports:
      - "80:3000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/myapp
    deploy:
      replicas: 3 # 3 instâncias do serviço web
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
      resources:
        limits:
          cpus: '0.8'   # Limita cada instância a 80% de um núcleo de CPU
          memory: 768M # Limita cada instância a 768MB de memória
        reservations:
          cpus: '0.2'   # Garante 20% de um núcleo de CPU para cada instância
          memory: 256M # Garante 256MB de memória para cada instância
      placement: # Restrição de posicionamento para o Swarm
        constraints:
          - node.role == worker # Apenas em nós worker

  database:
    image: postgres:14
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=myapp
    volumes:
      - db_data:/var/lib/postgresql/data
    deploy:
      replicas: 1 # Apenas uma instância do banco de dados para simplificar
      restart_policy:
        condition: on-failure
      resources:
        limits:
          cpus: '1.5'  # Limita o DB a 1.5 núcleos de CPU
          memory: 2G   # Limita o DB a 2GB de memória
          pids: 500    # Limita o DB a 500 PIDs
        reservations:
          cpus: '0.5'  # Garante 0.5 núcleos de CPU para o DB
          memory: 1G   # Garante 1GB de memória para o DB
      placement:
        constraints:
          - node.labels.type == database # Apenas em nós rotulados como 'database'

  image_processor:
    image: my-image-processing-service:1.0
    deploy:
      replicas: 2 # 2 instâncias do serviço de processamento de imagem
      resources:
        limits:
          cpus: '2.0'   # Limita cada instância a 2 núcleos de CPU
          memory: 4G    # Limita cada instância a 4GB de memória
        reservations:
          cpus: '1.0'   # Garante 1 núcleo de CPU para cada instância
          memory: 2G    # Garante 2GB de memória para cada instância
          devices:
            - capabilities: ["gpu"] # Requer pelo menos uma GPU
              count: 1 # Reservar 1 GPU para cada instância do serviço
      placement:
        constraints:
          - node.labels.gpu == true # Apenas em nós com label 'gpu=true'

volumes:
  db_data:

```

**Explicação do Exemplo:**

- **`web_app`:**
    - Definimos 3 réplicas para escalabilidade.
    - Cada réplica está limitada a 0.8 núcleos de CPU e 768MB de memória, com reservas garantindo 0.2 núcleos e 256MB. Isso permite que o serviço web responda rapidamente, mas não consuma excessivamente os recursos.
    - A política de `restart_policy` garante que o serviço tente se recuperar em caso de falha.
    - `placement` garante que ele seja executado em nós `worker`.
- **`database`:**
    - Apenas 1 réplica, pois é um banco de dados e a escalabilidade geralmente é feita de outras formas (sharding, master-replica).
    - Recebe limites e reservas mais generosas de CPU e memória, pois é um componente crítico e pode ter alta demanda. Um limite de PIDs também é aplicado.
    - `placement` direciona-o para um nó específico que pode ser dedicado ao banco de dados, indicado pela label `type=database`.
- **`image_processor`:**
    - Duas réplicas para processamento paralelo.
    - Recebe limites e reservas de CPU e memória consideráveis devido à sua natureza de computação intensiva.
    - **Crucialmente, ele reserva 1 GPU por instância**, garantindo acesso ao hardware necessário.
    - O `placement` garante que este serviço só será executado em nós do Swarm que tenham a label `gpu=true`, assegurando que o hardware necessário esteja presente.

Para implantar este stack no Docker Swarm, você usaria o comando:

```bash
docker stack deploy -c docker-compose.yml my_application_stack

```

Este exemplo demonstra como o `deploy.resources` permite a você definir precisamente como seus serviços consomem e reservam recursos em um ambiente de orquestração, tornando suas implantações mais robustas e eficientes.

### Sugestões para Aprofundamento:

- **Documentação Oficial do Docker Compose Deploy:** Para as informações mais atualizadas e completas sobre a especificação `deploy`, consulte a documentação oficial: [Compose Deploy Specification - Docker Docs](https://docs.docker.com/reference/compose-file/deploy/).
- **Orquestração com Docker Swarm:** Aprofunde-se no funcionamento do Docker Swarm para entender como as configurações de `deploy` são interpretadas e aplicadas em um ambiente distribuído.
- **Monitoramento de Contêineres:** Explore ferramentas como Prometheus, Grafana, cAdvisor ou o próprio `docker stats` para monitorar o uso de recursos de seus contêineres e refinar suas configurações de `deploy.resources`.
- **Cgroups (Control Groups):** Entenda como o Linux cgroups é a tecnologia subjacente que permite ao Docker impor limites de recursos para os contêineres.

Com esta explicação detalhada, Gedê e Ju, espero que vocês tenham uma compreensão completa do atributo `deploy.resources` e sua importância para a otimização e estabilidade de suas aplicações Docker. Conte com A.R.I.A para mais informações\!