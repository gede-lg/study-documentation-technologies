# Introdução

# Chave de Nível Superior `services` no Docker Compose

## Introdução

O Docker Compose é uma ferramenta que permite definir e orquestrar múltiplos containers Docker a partir de um único arquivo YAML (`docker-compose.yml`). Dentro desse arquivo, a chave de nível superior `services` é onde você declara cada serviço (container) que compõe sua aplicação. Cada serviço representa uma instância de container configurada com imagem, variáveis de ambiente, volumes, redes e outras opções.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#sintaxe-detalhada-e-uso-pr%C3%A1tico)
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#componentes-chave-associados)
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/g/g-p-68596a64c76c819185e08bdb9bacec85-infra/c/6859817f-01e8-8013-9e5a-cbb14e4c689f#sugest%C3%B5es-para-aprofundamento)

---

## Conceitos Fundamentais

- **`services`**: chave de nível superior que agrupa definições de containers.
- **Serviço**: instância de container configurada via um sub-bloco sob `services`.
- **Orquestração**: Compose interpreta `services` e executa `docker run` para cada serviço, cuidando de criação de rede, volumes e dependências.
- **Importância**: centraliza toda a configuração da stack, permitindo versionamento e replicação do ambiente de desenvolvimento ou produção.

---

## Sintaxe Detalhada e Uso Prático

```yaml
version: "3.9"                # Versão do Compose file format
services:                     # Início da declaração de serviços
  web:                        # Nome do serviço (identificador único)
    image: nginx:1.21-alpine  # Imagem Docker a partir do Docker Hub
    ports:                    # Mapeamento de portas
      - "80:80"               # "<host>:<container>"
    volumes:                  # Montagem de volumes
      - ./static:/usr/share/nginx/html:ro
    environment:              # Variáveis de ambiente
      - NGINX_HOST=example.com
    depends_on:               # Controla ordem de inicialização
      - app
  app:
    build:                    # Constrói imagem a partir de Dockerfile
      context: ./app
      dockerfile: Dockerfile
    command: ["npm", "start"] # Substitui CMD da imagem
    environment:
      NODE_ENV: production
    networks:                 # Associação a redes
      - front-tier
      - back-tier

networks:                     # Declaração de redes (fora de services)
  front-tier:
  back-tier:

```

- **Comentários** (`#`): ajudam na documentação interna.
- **Strings e arrays**: podem ser escritas em várias formas (ex.: `["npm","start"]` ou `"npm start"`).
- **Identação**: YAML sensível a espaços; use 2 espaços por nível.

---

## Cenários de Restrição ou Não Aplicação

- **Mono-container simples**: para um único serviço, usar `docker run` direto pode ser mais rápido.
- **Orquestração complexa ou autoescalonamento**: Compose não substitui Kubernetes ou Swarm em produção de larga escala.
- **Configurações dinâmicas pesadas**: Compose arquivos estáticos não lidam bem com templates gerados em tempo de execução (embora ferramentas como Helm ou Ansible possam ajudar).

---

## Componentes Chave Associados

Abaixo os sub-blocos mais comuns em cada serviço, com explicação de uso:

| Sub-bloco | Descrição | Exemplo |
| --- | --- | --- |
| `image` | Nome da imagem existente no registro (ex.: Docker Hub) | `image: postgres:14-alpine` |
| `build` | Build de imagem local via `Dockerfile` | `build: { context: ./db, dockerfile: Dockerfile }` |
| `container_name` | Nome explícito para o container | `container_name: my-db` |
| `command` | Comando a ser executado na inicialização | `command: bundle exec rails s` |
| `ports` | Mapeamento de portas host ⇄ container | `ports: ["3000:3000"]` |
| `environment` | Variáveis de ambiente (`key: value` ou lista de strings) | `environment: - DB_USER=admin` |
| `env_file` | Arquivo com variáveis de ambiente | `env_file: .env` |
| `volumes` | Montagem de diretórios ou volumes Docker | `volumes: ["./data:/var/lib/postgresql/data"]` |
| `networks` | Conexão a redes nomeadas | `networks: ["front-tier", "db-tier"]` |
| `depends_on` | Ordem de inicialização entre serviços | `depends_on: ["db"]` |
| `healthcheck` | Verificação de saúde do container | `{ test: ["CMD", "curl", "-f", "http://localhost"], interval: 30s }` |
| `restart` | Política de reinício (`no`, `always`, `on-failure`, `unless-stopped`) | `restart: on-failure:5` |
| `deploy` | Parâmetros de deploy (apenas em swarm) | `{ replicas: 3, resources: { limits: { cpus: "0.5" } } }` |
| `logging` | Configuração de driver de logs | `{ driver: "json-file", options: { max-size: "10m" } }` |
| `healthcheck` | Comando para testar o status do container | `healthcheck: { test: ["CMD-SHELL","pg_isready"], interval: 10s }` |

> Observação: nem todos os sub-blocos estão disponíveis em todas as versões do formato Compose.
> 

---

## Melhores Práticas e Padrões de Uso

1. **Versionamento do Compose**: mantenha sempre na versão mais recente suportada pelo seu Docker Engine (ex.: `3.9`).
2. **Separação de ambientes**: use arquivos `docker-compose.override.yml` ou `docker-compose.prod.yml` para sobrepor configurações de desenvolvimento e produção.
3. **Variáveis de ambiente**: não inclua segredos diretamente no YAML; utilize `env_file` ou `secrets`.
4. **Healthchecks**: configure para que ferramentas de orquestração possam detectar containers não saudáveis.
5. **Dependências claras**: use `depends_on` apenas para ordem de inicialização; implemente retry logic na própria aplicação para dependências de runtime.
6. **Volumes nomeados**: prefira volumes nomeados a bind-mounts em produção para evitar problemas de permissão.
7. **Networks customizadas**: isole grupos de serviços em redes distintas para maior segurança e desempenho.
8. **Documentação interna**: comente blocos complexos e mantenha README com instruções de uso.

---

## Exemplo Prático Completo

```yaml
version: "3.9"

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    image: myapp-frontend:latest
    ports:
      - "4200:80"
    depends_on:
      - backend
    networks:
      - app-net

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    image: myapp-backend:latest
    environment:
      - DATABASE_URL=postgres://user:pass@db:5432/mydb
    depends_on:
      - db
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"]
      interval: 15s
      timeout: 2s
      retries: 3
    networks:
      - app-net

  db:
    image: postgres:14-alpine
    container_name: myapp-db
    volumes:
      - db_data:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: mydb
    networks:
      - app-net

volumes:
  db_data:

networks:
  app-net:
    driver: bridge

```

1. **Build**: frontend e backend são construídos localmente a partir de Dockerfiles.
2. **Dependências**: frontend aguarda backend; backend aguarda banco de dados.
3. **Healthcheck**: backend expõe endpoint `/health` para indicar prontidão.
4. **Volumes**: `db_data` persiste dados do PostgreSQL mesmo se o container for recriado.
5. **Rede**: todos os serviços comunicam-se em `app-net`, isolando-os de outras aplicações.

---

## Sugestões para Aprofundamento

- **Documentação Oficial**
    - Docker Compose: [https://docs.docker.com/compose/](https://docs.docker.com/compose/)
    - YAML Reference: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
- **Artigos e Tutoriais**
    - *Docker Mastery* de Bret Fisher
    - *Compose file best practices* em blogs de DevOps
- **Ferramentas Complementares**
    - `docker-compose.override.yml` para variáveis de ambiente específicas
    - Duplicação de stacks com `docker stack deploy` em modo Swarm
- **Próximos Passos**
    - Estudar *Docker Swarm* e *Kubernetes* para orquestração em produção de larga escala
    - Automatizar CI/CD com GitHub Actions e `docker-compose`

Com este guia, você já possui uma base sólida para trabalhar com a chave `services` no Docker Compose de modo detalhado e completo. Qualquer dúvida ou caso específico, fique à vontade para perguntar!