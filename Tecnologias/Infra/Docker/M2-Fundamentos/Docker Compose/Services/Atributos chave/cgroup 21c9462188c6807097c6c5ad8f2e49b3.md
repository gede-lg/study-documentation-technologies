# cgroup

## Entendendo o Atributo `cgroup` na Chave `services` do Docker Compose

Este documento fornece uma explicação detalhada e completa sobre o atributo `cgroup` dentro da chave `services` em arquivos Docker Compose, explorando seu propósito, uso e o contexto das Control Groups (cgroups) do Linux no ecossistema Docker.

### Sumário

- **Introdução**: Contextualização do `cgroup` no Docker Compose e sua importância.
- **Conceitos Fundamentais**: Entendimento das cgroups do Linux, sua relação com o Docker e a função do `cgroup` e `cgroup_parent`.
- **Sintaxe Detalhada e Uso Prático**: Exploração das opções `host` e `private` para `cgroup`, e o uso de `cgroup_parent` para gerenciamento avançado de recursos, com exemplos de código.
- **Cenários de Restrição ou Não Aplicação**: Discussão sobre quando o uso explícito de `cgroup` pode não ser necessário ou adequado.
- **Componentes Chave Associados**: Como `cgroup` se relaciona com outras configurações de limite de recursos no Docker Compose.
- **Melhores Práticas e Padrões de Uso**: Recomendações para o uso eficaz do atributo `cgroup` e considerações de segurança.
- **Exemplo Prático Completo**: Um cenário de como usar `cgroup` e `cgroup_parent` para gerenciar recursos de múltiplos serviços.

---

### 1\. Introdução

No universo do Docker e da orquestração de contêineres com Docker Compose, a gestão de recursos é um pilar fundamental para garantir a estabilidade, performance e segurança das aplicações. O atributo `cgroup` na seção `services` de um arquivo `docker-compose.yml`, introduzido na versão 2.15.0 do Compose Specification, desempenha um papel crucial ao permitir o controle sobre o namespace cgroup ao qual um contêiner se junta. Em conjunto com `cgroup_parent`, ele oferece um nível granular de gerenciamento de recursos, impactando diretamente como seus contêineres interagem com o sistema operacional hospedeiro.

---

### 2\. Conceitos Fundamentais

Para entender o `cgroup` no Docker Compose, é essencial primeiro compreender as **Control Groups (cgroups)** do Linux.

### O que são Cgroups?

Cgroups são uma funcionalidade do kernel Linux que permite organizar processos hierarquicamente em grupos para gerenciar e alocar recursos do sistema, como CPU, memória, I/O de disco e rede. Eles fornecem um mecanismo para:

- **Limitação**: Restringir a quantidade de um recurso que um grupo de processos pode consumir.
- **Priorização**: Alocar mais ou menos recursos para um grupo em detrimento de outros.
- **Contabilidade**: Monitorar o uso de recursos pelos grupos.
- **Controle**: Congelar ou descongelar grupos de processos.

Diferente dos **Namespaces Linux**, que isolam processos fornecendo a cada um sua própria visão do sistema (ex: PIDs, rede, sistema de arquivos), as cgroups se concentram em *distribuir e limitar* recursos entre grupos de processos. O Docker utiliza extensivamente ambos para criar o ambiente isolado e controlado dos contêineres.

### Cgroup V1 vs. Cgroup V2

Houve uma evolução nas cgroups, resultando em duas versões principais:

- **Cgroup V1**: Caracteriza-se por uma hierarquia separada para cada subsistema (CPU, memória, I/O, etc.). Isso significa que um processo pode pertencer a diferentes cgroups em diferentes hierarquias.
- **Cgroup V2**: Apresenta uma hierarquia unificada, onde todos os subsistemas estão em uma única árvore. Isso simplifica o gerenciamento e resolve algumas inconsistências da V1, oferecendo uma interface mais consistente e melhor controle de recursos. Distribuições Linux modernas e projetos como `systemd` estão migrando para a Cgroup V2. Nomes de parâmetros também podem ter mudado (ex: `cpu.shares` na V1 vs. `cpu.weight` na V2; `memory.limit_in_bytes` na V1 vs. `memory.max` na V2).

### O Propósito do Atributo `cgroup` no Docker Compose

O atributo `cgroup` no `docker-compose.yml` permite que você especifique o *namespace cgroup* ao qual o contêiner de um serviço deve se juntar. Isso influencia como o contêiner compartilha os recursos com outros processos no sistema hospedeiro ou com outros contêineres.

Quando o `cgroup` não é definido, o *runtime* do contêiner (e.g., `containerd` ou `runc`) decide qual namespace cgroup usar, se suportado.

### O Atributo `cgroup_parent`

Enquanto `cgroup` controla o *namespace*, `cgroup_parent` especifica um *cgroup pai opcional* para o contêiner. Isso é particularmente útil para agrupar múltiplos contêineres sob uma mesma hierarquia de cgroup predefinida no hospedeiro, permitindo o gerenciamento coletivo de seus recursos. Por exemplo, você pode definir limites de CPU ou memória para um grupo de contêineres, em vez de individualmente.

---

### 3\. Sintaxe Detalhada e Uso Prático

O atributo `cgroup` e `cgroup_parent` são configurados sob a chave `services` em seu arquivo `docker-compose.yml`.

### Sintaxe do `cgroup`

Disponível a partir do Docker Compose 2.15.0, o atributo `cgroup` aceita os seguintes valores:

- **`host`**:
    - **Sintaxe**:
        
        ```yaml
        services:
          meu_servico:
            image: minha_imagem
            cgroup: host
        
        ```
        
    - **Uso**: Faz com que o contêiner seja executado no namespace cgroup do *runtime* do contêiner. Isso significa que o contêiner compartilha o mesmo namespace cgroup que o processo `dockerd` ou `containerd` no hospedeiro. Em muitos cenários, isso pode significar que o contêiner tem acesso a um nível mais amplo de controle de recursos, ou pode ser gerenciado como parte do grupo Docker padrão do sistema.
    - **Contexto**: Útil para cenários onde você precisa que o contêiner se alinhe com a gestão de recursos do hospedeiro de forma mais direta, ou para depuração avançada do comportamento das cgroups.
- **`private`**:
    - **Sintaxe**:
        
        ```yaml
        services:
          meu_servico:
            image: minha_imagem
            cgroup: private
        
        ```
        
    - **Uso**: Executa o contêiner em seu próprio namespace cgroup privado. Esta é a opção mais comum para garantir o isolamento de recursos para o contêiner. O contêiner terá sua própria hierarquia de cgroup, permitindo que o Docker aplique limites de recursos específicos a ele sem interferir diretamente com outros processos ou contêineres no mesmo namespace cgroup do host.
    - **Contexto**: É o padrão para a maioria das distribuições Linux modernas que usam cgroup v2 com `systemd` como driver de cgroup, e geralmente é a escolha recomendada para isolamento e segurança.

### Sintaxe e Uso do `cgroup_parent`

O atributo `cgroup_parent` é mais flexível, permitindo que você especifique um caminho para um cgroup pai existente no sistema hospedeiro. O Docker, então, aninha o cgroup do contêiner sob esse pai.

- **Sintaxe**:
    
    ```yaml
    services:
      meu_servico:
        image: minha_imagem
        cgroup_parent: /minhas_aplicacoes/servico_web
        # ou, se usando systemd slices:
        # cgroup_parent: meuapp.slice
    
    ```
    
- **Uso Prático**:
O `cgroup_parent` é frequentemente utilizado em conjunto com `systemd slices` para um gerenciamento mais robusto de recursos. Primeiro, você definiria um `slice` no `systemd` do hospedeiro para agrupar recursos:
    
    **Exemplo de Arquivo `systemd slice` (`/etc/systemd/system/meuapp.slice`)**:
    
    ```
    [Unit]
    Description=Slice para aplicações Docker
    Before=slices.target
    
    [Slice]
    MemoryAccounting=true  # Habilita contabilidade de memória
    CPUAccounting=true     # Habilita contabilidade de CPU
    MemoryMax=4G           # Limite máximo de memória para este slice (e seus filhos)
    CPUQuota=50%           # Cota de CPU (50% de um núcleo)
    
    ```
    
    Após criar este arquivo, recarregue o `systemd`: `sudo systemctl daemon-reload`.
    
    Então, no seu `docker-compose.yml`, você referenciaria este slice como `cgroup_parent`:
    
    ```yaml
    version: '3.8'
    services:
      servico_frontend:
        image: minha_imagem_frontend
        cgroup_parent: meuapp.slice # Contêiner frontend usará os limites definidos em meuapp.slice
        ports:
          - "80:80"
        deploy: # Exemplo de limites adicionais, que serão aninhados sob o cgroup pai
          resources:
            limits:
              cpus: '0.2' # Limite de 20% de CPU para este contêiner
              memory: 512M
    
      servico_backend:
        image: minha_imagem_backend
        cgroup_parent: meuapp.slice # Contêiner backend também usará os limites de meuapp.slice
        ports:
          - "8080:8080"
        deploy:
          resources:
            limits:
              cpus: '0.3' # Limite de 30% de CPU para este contêiner
              memory: 1G
    
    ```
    
    Neste exemplo, ambos `servico_frontend` e `servico_backend` operam dentro do cgroup `meuapp.slice`. Se a soma dos limites de CPU ou memória de ambos os serviços exceder os limites definidos em `meuapp.slice`, o sistema operacional gerenciará a alocação de forma a respeitar o limite do slice pai. Isso é poderoso para consolidar o gerenciamento de recursos para grupos de serviços relacionados.
    

---

### 4\. Cenários de Restrição ou Não Aplicação

Embora `cgroup` e `cgroup_parent` ofereçam controle granular, há situações em que seu uso explícito pode não ser a melhor escolha ou pode ser desnecessário:

- **Configuração Padrão Suficiente**: Para a maioria das aplicações Docker Compose simples, os padrões de alocação de cgroup do Docker (geralmente `private` com cgroup v2 e driver `systemd`) são suficientes. Se você não tem requisitos específicos de isolamento de namespace cgroup ou agrupamento de recursos, definir `cgroup` ou `cgroup_parent` explicitamente pode não adicionar valor.
- **Conflito com Drivers de Cgroup**: A forma como as cgroups são gerenciadas pode variar dependendo do driver de cgroup configurado no seu daemon Docker (`cgroupfs` vs. `systemd`). Se houver um desalinhamento entre o driver do Docker e a configuração que você tenta impor via `cgroup` ou `cgroup_parent`, pode haver comportamentos inesperados ou os limites podem não ser aplicados corretamente. É crucial verificar o driver de cgroup do seu sistema (`docker info | grep "Cgroup Driver"`) e a versão da cgroup (`mount | grep cgroup`).
- **Complexidade Excessiva**: Definir `cgroup_parent` exige um entendimento do sistema de cgroups do hospedeiro e, muitas vezes, a criação manual de cgroups ou `systemd slices`. Isso adiciona complexidade à sua configuração e à portabilidade da sua aplicação Docker Compose.
- **Segurança (Privilégios)**: Usar `cgroup: host` pode, em certos contextos, conceder mais acesso ao contêiner em relação ao controle de recursos do hospedeiro, o que pode ser uma preocupação de segurança se o contêiner não for totalmente confiável.

---

### 5\. Componentes Chave Associados

O atributo `cgroup` não funciona isoladamente. Ele está intrinsecamente ligado a outras configurações de gerenciamento de recursos no Docker e Docker Compose:

- **`deploy.resources.limits` e `deploy.resources.reservations`**: Estas são as chaves padrão no Docker Compose (especialmente na versão 3.x) para definir limites de CPU (`cpus`) e memória (`memory`) para um serviço. Embora `cgroup` e `cgroup_parent` definam o *namespace* ou *grupo* de cgroup, `deploy.resources` é o mecanismo principal para *impor* os limites de recursos usando as cgroups subjacentes.
    
    ```yaml
    services:
      meu_servico:
        image: minha_imagem
        deploy:
          resources:
            limits:
              cpus: '0.5' # Limita a 50% de um núcleo de CPU
              memory: 256M # Limita a 256MB de memória
            reservations:
              cpus: '0.1' # Garante 10% de CPU
              memory: 64M # Garante 64MB de memória
    
    ```
    
    O Docker traduz essas configurações em parâmetros de cgroup (como `cpu.max`, `memory.max`, `memory.min` etc.) dentro do cgroup do contêiner.
    
- **`cpu_shares`, `cpu_quota`, `cpu_period`**: Antigas configurações (ainda presentes em algumas versões do Docker Compose para compatibilidade) que permitem um controle mais detalhado da CPU, mas que são tipicamente abstraídas por `deploy.resources.limits.cpus`.
    - `cpu_shares`: Uma proporção de CPU que o contêiner recebe quando há contenção de recursos. (Cgroup V1: `cpu.shares`, Cgroup V2: substituído por `cpu.weight` em alguns contextos).
    - `cpu_quota` e `cpu_period`: Definem um limite absoluto de CPU em um determinado período.
- **`mem_limit`, `memswap_limit`**: Equivalentes antigos para limites de memória, também geralmente substituídos por `deploy.resources.limits.memory`.
- **`pids_limit`**: Controla o número máximo de processos que um contêiner pode criar, prevenindo "fork bombs". Isso também é imposto via cgroups.

O `cgroup` e `cgroup_parent` atuam como "meta-configurações" que definem a estrutura da cgroup para o contêiner, enquanto as opções de `resources` definem os *valores* dos limites de recursos dentro dessa estrutura de cgroup.

---

### 6\. Melhores Práticas e Padrões de Uso

- **Use `cgroup: private` como Padrão**: A menos que você tenha um motivo muito específico para usar `host`, `private` é a opção mais segura e isolada para o atributo `cgroup`. Ela garante que cada contêiner tenha seu próprio namespace cgroup, facilitando o gerenciamento individual de recursos.
- **Aproveite `cgroup_parent` para Agrupamento Lógico**: Se você precisa aplicar limites de recursos a um *grupo de contêineres* (e não apenas a contêineres individuais), `cgroup_parent` é a ferramenta ideal. Combine-o com `systemd slices` no hospedeiro para um controle centralizado e robusto. Isso é útil para ambientes multi-locatário ou para agrupar serviços de uma mesma aplicação que devem compartilhar um orçamento de recursos.
- **Priorize `deploy.resources` para Limites Diretos**: Para definir limites de CPU e memória de um *único contêiner*, a forma mais limpa e recomendada no Docker Compose 3.x é usar `deploy.resources.limits`. O Docker se encarregará de configurar as cgroups subjacentes corretamente.
- **Monitore o Uso de Recursos**: Mesmo com limites definidos, é crucial monitorar o uso real de CPU, memória e I/O pelos seus contêineres. Ferramentas como `docker stats`, `cAdvisor` ou o próprio `systemd-cgtop` (se estiver usando `systemd slices`) podem ajudar a verificar se os limites estão sendo respeitados e se a alocação de recursos está otimizada.
- **Cuidado com a Versão da Cgroup**: Esteja ciente da versão da cgroup (v1 ou v2) que seu sistema Linux está utilizando, pois isso pode impactar o comportamento de certas configurações de recursos e a estrutura dos arquivos de cgroup no `/sys/fs/cgroup`.
- **Documente suas Decisões**: Se você optar por usar `cgroup` ou `cgroup_parent` de forma explícita, documente o porquê e como essas configurações se encaixam na sua estratégia geral de gerenciamento de recursos.

---

### 7\. Exemplo Prático Completo

Vamos considerar um cenário onde você tem uma aplicação com um serviço de *frontend* (Nginx), um serviço de *backend* (Spring Boot) e um banco de dados (PostgreSQL). Você quer garantir que sua aplicação como um todo não exceda um determinado uso de CPU e memória, mas também deseja controlar individualmente cada serviço.

**1. Configuração do `systemd slice` no Hospedeiro (`/etc/systemd/system/minhaaplicacao.slice`)**:

```
[Unit]
Description=Slice para Minha Aplicação Docker
Before=slices.target

[Slice]
MemoryAccounting=true
CPUAccounting=true
MemoryMax=8G     # Limite de 8GB de RAM para toda a aplicação
CPUQuota=200%    # Limite de 2 núcleos de CPU para toda a aplicação (200% = 2 * 100%)

```

Após criar, execute: `sudo systemctl daemon-reload`

**2. Arquivo `docker-compose.yml`**:

```yaml
version: '3.8'

services:
  frontend:
    image: nginx:latest
    container_name: minhaapp_frontend
    ports:
      - "80:80"
    cgroup: private # Padrão para isolamento
    cgroup_parent: minhaaplicacao.slice # Aninha sob o slice da aplicação
    deploy:
      resources:
        limits:
          cpus: '0.5' # Limita Nginx a 0.5 núcleo de CPU
          memory: 256M # Limita Nginx a 256MB de RAM
        reservations:
          cpus: '0.1'
          memory: 64M
    networks:
      - app_network

  backend:
    image: minha_imagem_backend_spring_boot:latest # Substitua pela sua imagem
    container_name: minhaapp_backend
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/meubanco
      SPRING_DATASOURCE_USERNAME: user
      SPRING_DATASOURCE_PASSWORD: password
    cgroup: private
    cgroup_parent: minhaaplicacao.slice
    deploy:
      resources:
        limits:
          cpus: '1.0' # Limita Backend a 1 núcleo de CPU
          memory: 1G # Limita Backend a 1GB de RAM
        reservations:
          cpus: '0.2'
          memory: 256M
    depends_on:
      - db
    networks:
      - app_network

  db:
    image: postgres:13
    container_name: minhaapp_db
    environment:
      POSTGRES_DB: meubanco
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - db_data:/var/lib/postgresql/data
    cgroup: private
    cgroup_parent: minhaaplicacao.slice
    deploy:
      resources:
        limits:
          cpus: '0.5' # Limita DB a 0.5 núcleo de CPU
          memory: 512M # Limita DB a 512MB de RAM
        reservations:
          cpus: '0.1'
          memory: 128M
    networks:
      - app_network

networks:
  app_network:
    driver: bridge

volumes:
  db_data:

```

Neste exemplo:

- Todos os serviços (`frontend`, `backend`, `db`) são aninhados sob o `systemd slice` `minhaaplicacao.slice` usando `cgroup_parent`. Isso significa que, em conjunto, eles não excederão 2 núcleos de CPU ou 8GB de RAM.
- Cada serviço individual possui seus próprios limites de CPU e memória definidos em `deploy.resources.limits`. Esses limites são aplicados *dentro* do cgroup pai.
- O atributo `cgroup: private` é usado para garantir que cada contêiner tenha seu próprio namespace cgroup para isolamento.

Ao iniciar esta aplicação com `docker-compose up -d`, o Docker configurará os cgroups para cada contêiner de acordo com a hierarquia definida, garantindo que os limites globais e individuais sejam respeitados.

---

Este detalhamento visa proporcionar um entendimento abrangente do atributo `cgroup` no Docker Compose, sua relação com as cgroups do Linux e como ele pode ser utilizado para um gerenciamento eficaz de recursos em suas aplicações conteinerizadas.