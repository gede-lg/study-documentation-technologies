# cap_drop

# Atributo `cap_drop` em Docker Compose: Uma Explicação Detalhada para Segurança de Contêineres

## Introdução

No universo do desenvolvimento e implantação de aplicações, o Docker e o Docker Compose se estabeleceram como ferramentas indispensáveis para empacotar e orquestrar contêineres. Contudo, a segurança é uma preocupação primordial ao executar cargas de trabalho conteinerizadas. É nesse contexto que o atributo `cap_drop`, presente na chave `services` de um arquivo `docker-compose.yml`, se torna fundamental. Ele permite controlar as "capacidades" do Linux que um contêiner possui, garantindo que ele opere com o mínimo de privilégios necessários e, consequentemente, reduzindo a superfície de ataque.

## Sumário

Esta explicação detalhada abordará os seguintes pontos para oferecer uma compreensão completa do `cap_drop`:

- **Conceitos Fundamentais:** Entendimento das capacidades do Linux e seu papel na segurança de contêineres.
- **Sintaxe Detalhada e Uso Prático:** Como configurar `cap_drop` em `docker-compose.yml` com exemplos de código.
- **Cenários de Restrição ou Não Aplicação:** Limitações e quando `cap_drop` pode não ser a melhor ou única solução.
- **Componentes Chave Associados:** Relação com `cap_add` e outras ferramentas de segurança.
- **Melhores Práticas e Padrões de Uso:** Recomendações para uma postura de segurança robusta.
- **Exemplo Prático Completo:** Um cenário demonstrativo da aplicação de `cap_drop`.

---

## Conceitos Fundamentais

### O que são Capacidades do Linux?

Tradicionalmente, os sistemas Unix-like operavam com uma dicotomia de privilégios: um processo era executado como `root` (superusuário) com todos os privilégios, ou como um usuário comum com privilégios limitados. Essa abordagem "tudo ou nada" era um desafio para a segurança, pois mesmo tarefas que exigiam apenas uma fração dos privilégios de `root` tinham que ser executadas com acesso total.

Para resolver isso, o kernel Linux introduziu o conceito de **capacidades (capabilities)**. As capacidades dividem os privilégios tradicionalmente associados ao usuário `root` em unidades menores e distintas. Isso permite que um processo, mesmo que não esteja sendo executado como `root` completo, receba apenas as permissões específicas de que precisa para realizar uma determinada tarefa. Por exemplo, um servidor web que precisa se vincular a uma porta abaixo de 1024 (que normalmente requer privilégios de `root`) pode receber apenas a capacidade `CAP_NET_BIND_SERVICE`, em vez de ter acesso `root` completo ao sistema.

### Capacidades em Contêineres Docker

Por padrão, os contêineres Docker são iniciados com um conjunto de capacidades padrão. Este conjunto é uma seleção cuidadosa que visa equilibrar funcionalidade e segurança. No entanto, para maximizar a segurança e aderir ao **princípio do menor privilégio**, é frequentemente desejável remover capacidades adicionais que um contêiner não necessita para sua operação. É aqui que `cap_drop` entra em cena.

O `cap_drop` (e seu complemento, `cap_add`) permite aos usuários ajustar as capacidades padrão, fornecendo um controle granular sobre os privilégios do kernel Linux que um contêiner possui.

### Propósito do `cap_drop`

O principal propósito do `cap_drop` é **reduzir a superfície de ataque** de um contêiner. Ao remover capacidades desnecessárias, mesmo que um invasor consiga comprometer o processo dentro do contêiner, o escopo de suas ações é limitado. Por exemplo, se um contêiner não precisa manipular interfaces de rede, a remoção da capacidade `CAP_NET_ADMIN` impede que um processo malicioso altere as configurações de rede do host ou outros contêineres, mesmo que consiga escapar do isolamento básico do contêiner.

---

## Sintaxe Detalhada e Uso Prático

O atributo `cap_drop` é definido sob a chave `services` em um arquivo `docker-compose.yml`. Ele aceita uma lista de strings, onde cada string representa uma capacidade Linux a ser removida do contêiner.

### Sintaxe Básica

```yaml
version: '3.8'
services:
  meu_servico:
    image: minha_imagem
    cap_drop:
      - NET_ADMIN
      - SYS_ADMIN
      - CHOWN

```

**Explicação:**

- `version`: Especifica a versão da sintaxe do Docker Compose.
- `services`: A seção onde os serviços (contêineres) da aplicação são definidos.
- `meu_servico`: O nome do seu serviço.
- `image`: A imagem Docker a ser usada para este serviço.
- `cap_drop`: Uma lista de capacidades a serem removidas. Neste exemplo, `NET_ADMIN` (para administração de rede), `SYS_ADMIN` (para operações de sistema) e `CHOWN` (para alteração de propriedade de arquivos) são removidas.

### Lista de Capacidades Comuns (Exemplos)

A lista completa de capacidades pode ser encontrada na página `man 7 capabilities` do Linux. Algumas das capacidades mais comuns e seus usos incluem:

- **`CHOWN`**: Permite alterar a propriedade de arquivos e diretórios.
- **`DAC_OVERRIDE`**: Permite ignorar as permissões de leitura, escrita e execução de arquivos.
- **`FOWNER`**: Permite ignorar as permissões de propriedade de arquivos.
- **`MKNOD`**: Permite criar arquivos especiais (dispositivos).
- **`NET_ADMIN`**: Permite realizar várias operações de administração de rede (configurar interfaces, rotas, firewalls).
- **`NET_RAW`**: Permite o uso de soquetes RAW e PACKET (útil para ferramentas de rede como `ping`, `traceroute`).
- **`SETFCAP`**: Permite definir capacidades em arquivos.
- **`SETGID`**: Permite manipular GIDs de processos.
- **`SETPCAP`**: Permite manipular capacidades de outros processos.
- **`SETUID`**: Permite manipular UIDs de processos.
- **`SYS_ADMIN`**: Um conjunto amplo de operações administrativas, como montagem de sistemas de arquivos, manipulação de discos, entre outros. **Essa é uma das capacidades mais perigosas.**
- **`SYS_CHROOT`**: Permite usar a chamada de sistema `chroot`.
- **`KILL`**: Permite enviar sinais para qualquer processo.
- **`SYS_MODULE`**: Permite carregar e descarregar módulos do kernel.

### Uso do `ALL` para `cap_drop`

Uma prática de segurança altamente recomendada é remover *todas* as capacidades e, em seguida, adicionar apenas as que são estritamente necessárias. Isso adere ainda mais ao princípio do menor privilégio.

```yaml
version: '3.8'
services:
  servico_seguro:
    image: outra_imagem
    cap_drop:
      - ALL # Remove todas as capacidades por padrão
    cap_add:
      - NET_BIND_SERVICE # Adiciona apenas a capacidade de vincular a portas baixas (<1024)

```

**Explicação:**

- `cap_drop: - ALL`: Remove todas as capacidades que o Docker concede por padrão.
- `cap_add: - NET_BIND_SERVICE`: Adiciona *apenas* a capacidade `NET_BIND_SERVICE`, que é essencial para aplicações que precisam escutar em portas como 80 ou 443.

**Ordem de Operação `cap_add` e `cap_drop`:**

É importante notar que a ordem em que `cap_add` e `cap_drop` são listados no YAML não importa. O Docker processa essas listas da seguinte forma:

1. Se `privileged: true` é usado, `cap_add` e `cap_drop` são ignorados, e o contêiner recebe todas as capacidades.
2. Se `cap_add` e `cap_drop` estão vazios, o contêiner recebe o conjunto de capacidades padrão do Docker.
3. Se `cap_add` contém `ALL`: o contêiner recebe *todas* as capacidades do kernel, *menos* as listadas em `cap_drop` (qualquer `ALL` em `cap_drop` é ignorado neste caso).
4. Se `cap_drop` contém `ALL`: o contêiner recebe *apenas* as capacidades listadas em `cap_add`, ignorando as capacidades padrão do Docker.
5. Caso contrário (nenhum `ALL` e `-privileged` é `false`): primeiro, o Docker remove as capacidades listadas em `cap_drop` do conjunto padrão de capacidades; em seguida, adiciona as capacidades listadas em `cap_add` ao resultado.

**Exemplo Prático com Interação de `ALL`:**

Considere o seguinte cenário: você quer que um contêiner tenha acesso `CAP_SYS_PTRACE` para depuração, mas que todas as outras capacidades sejam removidas.

```yaml
version: '3.8'
services:
  depurador_app:
    image: alpine/git # Exemplo de imagem
    command: ["sh", "-c", "apk add --no-cache strace && strace sleep 10"]
    cap_drop:
      - ALL # Remove todas as capacidades
    cap_add:
      - SYS_PTRACE # Adiciona apenas a capacidade de rastrear outros processos (para strace)

```

Neste exemplo, o contêiner iniciará com praticamente nenhuma capacidade, exceto `SYS_PTRACE`, o que é ideal para uma ferramenta de depuração que precisa apenas dessa permissão específica.

---

## Cenários de Restrição ou Não Aplicação

Embora `cap_drop` seja uma ferramenta poderosa para segurança, existem situações em que ele pode não ser suficiente ou aplicável:

- **Uso de `-privileged`:** Se um serviço no Docker Compose for configurado com `privileged: true`, todas as restrições de capacidade são desabilitadas, e o contêiner terá acesso irrestrito ao hardware e às capacidades do kernel do host. Nesse caso, `cap_drop` (e `cap_add`) são completamente ignorados. O uso de `privileged: true` deve ser evitado a todo custo, a menos que seja absolutamente necessário e as implicações de segurança sejam totalmente compreendidas.
- **Funcionalidade da Aplicação:** Dropar capacidades indiscriminadamente pode quebrar a funcionalidade de uma aplicação. É crucial testar exaustivamente um contêiner após a remoção de capacidades para garantir que todas as funcionalidades esperadas continuem operando corretamente. Por exemplo, dropar `CAP_NET_RAW` impedirá que ferramentas como `ping` funcionem dentro do contêiner.
- **Vulnerabilidades do Kernel:** `cap_drop` restringe os privilégios concedidos a um processo, mas não protege contra vulnerabilidades no próprio kernel do Linux. Se houver uma falha de segurança no kernel, um invasor pode ser capaz de explorar essa falha para escapar do contêiner, independentemente das capacidades dropadas.
- **Conflito com outras ferramentas de segurança:** Embora complementares, o uso excessivo de `cap_drop` sem considerar perfis de `seccomp` ou políticas de AppArmor/SELinux pode levar a uma configuração excessivamente complexa ou redundante.

---

## Componentes Chave Associados

### `cap_add`

Como mencionado, `cap_add` é o oposto de `cap_drop`. Ele permite adicionar capacidades específicas ao contêiner, além das capacidades padrão ou após ter dropado todas elas com `ALL`. A combinação de `cap_drop: - ALL` e `cap_add: [...]` é a estratégia mais segura.

### Linux Kernel e `man 7 capabilities`

O entendimento das capacidades reside no kernel Linux. A documentação oficial do Linux, acessível via `man 7 capabilities` em um terminal Linux, fornece uma lista completa e detalhada de todas as capacidades disponíveis, suas descrições e implicações. Essa é a fonte definitiva para consultar as capacidades.

### Perfis Seccomp, AppArmor e SELinux

Além das capacidades, Docker também suporta outras camadas de segurança:

- **Perfis Seccomp (Secure Computing Mode):** Uma interface do kernel Linux que permite restringir as chamadas de sistema (syscalls) que um processo pode fazer. Docker aplica um perfil seccomp padrão que desabilita muitas syscalls perigosas. Perfis personalizados podem ser especificados para um controle ainda mais fino.
- **AppArmor e SELinux:** São módulos de segurança para o kernel Linux que fornecem controle de acesso obrigatório (MAC). Eles podem ser usados para definir políticas de segurança abrangentes que controlam o acesso a recursos do sistema de arquivos, rede e outros.

`cap_drop` trabalha em conjunto com essas tecnologias para criar um ambiente de contêiner mais seguro. `cap_drop` lida com privilégios de kernel, enquanto seccomp lida com chamadas de sistema e AppArmor/SELinux com políticas de acesso a recursos.

---

## Melhores Práticas e Padrões de Uso

1. **Princípio do Menor Privilégio como Ponto de Partida:** Sempre comece removendo *todas* as capacidades (`cap_drop: - ALL`) e adicione *apenas* as que são comprovadamente necessárias para a aplicação funcionar.
2. **Identifique as Capacidades Necessárias:** Antes de remover, entenda as necessidades da sua aplicação. Ferramentas como `strace` ou logs de auditoria (se configurados) podem ajudar a identificar as chamadas de sistema e, por extensão, as capacidades que sua aplicação realmente utiliza.
3. **Teste Exaustivamente:** Após ajustar as capacidades, teste minuciosamente a aplicação em todas as suas funcionalidades para garantir que nada foi quebrado.
4. **Combine com Outras Medidas de Segurança:**
    - **Executar como Usuário Não-Root:** Sempre configure seus contêineres para executar como um usuário não-root sempre que possível. Isso adiciona uma camada de segurança significativa.
    - **Sistema de Arquivos Somente Leitura:** Use `read_only: true` para o sistema de arquivos do contêiner, permitindo que as gravações ocorram apenas em volumes explicitamente montados (por exemplo, `/tmp`).
    - **Perfis Seccomp Personalizados:** Considere criar e aplicar perfis seccomp personalizados para limitar ainda mais as chamadas de sistema.
    - **Imagens Mínimas:** Use imagens base menores e mais seguras (ex: Alpine, distroless) para reduzir a superfície de ataque geral.
    - **Mantenha Docker e Imagens Atualizados:** Mantenha o Docker Engine, Docker Compose e as imagens de contêiner sempre atualizadas para se beneficiar das últimas correções de segurança.
5. **Documente Suas Escolhas:** Mantenha um registro das capacidades que foram dropadas ou adicionadas, e a justificativa para essas decisões.

---

## Exemplo Prático Completo: Aplicação Web Segura

Vamos considerar uma aplicação web simples em Node.js ou Python que serve conteúdo estático e não precisa de privilégios de rede avançados ou acesso a dispositivos. O objetivo é torná-la o mais segura possível, limitando suas capacidades.

**Estrutura de Arquivos:**

```
.
├── docker-compose.yml
└── app
    └── Dockerfile
    └── app.js (ou app.py)
    └── package.json (ou requirements.txt)

```

**`app/Dockerfile` (Exemplo para Node.js):**

```
# Usa uma imagem base leve
FROM node:18-alpine

# Define o usuário não-root para execução
RUN addgroup --system appgroup && adduser --system --ingroup appgroup appuser
USER appuser

WORKDIR /app

COPY package.json ./
RUN npm install

COPY . .

EXPOSE 8080

CMD ["node", "app.js"]

```

**`app/app.js` (Exemplo simples de servidor HTTP):**

```jsx
const http = require('http');

const hostname = '0.0.0.0'; // Escuta em todas as interfaces
const port = 8080; // Porta não privilegiada

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello from a secure container!\\n');
});

server.listen(port, hostname, () => {
  console.log(`Server running at <http://$>{hostname}:${port}/`);
});

```

**`docker-compose.yml` com `cap_drop` e outras medidas de segurança:**

```yaml
version: '3.8'
services:
  web_app:
    build: ./app
    ports:
      - "80:8080" # Mapeia a porta privilegiada 80 do host para a porta não privilegiada 8080 do contêiner
    read_only: true # Torna o sistema de arquivos do contêiner somente leitura
    tmpfs: # Permite gravação em /tmp, essencial para muitas aplicações
      - /tmp
    cap_drop:
      - ALL # Dropa todas as capacidades por padrão
    cap_add:
      # Nenhuma capacidade específica é adicionada, pois a aplicação não exige privilégios de kernel.
      # A capacidade NET_BIND_SERVICE não é necessária, pois a aplicação escuta na porta 8080
      # e a exposição para a porta 80 do host é feita pelo Docker daemon (que tem os privilégios).
    security_opt:
      - no-new-privileges:true # Garante que o contêiner não possa ganhar novos privilégios
    environment:
      NODE_ENV: production

```

**Explicação do Exemplo:**

- **`build: ./app`**: Constrói a imagem Docker a partir do Dockerfile na pasta `app`.
- **`ports: - "80:8080"`**: A aplicação Node.js escuta na porta `8080` (não privilegiada). O Docker Compose mapeia a porta `80` do host (privilegiada) para a `8080` do contêiner. Isso permite que a aplicação do contêiner não precise da capacidade `NET_BIND_SERVICE`.
- **`read_only: true`**: O sistema de arquivos raiz do contêiner é montado como somente leitura, impedindo gravações não autorizadas.
- **`tmpfs: - /tmp`**: Cria um `tmpfs` (sistema de arquivos baseado em RAM) para o diretório `/tmp`, permitindo que a aplicação escreva arquivos temporários se necessário, sem comprometer a imutabilidade do restante do sistema de arquivos.
- **`cap_drop: - ALL`**: Esta é a medida de segurança mais forte em relação às capacidades. Remove explicitamente *todas* as capacidades.
- **`cap_add:` (vazio)**: Como a aplicação é simples e o mapeamento de portas é feito pelo Docker (não pelo processo dentro do contêiner), nenhuma capacidade é adicionada. Isso exemplifica o menor privilégio possível.
- **`security_opt: - no-new-privileges:true`**: Uma opção de segurança que garante que o processo dentro do contêiner não pode escalar privilégios, por exemplo, através de executáveis com `setuid` ou `setgid`.
- **`environment: NODE_ENV: production`**: Configurações específicas para o ambiente de produção.

Ao executar `docker compose up`, este contêiner será iniciado com um conjunto de privilégios extremamente limitado, tornando-o significativamente mais resistente a ataques.

---

## Sugestões para Aprofundamento

Para aprofundar seu conhecimento sobre este tópico, Gedê, sugiro explorar os seguintes recursos:

- **Documentação Oficial do Docker sobre Capacidades:** [Running containers | Docker Docs](https://www.google.com/search?q=https://docs.docker.com/engine/security/references/apparmor/) (Pesquise por "capabilities" nesta página).
- **Página `man 7 capabilities` do Linux:** Para uma lista completa e detalhada de todas as capacidades e suas permissões específicas. Você pode acessá-la em qualquer terminal Linux.
- **OWASP Docker Security Cheat Sheet:** Uma excelente fonte de melhores práticas de segurança para Docker, incluindo o gerenciamento de capacidades. [Docker Security - OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)
- **Artigos sobre Exploiting Container Capabilities:** Para entender o "porquê" de dropar capacidades, leia sobre como capacidades excessivas podem ser exploradas por invasores. [Exploiting Excessive Container Capabilities - Redfox Security](https://redfoxsec.com/blog/exploiting-excessive-container-capabilities/)
- **Entendimento de Seccomp, AppArmor e SELinux:** Para uma visão mais holística da segurança de contêineres, pesquise sobre esses mecanismos complementares.

Espero que esta explicação detalhada, A.R.I.A, tenha sido útil para você, Gedê\! Se tiver mais alguma dúvida, pode perguntar.