# depends_on

De acordo, Gedê\! Vamos mergulhar fundo no atributo `depends_on` do Docker Compose. Como A.R.I.A, vou garantir que você tenha uma explicação detalhada e completa.

---

# Entendendo o Atributo `depends_on` da Chave `services` no Docker Compose

## Introdução

No mundo dos microsserviços e aplicações distribuídas, gerenciar a ordem de inicialização e a dependência entre diferentes componentes é crucial. O **Docker Compose** é uma ferramenta poderosa que facilita a definição e a execução de aplicações multi-contêiner. Dentro do arquivo `docker-compose.yml`, a chave `services` é onde definimos cada serviço da nossa aplicação. Um atributo fundamental para orquestrar esses serviços é o `depends_on`. Ele permite especificar dependências entre os serviços, garantindo que um serviço seja iniciado somente após seus dependentes estarem em um determinado estado.

## Sumário

Esta explicação detalhada abordará os seguintes pontos:

- **Conceitos Fundamentais:** O que é o `depends_on`, sua importância, propósito e como ele se encaixa no ciclo de vida do Docker Compose.
- **Sintaxe Detalhada e Uso Prático:** As diferentes formas de usar `depends_on`, incluindo exemplos de código comentados.
- **Cenários de Restrição ou Não Aplicação:** Quando o `depends_on` pode não ser a melhor solução e alternativas.
- **Componentes Chave Associados:** Análise dos comportamentos de `depends_on` em relação ao ciclo de vida dos contêineres e ao seu estado.
- **Melhores Práticas e Padrões de Uso:** Recomendações para utilizar `depends_on` de forma eficaz.
- **Exemplo Prático Completo:** Um cenário com vários serviços e suas dependências, demonstrando o uso do `depends_on`.

---

## Conceitos Fundamentais

O atributo `depends_on` é um dos mais utilizados em arquivos Docker Compose para gerenciar a **ordem de inicialização** e as **dependências de serviço**. Ele instrui o Docker Compose a iniciar um serviço somente depois que seus serviços dependentes forem iniciados.

### Propósito e Importância

O propósito principal do `depends_on` é garantir que os serviços que dependem de outros (como uma aplicação web que precisa de um banco de dados) sejam iniciados na sequência correta. Sem ele, o Docker Compose tentaria iniciar todos os serviços em paralelo, o que poderia levar a erros se um serviço tentasse se conectar a outro que ainda não está pronto.

Considere uma aplicação web (por exemplo, seu serviço Backend Java ou GO) que precisa de um banco de dados (como PostgreSQL ou MySQL). Se o serviço da aplicação web for iniciado antes do banco de dados, ele falhará ao tentar estabelecer uma conexão, pois o banco de dados ainda não estará disponível para aceitar conexões. O `depends_on` resolve esse problema, assegurando que o contêiner do banco de dados esteja "ativo" antes que o contêiner da aplicação web seja iniciado.

É importante ressaltar que o `depends_on` garante apenas que o contêiner dependente foi **iniciado**. Ele **não** espera que o serviço dentro do contêiner esteja "pronto" para aceitar conexões ou que suas portas estejam escutando. Para cenários onde é preciso esperar pela prontidão de um serviço (por exemplo, um banco de dados estar realmente pronto para aceitar conexões SQL), outras estratégias como `healthchecks` ou scripts de "wait-for-it" são mais apropriadas, as quais abordaremos brevemente mais adiante.

### Como se encaixa no Ciclo de Vida do Docker Compose

Quando você executa um comando como `docker compose up`, o Docker Compose lê o arquivo `docker-compose.yml` e constrói um grafo de dependências com base nos atributos `depends_on`. Ele então inicia os serviços na ordem correta, resolvendo as dependências. Se um serviço tem múltiplas dependências, todas elas devem ser satisfeitas antes que ele possa ser iniciado.

---

## Sintaxe Detalhada e Uso Prático

Existem duas formas principais de utilizar o `depends_on`, dependendo da versão do Compose File Format.

### Forma Curta (Compose File Format v2 e v3.X)

Esta é a sintaxe mais simples e comum. Ela apenas garante a ordem de inicialização do contêiner.

```yaml
version: '3.8'

services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    depends_on:
      - db # O serviço 'web' só será iniciado após o serviço 'db' ser iniciado.
      - api # O serviço 'web' também depende do serviço 'api'.

  api:
    image: meu-backend-go:latest # Seu futuro backend GO, Gedê!
    build: .
    ports:
      - "8080:8080"
    environment:
      DATABASE_URL: "jdbc:postgresql://db:5432/mydatabase"
    depends_on:
      - db # A API depende do banco de dados.

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:

```

**Explicação dos comentários no código:**

- No exemplo acima, o serviço `web` (um Nginx) depende dos serviços `db` e `api`. Isso significa que o Docker Compose garantirá que os contêineres `db` e `api` sejam iniciados antes do contêiner `web`.
- O serviço `api` (seu backend GO, por exemplo) depende do serviço `db`. Assim, o contêiner `db` será iniciado antes do `api`.
- A ordem de inicialização efetiva, neste caso, seria: `db` -\> `api` -\> `web`.

### Forma Longa (Compose File Format v3.8+)

A partir do Compose File Format versão 3.8, o `depends_on` ganhou uma sintaxe mais rica, permitindo especificar a **condição de dependência**. Isso oferece um controle mais refinado sobre quando um serviço deve ser considerado "pronto" para seus dependentes. As condições possíveis são:

- `service_started`: (Padrão, equivalente à forma curta) O serviço dependente foi iniciado.
- `service_healthy`: O serviço dependente passou em seu `healthcheck`. Isso requer que o serviço dependente tenha uma configuração de `healthcheck` definida.
- `service_completed_successfully`: O serviço dependente foi executado e saiu com um código de saída zero (indicando sucesso). Isso é útil para serviços que são tarefas únicas e que precisam ser concluídas antes que outros serviços dependam de seus resultados.

<!-- end list -->

```yaml
version: '3.8'

services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    depends_on:
      api:
        condition: service_healthy # 'web' só inicia após 'api' estar saudável.
      db:
        condition: service_started # 'web' só inicia após 'db' ter sido iniciado. (equivalente à forma curta)

  api:
    image: meu-backend-go:latest
    build: .
    ports:
      - "8080:8080"
    environment:
      DATABASE_URL: "jdbc:postgresql://db:5432/mydatabase"
    depends_on:
      db:
        condition: service_healthy # A API só inicia após o banco de dados estar saudável.
    healthcheck: # Healthcheck para a API, necessário para 'service_healthy'
      test: ["CMD", "curl", "-f", "<http://localhost:8080/health>"]
      interval: 10s
      timeout: 5s
      retries: 5

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data
    healthcheck: # Healthcheck para o banco de dados, essencial para 'service_healthy'
      test: ["CMD-SHELL", "pg_isready -U user -d mydatabase"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  db_data:

```

**Explicação dos comentários no código:**

- Neste exemplo, o serviço `web` agora depende do `api` estar `healthy` (saudável) e do `db` ter sido `started` (iniciado).
- O serviço `api` depende do `db` estar `healthy`.
- Para que as condições `service_healthy` funcionem, os serviços `api` e `db` precisam ter suas configurações de `healthcheck` definidas. Um `healthcheck` define como o Docker deve verificar se um contêiner está "saudável" (por exemplo, se um servidor web está respondendo ou se um banco de dados está pronto para aceitar conexões).

### Variações de Sintaxe e Comportamento

É crucial entender que, por padrão (e na forma curta), `depends_on` apenas controla a **ordem de início**. Ele não garante que o serviço dependente esteja *totalmente pronto* para uso. Se o seu serviço precisar de algo mais do que apenas o contêiner estar rodando (por exemplo, um banco de dados com seus schemas e dados iniciais prontos), você precisará de mecanismos adicionais, como os `healthchecks` na forma longa ou scripts personalizados.

---

## Cenários de Restrição ou Não Aplicação

Embora `depends_on` seja útil, existem situações em que ele pode não ser a melhor escolha ou onde suas limitações se tornam evidentes:

- **Verificação de Prontidão do Serviço (Service Readiness):** Como mencionado, `depends_on` na sua forma padrão (e na forma curta) não espera que o serviço *dentro* do contêiner esteja pronto para aceitar conexões. Por exemplo, um servidor Java ou GO pode levar alguns segundos para inicializar totalmente e estar pronto para responder a requisições, mesmo que o contêiner já esteja rodando. Se o serviço dependente tentar se conectar muito cedo, ele falhará.
    - **Alternativa:** Para garantir a prontidão do serviço, use `healthchecks` combinados com `condition: service_healthy` na forma longa do `depends_on`. Para casos mais complexos, scripts de inicialização que esperam pela disponibilidade de portas ou endpoints específicos (como o `wait-for-it.sh` ou `dockerize`) são excelentes opções.
- **Dependências Cíclicas:** O Docker Compose não suporta dependências cíclicas (Serviço A depende de B, e B depende de A). Isso resultaria em um impasse e um erro ao tentar iniciar os serviços.
    - **Solução:** Redesenhe a arquitetura dos seus serviços para remover dependências cíclicas. Isso geralmente indica um acoplamento excessivo entre os serviços, o que vai contra os princípios de microsserviços.
- **Serviços que Não Precisam Ser Iniciados Juntos:** Se dois serviços são independentes e não há uma ordem de inicialização obrigatória, não há necessidade de usar `depends_on`. Usá-lo desnecessariamente pode atrasar a inicialização geral da sua aplicação.
- **Orquestração Complexa Além de Simples Inicialização:** Para orquestrações mais complexas que envolvem autoescalonamento, balanceamento de carga avançado ou descoberta de serviço dinâmica, o Docker Compose pode ser limitado.
    - **Alternativa:** Ferramentas de orquestração como **Kubernetes** ou **Docker Swarm** oferecem recursos mais robustos para gerenciar dependências e o ciclo de vida de aplicações distribuídas em escala.

---

## Componentes Chave Associados

O atributo `depends_on` está intrinsecamente ligado ao ciclo de vida dos contêineres e, especialmente na forma longa, aos `healthchecks`.

### Ciclo de Vida do Contêiner e `depends_on`

Quando você executa `docker compose up`, o Docker Compose segue a ordem de dependência:

1. **Criação da Rede:** Primeiro, as redes definidas no `docker-compose.yml` (ou a rede padrão) são criadas.
2. **Criação de Volumes:** Os volumes nomeados são criados ou reutilizados.
3. **Início dos Serviços sem Dependências:** Serviços que não têm `depends_on` são iniciados primeiro.
4. **Resolução de Dependências:** O Docker Compose monitora o estado dos serviços dependentes.
    - Para `condition: service_started`, ele espera que o contêiner do serviço dependente tenha sido iniciado com sucesso.
    - Para `condition: service_healthy`, ele espera que o `healthcheck` do serviço dependente reporte o estado "healthy".
    - Para `condition: service_completed_successfully`, ele espera que o contêiner do serviço dependente termine e saia com código 0.
5. **Início dos Serviços Dependentes:** Uma vez que as condições de dependência são satisfeitas, os serviços que as possuem são iniciados.

### A Importância dos `healthchecks`

Os `healthchecks` são vitais quando você utiliza `depends_on` com a condição `service_healthy`. Eles permitem que o Docker (e, por extensão, o Docker Compose) saiba se um contêiner não apenas está rodando, mas se o aplicativo *dentro* do contêiner está funcionando corretamente e pronto para receber requisições.

Um `healthcheck` geralmente consiste em um comando que o Docker executa periodicamente dentro do contêiner. Se o comando retorna um código de saída 0, o contêiner é considerado saudável. Se retornar um código diferente de 0, é considerado não saudável.

**Exemplo de Sintaxe de `healthcheck`:**

```yaml
services:
  myservice:
    image: myapp:latest
    healthcheck:
      test: ["CMD", "curl", "-f", "<http://localhost:8080/status>"] # Comando para verificar a saúde
      interval: 30s # Frequência da verificação
      timeout: 10s # Tempo limite para o comando de healthcheck
      retries: 3 # Número de tentativas antes de considerar o serviço não saudável
      start_period: 10s # Período inicial para o contêiner se aquecer antes de healthchecks falharem

```

**Uso:** Sem um `healthcheck` configurado, a condição `service_healthy` no `depends_on` não terá efeito e resultará em um erro, pois o Docker Compose não terá como determinar a saúde do serviço.

---

## Melhores Práticas e Padrões de Uso

Para Gedê, que é um desenvolvedor backend e lida com APIs, aqui estão algumas práticas recomendadas:

1. **Sempre Utilize `healthchecks` com `service_healthy` para Aplicações e Bancos de Dados:**
Para serviços como bancos de dados, APIs e outros que precisam estar *realmente* prontos para uso antes que outros serviços se conectem, a combinação de `healthcheck` e `depends_on: condition: service_healthy` é a abordagem mais robusta. Isso evita que sua aplicação tente se conectar a um banco de dados que ainda está inicializando ou a uma API que ainda não carregou todas as suas rotas.
2. **Evite `depends_on` para Dependências Não Críticas:**
Se um serviço pode funcionar mesmo que outro não esteja disponível imediatamente (e lidar com a indisponibilidade de forma graciosa), talvez não precise de um `depends_on` estrito. Isso pode acelerar a inicialização geral da sua aplicação.
3. **Monitore os Logs Durante a Inicialização:**
Sempre observe os logs dos seus contêineres durante a inicialização (usando `docker compose logs -f`) para entender o comportamento de `depends_on` e garantir que seus serviços estão sendo iniciados na ordem e no estado corretos. Isso ajuda a depurar problemas de dependência.
4. **Use Scripts de `wait-for-it` para Casos Complexos (se `healthchecks` não forem suficientes):**
Em algumas situações, o `healthcheck` pode não ser granular o suficiente. Por exemplo, você pode precisar esperar que uma migração de banco de dados seja concluída. Nesses casos, scripts como `wait-for-it.sh` ou `dockerize` podem ser integrados ao `entrypoint` do seu contêiner de aplicação. Eles "esperam" que uma porta esteja aberta ou que um comando seja bem-sucedido antes de iniciar a aplicação principal.
    
    ```yaml
    # Exemplo de como usar wait-for-it.sh no seu serviço API
    services:
      api:
        image: meu-backend-go:latest
        command: ["/usr/src/app/wait-for-it.sh", "db:5432", "--", "go", "run", "main.go"] # Inicia o backend após o DB estar pronto
    
    ```
    
    *(Você precisaria adicionar o `wait-for-it.sh` ao seu Dockerfile ou montá-lo como um volume).*
    
5. **Entenda as Limitações e Considere Orquestradores Mais Poderosos:**
Para ambientes de produção ou aplicações muito complexas e escaláveis, o Docker Compose é uma excelente ferramenta para desenvolvimento local e CI/CD. No entanto, para gerenciar dependências, escalabilidade, recuperação de falhas e balanceamento de carga em produção, Gedê, você provavelmente vai querer explorar ferramentas como Kubernetes, que oferecem um controle muito mais granular e robusto sobre a orquestração de contêineres.

---

## Exemplo Prático Completo

Vamos montar um cenário para seu futuro projeto, Gedê, com um backend GO, um banco de dados PostgreSQL e um frontend Nginx, demonstrando o uso avançado de `depends_on` com `healthchecks`.

### Estrutura de Arquivos

```
.
├── docker-compose.yml
├── backend/
│   ├── Dockerfile
│   └── main.go (simulando sua API Go)
└── frontend/
    └── nginx.conf (configuração do Nginx)

```

### `backend/Dockerfile`

```
FROM golang:1.22-alpine

WORKDIR /app

COPY . .

RUN go mod init meuprojeto && go mod tidy # Inicializa go modules
RUN go build -o main .

EXPOSE 8080

CMD ["./main"]

```

### `backend/main.go` (simulado)

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	"time"
)

func main() {
	// Endpoint de healthcheck
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "OK")
	})

	// Endpoint principal
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Olá, Gedê! Sua API GO está rodando!")
	})

	fmt.Println("Servidor Go iniciado na porta 8080...")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

```

### `frontend/nginx.conf`

```
events {
    worker_connections 1024;
}

http {
    server {
        listen 80;

        location / {
            proxy_pass <http://api:8080>; # Encaminha requisições para o serviço 'api'
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}

```

### `docker-compose.yml`

```yaml
version: '3.8'

services:
  frontend:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./frontend/nginx.conf:/etc/nginx/nginx.conf:ro # Monta o arquivo de configuração do Nginx
    depends_on:
      api:
        condition: service_healthy # O frontend só iniciará depois que a API estiver saudável.

  api:
    build: ./backend # Constrói a imagem a partir do Dockerfile na pasta 'backend'
    ports:
      - "8080:8080"
    environment:
      DATABASE_URL: "postgresql://user:password@db:5432/mydatabase" # URL de conexão com o banco de dados
    depends_on:
      db:
        condition: service_healthy # A API só iniciará depois que o DB estiver saudável.
    healthcheck:
      test: ["CMD", "curl", "-f", "<http://localhost:8080/health>"] # Verifica o endpoint /health da API
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s # Dê um tempo para a API Go iniciar antes de checar.

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data # Volume persistente para os dados do DB
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mydatabase"] # Comando específico para PostgreSQL
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 5s # Dê um tempo para o PostgreSQL iniciar antes de checar.

volumes:
  db_data: # Define o volume nomeado para o banco de dados

```

**Como funciona este exemplo:**

1. **`db`:** É o primeiro a ser iniciado porque não tem dependências. Ele possui um `healthcheck` que verifica se o PostgreSQL está pronto para aceitar conexões.
2. **`api`:** Depende do `db` estar `healthy`. Seu próprio `healthcheck` verifica se o endpoint `/health` da API Go está respondendo.
3. **`frontend`:** Depende do `api` estar `healthy`. O Nginx, configurado para rotear requisições para o serviço `api`, só será iniciado depois que o backend GO estiver completamente saudável.

Para testar este exemplo, você precisaria ter o Docker e Docker Compose instalados. Navegue até o diretório raiz do projeto (`.`) e execute:

```bash
docker compose up --build

```

Você verá os logs de inicialização. O Docker Compose aguardará pacientemente até que cada serviço dependente atinja o estado `healthy` antes de iniciar o próximo. Após tudo estar no ar, você poderá acessar `http://localhost:80` no seu navegador e verá a mensagem da sua API GO.

---

Espero que esta explicação detalhada, A.R.I.A., tenha sido clara e útil para você, Gedê\! Sinta-se à vontade para perguntar se tiver mais alguma dúvida.