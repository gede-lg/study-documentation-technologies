# deploy

Claro, Gedê\! A.R.I.A está aqui para te ajudar a entender o atributo `deploy` no Docker Compose. Como você pediu uma explicação detalhada e completa, vamos mergulhar fundo nesse tópico.

---

## Gerenciamento de Implantação com `deploy` no Docker Compose

### Introdução

No mundo do Docker, o **Docker Compose** é uma ferramenta essencial para definir e executar aplicações multi-contêiner. Ele permite que você organize seus serviços, redes e volumes em um único arquivo `docker-compose.yml`, simplificando o gerenciamento de ambientes de desenvolvimento, teste e até mesmo produção.

O atributo `deploy`, em particular, é um recurso poderoso que permite configurar aspectos de implantação e escalabilidade dos serviços definidos no seu arquivo Compose, principalmente quando utilizados em conjunto com um orquestrador como o Docker Swarm. Ele oferece controle granular sobre como seus serviços serão distribuídos e executados em um cluster.

### Sumário

Nesta explicação detalhada, abordaremos os seguintes pontos para garantir que você tenha uma compreensão completa do atributo `deploy`:

- **Conceitos Fundamentais:** Entenderemos o propósito e a importância do `deploy` no contexto do Docker Compose e Docker Swarm.
- **Sintaxe Detalhada e Uso Prático:** Exploraremos cada sub-atributo de `deploy` com exemplos de código comentados.
- **Cenários de Restrição ou Não Aplicação:** Discutiremos quando o `deploy` pode não ser a melhor escolha.
- **Componentes Chave Associados:** Abordaremos o Docker Swarm como o orquestrador principal para o `deploy`.
- **Melhores Práticas e Padrões de Uso:** Forneceremos recomendações para otimizar suas implantações.
- **Exemplo Prático Completo:** Demonstraremos um cenário de ponta a ponta.

---

### Conceitos Fundamentais

O atributo `deploy` dentro de uma chave `services` em um arquivo `docker-compose.yml` serve para definir políticas de implantação e escalabilidade para um serviço. Embora o Docker Compose seja amplamente utilizado para orquestração local (desenvolvimento), o atributo `deploy` ganha sua verdadeira força quando o Compose é usado para implantar serviços em um **cluster Docker Swarm**.

**Propósito e Importância:**

1. **Escalabilidade:** Permite definir quantas réplicas de um serviço devem ser executadas, garantindo alta disponibilidade e capacidade de lidar com carga.
2. **Restrições de Colocação:** Você pode especificar onde os contêineres de um serviço devem ou não ser executados dentro do cluster (por exemplo, em nós com recursos específicos).
3. **Atualizações Contínuas (Rolling Updates):** Facilita a atualização de serviços sem tempo de inatividade, garantindo que novas versões sejam implantadas gradualmente.
4. **Recursos:** Define limites e reservas de CPU e memória para os contêineres, evitando que um serviço consuma excessivamente os recursos do nó.
5. **Reinicialização:** Controla como os contêineres devem se comportar em caso de falha.

É crucial entender que as configurações dentro do `deploy` são ignoradas pelo Docker Compose em modo de execução simples (não Swarm). Elas são processadas e aplicadas apenas quando você implanta seu stack com `docker stack deploy` em um cluster Docker Swarm.

---

### Sintaxe Detalhada e Uso Prático

O atributo `deploy` possui vários sub-atributos, cada um com uma função específica. Vamos explorar cada um deles com exemplos.

```yaml
services:
  meu-servico:
    image: minha-imagem:latest
    deploy:
      # 1. Modo de Replicação
      mode: replicated # ou global
      # 2. Número de Réplicas (apenas para modo 'replicated')
      replicas: 3
      # 3. Limites e Reservas de Recursos
      resources:
        limits:
          cpus: '0.50' # 0.5 CPU
          memory: 512M # 512 Megabytes
        reservations:
          cpus: '0.25' # 0.25 CPU reservada
          memory: 128M # 128 Megabytes reservados
      # 4. Políticas de Reinicialização
      restart_policy:
        condition: on-failure # 'none', 'on-failure', 'any'
        delay: 5s # Atraso antes de tentar reiniciar
        max_attempts: 3 # Número máximo de tentativas de reinicialização
        window: 120s # Período para considerar tentativas
      # 5. Restrições de Nó
      placement:
        constraints:
          - node.role == worker # Apenas em nós com o papel 'worker'
          - node.labels.region == us-east-1 # Apenas em nós com o label 'region=us-east-1'
          - !node.labels.temp == true # Não em nós com o label 'temp=true'
        preferences:
          - spread: node.labels.zone # Distribuir réplicas entre zonas
          - spread: node.hostname # Distribuir réplicas entre hosts
      # 6. Políticas de Atualização
      update_config:
        parallelism: 2 # Quantos contêineres atualizar em paralelo
        delay: 10s # Atraso entre grupos de contêineres atualizados
        failure_action: rollback # 'continue', 'pause', 'rollback'
        monitor: 5s # Duração para monitorar o serviço após uma atualização
        max_failure_ratio: 0.1 # Porcentagem máxima de falhas antes de reverter
        order: stop-first # 'stop-first' (padrão) ou 'start-first'
      # 7. Políticas de Rollback
      rollback_config:
        parallelism: 1 # Quantos contêineres fazer rollback em paralelo
        delay: 10s # Atraso entre grupos de contêineres em rollback
        failure_action: pause # 'continue', 'pause', 'rollback'
        monitor: 5s # Duração para monitorar o serviço após um rollback
        max_failure_ratio: 0.1 # Porcentagem máxima de falhas antes de parar
        order: stop-first # 'stop-first' (padrão) ou 'start-first'

```

Vamos detalhar cada sub-atributo:

### 1\. `mode`

Define como o serviço será escalado.

- **`replicated` (padrão):** O serviço é executado em um número específico de réplicas, distribuídas entre os nós do Swarm. É ideal para a maioria das aplicações que precisam de escalabilidade e alta disponibilidade.
- **`global`:** Uma única instância do serviço é executada em *cada* nó disponível no Swarm que atenda às restrições de `placement`. Usado para agentes de monitoramento, logs, ou qualquer serviço que precise estar presente em todos os nós.

**Exemplo:**

```yaml
services:
  web:
    image: nginx:latest
    deploy:
      mode: replicated # Teremos múltiplas instâncias do Nginx
      replicas: 5 # Teremos 5 instâncias do Nginx
  monitoring-agent:
    image: prom/node-exporter:latest
    deploy:
      mode: global # Uma instância do agente em cada nó do cluster

```

### 2\. `replicas`

(Apenas para `mode: replicated`) Define o número desejado de instâncias do serviço. O Docker Swarm tentará manter esse número de réplicas em execução.

**Exemplo:**

```yaml
services:
  api:
    image: minha-api:1.0
    deploy:
      mode: replicated
      replicas: 3 # A API terá 3 instâncias em execução

```

### 3\. `resources`

Controla a alocação de recursos (CPU e memória) para os contêineres do serviço. Isso ajuda a prevenir que um único serviço consuma todos os recursos de um nó e garante que os serviços tenham recursos suficientes.

- **`limits`:** O limite máximo de recursos que um contêiner pode usar. Se um contêiner tentar usar mais, ele será limitado (throttled) ou encerrado.
    - `cpus`: O número máximo de CPUs que o contêiner pode usar. Pode ser um número fracionário (ex: `'0.5'` para meia CPU).
    - `memory`: O limite de memória. Pode ser em bytes, K, M, G. (ex: `1024M`, `2G`).
- **`reservations`:** A quantidade de recursos que o Swarm tentará garantir para o contêiner. Se um nó não puder garantir essa reserva, o contêiner não será agendado nele.
    - `cpus`: CPU reservada.
    - `memory`: Memória reservada.

**Exemplo:**

```yaml
services:
  processador-dados:
    image: data-processor:latest
    deploy:
      resources:
        limits:
          cpus: '2.0' # Limite de 2 CPUs
          memory: 4G # Limite de 4 GB de RAM
        reservations:
          cpus: '1.0' # 1 CPU garantida
          memory: 2G # 2 GB de RAM garantidos

```

### 4\. `restart_policy`

Define a política de reinicialização para os contêineres do serviço em caso de falha ou encerramento.

- **`condition`:**
    - `none`: Não reinicia automaticamente.
    - `on-failure`: Reinicia apenas se o contêiner sair com um código de erro diferente de zero.
    - `any`: Reinicia sempre que o contêiner parar, independentemente do código de saída.
- **`delay`:** Um atraso (duração) antes de tentar reiniciar o contêiner. (ex: `5s`, `1m`).
- **`max_attempts`:** O número máximo de tentativas de reinicialização antes de considerar o serviço como falho e não tentar mais.
- **`window`:** O período de tempo em que as tentativas de reinicialização são contadas. Se o contêiner for reiniciado com sucesso e permanecer em execução por mais tempo que `window`, a contagem de tentativas é resetada.

**Exemplo:**

```yaml
services:
  worker:
    image: my-worker:latest
    deploy:
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 5
        window: 300s # Se falhar 5 vezes em 5 minutos, não tenta mais

```

### 5\. `placement`

Define restrições e preferências para o agendamento de contêineres em nós específicos do Swarm.

- **`constraints`:** Regras rígidas que devem ser satisfeitas para que um contêiner seja agendado em um nó. Se um nó não atender a todas as restrições, ele não será considerado para o agendamento.
    - A sintaxe é `key operator value`.
    - Operadores: `==` (igual), `!=` (diferente).
    - Chaves comuns: `node.id`, `node.hostname`, `node.role` (`manager` ou `worker`), `node.labels.<label_name>`.
- **`preferences`:** Sugestões para o agendador, mas não são regras rígidas. Eles influenciam a distribuição dos contêineres.
    - `spread`: Tenta distribuir as réplicas uniformemente com base na chave fornecida (ex: `node.labels.zone`).

**Exemplo:**

```yaml
services:
  db:
    image: postgres:13
    deploy:
      placement:
        constraints:
          - node.labels.data_disk == ssd # DB só pode rodar em nós com SSD
          - node.hostname != old-server # Não rodar no servidor antigo
        preferences:
          - spread: node.labels.rack # Distribuir o DB por racks para resiliência

```

### 6\. `update_config`

Controla como as atualizações de serviço são executadas, permitindo atualizações contínuas (rolling updates) sem tempo de inatividade.

- **`parallelism`:** O número de tarefas (contêineres) a serem atualizadas simultaneamente.
- **`delay`:** O tempo de espera entre a atualização de um grupo de tarefas e o próximo.
- **`failure_action`:** O que fazer se uma tarefa falhar durante a atualização.
    - `continue`: Continuar a atualização.
    - `pause`: Pausar a atualização.
    - `rollback`: Reverter para a versão anterior.
- **`monitor`:** Duração para monitorar o status de uma tarefa atualizada antes de prosseguir. Se a tarefa ficar "unhealthy" durante esse período, a ação `failure_action` é acionada.
- **`max_failure_ratio`:** A porcentagem máxima de falhas que podem ocorrer durante uma atualização antes que a `failure_action` seja acionada.
- **`order`:** A ordem em que as tarefas são atualizadas.
    - `stop-first` (padrão): Para a tarefa antiga, inicia a nova.
    - `start-first`: Inicia a nova tarefa, depois para a antiga (garante que sempre haja uma instância rodando, mas temporariamente consome mais recursos).

**Exemplo:**

```yaml
services:
  app:
    image: my-app:2.0
    deploy:
      update_config:
        parallelism: 1 # Atualizar uma instância por vez
        delay: 30s # Esperar 30s entre cada atualização
        failure_action: rollback # Se algo der errado, reverte
        monitor: 60s # Monitorar por 1 minuto
        max_failure_ratio: 0.1 # Reverter se mais de 10% falhar
        order: start-first # Garante que a nova versão esteja online antes de parar a antiga

```

### 7\. `rollback_config`

Define as políticas de rollback se uma atualização falhar e precisar ser revertida para a versão anterior. A sintaxe é idêntica à de `update_config`, mas se aplica especificamente ao processo de reversão.

**Exemplo:**

```yaml
services:
  app:
    image: my-app:2.0
    deploy:
      update_config:
        # ... configurações de update ...
        failure_action: rollback # Importante para acionar o rollback
      rollback_config:
        parallelism: 1
        delay: 5s
        failure_action: pause # Pausar o rollback se falhar
        monitor: 15s
        max_failure_ratio: 0.1
        order: stop-first

```

---

### Cenários de Restrição ou Não Aplicação

É importante saber quando o atributo `deploy` não é a melhor escolha ou simplesmente não se aplica:

1. **Docker Compose Standalone (Ambientes de Desenvolvimento/Teste Local):** Como mencionado, as configurações de `deploy` são **ignoradas** quando você executa `docker-compose up` diretamente. Elas são projetadas para orquestração em cluster (Docker Swarm). Se seu objetivo é apenas levantar serviços localmente, adicionar `deploy` é redundante e não terá efeito.
2. **Kubernetes:** Se você estiver usando Kubernetes como orquestrador, as configurações de implantação são definidas em manifestos Kubernetes (Deployment, StatefulSet, DaemonSet, etc.), não via `deploy` do Docker Compose. Embora existam ferramentas como `kompose` que convertem arquivos Compose para manifestos Kubernetes, o atributo `deploy` não é traduzido diretamente de forma abrangente, pois o Kubernetes tem sua própria maneira de gerenciar esses aspectos.
3. **Containers de Uso Único/Jobs:** Para contêineres que são executados uma única vez para uma tarefa específica (ex: migrações de banco de dados, scripts de processamento batch) e não precisam de alta disponibilidade ou escalabilidade contínua, as políticas de `deploy` são excessivas. Nesses casos, o `restart_policy` dentro da própria configuração do serviço (fora de `deploy`) pode ser suficiente.

---

### Componentes Chave Associados

O atributo `deploy` do Docker Compose funciona em estreita colaboração com o **Docker Swarm**.

### Docker Swarm

O Docker Swarm é o modo de orquestração de contêineres nativo do Docker. Ele permite que você agrupe múltiplos hosts Docker em um cluster virtual, e o Swarm se encarrega de gerenciar a implantação, escalabilidade e manutenção de seus serviços.

**Como funciona com `deploy`:**

1. **Inicialização do Swarm:** Você inicializa um Swarm em um dos seus nós (`docker swarm init`).
2. **Adição de Nós:** Outros hosts Docker podem ser adicionados ao Swarm como `manager` (para gerenciar o cluster) ou `worker` (para executar contêineres).
3. **Implantação de Stacks:** Em vez de `docker-compose up`, você usa `docker stack deploy -c docker-compose.yml <stack_name>` para implantar sua aplicação multi-serviço no Swarm.
4. **Agendador (Scheduler):** O agendador do Swarm lê as configurações de `deploy` para cada serviço no seu arquivo Compose. Ele usa essas informações para:
    - Distribuir as réplicas dos serviços pelos nós.
    - Garantir que as restrições de `placement` sejam atendidas.
    - Aplicar limites e reservas de `resources`.
    - Gerenciar atualizações e rollbacks de acordo com `update_config` e `rollback_config`.
    - Controlar as reinicializações dos contêineres (`restart_policy`).

**Comandos Importantes do Swarm:**

- `docker swarm init`: Inicializa um Swarm.
- `docker node ls`: Lista os nós no Swarm.
- `docker stack deploy -c docker-compose.yml <stack_name>`: Implanta um stack no Swarm.
- `docker stack ls`: Lista os stacks implantados.
- `docker stack ps <stack_name>`: Lista as tarefas (contêineres) de um stack.
- `docker service ls`: Lista os serviços no Swarm.
- `docker service scale <service_name>=<replicas>`: Escala um serviço (também pode ser feito alterando `replicas` no Compose e re-deployando).
- `docker service update --image <new_image> <service_name>`: Atualiza a imagem de um serviço (o Swarm usa o `update_config`).

---

### Melhores Práticas e Padrões de Uso

Para aproveitar ao máximo o atributo `deploy` e garantir implantações robustas:

1. **Use `mode: replicated` para serviços escaláveis:** A maioria dos serviços de aplicação (APIs, frontends, workers) deve usar `replicated` para alta disponibilidade e escalabilidade.
2. **Use `mode: global` com sabedoria:** Reserve `global` para serviços que *necessariamente* precisam de uma instância em cada nó (ex: agentes de monitoramento, coleta de logs).
3. **Defina `resources` apropriadamente:**
    - **Comece com reservas:** Defina `reservations` para garantir que seus serviços tenham recursos mínimos para operar. Isso ajuda o agendador do Swarm a tomar decisões mais inteligentes.
    - **Monitore e ajuste limites:** Observe o consumo de recursos dos seus serviços em produção. Defina `limits` para evitar "vizinhos barulhentos" (contêineres que consomem todos os recursos de um nó e afetam outros serviços) e garantir a estabilidade do nó. Evite limites muito apertados que possam causar `OOMKilled` (Out Of Memory Killed).
4. **Configure `restart_policy` para resiliência:** `on-failure` é um bom padrão para a maioria dos serviços. Ajuste `delay`, `max_attempts` e `window` para evitar reinicializações rápidas em loop (thrashing) e dar tempo ao serviço para se estabilizar.
5. **Utilize `placement` para otimização e isolamento:**
    - **Separação de Funções:** Use `node.role` para separar managers de workers.
    - **Hardware Específico:** Utilize `node.labels` para direcionar serviços para nós com hardware específico (GPUs, SSDs, etc.).
    - **Alta Disponibilidade Geográfica:** Se seu Swarm abrange diferentes data centers ou zonas de disponibilidade, use `spread: node.labels.zone` ou similar para distribuir as réplicas.
6. **Domine `update_config` para zero-downtime:**
    - **`parallelism`:** Comece com `1` ou `2` para garantir que a nova versão funcione bem antes de propagar. Aumente com cautela.
    - **`delay`:** Um atraso razoável (ex: 10-30s) permite que os contêineres iniciem e passem pelos health checks antes que o próximo lote seja atualizado.
    - **`failure_action: rollback`:** Essencial para garantir que, em caso de problemas, o sistema retorne a um estado funcional conhecido.
    - **`monitor`:** Use um valor que permita ao seu serviço estabilizar e realizar um health check inicial antes de considerar a atualização bem-sucedida.
    - **`order: start-first`:** Se o tempo de inatividade for crítico e você tiver recursos para executar temporariamente as versões antiga e nova simultaneamente, `start-first` é preferível. Caso contrário, `stop-first` é mais conservador em uso de recursos.
7. **`rollback_config` para recuperação:** Configure-o de forma semelhante ao `update_config` para garantir um processo de reversão suave e controlado.

---

### Exemplo Prático Completo: Aplicação Web com API e Banco de Dados

Vamos criar um `docker-compose.yml` para uma aplicação web simples composta por três serviços: um frontend Nginx, uma API Backend (Java, Go, ou qualquer outro), e um banco de dados PostgreSQL. Iremos implantar isso em um Swarm.

```yaml
version: '3.8' # Versão do Compose File

services:
  # --- Serviço Frontend (Nginx) ---
  web:
    image: nginx:1.21-alpine # Imagem Nginx
    ports:
      - "80:80" # Mapeia porta 80 do host para 80 do contêiner
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro # Monta arquivo de configuração do Nginx
    deploy:
      mode: replicated # Serviço replicado para escalabilidade
      replicas: 3 # 3 instâncias do Nginx
      resources:
        limits:
          cpus: '0.2' # Limite de 0.2 CPU
          memory: 128M # Limite de 128 MB de RAM
        reservations:
          cpus: '0.1' # Reserva de 0.1 CPU
          memory: 64M # Reserva de 64 MB de RAM
      restart_policy:
        condition: on-failure # Reiniciar em caso de falha
        delay: 5s
        max_attempts: 3
        window: 60s
      placement:
        constraints:
          - node.role == worker # Rodar apenas em nós worker
        preferences:
          - spread: node.hostname # Distribuir as réplicas entre diferentes hosts
      update_config:
        parallelism: 1 # Atualizar uma réplica por vez
        delay: 10s # Esperar 10s entre atualizações
        failure_action: rollback # Reverter se falhar
        monitor: 30s # Monitorar por 30s
        max_failure_ratio: 0.1 # Permitir até 10% de falha
        order: start-first # Iniciar nova antes de parar antiga

  # --- Serviço Backend (API) ---
  api:
    image: gedelabs/minha-api:1.0 # Exemplo de imagem de API
    environment:
      - DATABASE_URL=postgres://user:password@db:5432/mydb # Conexão com o DB
    ports:
      - "8080:8080"
    depends_on:
      - db # Depende do serviço 'db' estar rodando
    deploy:
      mode: replicated
      replicas: 2 # 2 instâncias da API
      resources:
        limits:
          cpus: '1.0'
          memory: 1024M # 1 GB de RAM
        reservations:
          cpus: '0.5'
          memory: 512M # 512 MB de RAM
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 5
        window: 120s
      placement:
        constraints:
          - node.labels.app_tier == backend # Rodar em nós com label 'app_tier=backend'
      update_config:
        parallelism: 1
        delay: 20s
        failure_action: rollback
        monitor: 60s
        max_failure_ratio: 0.2
        order: start-first
      rollback_config: # Configurações específicas para rollback
        parallelism: 1
        delay: 5s
        failure_action: pause # Pausar se o rollback falhar
        monitor: 15s
        max_failure_ratio: 0.1
        order: stop-first

  # --- Serviço Banco de Dados (PostgreSQL) ---
  db:
    image: postgres:13 # Imagem PostgreSQL
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - db_data:/var/lib/postgresql/data # Volume persistente para dados do DB
    deploy:
      mode: replicated # Mesmo sendo um DB, para o Swarm é um serviço replicado
      replicas: 1 # Geralmente 1 instância de DB primário em Swarm simples.
                  # Para HA de DB, é comum usar soluções externas ou StatefulSets no K8s.
      resources:
        limits:
          cpus: '1.5'
          memory: 2048M # 2 GB de RAM
        reservations:
          cpus: '1.0'
          memory: 1024M # 1 GB de RAM
      restart_policy:
        condition: on-failure
        delay: 15s
        max_attempts: 3
        window: 300s
      placement:
        constraints:
          - node.labels.data_node == true # Rodar em nós marcados como 'data_node'
          - node.role == manager # Opcional: Rodar em um nó manager (para pequena escala)
    healthcheck: # Healthcheck para o banco de dados
      test: ["CMD-SHELL", "pg_isready -U user -d mydb"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  db_data: # Define o volume para persistência dos dados do DB

```

**Como implantar este stack no Docker Swarm:**

1. **Certifique-se de ter um Docker Swarm ativo:**
    
    ```bash
    docker swarm init # Se for o primeiro nó
    # ou
    docker swarm join --token <token> <manager_ip>:<port> # Para adicionar um nó worker
    
    ```
    
2. **Crie o arquivo `nginx.conf` (se não tiver):**
    
    ```
    # nginx.conf
    events {
        worker_connections 1024;
    }
    http {
        server {
            listen 80;
            location / {
                proxy_pass <http://api:8080>; # Redireciona para o serviço 'api'
            }
        }
    }
    
    ```
    
3. **Implante o stack:**
    
    ```bash
    docker stack deploy -c docker-compose.yml myapp # 'myapp' é o nome do seu stack
    
    ```
    
4. **Verifique o status:**
    
    ```bash
    docker stack ls
    docker stack services myapp
    docker stack ps myapp
    
    ```
    

---

Espero que esta explicação detalhada, Gedê, tenha te dado uma compreensão completa do atributo `deploy` no Docker Compose e como ele se integra ao Docker Swarm. Com essas informações, você poderá configurar suas implantações de forma mais robusta e eficiente\!

Você gostaria de explorar mais a fundo algum dos sub-atributos ou talvez ver um exemplo prático de como atualizar um serviço usando o `update_config`?