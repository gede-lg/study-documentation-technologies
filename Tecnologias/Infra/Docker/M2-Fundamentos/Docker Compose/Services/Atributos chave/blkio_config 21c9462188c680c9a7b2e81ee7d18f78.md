# blkio_config

Certo, Gedê\! Entendido. A.R.I.A vai te ajudar com uma explicação detalhada e completa sobre o atributo `blkio_config` da chave `services` no Docker Compose, focando nos seus conceitos, sintaxe e uso prático, com exemplos e melhores práticas.

---

# Gerenciando Recursos de I/O de Bloco com `blkio_config` no Docker Compose

## Introdução

No mundo dos contêineres, gerenciar recursos é fundamental para garantir a estabilidade e o desempenho das aplicações. Assim como CPU e memória, o acesso a dispositivos de **entrada/saída (I/O)** de bloco, como discos rígidos e SSDs, pode se tornar um gargalo significativo em ambientes com múltiplos contêineres. O **Docker Compose**, uma ferramenta para definir e rodar aplicações Docker multi-contêineres, oferece o atributo `blkio_config` para controlar e limitar o acesso de leitura/escrita dos contêineres a esses dispositivos.

Este guia fornecerá uma explicação aprofundada sobre `blkio_config`, cobrindo desde os conceitos fundamentais até exemplos práticos e melhores práticas, para que você, Gedê, possa otimizar o desempenho de suas aplicações e evitar problemas de contenção de I/O em seus ambientes Docker.

## Sumário

- **Conceitos Fundamentais:** Entendendo I/O de Bloco, cgroups e a importância do gerenciamento de recursos de I/O.
- **Sintaxe Detalhada e Uso Prático:** Exploração de cada sub-opção de `blkio_config` com exemplos de código.
- **Cenários de Restrição ou Não Aplicação:** Quando o `blkio_config` é útil e quando pode não ser a melhor solução.
- **Componentes Chave Associados:** Entendendo os identificadores de dispositivos (major:minor).
- **Melhores Práticas e Padrões de Uso:** Recomendações para otimizar o uso de `blkio_config`.
- **Exemplo Prático Completo:** Um cenário com dois serviços competindo por I/O e a aplicação de `blkio_config`.

---

## Conceitos Fundamentais

Para entender `blkio_config`, precisamos primeiro revisar alguns conceitos essenciais:

### I/O de Bloco (Block I/O)

**I/O de Bloco** refere-se à entrada/saída de dados que ocorre em blocos de tamanho fixo para dispositivos de armazenamento, como discos rígidos, SSDs, e dispositivos NVMe. Diferente de I/O de caracteres (que lida com bytes individuais), o I/O de bloco é otimizado para transferências de grandes volumes de dados. Praticamente todo acesso a arquivos em um sistema de arquivos envolve operações de I/O de bloco.

Em ambientes de contêineres, se um ou mais contêineres realizam muitas operações de leitura ou escrita em disco, eles podem saturar o subsistema de I/O do host. Isso pode levar a uma queda significativa no desempenho para todos os contêineres e até mesmo para o próprio sistema operacional do host.

### cgroups (Control Groups)

Os **cgroups (control groups)** são uma funcionalidade do kernel Linux que permite organizar processos em grupos hierárquicos para alocar recursos de forma programática. Eles são a base para a maioria das funcionalidades de isolamento e limitação de recursos do Docker, incluindo CPU, memória e, é claro, I/O de bloco.

O `blkio_config` no Docker Compose é, na verdade, uma interface amigável para configurar os parâmetros de **cgroup blkio** para os contêineres. Ao definir limites de I/O usando `blkio_config`, o Docker traduz essas configurações em regras de cgroup que o kernel Linux enforcementa.

### Importância do Gerenciamento de Recursos de I/O

O gerenciamento eficaz dos recursos de I/O é crucial por várias razões:

- **Prevenção de Inanição (Starvation):** Impede que um único contêiner com uso intensivo de I/O monopolize o disco, deixando outros contêineres sem recursos.
- **Consistência de Desempenho:** Ajuda a garantir que contêineres críticos mantenham um nível de desempenho aceitável, mesmo sob carga pesada.
- **Estabilidade do Host:** Evita que a saturação do disco por contêineres afete a responsividade do sistema operacional do host.
- **Justiça na Alocação:** Permite distribuir o acesso ao disco de forma justa entre os serviços, de acordo com suas necessidades e prioridades.
- **Otimização de Custos:** Em ambientes de nuvem, onde o I/O é muitas vezes um recurso caro, a limitação pode ajudar a controlar gastos.

---

## Sintaxe Detalhada e Uso Prático

O atributo `blkio_config` é um objeto YAML que pode ser aninhado sob a chave de um serviço no seu arquivo `docker-compose.yml`. Ele contém várias sub-opções que permitem configurar diferentes aspectos da limitação de I/O.

A estrutura geral é a seguinte:

```yaml
services:
  meu_servico:
    image: minha_imagem
    blkio_config:
      # Opções de blkio_config aqui
      # ...

```

Vamos explorar cada uma das sub-opções:

### 1\. `device_read_bps`

- **Propósito:** Limita a taxa de leitura em bytes por segundo para um dispositivo específico.
- **Sintaxe:** Uma lista de objetos, onde cada objeto tem as chaves `path` (caminho do dispositivo ou major:minor) e `rate` (a taxa máxima).
- **Valores de `rate`:** Podem ser sufixados com `kb`, `mb`, `gb` (case-insensitive) para kilobytes, megabytes ou gigabytes por segundo, respectivamente. Se nenhum sufixo for fornecido, assume-se bytes por segundo.

<!-- end list -->

```yaml
services:
  banco_de_dados:
    image: postgres:13
    blkio_config:
      device_read_bps:
        - path: "/dev/sda"  # Ou "8:0" se souber o major:minor
          rate: "10mb"     # Limita a leitura a 10 Megabytes por segundo
        - path: "/dev/sdb"
          rate: "200kb"    # Limita a leitura a 200 Kilobytes por segundo
    volumes:
      - /data/db:/var/lib/postgresql/data

```

**Explicação:** Este exemplo limita o serviço `banco_de_dados` a ler no máximo 10MB/s do dispositivo `/dev/sda` e 200KB/s do dispositivo `/dev/sdb`. Isso é útil para garantir que um serviço de banco de dados não sature o disco durante leituras intensivas, impactando outros serviços.

### 2\. `device_write_bps`

- **Propósito:** Limita a taxa de escrita em bytes por segundo para um dispositivo específico.
- **Sintaxe:** Similar a `device_read_bps`, uma lista de objetos com `path` e `rate`.
- **Valores de `rate`:** Podem ser sufixados com `kb`, `mb`, `gb`.

<!-- end list -->

```yaml
services:
  processador_log:
    image: log_processor:latest
    blkio_config:
      device_write_bps:
        - path: "/dev/sda"
          rate: "5mb"      # Limita a escrita a 5 Megabytes por segundo
    volumes:
      - /var/log/app:/app/logs

```

**Explicação:** Aqui, o serviço `processador_log` (que pode estar escrevendo muitos logs) é limitado a escrever no máximo 5MB/s no dispositivo `/dev/sda`. Isso evita que a escrita excessiva de logs degrade o desempenho do disco.

### 3\. `device_read_iops`

- **Propósito:** Limita a taxa de leitura em operações de I/O por segundo (IOPS) para um dispositivo específico. IOPS é uma métrica crucial para o desempenho de SSDs e SANs.
- **Sintaxe:** Similar, uma lista de objetos com `path` e `rate`.
- **Valores de `rate`:** A taxa é um número inteiro que representa o número de operações por segundo.

<!-- end list -->

```yaml
services:
  analise_dados:
    image: data_analyzer:latest
    blkio_config:
      device_read_iops:
        - path: "/dev/sdb"
          rate: 1000       # Limita a leitura a 1000 IOPS do dispositivo sdb

```

**Explicação:** O serviço `analise_dados`, que pode realizar muitas pequenas leituras aleatórias (altas IOPS), é limitado a 1000 IOPS no dispositivo `/dev/sdb`. Isso é útil para controlar a carga de pequenas operações de leitura que podem sobrecarregar o controlador do disco.

### 4\. `device_write_iops`

- **Propósito:** Limita a taxa de escrita em operações de I/O por segundo (IOPS) para um dispositivo específico.
- **Sintaxe:** Similar a `device_read_iops`, uma lista de objetos com `path` e `rate`.
- **Valores de `rate`:** Um número inteiro.

<!-- end list -->

```yaml
services:
  fila_mensagens:
    image: rabbitmq:3.9
    blkio_config:
      device_write_iops:
        - path: "/dev/sda"
          rate: 500        # Limita a escrita a 500 IOPS do dispositivo sda
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

volumes:
  rabbitmq_data:

```

**Explicação:** Um servidor de filas de mensagens como RabbitMQ pode ter um padrão de escrita de muitas pequenas operações (mensagens persistidas). Limitar as IOPS de escrita a 500 para `/dev/sda` pode evitar que ele monopolize o desempenho do disco.

### 5\. `weight`

- **Propósito:** Define um peso de proporção para o acesso de I/O de bloco para todos os dispositivos. Isso é útil quando você quer dar mais prioridade a um contêiner em relação a outros, mas sem definir limites absolutos de taxa. O peso padrão é 500.
- **Sintaxe:** Um número inteiro entre 10 e 1000.
- **Como funciona:** Se um contêiner tem `weight: 1000` e outro tem `weight: 500`, o primeiro receberá o dobro de oportunidades de I/O em comparação com o segundo, quando houver contenção.

<!-- end list -->

```yaml
services:
  servico_critico:
    image: aplicacao_web:latest
    blkio_config:
      weight: 800  # Dá maior prioridade de I/O
  servico_secundario:
    image: batch_job:latest
    blkio_config:
      weight: 200  # Dá menor prioridade de I/O

```

**Explicação:** No cenário acima, o `servico_critico` terá 80% do peso de I/O disponível quando houver contenção, enquanto o `servico_secundario` terá 20%. Isso garante que a aplicação web principal tenha preferência no acesso ao disco em relação a um job em lote menos crítico.

### 6\. `weight_device`

- **Propósito:** Similar a `weight`, mas permite definir um peso de proporção para um dispositivo específico, em vez de para todos os dispositivos.
- **Sintaxe:** Uma lista de objetos, cada um com `path` e `weight` (inteiro entre 10 e 1000).

<!-- end list -->

```yaml
services:
  processamento_pesado:
    image: analytics:latest
    blkio_config:
      weight_device:
        - path: "/dev/nvme0n1" # Assumindo um NVMe rápido
          weight: 900
        - path: "/dev/sda"    # Assumindo um HDD mais lento
          weight: 100
    volumes:
      - /data/fast:/mnt/fast
      - /data/slow:/mnt/slow

```

**Explicação:** Este exemplo atribui um peso muito maior ao dispositivo NVMe (`/dev/nvme0n1`) para o serviço `processamento_pesado`, garantindo que ele tenha acesso prioritário a esse disco mais rápido, enquanto o acesso ao `/dev/sda` (um disco mais lento) é menos prioritário.

---

## Cenários de Restrição ou Não Aplicação

Embora `blkio_config` seja uma ferramenta poderosa, há cenários onde ela pode não ser a melhor escolha ou ter limitações:

- **Sistemas com I/O de Disco Limitado ou Compartilhado:** Em ambientes onde o subsistema de I/O é a principal limitação (por exemplo, discos rotacionais antigos, volumes de rede com alta latência), mesmo com `blkio_config`, o desempenho geral pode ser baixo. Nestes casos, a solução pode ser otimizar a infraestrutura de I/O subjacente.
- **Volumes de Rede (NFS, SMB, iSCSI):** As configurações de `blkio_config` atuam no kernel do host Docker, impactando o acesso ao disco local. Para volumes de rede, o controle de I/O pode ser mais complexo e depender das configurações do próprio servidor de armazenamento em rede, e não diretamente do cgroup `blkio` do Docker. Embora o tráfego de I/O para esses volumes ainda passe pelo kernel do host e possa ser limitado, a eficácia pode variar.
- **Containers com Baixo Uso de I/O:** Para contêineres que quase não realizam operações de disco (por exemplo, um servidor de API que se comunica apenas pela rede e armazena estados em memória ou banco de dados remoto), configurar `blkio_config` pode ser desnecessário e não trará benefícios de desempenho.
- **Dependência da Versão do Kernel Linux:** O subsistema cgroups `blkio` no kernel Linux passou por evoluções. Kernels muito antigos podem não suportar todas as funcionalidades ou ter comportamentos ligeiramente diferentes. O Docker geralmente tem requisitos mínimos de kernel, mas é algo a se considerar em sistemas mais legados.
- **Complexidade da Configuração:** Para ambientes com muitos contêineres e dispositivos de I/O, a configuração de `blkio_config` pode se tornar complexa e exigir monitoramento cuidadoso para ajustar os limites.

---

## Componentes Chave Associados

A chave principal para usar `blkio_config` com `device_read_bps`, `device_write_bps`, `device_read_iops`, `device_write_iops`, e `weight_device` é identificar corretamente o **caminho do dispositivo** ou, preferencialmente, o seu **identificador major:minor**.

### Identificador Major:Minor

Em sistemas Linux, cada dispositivo de bloco tem um número **major** e um número **minor**.

- O **número major** identifica o tipo geral de dispositivo ou o driver do dispositivo (por exemplo, discos SCSI, discos SATA, dispositivos NVMe).
- O **número minor** identifica a instância específica do dispositivo (por exemplo, a primeira partição do primeiro disco, a segunda partição do segundo disco).

Você pode descobrir os números major:minor de seus dispositivos de várias maneiras:

1. **Usando `lsblk -o KNAME,MAJ:MIN,FSTYPE,MOUNTPOINT`:**
    
    ```bash
    lsblk -o KNAME,MAJ:MIN,FSTYPE,MOUNTPOINT
    
    ```
    
    **Exemplo de Saída:**
    
    ```
    KNAME MAJ:MIN FSTYPE MOUNTPOINT
    sda     8:0
    ├─sda1  8:1   ext4   /
    └─sda2  8:2   swap   [SWAP]
    sdb     8:16
    └─sdb1  8:17  xfs    /data
    
    ```
    
    Neste exemplo, `/dev/sda` é `8:0`, `/dev/sda1` é `8:1`, e assim por diante. `/dev/sdb` é `8:16`.
    
2. **Usando `stat`:**
    
    ```bash
    stat -c '%t:%T' /dev/sda
    
    ```
    
    **Exemplo de Saída:**
    
    ```
    8:0
    
    ```
    
    O primeiro número é o major, e o segundo é o minor (em formato hexadecimal, mas o Docker Compose aceita o formato decimal `major:minor`).
    

**Por que usar `major:minor` em vez do caminho `/dev/sdx`?**

O caminho `/dev/sdx` (como `/dev/sda`, `/dev/sdb`) pode mudar entre reinicializações do sistema ou se novos dispositivos forem adicionados. Usar o identificador `major:minor` é mais robusto, pois ele é estático para um determinado dispositivo (a menos que o dispositivo seja removido e adicionado de forma diferente, o que é menos comum).

**Sintaxe no Docker Compose:**

Você pode usar tanto o caminho absoluto quanto o `major:minor` em suas configurações de `blkio_config`. Por exemplo:

```yaml
services:
  meu_servico:
    blkio_config:
      device_read_bps:
        - path: "/dev/sda"  # Caminho absoluto
          rate: "10mb"
        - path: "8:0"      # Major:Minor
          rate: "10mb"

```

Ambas as formas são válidas, mas Gedê, usar o `major:minor` é geralmente preferível para robustez em ambientes de produção.

---

## Melhores Práticas e Padrões de Uso

Aplicar `blkio_config` de forma eficaz requer algumas considerações e melhores práticas:

1. **Monitoramento é Essencial:** Antes de aplicar qualquer limite, **monitore o uso de I/O** dos seus contêineres e do host. Ferramentas como `iotop`, `iostat`, `dstat`, Prometheus com Node Exporter (para métricas de disco) e cAdvisor (para métricas de contêiner) são inestimáveis. Isso te ajudará a identificar gargalos e a definir limites realistas.
2. **Comece com Pesos (`weight`):** Se você não tem certeza sobre os limites absolutos (BPS/IOPS), comece usando `weight` ou `weight_device`. Isso permite que o Docker aloque I/O de forma proporcional sem impor limites rígidos que podem estrangular o desempenho de um contêiner quando o disco está ocioso.
3. **Defina Limites Gradualmente:** Não imponha limites muito agressivos de início. Comece com limites que são um pouco mais altos do que o uso médio de pico e vá ajustando para baixo, monitorando o impacto no desempenho.
4. **Entenda o Perfil de I/O do Aplicativo:**
    - **Leitura/Escrita Sequencial:** Aplicações que leem/escrevem grandes arquivos de forma contínua (ex: stream de vídeo, backup) se beneficiarão mais dos limites de **BPS**.
    - **Leitura/Escrita Aleatória:** Aplicações que realizam muitas pequenas operações dispersas (ex: banco de dados OLTP, cache de disco) se beneficiarão mais dos limites de **IOPS**.
5. **Use `major:minor` para Robustez:** Como discutido, usar o identificador `major:minor` para os caminhos dos dispositivos é mais seguro do que usar `/dev/sdx`, que pode mudar.
6. **Documente suas Configurações:** Registre os motivos pelos quais você definiu certos limites e como eles afetam o desempenho. Isso é crucial para a manutenção e resolução de problemas.
7. **Teste sob Carga:** Simule cenários de alta carga para validar se suas configurações de `blkio_config` estão funcionando conforme o esperado e se não estão introduzindo novos gargalos.
8. **Considere o Tipo de Disco:**
    - **HDDs (Discos Rígidos):** Geralmente têm BPS e IOPS limitados. O gargalo pode ser tanto a taxa de transferência quanto o número de operações por segundo.
    - **SSDs (Solid State Drives):** Muito mais rápidos em IOPS (especialmente leitura aleatória) e BPS. A limitação pode vir mais da controladora do SSD ou da interface (SATA, NVMe).
    - **Volumes de Rede (SAN, NAS):** O desempenho aqui é altamente dependente da rede e do próprio storage. `blkio_config` atuará na interface do host com o volume de rede, mas a limitação principal pode estar no lado do storage.

---

## Exemplo Prático Completo

Vamos considerar um cenário onde temos dois serviços que competem por recursos de I/O no mesmo disco (`/dev/sda` ou `8:0`):

1. **`servico_bd`:** Um banco de dados PostgreSQL, que é crítico e precisa de alta prioridade de escrita.
2. **`servico_backup`:** Um serviço que realiza backups periódicos e pode ser intenso em leituras, mas não deve prejudicar o desempenho do banco de dados.

**Objetivo:**

- Garantir que o `servico_bd` tenha pelo menos 80% do peso de I/O de escrita e um limite máximo de 200 MB/s de escrita.
- Limitar o `servico_backup` a 50 MB/s de leitura, para que ele não sature o disco durante a operação de backup.

**Arquivo `docker-compose.yml`:**

```yaml
version: '3.8'

services:
  servico_bd:
    image: postgres:13
    container_name: postgres_db
    environment:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
    volumes:
      - db_data:/var/lib/postgresql/data
    blkio_config:
      # Damos a ele um peso maior para I/O geral no dispositivo sda (8:0)
      # Isso é especialmente relevante para a escrita do banco de dados
      weight_device:
        - path: "8:0" # Substitua pelo major:minor do seu disco principal
          weight: 800 # Alto peso para prioridade
      # Limitamos a escrita para garantir que não sature completamente, mesmo com alta prioridade
      device_write_bps:
        - path: "8:0"
          rate: "200mb" # Limite de escrita em 200 MB/s
    ports:
      - "5432:5432"
    networks:
      - app_network

  servico_backup:
    image: alpine/git # Usando uma imagem genérica para simular um processo de backup
    container_name: backup_agent
    command: sh -c "while true; do dd if=/dev/zero of=/data/temp_backup.img bs=1M count=500 status=none; rm /data/temp_backup.img; sleep 60; done"
    # Este comando simula uma escrita e leitura intensa (dd if=/dev/zero para escrita, então apagando)
    # Para simular uma leitura: "dd if=/data/large_file.img of=/dev/null bs=1M status=none; sleep 60;"
    volumes:
      - db_data:/data # Montando o mesmo volume para simular leitura/escrita no mesmo disco
    blkio_config:
      # Este serviço tem um peso menor, indicando menor prioridade geral
      weight_device:
        - path: "8:0"
          weight: 200 # Baixo peso para menor prioridade
      # Limitamos estritamente a leitura para não impactar o BD
      device_read_bps:
        - path: "8:0"
          rate: "50mb" # Limite de leitura em 50 MB/s
    networks:
      - app_network

volumes:
  db_data:

networks:
  app_network:
    driver: bridge

```

**Como testar (simulado):**

1. **Encontre o `major:minor` do seu disco:** No seu terminal, execute `lsblk -o KNAME,MAJ:MIN,FSTYPE,MOUNTPOINT`. Identifique o `MAJ:MIN` do disco onde seus dados Docker estão sendo armazenados (geralmente o disco do sistema de arquivos raiz ou um volume dedicado). Substitua `"8:0"` no `docker-compose.yml` pelo valor correto.
2. **Crie um arquivo grande para simular leitura para o `servico_backup` (opcional, para testar `device_read_bps`):**
Então, altere o comando do `servico_backup` para `command: sh -c "while true; do dd if=/data/large_file.img of=/dev/null bs=1M status=none; sleep 60; done"`.
    
    ```bash
    docker volume create my_test_volume
    docker run --rm -v my_test_volume:/data alpine sh -c "head -c 1G </dev/urandom >/data/large_file.img"
    # Se você está usando o volume `db_data` como no exemplo, o comando seria:
    # docker run --rm -v db_data:/data alpine sh -c "head -c 1G </dev/urandom >/data/large_file.img"
    
    ```
    
3. **Execute o Docker Compose:** `docker-compose up -d`
4. **Monitore o uso de I/O:**
    - No host: `sudo iotop` ou `sudo iostat -dx 1` (substitua `sdx` pelo seu disco, e 1 é o intervalo em segundos).
    - Você pode usar `docker stats` para ver um resumo, mas ele não mostra I/O de disco detalhado. Para ver os cgroups diretamente:
        - Descubra o ID do contêiner: `docker ps`
        - Navegue até o cgroup blkio do contêiner (no host):
        `cd /sys/fs/cgroup/blkio/docker/<container_id>cat blkio.throttle.read_bps_device` (para ler o limite configurado)
        `cat blkio.io_service_bytes` (para ver as estatísticas de uso de I/O)
        `cat blkio.io_service_bytes_recursive` (mais detalhado)

**Observações sobre o Exemplo:**

- O comando `dd` no `servico_backup` é uma simulação simples de I/O. Em um cenário real, você teria sua aplicação de backup.
- Os valores `rate` e `weight` são arbitrários para o exemplo. No mundo real, você ajustaria esses valores com base no monitoramento e nas necessidades de desempenho da sua aplicação.
- Lembre-se de que esses limites são impostos pelo kernel no nível do host.

---

Este nível de detalhe deve te dar uma compreensão completa, Gedê, sobre o `blkio_config` no Docker Compose. Se tiver mais alguma dúvida ou precisar de mais exemplos, é só perguntar\!