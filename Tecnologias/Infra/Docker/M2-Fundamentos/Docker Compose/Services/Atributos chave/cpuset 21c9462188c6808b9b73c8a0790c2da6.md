# cpuset

# Atributo `cpuset` da Chave `Services` no Docker Compose: Uma Explicação Detalhada

## Introdução

No mundo da orquestração de contêineres com Docker, o gerenciamento eficiente de recursos é crucial para garantir o desempenho e a estabilidade das aplicações. O Docker Compose, uma ferramenta para definir e executar aplicações Docker multi-contêineres, oferece diversas opções para controlar como os recursos do host são alocados para os serviços. Entre essas opções, o atributo `cpuset` se destaca por permitir um controle granular sobre quais CPUs (ou núcleos) específicos um contêiner pode utilizar.

Esta explicação detalhada abordará o `cpuset`, seu propósito, sintaxe, cenários de uso, limitações e melhores práticas, fornecendo um guia completo para desenvolvedores e administradores que buscam otimizar a alocação de recursos em seus ambientes Docker Compose.

## Sumário

- **Conceitos Fundamentais:** Entendimento do `cpuset` e sua importância.
- **Sintaxe Detalhada e Uso Prático:** Como configurar `cpuset` com exemplos.
- **Cenários de Restrição ou Não Aplicação:** Onde `cpuset` pode não ser a melhor escolha ou onde suas configurações são ignoradas.
- **Componentes Chave Associados:** Discussão de outros atributos de controle de CPU.
- **Melhores Práticas e Padrões de Uso:** Recomendações para otimizar o uso do `cpuset`.
- **Exemplo Prático Completo:** Um cenário de uso demonstrando a aplicação de `cpuset`.

## Conceitos Fundamentais

O atributo `cpuset` (ou `cpuset-cpus` em comandos `docker run`) permite "fixar" um contêiner a um conjunto específico de CPUs físicas ou lógicas no host. Isso significa que o agendador do kernel do Linux só permitirá que as threads do processo do contêiner sejam executadas nas CPUs designadas por `cpuset`.

**Propósito e Importância:**

- **Otimização de Desempenho:** Ao isolar contêineres em CPUs específicas, você pode reduzir a contenção de recursos e o overhead de comutação de contexto entre CPUs, o que é particularmente benéfico para aplicações sensíveis à latência ou de alto desempenho.
- **Isolamento de Carga de Trabalho:** Garante que cargas de trabalho críticas tenham acesso exclusivo a determinados núcleos de CPU, evitando que outras aplicações no mesmo host interfiram em seu desempenho.
- **Previsibilidade:** Ajuda a alcançar um desempenho mais consistente, pois o contêiner sempre será executado no mesmo conjunto de CPUs.
- **Evitar Vizinhos Barulhentos (Noisy Neighbors):** Impede que contêineres com uso intensivo de CPU afetem o desempenho de outros contêineres no mesmo host.

É importante notar que `cpuset` não limita a quantidade de CPU que um contêiner pode usar dentro do conjunto de CPUs atribuído; ele apenas define *onde* o contêiner pode ser executado. Para limitar a *quantidade* de CPU, outros atributos como `cpus` (ou `cpu-quota` e `cpu-period`) devem ser usados em conjunto.

## Sintaxe Detalhada e Uso Prático

No Docker Compose, o `cpuset` é definido sob a chave `services` para um serviço específico. A sintaxe é uma string que pode ser uma lista separada por vírgulas de IDs de CPU ou um intervalo de IDs. Os IDs de CPU são baseados em zero (ou seja, o primeiro CPU é `0`).

**Sintaxe:**

```yaml
version: '3.8' # Ou outra versão compatível
services:
  meu_servico:
    image: minha_imagem
    cpuset: "0-3" # Exemplo: Permite execução nas CPUs 0, 1, 2 e 3

```

**Variações de Sintaxe e Exemplos Comentados:**

1. **Intervalo de CPUs:**
Define um intervalo contínuo de CPUs onde o contêiner pode ser executado.
    
    ```yaml
    services:
      servico_web:
        image: nginx:latest
        cpuset: "0-1" # Este serviço só pode ser executado nas CPUs 0 e 1.
    
    ```
    
    *Comentário:* Ideal para isolar um serviço em um pequeno conjunto de núcleos consecutivos.
    
2. **Lista de CPUs Discretas:**
Define CPUs específicas e não necessariamente consecutivas.
    
    ```yaml
    services:
      servico_banco_dados:
        image: postgres:latest
        cpuset: "2,4" # Este serviço só pode ser executado nas CPUs 2 e 4.
    
    ```
    
    *Comentário:* Útil quando você tem núcleos específicos que deseja dedicar a uma carga de trabalho, talvez para evitar conflitos com outras aplicações fora do Docker ou outros contêineres.
    
3. **Combinação de `cpuset` com `cpus` (limite de uso de CPU):**
Enquanto `cpuset` define *onde* um contêiner pode ser executado, `cpus` (ou `cpu_quota` e `cpu_period` em versões mais antigas do Compose/Docker Engine) define a *quantidade* de CPU que ele pode consumir.
    
    ```yaml
    services:
      servico_intensivo:
        image: minha_imagem_computacao:latest
        cpuset: "0-3"  # Pode ser executado nas CPUs 0, 1, 2, 3
        cpus: "2.0"    # Mas só pode usar o equivalente a 2 CPUs completas dentro desse conjunto.
    
    ```
    
    *Comentário:* Isso garante que, mesmo que o contêiner esteja fixado em 4 CPUs, ele não monopolizará mais do que o equivalente a 2 CPUs, liberando recursos para outros processos no host ou em outros `cpusets`.
    
    Para Docker Compose v3.x e Docker Swarm (com `docker stack deploy`), `cpuset` e `cpus` são frequentemente usados dentro da seção `deploy` -\> `resources` -\> `limits` ou `reservations`.
    
    ```yaml
    version: '3.8'
    services:
      servico_com_deploy:
        image: minha_imagem
        deploy:
          resources:
            limits:
              cpus: '0.5' # Limite de 0.5 CPU
            reservations:
              cpus: '0.25' # Reserva de 0.25 CPU
          placement:
            constraints:
              - node.labels.cpuset_group == group_a # Exemplo de restrição de colocação
        cpuset: "0" # Fixa no CPU 0 (será ignorado pelo Docker Stack/Swarm, mas útil para docker-compose up local)
    
    ```
    
    *Comentário:* É importante notar que em Docker Compose v3, especialmente quando usado com `docker stack deploy` para Docker Swarm, o `cpuset` diretamente sob o serviço pode ser ignorado em favor das configurações dentro de `deploy.resources`. No entanto, para `docker-compose up` local, o `cpuset` ainda é respeitado. A documentação do Docker menciona que `cpu_shares`, `cpu_quota`, `cpuset`, `mem_limit`, `memswap_limit` foram substituídos pela chave `resources` sob `deploy` para o formato de arquivo v3, e as configurações de `deploy` só são eficazes ao usar `docker stack deploy`, sendo ignoradas por `docker-compose`.
    

## Cenários de Restrição ou Não Aplicação

Embora `cpuset` seja uma ferramenta poderosa, há cenários onde ele pode não ser a melhor escolha ou onde suas configurações são ignoradas:

- **Ambientes com Número Limitado de CPUs:** Se o seu host Docker possui poucas CPUs (por exemplo, 1 ou 2), o uso de `cpuset` pode não trazer benefícios significativos ou até mesmo ser contraproducente, pois pode restringir demais o agendamento de tarefas.
- **Docker Swarm (Docker Compose v3 `deploy` section):** Conforme mencionado anteriormente, em Docker Compose v3, as configurações de `cpuset` diretamente sob o serviço podem ser ignoradas se as opções de `deploy.resources` forem usadas em um contexto de Docker Swarm (`docker stack deploy`). Para gerenciamento de recursos em Swarm, as opções em `deploy.resources` (como `cpus` para limites e reservas) são as preferidas. O `cpuset` é mais relevante para o agendamento local de contêineres com `docker-compose up`.
- **Container de Uso Geral:** Para contêineres que não têm requisitos de desempenho críticos ou que realizam tarefas intermitentes, a fixação de CPU pode não ser necessária e pode levar a um uso ineficiente dos recursos do host.
- **Complexidade de Gerenciamento:** Gerenciar `cpusets` para muitos serviços em um ambiente dinâmico pode se tornar complexo, exigindo um bom entendimento da topologia de CPU do host.
- **Hardware Heterogêneo:** Em hosts com CPUs heterogêneas (diferentes modelos ou velocidades de núcleo), a simples atribuição por ID pode não garantir o desempenho esperado, pois os núcleos podem ter capacidades diferentes.
- **Over-Provisioning:** Se você atribuir mais CPUs a um `cpuset` do que o contêiner realmente precisa, os recursos alocados ficarão ociosos, sendo um uso ineficiente.

## Componentes Chave Associados

`cpuset` geralmente trabalha em conjunto com outros atributos de controle de recursos de CPU no Docker e Docker Compose:

- **`cpus` (ou `cpu-quota` e `cpu-period`):**
    - **Propósito:** Limita a *quantidade* total de tempo de CPU que um contêiner pode usar em um determinado período.
    - **Sintaxe:** `cpus: "0.5"` (usa até metade de uma CPU), `cpus: "2.0"` (usa até 2 CPUs).
    - **Uso:** Complementa `cpuset`. `cpuset` define o "onde", enquanto `cpus` define o "quanto". Um contêiner pode ser fixado em 4 CPUs (com `cpuset: "0-3"`) mas limitado a usar apenas 2 CPUs de tempo total dentro desse conjunto (com `cpus: "2.0"`).
    - **Observação:** `cpu_period` e `cpu_quota` são configurações de baixo nível que `cpus` abstrai. `cpu_period` define a duração de um período de agendamento de CPU em microssegundos (padrão é 100.000 microssegundos). `cpu_quota` define a quantidade de tempo de CPU que um contêiner pode usar em um período. `cpus` é uma forma mais simples de definir isso, onde `cpus: "1.5"` é equivalente a `cpu_period: 100000` e `cpu_quota: 150000`.
- **`cpu_shares`:**
    - **Propósito:** Define uma "peso" relativo para a alocação de CPU. Em um cenário de contenção de CPU, contêineres com `cpu_shares` mais altos recebem uma fatia maior do tempo de CPU disponível em relação a outros contêineres.
    - **Sintaxe:** `cpu_shares: 1024` (valor padrão), `cpu_shares: 2048`.
    - **Uso:** É um mecanismo de alocação de CPU *relativo*. Não garante uma quantidade específica de CPU, mas sim uma proporção quando há demanda. Se você tem um host com CPU 0-3 e dois contêineres com `cpu_shares: 1024` e `cpu_shares: 2048` respectivamente, o segundo contêiner terá o dobro de tempo de CPU que o primeiro, *se houver contenção*. `cpuset` e `cpu_shares` podem ser usados juntos.
- **`deploy` -\> `resources` (em Docker Compose v3):**
    - **Propósito:** Para serviços implantados em um cluster Docker Swarm (`docker stack deploy`), esta seção é a maneira recomendada de definir limites e reservas de recursos, incluindo CPU e memória.
    - **Sintaxe:**
        
        ```yaml
        deploy:
          resources:
            limits:
              cpus: '0.5'
              memory: 50M
            reservations:
              cpus: '0.25'
              memory: 20M
        
        ```
        
    - **Uso:** Esta é a forma preferida de gerenciar recursos em ambientes Swarm, pois o Swarm orquestra a colocação de contêineres nos nós do cluster com base nessas configurações. O `cpuset` diretamente sob o serviço é mais para uso local com `docker-compose up`.

## Melhores Práticas e Padrões de Uso

1. **Conheça sua Topologia de CPU:** Antes de usar `cpuset`, entenda a arquitetura de CPU do seu host. Saiba quantos núcleos físicos e lógicos você tem e como eles estão organizados (por exemplo, NUMA - Non-Uniform Memory Access). Comando como `lscpu` pode ser útil no Linux.
2. **Combine com Limites de CPU (`cpus`):** Sempre que usar `cpuset` para fixar um contêiner a CPUs específicas, considere também usar `cpus` para limitar a quantidade total de tempo de CPU que ele pode consumir dentro desse conjunto. Isso evita que um único contêiner monopolize as CPUs designadas, mesmo que outras aplicações possam se beneficiar.
3. **Use `cpuset` para Cargas de Trabalho Sensíveis:** Reserve `cpuset` para serviços que exigem desempenho altamente previsível ou que são sensíveis à latência, como bancos de dados de alto desempenho, servidores de jogos, ou aplicações de processamento de dados em tempo real.
4. **Evite Over-Subscription do `cpuset`:** Não atribua as mesmas CPUs a `cpusets` de múltiplos contêineres se esses contêineres tiverem cargas de trabalho intensivas e concorrentes. Isso anularia o benefício do isolamento. Se for necessário que contêineres compartilhem CPUs, considere usar `cpu_shares` para gerenciar a prioridade de forma relativa.
5. **Teste e Monitore:** Após aplicar `cpuset`, teste exaustivamente o desempenho do seu serviço e monitore o uso da CPU para garantir que as configurações estejam tendo o efeito desejado e que não haja degradação inesperada. Ferramentas como `docker stats` ou ferramentas de monitoramento de sistema (`top`, `htop`, `grafana`) são essenciais.
6. **Cuidado com a Escala:** Se você dimensionar (`scale`) um serviço com `cpuset`, todas as novas instâncias do contêiner tentarão usar o *mesmo* conjunto de CPUs. Isso pode levar a contenção e degradação de desempenho. Para serviços dimensionados, `cpuset` é geralmente menos apropriado, a menos que você tenha um `cpuset` grande o suficiente para acomodar todas as instâncias sem contenção. Para ambientes Swarm, as opções `deploy.resources.limits.cpus` são mais adequadas.
7. **Considerar `isolcpus` no Host:** Para isolamento de CPU de nível mais baixo e garantias de desempenho extremo, você pode configurar o kernel do Linux com `isolcpus` no `bootloader`. Isso remove CPUs específicas do agendamento geral do kernel, dedicando-as exclusivamente a aplicações (como contêineres com `cpuset`).

## Exemplo Prático Completo

Vamos criar um cenário onde temos uma aplicação web (Nginx) e um serviço de processamento de dados intensivo (simulado por uma imagem Alpine rodando um loop CPU-bound) em um host com 4 CPUs (0, 1, 2, 3). Queremos que o Nginx tenha acesso geral à CPU, mas que o serviço de processamento intensivo seja fixado às CPUs 2 e 3 para isolamento.

**`docker-compose.yml`:**

```yaml
version: '3.8'

services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    # Não usamos cpuset para o Nginx, permitindo que ele use qualquer CPU disponível.
    # Podemos, no entanto, limitar sua alocação total de CPU se necessário.
    cpus: "0.5" # O Nginx usará no máximo 0.5 de uma CPU.

  processador_intensivo:
    image: alpine:latest
    command: sh -c "while true; do echo 'Processando...'; done" # Simula uma carga de CPU contínua
    cpuset: "2,3" # Fixa este contêiner para ser executado *apenas* nas CPUs 2 e 3.
    cpus: "1.0" # Limita este contêiner a usar no máximo 1 CPU (dentro das CPUs 2 e 3).
    # Comentário: Mesmo que cpuset dê acesso a 2 CPUs (2 e 3), cpus: "1.0" garante que ele não monopolize ambas.
    # O agendador do Docker tentará manter o uso médio dentro do limite de 1 CPU, alternando entre 2 e 3.
    # Se fosse cpus: "2.0", ele poderia usar ambas as CPUs (2 e 3) ao máximo.

```

**Como Testar:**

1. **Salve o arquivo:** Salve o conteúdo acima como `docker-compose.yml`.
2. **Inicie os serviços:**
    
    ```bash
    docker-compose up -d
    
    ```
    
3. **Monitore o uso da CPU:** Abra um novo terminal e use `docker stats` para ver o uso da CPU pelos contêineres:
    
    ```bash
    docker stats
    
    ```
    
    Você verá o `processador_intensivo` consumindo CPU, e se o host tiver núcleos suficientes, seu uso será confinado às CPUs 2 e 3.
    
4. **Verifique os cpusets (no host Linux):**
Você pode inspecionar os cgroups para confirmar o `cpuset` de um contêiner. Primeiro, obtenha o ID completo do contêiner:
    
    ```bash
    docker ps
    
    ```
    
    Então, encontre o `cpuset` no cgroup do contêiner:
    
    ```bash
    CONTAINER_ID=$(docker ps -aqf "name=processador_intensivo")
    cat /sys/fs/cgroup/cpuset/docker/${CONTAINER_ID}*/cpuset.cpus
    
    ```
    
    A saída deve ser "2,3" (ou "2-3" dependendo da representação do kernel), confirmando que o contêiner está restrito a essas CPUs.
    

Este exemplo demonstra como o `cpuset` pode ser usado para isolar uma carga de trabalho específica, garantindo que ela tenha acesso a núcleos de CPU dedicados e, opcionalmente, limitando seu uso total de CPU dentro desse conjunto.

## Sugestões para Aprofundamento

Para um aprofundamento contínuo sobre o gerenciamento de recursos no Docker e Docker Compose, sugiro explorar os seguintes tópicos e recursos:

- **Documentação Oficial do Docker:**
    - [Docker Compose File Reference: Services `cpuset`](https://www.google.com/search?q=%5Bhttps://docs.docker.com/reference/compose-file/services/%23cpuset%5D%5C(https://docs.docker.com/reference/compose-file/services/%23cpuset%5C)) (ponto de partida para esta explicação)
    - [Resource constraints (Docker Engine)](https://docs.docker.com/engine/containers/resource_constraints/) (detalhes sobre `cpus`, `cpu-period`, `cpu-quota`, `cpu-shares`, `mem_limit`, etc.)
    - [Compose Deploy Specification (para Docker Swarm)](https://docs.docker.com/reference/compose-file/deploy/)
- **Cgroups (Control Groups) no Linux:** O `cpuset` é implementado através dos cgroups do Linux. Entender como os cgroups funcionam (especialmente o subsistema `cpuset`) fornecerá uma base sólida para otimizações avançadas.
- **NUMA (Non-Uniform Memory Access):** Em sistemas multi-socket ou com múltiplas CPUs, a arquitetura NUMA pode impactar o desempenho. A fixação de contêineres em CPUs (e, portanto, nós NUMA) pode ser crucial para cargas de trabalho de alto desempenho.
- **Ferramentas de Monitoramento de Sistema:** Aprenda a usar ferramentas como `top`, `htop`, `vmstat`, `iostat`, `perf`, e soluções de monitoramento como Prometheus e Grafana para observar o uso da CPU e identificar gargalos.
- **Otimização de Desempenho do Kernel Linux:** Explore configurações de kernel (como `isolcpus` e `rcu_nocbs`) que podem ser usadas para um isolamento de CPU ainda mais rigoroso.
- **Virtualização Aninhada e `cpuset`:** Se você estiver executando Docker dentro de uma máquina virtual, compreenda como o hipervisor gerencia os recursos de CPU e como isso pode interagir com as configurações de `cpuset` dentro da VM.

Continuo à disposição para auxiliar em outras questões, Gedê\!