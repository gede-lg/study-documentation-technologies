# cpu_quota

De acordo, Gedê\! Vamos mergulhar fundo no atributo `cpu_quota` do Docker Compose. Como um desenvolvedor Backend Java buscando migrar para Go, entender a gestão de recursos é crucial para otimizar suas aplicações.

---

# Gerenciando Recursos de CPU com `cpu_quota` no Docker Compose

### Introdução

No mundo dos contêineres, gerenciar os recursos que suas aplicações consomem é fundamental para garantir a estabilidade, performance e eficiência dos seus sistemas. O **Docker Compose**, uma ferramenta para definir e rodar aplicações multi-contêineres Docker, oferece uma gama de opções para controlar esses recursos. Uma dessas opções, e o foco da nossa discussão, é o atributo `cpu_quota` dentro da seção `services` do seu arquivo `docker-compose.yml`. Este atributo é essencial para limitar o quanto de tempo de CPU um contêiner pode utilizar, evitando que ele monopolize os recursos do host e prejudique outras aplicações ou o próprio sistema operacional.

### Sumário

Nesta explicação detalhada, abordaremos os seguintes tópicos:

- **Conceitos Fundamentais:** Entender o propósito e a importância da limitação de CPU em ambientes de contêineres.
- **Sintaxe Detalhada e Uso Prático:** Como configurar `cpu_quota` no Docker Compose, com exemplos claros e comentados.
- **Cenários de Restrição ou Não Aplicação:** Quando o `cpu_quota` pode não ser a melhor escolha e alternativas a considerar.
- **Componentes Chave Associados:** A relação entre `cpu_quota`, `cpu_period` e `cpus` (seção `deploy.resources.limits.cpus`).
- **Melhores Práticas e Padrões de Uso:** Recomendações para utilizar `cpu_quota` de forma eficaz.
- **Exemplo Prático Completo:** Um cenário demonstrando a aplicação de `cpu_quota` em um projeto com múltiplos serviços.

---

### Conceitos Fundamentais: A Importância do Controle de CPU em Contêineres

Em ambientes virtualizados e de contêineres, múltiplos processos e aplicações compartilham os recursos de hardware de uma única máquina hospedeira. Sem um controle adequado, um contêiner com uma carga de trabalho intensiva pode consumir uma quantidade desproporcional de CPU, degradando a performance de outros contêineres e até mesmo do próprio host. É aqui que entra a limitação de recursos.

O atributo `cpu_quota` no Docker Compose permite que você defina um **limite superior** para o tempo de CPU que um contêiner pode usar em um determinado período. Ele trabalha em conjunto com o `cpu_period` para controlar o percentual total da CPU que um contêiner tem permissão de utilizar.

**Por que isso é importante?**

1. **Estabilidade do Sistema:** Impede que um contêiner "famele" a CPU, garantindo que o host e outros serviços continuem operando de forma suave.
2. **Previsibilidade de Performance:** Ajuda a garantir que suas aplicações tenham um desempenho mais consistente, pois a disponibilidade de CPU é limitada e gerenciada.
3. **Justiça no Compartilhamento de Recursos:** Em um ambiente com vários contêineres, o `cpu_quota` garante que cada contêiner receba sua "fatia justa" da CPU disponível, evitando que um único serviço cause gargalos.
4. **Otimização de Custos:** Em ambientes de nuvem onde você paga por recursos computacionais, um gerenciamento eficaz de CPU pode levar a uma alocação mais eficiente de instâncias e, consequentemente, a custos mais baixos.

Imagine que você tem uma aplicação Go de backend, Gedê, e um serviço de processamento de dados em Python rodando no mesmo host. Se o serviço Python começar a consumir 100% da CPU devido a um processamento pesado, sua aplicação Go pode sofrer com latência e lentidão. Ao usar `cpu_quota`, você pode garantir que o serviço Python, mesmo sob carga máxima, não ultrapasse um limite pré-definido, protegendo a performance do seu backend Go.

---

### Sintaxe Detalhada e Uso Prático

O atributo `cpu_quota` é configurado sob a chave `resources` de um serviço no arquivo `docker-compose.yml`. Ele especifica a **quantidade máxima de tempo de CPU (em microssegundos)** que um contêiner pode usar durante um `cpu_period`.

A sintaxe básica é a seguinte:

```yaml
version: '3.8' # Sempre use uma versão recente para mais funcionalidades

services:
  meu_servico:
    image: meu_aplicativo_go:latest # Exemplo de imagem para seu backend Go
    deploy:
      resources:
        limits:
          cpu_quota: <valor_em_microssegundos>

```

Vamos detalhar a relação entre `cpu_quota` e `cpu_period`:

- **`cpu_period`**: Define o período de tempo (em microssegundos) em que o scheduler do Docker considera o uso de CPU. O valor padrão é 100.000 microssegundos (100ms). Este é o numerador implícito para o cálculo de compartilhamento de CPU.
- **`cpu_quota`**: Define o limite máximo de tempo de CPU (em microssegundos) que um contêiner pode utilizar dentro de cada `cpu_period`.

**Como eles trabalham juntos?**

Se você tem um `cpu_period` de 100.000 microssegundos (o padrão) e define um `cpu_quota` de 50.000 microssegundos, o contêiner poderá usar no máximo 50% de um núcleo de CPU durante cada ciclo de 100ms.

**Fórmula de Cálculo:**

$\\text{Uso Percentual de CPU} = \\frac{\\text{cpu\_quota}}{\\text{cpu\_period}}$

**Exemplos Comentados:**

```yaml
version: '3.8'

services:
  backend-go:
    image: gedes-backend-go:1.0 # Sua aplicação Go
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          # Exemplo 1: Limitar a 50% de um núcleo de CPU
          # cpu_period padrão é 100000 (100ms)
          # Então, 50000 / 100000 = 0.5 (50%)
          cpu_quota: 50000

  processador-dados:
    image: data-processor:1.0 # Um serviço que pode ser intensivo em CPU
    deploy:
      resources:
        limits:
          # Exemplo 2: Limitar a 25% de um núcleo de CPU
          # Aqui, 25000 / 100000 = 0.25 (25%)
          cpu_quota: 25000

  servico-web-leve:
    image: frontend-nginx:1.0
    ports:
      - "80:80"
    deploy:
      resources:
        limits:
          # Exemplo 3: Limitar a 100% de um núcleo de CPU
          # Usar 100000 garante que o contêiner possa usar um núcleo inteiro, se disponível.
          # Pode ser útil para serviços que precisam de um núcleo dedicado.
          cpu_quota: 100000

  servico-multi-core:
    image: heavy-compute-app:1.0
    deploy:
      resources:
        limits:
          # Exemplo 4: Limitar a 150% (equivalente a 1.5 núcleos)
          # Isso é útil se você tem uma máquina com múltiplos núcleos e quer permitir
          # que um contêiner use mais de um núcleo, mas não todos.
          # 150000 / 100000 = 1.5 (150%)
          cpu_quota: 150000
        # Também é possível definir o cpu_period explicitamente, embora raramente necessário
        # cpu_period: 50000 # Se você mudar o período, o quota precisa ser ajustado

```

**Observações importantes:**

- **Valores em Microssegundos:** Lembre-se sempre que `cpu_quota` e `cpu_period` são expressos em microssegundos.
- **Limitação por Núcleo:** O `cpu_quota` limita o tempo de CPU **por núcleo**. Um `cpu_quota` de `100000` (com `cpu_period` padrão de `100000`) significa que o contêiner pode usar até 100% de um único núcleo. Para usar mais de um núcleo, você precisa aumentar o `cpu_quota` proporcionalmente.
- **Valores Negativos/Zero:** Valores negativos ou zero são inválidos para `cpu_quota`.

---

### Cenários de Restrição ou Não Aplicação

Embora `cpu_quota` seja uma ferramenta poderosa, há situações em que pode não ser a melhor escolha ou onde sua aplicação pode ser limitada:

1. **Ambientes de Teste/Desenvolvimento:** Para um ambiente de desenvolvimento local, Gedê, onde a otimização de recursos não é a principal preocupação, a limitação de CPU pode, na verdade, atrapalhar. Você pode querer que seus contêineres rodem com acesso total à CPU para agilizar compilações ou testes.
2. **Cargas de Trabalho Esporádicas e Intensas:** Para um contêiner que executa tarefas intensivas de CPU por curtos períodos, mas que fica ocioso na maior parte do tempo (como um job de backup noturno), um `cpu_quota` muito restritivo pode prolongar desnecessariamente o tempo de execução. Nesses casos, `cpu_shares` (ver abaixo) pode ser mais apropriado, ou até mesmo nenhuma limitação, se o impacto no sistema for aceitável.
3. **Compreensão Inadequada do `cpu_period`:** Se você não entender como `cpu_quota` interage com `cpu_period` (especialmente se você o modificar), pode acabar com limites inesperados ou ineficazes. O `cpu_period` padrão (100ms) geralmente é adequado.
4. **Over-provisioning Intencional:** Em alguns cenários, você pode ter um servidor robusto e querer que seus contêineres usem a maior parte da CPU disponível para alcançar o máximo desempenho, mesmo que isso signifique menos recursos para o host. Nestes casos, limitar a CPU seria contraproducente.
5. **Alternativas como `cpus` (Deployment)**: Para casos onde você quer especificar explicitamente o número de CPUs que um serviço pode usar, a chave `cpus` sob `deploy.resources.limits` pode ser mais intuitiva e direta do que calcular `cpu_quota` e `cpu_period`. No entanto, `cpu_quota` oferece um controle mais granular sobre frações de CPU.

---

### Componentes Chave Associados

É crucial entender que `cpu_quota` não opera isoladamente. Ele faz parte de um conjunto de opções de controle de recursos de CPU no Docker e Docker Compose.

### 1\. `cpu_period`

- **Localização:** `deploy.resources.limits.cpu_period` (não é comum configurar, pois o padrão é geralmente bom).
- **Propósito:** Define o período de tempo em microssegundos (padrão: 100.000 microssegundos ou 100ms) para o scheduler de CPU. Todos os limites e pesos de CPU são calculados com base neste período.
- **Sintaxe:**
    
    ```yaml
    services:
      meu_servico:
        deploy:
          resources:
            limits:
              cpu_period: 200000 # Define o período para 200ms
              cpu_quota: 100000 # Agora, isso seria 100000 / 200000 = 0.5 (50%)
    
    ```
    
- **Uso:** Raramente é necessário alterar o `cpu_period` padrão. Ele é um denominador para o cálculo de `cpu_quota`. Mudar o `cpu_period` sem ajustar o `cpu_quota` mudará o percentual efetivo de CPU alocado.

### 2\. `cpu_shares`

- **Localização:** `cpu_shares` (diretamente sob o serviço, ou em `deploy.resources.reservations.cpu_shares`).
- **Propósito:** `cpu_shares` (ou `cpu_percent` em versões mais antigas do Compose) define a **proporção** de tempo de CPU que um contêiner recebe em relação a outros contêineres quando há contenção de CPU. Não é um limite absoluto, mas uma **preferência de peso**. Se o sistema tiver CPU de sobra, um contêiner com `cpu_shares` alto pode usar mais CPU do que sua proporção. Se houver escassez, ele terá uma fatia maior do "bolo" de CPU disponível. O valor padrão é 1024.
- **Sintaxe:**
    
    ```yaml
    services:
      servico-prioridade-alta:
        image: high-priority-app
        cpu_shares: 2048 # Prioridade dobrada em relação ao padrão
      servico-prioridade-baixa:
        image: low-priority-app
        cpu_shares: 512 # Metade da prioridade em relação ao padrão
    
    ```
    
- **Uso:** Use `cpu_shares` quando você quer dar mais "peso" a um contêiner em relação a outros durante a contenção de CPU, mas não quer impor um limite rígido. É útil para balancear cargas de trabalho onde a utilização de CPU é flutuante.

### 3\. `cpus` (Docker Compose V3.8+)

- **Localização:** `deploy.resources.limits.cpus`
- **Propósito:** Define o número máximo de CPUs que o contêiner pode usar. É uma forma mais simples e direta de limitar a CPU do que `cpu_quota`. Aceita valores de ponto flutuante, como `0.5` para meio núcleo, `1.0` para um núcleo, `2.5` para dois núcleos e meio, etc.
- **Sintaxe:**
    
    ```yaml
    services:
      meu_servico:
        deploy:
          resources:
            limits:
              cpus: 1.5 # Limita o contêiner a usar o equivalente a 1.5 núcleos de CPU
    
    ```
    
- **Uso:** Essa é a opção mais recente e geralmente a mais recomendada para limitar a CPU de forma simples e direta, pois é mais fácil de entender do que `cpu_quota`/`cpu_period`. Internamente, o Docker Compose pode converter esse valor em `cpu_quota`/`cpu_period`.
- **Relação com `cpu_quota`:** Embora `cpus` seja mais legível, ele é essencialmente um "açúcar sintático" para configurar `cpu_quota` e `cpu_period`. Por exemplo, `cpus: 1.5` é equivalente a `cpu_quota: 150000` (com `cpu_period` padrão de `100000`). Se você definir ambos `cpus` e `cpu_quota`, o Docker Compose pode priorizar um sobre o outro ou gerar um erro, então é melhor escolher um método e se ater a ele. Para clareza, recomendo usar `cpus` quando possível, a menos que você precise do controle granular específico que `cpu_quota` e `cpu_period` oferecem para cenários muito complexos.

---

### Melhores Práticas e Padrões de Uso

Ao utilizar `cpu_quota` (ou `cpus`), considere as seguintes melhores práticas:

1. **Comece com Valores Realistas:** Não comece com limites excessivamente restritivos. Monitore o uso de CPU dos seus contêineres em ambientes de produção (ou pré-produção) para entender suas necessidades reais e ajuste os limites gradualmente.
2. **Monitore o Uso de CPU:** Ferramentas como `docker stats` ou soluções de monitoramento mais robustas (Prometheus + Grafana, Datadog, etc.) são essenciais para verificar se seus contêineres estão atingindo os limites de CPU e se isso está impactando a performance.
3. **Priorize `cpus` (quando aplicável):** Para a maioria dos casos, especialmente se você está usando Docker Compose versão 3.8 ou superior, a chave `cpus` é mais fácil de entender e gerenciar do que `cpu_quota` e `cpu_period`. Seus valores intuitivos (`0.5`, `1.0`, `2.0`, etc.) tornam o controle de CPU muito mais claro.
4. **Considere `cpu_shares` para Priorização Flexível:** Se você tem serviços onde a prioridade é mais importante do que um limite absoluto (e.g., um serviço crítico que precisa ter preferência sobre um serviço de background menos importante), `cpu_shares` pode ser mais adequado que `cpu_quota`.
5. **Documente Seus Limites:** Deixe claro em sua documentação ou comentários no `docker-compose.yml` o porquê de certos limites terem sido definidos. Isso ajuda futuras equipes (ou você mesmo no futuro) a entender as decisões de design.
6. **Não Super-alocar Exageradamente:** Evite somar os limites de CPU de todos os seus contêineres para um valor muito maior do que a CPU total do seu host. Embora seja possível (e às vezes útil para picos esporádicos), super-alocar demais pode levar a problemas de desempenho quando todos os contêineres demandarem seus limites simultaneamente. Por exemplo, Gedê, se seu servidor tem 4 núcleos, e você dá a cada um de 5 contêineres 1 núcleo com `cpus: 1.0`, você pode ter problemas de CPU se todos estiverem ativos ao mesmo tempo.

---

### Exemplo Prático Completo: Aplicação Backend Go com Processamento de Fila

Vamos criar um exemplo de um arquivo `docker-compose.yml` para uma aplicação Go de backend (como a que você está buscando) que interage com um serviço de fila (RabbitMQ) e um processador de mensagens que pode ser intensivo em CPU.

Neste cenário, queremos garantir que:

- O backend Go tenha recursos de CPU suficientes para responder rapidamente às requisições.
- O processador de fila, que pode ter picos de uso, não monopolize a CPU, deixando recursos para o backend e o sistema.
- O RabbitMQ, um serviço de infraestrutura, tenha uma pequena garantia de CPU.

<!-- end list -->

```yaml
version: '3.8'

services:
  # Seu serviço de Backend Go
  backend-go-api:
    image: gedes-go-api:latest # Imagem da sua aplicação Go
    ports:
      - "8080:8080"
    environment:
      RABBITMQ_HOST: rabbitmq
    deploy:
      resources:
        limits:
          # Limita o backend a 0.8 de um núcleo de CPU.
          # Isso é adequado para a maioria das APIs que não realizam processamento pesado no request.
          # Equivale a cpu_quota: 80000 com cpu_period padrão de 100000.
          cpus: 0.8
        # Não adicionamos reservas aqui, pois queremos que ele possa burstar
        # se houver CPU disponível, mas com um limite rígido.
    depends_on:
      - rabbitmq
    networks:
      - app-network

  # Serviço de Processamento de Fila (pode ser Go, Python, Node, etc.)
  queue-processor:
    image: data-processor:latest # Imagem do processador de dados
    environment:
      RABBITMQ_HOST: rabbitmq
    deploy:
      resources:
        limits:
          # Limita o processador a 1.2 núcleos de CPU.
          # Permite que ele utilize mais de um núcleo, mas com um teto.
          # Isso é crucial para evitar que ele sobrecarregue o host durante picos de processamento.
          # Equivale a cpu_quota: 120000 com cpu_period padrão.
          cpus: 1.2
        reservations:
          # Garante que o processador terá pelo menos 0.5 núcleo de CPU sempre disponível.
          # Isso é útil para cargas de trabalho que exigem uma base mínima de recursos.
          cpus: 0.5
    depends_on:
      - rabbitmq
    networks:
      - app-network

  # Serviço de Mensageria RabbitMQ
  rabbitmq:
    image: rabbitmq:3-management-alpine
    ports:
      - "5672:5672" # Porta padrão do AMQP
      - "15672:15672" # Porta do painel de gerenciamento
    deploy:
      resources:
        limits:
          # Limita o RabbitMQ a 0.3 de um núcleo de CPU.
          # É um serviço de infraestrutura, não deve precisar de muita CPU.
          cpus: 0.3
        reservations:
          # Garante uma pequena reserva para estabilidade.
          cpus: 0.1
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

```

**Explicação Detalhada do Exemplo:**

- **`backend-go-api`**: Seu backend Go é limitado a **0.8 de um núcleo de CPU**. Isso significa que ele tem acesso a quase um núcleo inteiro, mas não pode consumir 100% de um núcleo e "roubar" tempo de CPU de outros serviços se não houver mais de um núcleo disponível para ele. Esta é uma configuração razoável para uma API que precisa de boa resposta.
- **`queue-processor`**: Este serviço, que pode ser intensivo, é limitado a **1.2 núcleos de CPU**. Isso permite que ele utilize mais de um núcleo, mas impede que ele consuma todos os recursos da máquina. Adicionalmente, ele tem uma **reserva de 0.5 núcleo**, o que significa que o scheduler do Docker tentará garantir que este serviço sempre tenha pelo menos meio núcleo disponível, mesmo sob forte contenção de recursos. A reserva (`reservations`) indica a quantidade de recursos que o contêiner *solicita* e *receberá* se disponível, enquanto o limite (`limits`) é o *máximo* que ele pode usar.
- **`rabbitmq`**: Como um serviço de infraestrutura que geralmente não é intensivo em CPU, ele é limitado a **0.3 de um núcleo**, com uma **reserva de 0.1 núcleo**. Isso garante que o RabbitMQ sempre tenha uma pequena fatia de CPU para operar, sem permitir que ele inesperadamente consuma muitos recursos.

Este exemplo demonstra como você pode usar `cpus` (que é a forma mais moderna de usar `cpu_quota` implicitamente) em conjunto com `reservations.cpus` para gerenciar tanto os limites superiores quanto as garantias mínimas de CPU para seus serviços, Gedê.

---

Espero que esta explicação detalhada ajude você a dominar o uso de `cpu_quota` e outras opções de gerenciamento de CPU no Docker Compose, Gedê\! Se tiver mais alguma dúvida ou quiser explorar outro tópico, é só perguntar.