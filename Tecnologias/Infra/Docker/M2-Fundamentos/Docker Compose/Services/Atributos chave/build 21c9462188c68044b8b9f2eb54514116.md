# build

De acordo, Gedê\! A.R.I.A está pronta para te ajudar com uma explicação extremamente detalhada sobre o atributo `build` da chave `services` no Docker Compose.

---

# Entendendo o Atributo `build` no Docker Compose: Construindo suas Imagens no Orquestrador de Contêineres

---

## Introdução

No universo do desenvolvimento e implantação de aplicações modernas, a **conteinerização** emergiu como uma prática fundamental para garantir consistência, isolamento e portabilidade. O **Docker** é a ferramenta líder nesse cenário, permitindo que desenvolvedores empacotem suas aplicações e suas dependências em **contêineres** leves e autossuficientes. No entanto, quando uma aplicação envolve múltiplos serviços que precisam interagir entre si (como um backend, um frontend, um banco de dados, etc.), orquestrar esses contêineres manualmente pode se tornar complexo e propenso a erros. É aqui que o **Docker Compose** entra em cena.

O Docker Compose é uma ferramenta que facilita a definição e execução de aplicações Docker multi-contêineres. Com um único arquivo YAML, você pode configurar todos os serviços da sua aplicação, as redes que eles usarão e os volumes que compartilharão. Dentro da chave `services` de um arquivo `docker-compose.yml`, cada serviço representa um contêiner. Para cada um desses serviços, você precisa especificar qual imagem Docker será usada. E é exatamente nesse ponto que o atributo `build` se torna crucial.

O atributo `build` permite que o Docker Compose não apenas use uma imagem existente do Docker Hub ou de um registro privado, mas também **construa uma nova imagem a partir de um Dockerfile** no momento em que você executa o comando `docker-compose up`. Isso é incrivelmente poderoso, pois permite que você defina e mantenha a construção da sua imagem de serviço diretamente no seu projeto, garantindo que o ambiente do contêiner esteja sempre alinhado com o código-fonte da sua aplicação.

---

## Sumário

Nesta explanação aprofundada, abordaremos os seguintes tópicos para garantir um entendimento completo do atributo `build`:

- **Conceitos Fundamentais:** A base teórica por trás do `build`, sua importância vital no ciclo de vida de desenvolvimento e implantação, e seu propósito principal.
- **Sintaxe Detalhada e Uso Prático:** Uma análise minuciosa das diferentes formas de usar o atributo `build`, incluindo exemplos de código comentados e variações de sintaxe.
- **Cenários de Restrição ou Não Aplicação:** Quando o `build` pode não ser a melhor escolha e por que, oferecendo alternativas e considerações.
- **Componentes Chave Associados:** Explicação dos sub-atributos cruciais do `build` (`context`, `dockerfile`, `args`, `cache_from`, `labels`, `network`, `shm_size`, `target`), seus usos e sintaxe específica.
- **Melhores Práticas e Padrões de Uso:** Recomendações, dicas e casos de uso comuns e eficazes para otimizar suas construções de imagem com Docker Compose.
- **Exemplo Prático Completo:** Um cenário de ponta a ponta demonstrando o uso do `build` em uma aplicação multi-serviços.

---

## Conceitos Fundamentais

### O Que é o Atributo `build`?

O atributo `build` na seção `services` de um arquivo `docker-compose.yml` informa ao Docker Compose que, em vez de puxar uma imagem preexistente de um registro (como o Docker Hub), ele deve **construir uma nova imagem Docker localmente** antes de iniciar o contêiner para aquele serviço. Essa construção é realizada com base em um **Dockerfile** e, opcionalmente, em um **contexto de construção** específico.

### Importância e Propósito

1. **Reproducibilidade e Consistência:** Ao definir a construção da imagem diretamente no seu arquivo Compose, você garante que qualquer pessoa que execute seu `docker-compose.yml` construirá exatamente a mesma imagem, com as mesmas dependências e configurações. Isso elimina o famoso "funciona na minha máquina".
2. **Integração com o Código-Fonte:** O `build` é fundamental quando você está desenvolvendo uma aplicação. As alterações no seu código-fonte (que geralmente estão no mesmo diretório do Dockerfile) são automaticamente incluídas na nova imagem sempre que você reconstrói o serviço.
3. **Ambientes Personalizados:** Você pode precisar de dependências específicas, pacotes de sistema ou configurações que não estão disponíveis em imagens base genéricas. O `build` permite que você crie uma imagem altamente personalizada para as necessidades exatas da sua aplicação.
4. **Otimização de Tamanho e Segurança:** Ao construir suas próprias imagens, você tem controle total sobre o que é incluído, permitindo a remoção de pacotes desnecessários e a aplicação de práticas de segurança, resultando em imagens mais leves e seguras.
5. **Ciclo de Desenvolvimento Rápido:** Em vez de construir a imagem manualmente com `docker build` e depois referenciá-la no `compose` com `image`, o `build` simplifica o processo, combinando as etapas de construção e orquestração.

### Como Funciona Internamente?

Quando você executa `docker-compose up` e um serviço tem o atributo `build` configurado, o Docker Compose:

1. **Identifica o Contexto:** Ele determina o diretório que servirá como o "contexto de construção" (o diretório que será enviado para o daemon Docker para a construção).
2. **Localiza o Dockerfile:** Dentro desse contexto, ele procura pelo Dockerfile especificado (ou o padrão, se não especificado).
3. **Envia o Contexto:** Todo o conteúdo do diretório de contexto é enviado para o daemon Docker. Isso é crucial, pois apenas os arquivos dentro do contexto são acessíveis durante a construção da imagem.
4. **Executa o Dockerfile:** O daemon Docker executa as instruções no Dockerfile passo a passo, criando camadas da imagem.
5. **Taggeia a Imagem:** Uma vez construída, a imagem é automaticamente "taggeada" pelo Docker Compose com um nome que reflete o nome do serviço e um hash (ex: `meuapp_backend:latest`).
6. **Inicia o Contêiner:** Finalmente, o contêiner para o serviço é iniciado usando a imagem recém-construída.

**Importante:** Se o Docker Compose detectar que não houve mudanças no Dockerfile ou no contexto de construção desde a última vez que a imagem foi construída para aquele serviço, ele pode usar uma imagem em cache, agilizando o processo. No entanto, para garantir que as últimas alterações sejam consideradas, é comum usar `docker-compose up --build`.

---

## Sintaxe Detalhada e Uso Prático

O atributo `build` pode ser especificado de algumas maneiras diferentes, dependendo da flexibilidade e controle que você precisa.

### 1\. Forma Mais Simples: Apenas o Caminho do Contexto

Esta é a forma mais comum e direta, onde o valor do `build` é o caminho para o diretório que contém o Dockerfile. O Docker Compose assumirá que o Dockerfile se chama `Dockerfile` e está na raiz do diretório especificado.

```yaml
# docker-compose.yml
version: '3.8'
services:
  backend:
    # O Dockerfile está em ./backend/Dockerfile
    build: ./backend
    ports:
      - "8080:8080"
    volumes:
      - ./backend:/app # Mapeia o código-fonte para dentro do contêiner

```

**Explicação:**

- `backend:` Define um serviço chamado `backend`.
- `build: ./backend`: Instruí o Docker Compose a construir a imagem para este serviço usando o Dockerfile encontrado no diretório `./backend`. Ele esperará que o Dockerfile esteja em `backend/Dockerfile`.

### 2\. Forma Detalhada: Objeto com `context` e `dockerfile`

Esta é a forma mais flexível e recomendada, permitindo que você especifique o contexto de construção (`context`) e o nome ou caminho do Dockerfile (`dockerfile`) separadamente. Isso é útil quando seu Dockerfile não está na raiz do contexto ou tem um nome diferente de `Dockerfile`.

```yaml
# docker-compose.yml
version: '3.8'
services:
  frontend:
    build:
      context: ./frontend_app # O diretório de contexto é frontend_app
      dockerfile: Dockerfile.dev # O Dockerfile específico a ser usado é Dockerfile.dev dentro do contexto
    ports:
      - "3000:3000"

  api:
    build:
      context: ../api/v1 # O contexto está em um diretório acima e depois dentro de api/v1
      dockerfile: Dockerfile # O Dockerfile se chama Dockerfile neste contexto
    ports:
      - "5000:5000"

```

**Explicação:**

- **`frontend` serviço:**
    - `context: ./frontend_app`: O diretório `frontend_app` (relativo ao `docker-compose.yml`) será o contexto de construção. Todos os arquivos dentro deste diretório serão enviados para o daemon Docker.
    - `dockerfile: Dockerfile.dev`: O Docker Compose procurará por um arquivo chamado `Dockerfile.dev` *dentro* do diretório `./frontend_app` para construir a imagem.
- **`api` serviço:**
    - `context: ../api/v1`: Demonstra que o contexto pode estar em um caminho relativo que navega para fora do diretório atual do `docker-compose.yml`.
    - `dockerfile: Dockerfile`: Neste caso, o nome padrão `Dockerfile` é explicitamente especificado dentro do contexto `../api/v1`.

### 3\. Usando um Caminho para uma URL (Obsoleto ou Não Recomendado para Produção)

Embora a documentação oficial mencione a possibilidade de usar uma URL para um repositório Git ou para um arquivo compactado remoto, esta prática é **raramente utilizada em cenários de produção** devido a questões de controle de versão, segurança e desempenho. Geralmente, as imagens são construídas a partir de código-fonte local.

```yaml
# docker-compose.yml (Exemplo teórico, não recomendado para uso geral)
version: '3.8'
services:
  my-service:
    # Isso puxaria um repositório Git e construiria a partir do Dockerfile em sua raiz
    build: <https://github.com/myuser/myrepo.git#mybranch:mydirectory>
    ports:
      - "80:80"

```

**Observação:** O uso de URLs para o `build` é mais comum para fins de teste ou experimentação, mas não para o desenvolvimento ou implantação contínua onde a reprodutibilidade e o controle são primordiais.

---

## Cenários de Restrição ou Não Aplicação

Embora o atributo `build` seja extremamente útil, há situações em que ele pode não ser a melhor escolha ou onde seu uso deve ser ponderado:

1. **Imagens Pré-construídas e Estáveis:**
    - **Cenário:** Se o seu serviço utiliza uma imagem Docker pública e estável que raramente muda e não requer personalizações (ex: um banco de dados PostgreSQL, um servidor Nginx básico, Redis), usar `image` é mais eficiente.
    - **Por que não `build`:** Construir uma imagem que já existe e é bem mantida por outros adiciona tempo desnecessário ao `docker-compose up` e não oferece benefícios de personalização se você não for modificar o Dockerfile base.
2. **Imagens Publicadas em Registros Privados/Públicos:**
    - **Cenário:** Em ambientes de CI/CD (Integração Contínua/Entrega Contínua), é comum que as imagens sejam construídas e publicadas em um registro de contêiner (como Docker Hub, Google Container Registry, AWS ECR) como parte do pipeline de build. Nesses casos, o ambiente de produção ou staging apenas puxa a imagem já construída.
    - **Por que não `build`:** Para ambientes de produção, puxar uma imagem pré-construída e testada de um registro garante que você está implantando exatamente a versão que foi validada, em vez de construir no ambiente de destino. Isso também otimiza o tempo de implantação, pois não há necessidade de compilar ou instalar dependências no servidor de destino.
3. **Ambientes com Recursos Limitados:**
    - **Cenário:** Em máquinas com pouca CPU ou memória, construir imagens pode ser um processo demorado e intensivo em recursos.
    - **Por que não `build`:** Se a máquina onde o Docker Compose será executado para iniciar os serviços for limitada, pode ser mais eficiente pré-construir as imagens em um ambiente mais robusto (como um servidor de CI/CD) e depois apenas puxá-las.
4. **Imagens Extremamente Grandes ou Complexas:**
    - **Cenário:** Se o Dockerfile for muito complexo, com muitas camadas, ou resultar em imagens muito grandes, a reconstrução constante pode ser lenta.
    - **Consideração:** Nesses casos, é fundamental otimizar o Dockerfile (multi-stage builds, `.dockerignore`) para reduzir o tamanho da imagem e o tempo de construção, mesmo que você use `build`.

### Alternativas ao `build`

Quando o `build` não é a melhor opção, a alternativa é usar o atributo `image`:

```yaml
# docker-compose.yml
version: '3.8'
services:
  database:
    # Puxa a imagem oficial do PostgreSQL do Docker Hub
    image: postgres:13
    environment:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password

  cache:
    # Puxa a imagem oficial do Redis
    image: redis:6-alpine

```

**Observação:** Você pode combinar `build` e `image` no mesmo serviço, mas o Docker Compose priorizará o `build` se ambos estiverem presentes. A tag definida em `image` será usada para nomear a imagem construída, o que pode ser útil para organizar suas imagens locais.

```yaml
version: '3.8'
services:
  my-app:
    build: ./app
    image: my-company/my-app:dev # A imagem construída será taggeada como my-company/my-app:dev
    ports:
      - "80:80"

```

---

## Componentes Chave Associados ao `build`

Quando você usa a forma detalhada do atributo `build` (como um objeto), pode especificar vários sub-atributos que fornecem controle granular sobre o processo de construção da imagem.

### 1\. `context` (Obrigatório na Forma de Objeto)

- **Definição:** Especifica o caminho (relativo ao arquivo `docker-compose.yml` ou absoluto) para o diretório que o Docker Compose enviará para o daemon Docker como o "contexto de construção". Todos os arquivos e diretórios dentro deste contexto estarão disponíveis para o Dockerfile.
- **Uso:** É fundamental que o Dockerfile e quaisquer arquivos que ele referencie (como seu código-fonte, arquivos de configuração, etc.) estejam dentro deste diretório de contexto.
- **Sintaxe:**
Ou, como no exemplo mais simples:
    
    ```yaml
    build:
      context: ./path/to/your/app
    
    ```
    
    ```yaml
    build: ./path/to/your/app # Neste caso, './path/to/your/app' é o contexto
    
    ```
    
- **Exemplo:** Se seu Dockerfile copia o arquivo `package.json` e ele está na mesma pasta do Dockerfile, o `context` deve apontar para essa pasta.

### 2\. `dockerfile` (Opcional)

- **Definição:** Permite especificar o nome do Dockerfile a ser usado para a construção, caso ele não se chame `Dockerfile` ou esteja em um subdiretório específico dentro do `context`. O caminho é relativo ao `context`.
- **Uso:** Útil para ter múltiplos Dockerfiles no mesmo projeto (ex: `Dockerfile.dev`, `Dockerfile.prod`, `Dockerfile.test`) ou quando o Dockerfile não está na raiz do contexto.
- **Sintaxe:**
Neste exemplo, o contexto é o diretório atual (`.`), e o Dockerfile usado é `Dockerfile.dev` que está neste mesmo diretório.
    
    ```yaml
    build:
      context: .
      dockerfile: Dockerfile.dev
    
    ```
    

### 3\. `args` (Opcional)

- **Definição:** Permite passar variáveis de construção (build-time variables) para o Dockerfile. Essas variáveis são definidas com a instrução `ARG` no Dockerfile e podem ser usadas durante o processo de construção da imagem, mas não estarão disponíveis nos contêineres em tempo de execução.
- **Uso:** Ideal para passar segredos não sensíveis (como versões de bibliotecas, branches Git), configurar diferentes ambientes de construção (produção vs. desenvolvimento) ou injetar informações que só são conhecidas no momento da construção.
- **Sintaxe:** Pode ser uma lista de chaves-valor ou um mapeamento.
    
    ```yaml
    build:
      context: .
      dockerfile: Dockerfile
      args:
        # Forma de mapeamento
        HTTP_PROXY: <http://proxy.example.com>
        NODE_VERSION: "18"
        BUILD_ENV: production
        # Ou forma de lista (menos comum para variáveis com valores)
        - DEBUG_MODE
    
    ```
    
    E no `Dockerfile`:
    
    ```
    # Dockerfile
    FROM node:${NODE_VERSION} # Usa a variável NODE_VERSION passada via build.args
    ARG HTTP_PROXY
    ENV http_proxy=${HTTP_PROXY} # Define uma variável de ambiente no contêiner com o valor do ARG
    ARG BUILD_ENV=development # Define um valor padrão para BUILD_ENV
    RUN if [ "$BUILD_ENV" = "production" ]; then echo "Building for production"; else echo "Building for development"; fi
    
    ```
    
- **Importante:** `args` são diferentes de `environment` (que define variáveis de ambiente *dentro do contêiner em tempo de execução*). Variáveis `ARG` só existem durante o processo de construção.

### 4\. `cache_from` (Opcional)

- **Definição:** Especifica uma lista de imagens a serem usadas como cache durante a construção. O Docker tentará usar camadas dessas imagens para acelerar a construção, evitando a reconstrução de camadas idênticas.
- **Uso:** Extremamente útil em pipelines de CI/CD para reutilizar camadas de construções anteriores, reduzindo significativamente o tempo de construção.
- **Sintaxe:**
Para que isso funcione, as imagens referenciadas devem existir no ambiente local do Docker ou serem acessíveis em um registro.
    
    ```yaml
    build:
      context: .
      cache_from:
        - myrepo/myimage:latest
        - anotherrepo/baseimage:1.0
    
    ```
    

### 5\. `labels` (Opcional)

- **Definição:** Adiciona metadados personalizados à imagem construída. Esses metadados são pares chave-valor que podem ser usados para organizar, buscar ou fornecer informações sobre a imagem.
- **Uso:** Útil para adicionar informações como a versão do aplicativo, o autor, a data de construção, ou informações de licença diretamente na imagem.
- **Sintaxe:**
Ou em uma lista:
    
    ```yaml
    build:
      context: .
      labels:
        com.example.vendor: MyCompany
        com.example.version: "1.2.0"
        org.opencontainers.image.source: <https://github.com/myuser/myproject>
    
    ```
    
    ```yaml
    build:
      context: .
      labels:
        - "maintainer=Gedê <gedê@example.com>"
        - "description=Meu Backend Go para o casamento da Ju"
    
    ```
    

### 6\. `network` (Opcional)

- **Definição:** Especifica a rede sob a qual o contêiner será executado durante a fase de **construção**. Isso permite que o processo de construção acesse recursos de rede específicos.
- **Uso:** Crucial se o seu processo de construção precisar baixar dependências ou pacotes de fontes internas ou de uma rede específica que não seja a rede padrão.
- **Sintaxe:**
Você precisaria definir `custom_build_network` na seção `networks` do seu `docker-compose.yml`.
    
    ```yaml
    build:
      context: .
      network: custom_build_network
    
    ```
    

### 7\. `shm_size` (Opcional)

- **Definição:** Define o tamanho da memória compartilhada (`/dev/shm`) disponível para o contêiner **durante o processo de construção**.
- **Uso:** Útil para processos de construção que exigem uma grande quantidade de memória compartilhada, como algumas compilações complexas ou testes que usam navegadores headless.
- **Sintaxe:**
Pode ser em bytes, ou como string com sufixos `b`, `k`, `m`, `g`.
    
    ```yaml
    build:
      context: .
      shm_size: '2g' # 2 Gigabytes
    
    ```
    

### 8\. `target` (Opcional)

- **Definição:** Permite selecionar um estágio específico em um Dockerfile multi-stage para construir a imagem.
- **Uso:** Em Dockerfiles multi-stage, você define vários estágios com a instrução `AS`. O `target` é ideal para criar imagens menores de produção (usando apenas o estágio final com as dependências mínimas) e imagens maiores de desenvolvimento (com ferramentas de depuração e build) a partir do mesmo Dockerfile.
- **Sintaxe:**
No `Dockerfile`:
Com `target: builder_stage`, apenas o primeiro estágio (`builder_stage`) seria construído. Se `target` não for especificado, o Docker construirá o último estágio do Dockerfile.
    
    ```yaml
    build:
      context: .
      dockerfile: Dockerfile
      target: builder_stage # Nome do estágio a ser construído
    
    ```
    
    ```
    # Dockerfile
    FROM node:18-alpine AS builder_stage # Primeiro estágio para build
    WORKDIR /app
    COPY package*.json ./
    RUN npm install
    COPY . .
    RUN npm run build # Compila o frontend
    
    FROM nginx:alpine AS production_stage # Segundo estágio para produção
    COPY --from=builder_stage /app/dist /usr/share/nginx/html
    EXPOSE 80
    CMD ["nginx", "-g", "daemon off;"]
    
    ```
    

---

## Melhores Práticas e Padrões de Uso

Para Gedê, que é desenvolvedor Backend Java e busca Go, estas práticas são essenciais para otimizar suas construções de imagem:

1. **Use `.dockerignore`:**
    - **Propósito:** Semelhante ao `.gitignore`, o `.dockerignore` lista arquivos e diretórios que devem ser **excluídos** do contexto de construção.
    - **Benefício:** Reduz o tamanho do contexto enviado para o daemon Docker (acelerando o build) e evita que arquivos desnecessários (como `.git`, `node_modules` local, logs, `target/` de Java, etc.) sejam copiados para a imagem final, diminuindo seu tamanho.
    - **Exemplo:**
        
        ```
        # .dockerignore
        .git
        .gitignore
        node_modules
        npm-debug.log
        build/
        dist/
        target/ # Para projetos Java/Go
        *.iml
        .DS_Store
        
        ```
        
2. **Aproveite o Cache de Camadas do Docker:**
    - **Como funciona:** O Docker constrói imagens em camadas. Se uma instrução no Dockerfile (e seus arquivos dependentes) não mudou, o Docker reutiliza a camada em cache, acelerando a construção.
    - **Melhor Prática:** Organize seu Dockerfile para que as instruções que mudam com mais frequência (seu código-fonte) venham **depois** das instruções que mudam menos (instalação de dependências, cópia de arquivos de configuração estáticos).
    - **Exemplo (Go):**
        
        ```
        # Dockerfile para Go
        FROM golang:1.22-alpine AS builder
        WORKDIR /app
        COPY go.mod go.sum ./
        RUN go mod download # Esta camada muda menos frequentemente
        COPY . . # Esta camada muda frequentemente (código-fonte)
        RUN CGO_ENABLED=0 GOOS=linux go build -a -o /app/main .
        
        FROM alpine:latest
        WORKDIR /app
        COPY --from=builder /app/main .
        EXPOSE 8080
        CMD ["./main"]
        
        ```
        
3. **Utilize Multi-Stage Builds:**
    - **Propósito:** Permite usar várias imagens base e estágios intermediários no mesmo Dockerfile para otimizar o tamanho da imagem final. Você pode compilar seu código em um estágio e depois copiar apenas o binário compilado para um estágio final muito menor, sem as ferramentas de compilação e dependências de desenvolvimento.
    - **Benefício:** Imagens de produção muito menores, mais seguras e mais rápidas para implantar.
    - **Exemplo (Java - Gedê, isso é para você\!):**
        
        ```
        # Dockerfile para Java com Spring Boot
        FROM eclipse-temurin:17-jdk-alpine AS builder # Estágio de build
        WORKDIR /app
        COPY .mvn/ .mvn
        COPY mvnw pom.xml ./
        RUN ./mvnw dependency:go-offline # Baixa as dependências
        COPY src ./src
        RUN ./mvnw package -DskipTests # Compila a aplicação e cria o JAR
        
        FROM eclipse-temurin:17-jre-alpine # Estágio final (runtime)
        WORKDIR /app
        COPY --from=builder /app/target/*.jar app.jar # Copia apenas o JAR compilado
        ENTRYPOINT ["java", "-jar", "app.jar"]
        
        ```
        
4. **Tagging de Imagens com `image`:**
    - Mesmo usando `build`, você pode especificar uma tag usando o atributo `image`. Isso ajuda a nomear suas imagens locais de forma consistente.
    - `docker-compose.yml`:
        
        ```yaml
        services:
          my-app:
            build: .
            image: gededesign/my-backend:latest # A imagem construída será taggeada assim
        
        ```
        
5. **Reconstrução Forçada com `-build`:**
    - Sempre que você fizer alterações no seu Dockerfile ou nos arquivos que ele copia (e que não seriam detectados pelo cache padrão, como alterações em dependências não copiadas explicitamente), use `docker-compose up --build`. Isso garante que as imagens sejam reconstruídas.
6. **Gerenciamento de Segredos (Build-time):**
    - Para informações realmente sensíveis (senhas, chaves de API) que são necessárias APENAS durante o build e não devem ir para a imagem final, use `docker build --secret` (que não é diretamente suportado por `build` no `docker-compose` nativo, mas pode ser simulado com `compose build` e `DOCKER_BUILDKIT=1`). Para segredos em tempo de execução, use a seção `secrets` do Docker Compose.
    - Para `args`, use apenas informações não-sensíveis ou que podem ser publicamente expostas.

---

## Exemplo Prático Completo: Aplicação Go com Banco de Dados PostgreSQL

Vamos simular uma pequena aplicação backend em Go que se conecta a um banco de dados PostgreSQL.

### Estrutura do Projeto:

```
my-go-app/
├── docker-compose.yml
├── backend/
│   ├── Dockerfile
│   └── main.go
└── data/
    └── .gitkeep # Para manter o diretório de dados do Postgres

```

### 1\. `my-go-app/backend/main.go` (Um Go Backend Simples)

```go
package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"os"

	_ "github.com/lib/pq"
)

func main() {
	dbHost := os.Getenv("DB_HOST")
	dbPort := os.Getenv("DB_PORT")
	dbUser := os.Getenv("DB_USER")
	dbPassword := os.Getenv("DB_PASSWORD")
	dbName := os.Getenv("DB_NAME")

	connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		dbHost, dbPort, dbUser, dbPassword, dbName)

	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatalf("Erro ao conectar ao banco de dados: %v", err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		log.Fatalf("Não foi possível pingar o banco de dados: %v", err)
	}
	fmt.Println("Conexão com o banco de dados PostgreSQL estabelecida com sucesso!")

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Olá, Gedê! Seu backend Go está rodando e conectado ao PostgreSQL!")
	})

	fmt.Println("Servidor Go escutando na porta 8080...")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

```

**Observação:** O Go Backend usa variáveis de ambiente para se conectar ao banco de dados.

### 2\. `my-go-app/backend/Dockerfile` (Dockerfile para o Backend Go)

```
# Dockerfile para o backend Go
# Estágio de build: compila a aplicação Go
FROM golang:1.22-alpine AS builder

WORKDIR /app

# Copia os arquivos de dependência do Go e baixa-os primeiro para usar o cache de camada
COPY go.mod go.sum ./
RUN go mod download

# Copia o código-fonte da aplicação
COPY . .

# Compila a aplicação Go
# CGO_ENABLED=0 desabilita cgo para criar um binário estático
# GOOS=linux garante que o binário seja compilado para Linux
# -a -o /app/main cria um binário executável chamado 'main' no diretório /app
RUN CGO_ENABLED=0 GOOS=linux go build -a -o /app/main .

# Estágio final: imagem de produção leve
FROM alpine:latest

WORKDIR /app

# Copia apenas o binário compilado do estágio 'builder'
COPY --from=builder /app/main .

# Expõe a porta que a aplicação Go escutará
EXPOSE 8080

# Comando para rodar a aplicação quando o contêiner iniciar
CMD ["./main"]

```

**Explicação:**

- Este é um **Dockerfile multi-stage**.
- O primeiro estágio (`builder`) usa `golang:1.22-alpine` para compilar o código Go. Ele baixa as dependências (`go mod download`) e então compila o `main.go` em um executável chamado `main`.
- O segundo estágio (final) usa uma imagem base muito menor (`alpine:latest`) e copia **apenas** o binário `main` do estágio `builder`. Isso resulta em uma imagem de produção muito mais leve, sem as ferramentas de build Go.

### 3\. `my-go-app/docker-compose.yml` (Arquivo Docker Compose)

```yaml
# docker-compose.yml
version: '3.8'

services:
  backend:
    build:
      context: ./backend # O contexto de build é o diretório 'backend'
      dockerfile: Dockerfile # O Dockerfile a ser usado é 'backend/Dockerfile'
      args:
        # Exemplo de um argumento que poderia ser passado no build, embora não usado no Dockerfile Go atual
        BUILD_ENVIRONMENT: development
    image: gededesign/go-backend:latest # A imagem construída será taggeada assim
    ports:
      - "8080:8080" # Mapeia a porta 8080 do host para a porta 8080 do contêiner
    environment:
      # Variáveis de ambiente para o contêiner em tempo de execução
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: user
      DB_PASSWORD: password
      DB_NAME: mydatabase
    depends_on:
      - db # O serviço 'backend' depende do serviço 'db'
    volumes:
      - ./backend:/app # Mapeia o código-fonte para dentro do contêiner (útil para desenvolvimento rápido)

  db:
    image: postgres:13 # Usa uma imagem pré-construída do Docker Hub para o PostgreSQL
    ports:
      - "5432:5432" # Opcional: expõe a porta do DB para acesso externo (para ferramentas como DBeaver)
    environment:
      # Variáveis de ambiente para configurar o PostgreSQL
      POSTGRES_DB: mydatabase
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - db_data:/var/lib/postgresql/data # Mapeia um volume nomeado para persistir os dados do DB

volumes:
  db_data: # Definição do volume nomeado para os dados do PostgreSQL

```

### Como Executar:

1. **Navegue até o diretório `my-go-app` no seu terminal:**
    
    ```bash
    cd my-go-app
    
    ```
    
2. **Inicie os serviços e construa a imagem do backend:**
    
    ```bash
    docker-compose up --build
    
    ```
    
    - O `-build` garante que o Docker Compose reconstruirá a imagem do `backend` (se houver alterações no Dockerfile ou contexto) antes de iniciar o serviço.
    - Você verá a saída do processo de construção da imagem Go e, em seguida, as saídas dos contêineres `backend` e `db`.
3. **Verifique a aplicação:**
Abra seu navegador e acesse `http://localhost:8080`. Você deverá ver a mensagem "Olá, Gedê\! Seu backend Go está rodando e conectado ao PostgreSQL\!".
4. **Parar e remover os serviços:**
    
    ```bash
    docker-compose down
    
    ```
    

Este exemplo demonstra claramente como o atributo `build` é usado para construir sua aplicação Go a partir do Dockerfile, enquanto o serviço de banco de dados (`db`) utiliza uma imagem pré-existente. A persistência de dados é garantida pelo volume nomeado, e as variáveis de ambiente conectam os serviços.

---

## Sugestões para Aprofundamento

Para Gedê e Ju, que estão explorando o mundo de Docker e Go:

- **Docker BuildKit:** Aprofunde-se no BuildKit (`DOCKER_BUILDKIT=1`). Ele oferece recursos avançados como cache aprimorado, paralelismo de build, e a capacidade de usar `-secret` para lidar com segredos de forma segura durante a construção (que pode ser integrado com `docker-compose build` se você estiver usando uma versão mais recente do Compose que suporte BuildKit).
- **Otimização de Dockerfiles:** Explore mais técnicas para otimizar seus Dockerfiles, como a ordem das instruções para aproveitar o cache, usar imagens base Alpine para tamanhos menores, e aprofundar em multi-stage builds.
- **Gerenciamento de Variáveis de Ambiente:** Entenda a diferença e o melhor uso de `build.args` (tempo de construção) versus `environment` (tempo de execução do contêiner) e a chave `env_file` para externalizar variáveis de ambiente.
- **Docker Compose para Produção:** Embora o Docker Compose seja excelente para desenvolvimento, para produção, considere ferramentas como Docker Swarm ou Kubernetes para orquestração de contêineres em escala. Entender as diferenças e a transição é crucial.
- **Redes no Docker Compose:** Aprofunde-se em como as redes funcionam no Docker Compose, especialmente a rede padrão que ele cria, e como definir suas próprias redes personalizadas.

Espero que esta explicação detalhada sobre o atributo `build` no Docker Compose tenha sido útil, Gedê\! Se tiver mais alguma dúvida, A.R.I.A está aqui para ajudar\!