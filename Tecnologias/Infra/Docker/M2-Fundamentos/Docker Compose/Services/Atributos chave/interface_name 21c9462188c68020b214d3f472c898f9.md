# interface_name

**Título da Explicação:** Configuração de `interface_name` em serviços no Docker Compose

---

## Introdução

O Docker Compose é uma ferramenta que permite definir e orquestrar aplicações multicontêiner por meio de um arquivo YAML, no qual cada serviço representa um conjunto de contêineres com configurações idênticas. Nesse contexto, as configurações de rede determinam como esses contêineres se comunicam entre si e com o mundo externo ([docs.docker.com](https://docs.docker.com/reference/compose-file/?utm_source=chatgpt.com)). O atributo `interface_name` surge para dar ao operador controle preciso sobre o nome do dispositivo de rede criado dentro do contêiner ao conectar-se a uma rede específica, garantindo previsibilidade e facilitando depurações em ambientes com múltiplas redes.

---

## Sumário

1. **Conceitos Fundamentais**
2. **Sintaxe Detalhada e Uso Prático**
3. **Cenários de Restrição ou Não Aplicação**
4. **Componentes Chave Associados**
5. **Melhores Práticas e Padrões de Uso**
6. **Exemplo Prático Completo**
7. **Sugestões para Aprofundamento**

---

## 1. Conceitos Fundamentais

O atributo `interface_name` foi introduzido no Docker Compose CLI a partir da versão 2.36.0, permitindo que o nome do dispositivo de rede (por exemplo, `eth0`, `eth1` etc.) seja explicitamente definido quando um serviço se conecta a uma determinada rede. Sem essa configuração, o kernel Linux atribui nomes de forma dinâmica, o que pode variar conforme a ordem de anexação às múltiplas redes, dificultando testes, scripts de monitoramento e a identificação de interfaces em logs de sistema ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).

Em ambientes heterogêneos ou de produção, onde um serviço possa estar ligado a várias redes (por exemplo, uma rede interna de banco de dados e outra pública de front-end), padronizar o nome da interface garante que regras de firewall, QoS ou scripts de inicialização que se baseiam em nomes fixos funcionem corretamente.

---

## 2. Sintaxe Detalhada e Uso Prático

No Compose, a configuração de `interface_name` fica dentro do bloco `services.<nome_do_serviço>.networks.<nome_da_rede>`. Veja a sintaxe básica:

```yaml
services:
  backend:
    image: alpine
    command: ip link show
    networks:
      back-tier:
        interface_name: eth0

```

- **services:** define os serviços da aplicação.
- **networks:** lista as redes às quais o serviço se conecta.
- **<nome_da_rede>:** nome de uma rede declarada no topo ou implícita.
- **interface_name:** nome do dispositivo de rede dentro do contêiner ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).

Você pode combinar `interface_name` com outros atributos estáticos, por exemplo:

```yaml
services:
  frontend:
    image: nginx
    networks:
      front-tier:
        interface_name: eth0
        ipv4_address: 172.16.238.10
      back-tier:
        interface_name: eth1
        ipv6_address: 2001:db8::10

```

Isso gera interfaces `eth0` e `eth1` com endereços IPs específicos, facilitando scripts que verificam conectividade ou filtrar tráfego por interface.

---

## 3. Cenários de Restrição ou Não Aplicação

- **Versões anteriores ao Compose 2.36.0:** ao usar `interface_name` em versões anteriores, o Compose reporta erro de atributo desconhecido ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).
- **`network_mode: host`:** quando um serviço é configurado em modo host, não há criação de namespace de rede separado nem de interfaces virtuais; portanto, `interface_name` não se aplica e sua presença junto a `network_mode` causa erro de validação ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).
- **Drivers de rede não suportados:** alguns drivers (por exemplo, plug-ins de terceiros) podem ignorar ou não oferecer suporte completo à nomeação de interface customizada.
- **Plataformas Windows:** a nomenclatura de interfaces difere (como `Ethernet`, `Ethernet 2`), e o Docker Compose pode não respeitar `interface_name` nesses ambientes.

---

## 4. Componentes Chave Associados

Além de `interface_name`, vários atributos podem ser definidos por rede em cada serviço:

- **`ipv4_address` / `ipv6_address`:** endereços IP estáticos, exigem configuração de `ipam` na definição de rede ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).
- **`link_local_ips`:** lista de IPs link-local gerenciados manualmente, úteis em arquiteturas específicas ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).
- **`mac_address`:** define o endereço MAC por rede, permitindo controle de nível de enlace ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).
- **`gw_priority`:** atribui prioridade para seleção de gateway padrão quando múltiplas redes estão conectadas ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).
- **`priority`:** determina a ordem de anexação das redes, podendo influenciar o nome dos dispositivos se `interface_name` não estiver definido ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).

Esses componentes, em conjunto com `interface_name`, fornecem controle total sobre a configuração de rede dos contêineres.

---

## 5. Melhores Práticas e Padrões de Uso

- **Consistência de nomes:** padronize `interface_name` em toda a aplicação para evitar confusão (por exemplo, sempre usar `eth0` para rede de front-end).
- **Documentação clara:** descreva nas documentações internas o mapeamento entre rede lógica e interface (ex.: “`front-tier` → `eth0`”).
- **Evite duplicidades:** não reutilize o mesmo nome de interface em redes diferentes ao conectar múltiplas redes, para prevenir conflitos de namespace.
- **Valide em ambiente de testes:** teste o Compose em ambiente similar à produção para confirmar suporte do driver de rede e do runtime.
- **Combine com monitoramento:** configure ferramentas de logs e métricas para filtrar dados por interface específica, facilitando diagnóstico de problemas.

---

## 6. Exemplo Prático Completo

```yaml
version: '3.9'

services:
  backend:
    image: alpine
    command: ["sh","-c","ip link show && ping -c3 frontend"]
    networks:
      back-tier:
        interface_name: eth1
        ipv4_address: 172.16.239.11

  frontend:
    image: nginx
    networks:
      front-tier:
        interface_name: eth0
        ipv4_address: 172.16.238.10
      back-tier:
        interface_name: eth2

networks:
  front-tier:
    driver: bridge
    ipam:
      config:
        - subnet: 172.16.238.0/24

  back-tier:
    driver: bridge
    ipam:
      config:
        - subnet: 172.16.239.0/24

```

1. **`backend`** conecta-se à rede `back-tier` via `eth1` e recebe IP estático.
2. **`frontend`** tem duas interfaces: `eth0` em `front-tier` e `eth2` em `back-tier`.
3. As seções de `ipam.config` definem sub-redes compatíveis com os endereços estáticos ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/)).

---

## 7. Sugestões para Aprofundamento

- **Compose Networks top-level element** (para entender driver, IPAM e opções avançadas).
- **Compose Specification no GitHub** (repositório oficial da especificação).
- **Post “Docker Networking Deep Dive”** (blogs e apresentações sobre namespace e drivers).
- **Documentação do kernel Linux** sobre nomeação de interfaces em ambientes de rede virtual.

---

*Referências:*

Compose file reference: Services top-level elements – Docker Docs ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/))

Compose file reference: Services – `interface_name` section ([docs.docker.com](https://docs.docker.com/reference/compose-file/services/))