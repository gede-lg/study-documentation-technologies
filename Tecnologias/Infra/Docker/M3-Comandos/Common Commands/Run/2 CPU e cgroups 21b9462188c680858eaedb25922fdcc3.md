# 2. CPU e cgroups

Os parâmetros de CPU e cgroups permitem controlar o uso de CPU e a vinculação a grupos de controle (cgroups) no host. A seguir, uma análise pormenorizada de cada um:

---

### 2.1 `c`, `-cpu-shares int`

- **Sintaxe**
    
    ```bash
    -c 512
    --cpu-shares=512
    
    ```
    
- **Descrição**
    
    Configura o peso relativo de CPU do contêiner em relação aos demais. O valor padrão é `1024`.
    
- **Conceito de Uso**
    
    Em ambientes com múltiplos contêineres competindo por CPU, **cpu-shares** define um “peso” proporcional. Ex.: um contêiner com 512 shares receberá metade da CPU de outro com 1024, sob contenção.
    
- **Propriedades Internas**
    - Mapeia-se para `cpu.shares` em cgroup v1 ou `cpu.weight` em cgroup v2.
    - No kernel: escala de 2–262144 (cgroup v2); valores fora do intervalo são ajustados ao mínimo/máximo.
- **Exemplo**
    
    ```bash
    docker run -d -c 2048 myapp
    # Dá ao contêiner peso 2048, o dobro da prioridade padrão.
    
    ```
    

---

### 2.2 `-cpus decimal`

- **Sintaxe**
    
    ```bash
    --cpus=1.5
    
    ```
    
- **Descrição**
    
    Limita o número de CPUs virtuais disponíveis ao contêiner. Ex.: `1.5` permite até 1,5 CPU.
    
- **Conceito de Uso**
    
    Simplifica o controle de CPU combinando **cpu-period** e **cpu-quota** internamente. Ideal para garantir que um contêiner não ultrapasse uma fração específica de CPU.
    
- **Propriedades Internas**
    - Calcula internamente:
        
        ```
        cpu-period = 100000 μs
        cpu-quota  = cpus × cpu-period
        
        ```
        
    - Ajusta `HostConfig.CPUPeriod` e `HostConfig.CPUQuota`.
- **Exemplo**
    
    ```bash
    docker run --cpus=0.75 busybox top
    # Limita o busybox a 75% de um CPU.
    
    ```
    

---

### 2.3 `-cpu-period int`

- **Sintaxe**
    
    ```bash
    --cpu-period=100000
    
    ```
    
- **Descrição**
    
    Define o período em microssegundos para o escalonamento (Completely Fair Scheduler) do Linux. O padrão é `100000` μs (0,1 s).
    
- **Conceito de Uso**
    
    Junto com `--cpu-quota`, determina intervalos de janela de CPU. Kubernetes, por exemplo, utiliza `100000` como padrão para uniformidade.
    
- **Propriedades Internas**
    - Mapeado para `cpu.cfs_period_us` no cgroup v1 ou `cpu.max` em cgroup v2 (como parte do parâmetro).
- **Exemplo**
    
    ```bash
    docker run --cpu-period=50000 --cpu-quota=25000 myapp
    # Janela de 50 ms, com 25 ms de CPU alocado.
    
    ```
    

---

### 2.4 `-cpu-quota int`

- **Sintaxe**
    
    ```bash
    --cpu-quota=25000
    
    ```
    
- **Descrição**
    
    Especifica, em microssegundos, quanto tempo de CPU o contêiner pode usar em cada período definido por `--cpu-period`.
    
- **Conceito de Uso**
    
    Controla rigorosamente a quota de CPU. Se `quota < period`, o contêiner será pausado até o próximo período.
    
- **Propriedades Internas**
    - Mapeado para `cpu.cfs_quota_us` em cgroup v1.
    - Em cgroup v2, faz parte de `cpu.max` (`"quota period"`).
- **Exemplo**
    
    ```bash
    docker run --cpu-period=100000 --cpu-quota=50000 redis
    # Permite 50 ms de CPU a cada 100 ms (50% de um CPU).
    
    ```
    

---

### 2.5 `-cpu-rt-period int`

- **Sintaxe**
    
    ```bash
    --cpu-rt-period=950000
    
    ```
    
- **Descrição**
    
    Define, em microssegundos, o período para trabalho real-time (RT). Padrão do kernel é `1000000` μs.
    
- **Conceito de Uso**
    
    Para workloads com requisitos de latência (áudio, vídeo, automação industrial). O RT scheduler permite respostas determinísticas.
    
- **Propriedades Internas**
    - Em cgroup v1: `cpu.rt_period_us`.
    - No v2: dentro de `cpu.rt_runtime_us` e `cpu.rt_period_us` combinados.
- **Exemplo**
    
    ```bash
    docker run --cpu-rt-period=1000000 --cpu-rt-runtime=950000 my-rt-app
    
    ```
    

---

### 2.6 `-cpu-rt-runtime int`

- **Sintaxe**
    
    ```bash
    --cpu-rt-runtime=950000
    
    ```
    
- **Descrição**
    
    Tempo de execução RT (em μs) permitido durante cada período RT (`--cpu-rt-period`).
    
- **Conceito de Uso**
    
    Garante que, por exemplo, em 1 s de janela RT, só 0,95 s sejam dedicados ao contêiner RT, evitando bloqueio de outros processos críticos.
    
- **Propriedades Internas**
    - Mapeado para `cpu.rt_runtime_us` em cgroup v1.
    - Em cgroup v2, parte de `cpu.max` se habilitado RT.
- **Exemplo**
    
    ```bash
    docker run --cpu-rt-period=1000000 --cpu-rt-runtime=900000 audio-processor
    
    ```
    

---

### 2.7 `-cpuset-cpus string`

- **Sintaxe**
    
    ```bash
    --cpuset-cpus="0-3,5"
    
    ```
    
- **Descrição**
    
    Lista de CPUs (por índice) nas quais o contêiner pode ser executado.
    
- **Conceito de Uso**
    
    Fixar contêineres em CPUs específicas reduz cache misses e melhora desempenho em workloads de alta demanda.
    
- **Formato**
    - Intervalos: `0-3`
    - Listas: `0,1,4`
    - Combinações: `0-2,4,6-7`
- **Propriedades Internas**
    - Mapeia para `cpuset.cpus` em cgroup v1 e v2.
- **Exemplo**
    
    ```bash
    docker run --cpuset-cpus="2,4" myapp
    # Restrito às CPUs 2 e 4.
    
    ```
    

---

### 2.8 `-cpuset-mems string`

- **Sintaxe**
    
    ```bash
    --cpuset-mems="0-1"
    
    ```
    
- **Descrição**
    
    Define quais nós de memória (memory nodes) podem ser usados pelo contêiner, em sistemas NUMA.
    
- **Conceito de Uso**
    
    Em hosts NUMA, vincular local de memória junto à CPU reduz latência de acesso à RAM.
    
- **Formato**
    
    Mesmo padrão de ranges e listas de `--cpuset-cpus`.
    
- **Propriedades Internas**
    - Preenche `cpuset.mems` no cgroup.
- **Exemplo**
    
    ```bash
    docker run --cpuset-cpus="0-3" --cpuset-mems="1" myapp
    
    ```
    

---

### 2.9 `-cgroup-parent string`

- **Sintaxe**
    
    ```bash
    --cgroup-parent="/docker.slice/mygroup.slice"
    
    ```
    
- **Descrição**
    
    Especifica o grupo de controle pai sob o qual o contêiner será criado.
    
- **Conceito de Uso**
    
    Organizar contêineres hierarquicamente em cgroups para monitoramento e limites compartilhados.
    
- **Propriedades Internas**
    - Define `HostConfig.CgroupParent`.
    - Docker criará o sub-cgroup `<parent>/<container-id>`.
- **Exemplo**
    
    ```bash
    docker run --cgroup-parent="teamA.slice" nginx
    # Coloca o cgroup do nginx em teamA.slice.
    
    ```
    

---

### 2.10 `-cgroupns string`

- **Sintaxe**
    
    ```bash
    --cgroupns=host
    --cgroupns=private
    
    ```
    
- **Descrição**
    
    Define o namespace de cgroup para o contêiner:
    
    - `host`: compartilha o namespace de cgroups com o host.
    - `private`: isola em um novo namespace de cgroups.
- **Conceito de Uso**
    - **host**: necessário se o contêiner gerencia outros contêineres ou inspeções de cgroup no host.
    - **private**: reforça isolamento, evitando que processos vejam ou modifiquem cgroups fora do próprio contêiner.
- **Propriedades Internas**
    - Configure `CgroupNamespaceMode` em `ContainerCreateRequest`.
- **Exemplo**
    
    ```bash
    docker run --cgroupns=private myapp
    
    ```
    

---

### Observações Finais

- **Valores Padrão**
    - `cpu-period`: 100000 μs
    - `cpu-shares`: 1024
- **Ordem de Precedência**
    - `-cpus` prevalece sobre `-cpu-period`/`-cpu-quota` se ambos configurados.
- **Compatibilidade de cgroup v1 x v2**
    - Docker ajusta nomes e limites conforme o sistema de cgroup do kernel.

Com essas definições e exemplos, você tem um guia completo sobre como limitar e priorizar recursos de CPU via Docker e cgroups. Qualquer dúvida ou cenário específico, me avise!