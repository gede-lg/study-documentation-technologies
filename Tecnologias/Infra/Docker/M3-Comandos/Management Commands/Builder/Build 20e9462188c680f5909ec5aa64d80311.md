# Build

Olá, Gedê! Como A.R.I.A, sua Assistente Rápida, preparei uma explicação completa e bem estruturada sobre o comando `docker buildx build`, que é a ferramenta moderna e mais poderosa para construir imagens Docker.

Vamos detalhar todos os parâmetros que você listou.

### Visão Geral do `docker buildx build`

O `docker buildx build` é uma evolução do comando `docker build` clássico. Ele faz parte do BuildKit, o motor de construção de nova geração do Docker, e oferece vantagens significativas, como:

- **Construção Multi-plataforma:** Criar imagens para diferentes arquiteturas (ex: `linux/amd64` para servidores e `linux/arm64` para Raspberry Pi) a partir de uma única máquina.
- **Gerenciamento de Cache Avançado:** Utilizar caches remotos para acelerar builds em ambientes de CI/CD.
- **Saídas Flexíveis:** Enviar a imagem diretamente para um registro (`-push`), carregá-la no daemon local (`-load`) ou exportá-la como um arquivo (`-output`).
- **Construção Paralela:** Otimizar a construção de stages paralelos no seu Dockerfile.

A sintaxe fundamental é:

```bash
docker buildx build [OPÇÕES] CONTEXTO

```

O `CONTEXTO` é o caminho (`PATH`) para os arquivos da sua aplicação (geralmente `.`), uma URL de um repositório Git, ou `-` para ler o contexto do `stdin`.

---

### Tabela de Parâmetros

A tabela a seguir resume cada parâmetro, sua finalidade e um exemplo prático de uso.

| Parâmetro (Sintaxe) | Finalidade | Exemplo de Uso |
| --- | --- | --- |
| `--add-host strings` | Adiciona uma resolução de nome de host para IP customizada (similar ao arquivo `/etc/hosts`). | `--add-host meu-banco:192.168.1.100` |
| `--allow stringArray` | Permite privilégios extras durante o build, como acesso à rede do host. | `--allow network.host` |
| `--annotation stringArray` | Adiciona anotações (metadata) no padrão OCI à imagem. | `--annotation "com.example.vendor=Gedê Corp"` |
| `--attest stringArray` | Anexa atestados à imagem, como SBOM (Software Bill of Materials) ou proveniência. | `--attest type=sbom` |
| `--build-arg stringArray` | Define variáveis de ambiente que só existem durante o tempo de construção da imagem. | `--build-arg VERSAO_APP=1.2.3` |
| `--build-context stringArray` | Define contextos de build adicionais, útil para usar arquivos de outros locais. | `--build-context frontend=./meu-app-frontend` |
| `--builder string` | Especifica qual instância do construtor `buildx` usar. | `--builder meu-builder-remoto` |
| `--cache-from stringArray` | Especifica fontes de cache externas para acelerar o build. | `--cache-from type=registry,ref=gedelg/minha-app:cache` |
| `--cache-to stringArray` | Exporta o cache do build para um destino, para ser usado em builds futuros. | `--cache-to type=inline` ou `--cache-to type=local,dest=./meu-cache` |
| `--call string` | Modifica a avaliação do build (verificar, delinear, etc.). | `--call=check` |
| `--cgroup-parent string` | Define o cgroup pai para as instruções `RUN` durante o build. | `--cgroup-parent /docker/builds` |
| `--check` | Atalho para `--call=check`, que valida o Dockerfile sem executar o build. | `--check .` |
| `-D, --debug` | Habilita logs detalhados (debug) para a construção. | `--debug` |
| `-f, --file string` | Especifica o nome e caminho do Dockerfile a ser usado. | `-f Dockerfile.prod` |
| `--iidfile string` | Grava o ID da imagem resultante em um arquivo de texto. | `--iidfile ./image_id.txt` |
| `--label stringArray` | Adiciona metadados (labels) à imagem. | `--label "maintainer=Luiz Gustavo <gedelg@email.com>"` |
| `--load` | Atalho para `--output=type=docker`. Carrega a imagem final no daemon local do Docker. | `--load` |
| `--metadata-file string` | Grava os metadados do resultado do build em um arquivo JSON. | `--metadata-file ./build-metadata.json` |
| `--network string` | Define o modo de rede para as instruções `RUN` (`default`, `host`, `none`). | `--network=host` |
| `--no-cache` | Instrui o Docker a não usar o cache de camadas durante a construção. | `--no-cache` |
| `--no-cache-filter stringArray` | Especifica quais estágios (`stages`) do Dockerfile não devem usar o cache. | `--no-cache-filter meu-stage-de-testes` |
| `-o, --output stringArray` | Define o destino da saída do build (ex: local, registro, tarball). | `-o type=local,dest=./output-dir` |
| `--platform stringArray` | Define a(s) plataforma(s) de destino para a imagem (ex: `linux/amd64`, `linux/arm64`). | `--platform linux/amd64,linux/arm64` |
| `--progress string` | Define o tipo de visualização do progresso (`auto`, `plain`, `tty`). `plain` mostra a saída do container. | `--progress=plain` |
| `--provenance string` | Atalho para `--attest=type=provenance`, que registra como a imagem foi construída. | `--provenance=true` |
| `--pull` | Força a atualização (pull) de todas as imagens base referenciadas no Dockerfile. | `--pull` |
| `--push` | Atalho para `--output=type=registry`. Envia a imagem diretamente para o registro após o build. | `--push` |
| `-q, --quiet` | Suprime a maior parte da saída do build, exibindo apenas o ID da imagem em caso de sucesso. | `-q` |
| `--sbom string` | Atalho para `--attest=type=sbom`, para gerar um "Software Bill of Materials". | `--sbom=true` |
| `--secret stringArray` | Expõe segredos (arquivos ou variáveis) ao build de forma segura, sem vazá-los na imagem final. | `--secret id=meutoken,src=./token.txt` |
| `--shm-size bytes` | Define o tamanho da memória compartilhada (`/dev/shm`) para os contêineres de build. | `--shm-size=256m` |
| `--ssh stringArray` | Expõe sockets ou chaves SSH ao build, útil para clonar repositórios privados. | `--ssh default` |
| `-t, --tag stringArray` | Aplica um nome e, opcionalmente, uma tag à imagem no formato `nome:tag`. | `-t gedelg/minha-api:1.0 -t gedelg/minha-api:latest` |
| `--target string` | Define qual estágio (`stage`) de um Dockerfile multi-stage deve ser construído. | `--target builder` |
| `--ulimit ulimit` | Define limites de recursos (ulimit) para os contêineres de build. | `--ulimit nofile=1024:1024` |

---

### Exemplo Prático Combinando Parâmetros

Imagine, Gedê, que você está finalizando sua aplicação em Go e quer construir uma imagem para rodar em servidores comuns (`amd64`) e em dispositivos ARM (`arm64`), enviando-a diretamente para o Docker Hub.

Você poderia usar um comando assim:

```bash
docker buildx build \\
  --platform linux/amd64,linux/arm64 \\
  -t gedelg/minha-app-go:1.0 \\
  -t gedelg/minha-app-go:latest \\
  --build-arg APP_VERSION=1.0 \\
  --cache-from type=registry,ref=gedelg/minha-app-go:buildcache \\
  --cache-to type=registry,ref=gedelg/minha-app-go:buildcache,mode=max \\
  --provenance=true \\
  --push \\
  .

```

Vamos analisar este comando:

- **`-platform linux/amd64,linux/arm64`**: Constrói a imagem para as duas arquiteturas. O Docker cria um "manifesto" que agrupa as duas.
- **`t gedelg/minha-app-go:1.0 -t gedelg/minha-app-go:latest`**: Atribui duas tags à imagem.
- **`-build-arg APP_VERSION=1.0`**: Passa uma variável para o Dockerfile, que poderia ser usada para exibir a versão da sua aplicação.
- **`-cache-from ...`**: Tenta buscar um cache de um build anterior na tag `buildcache` do seu repositório, acelerando o processo.
- **`-cache-to ...`**: Salva o novo cache de build no mesmo local, para que o próximo build seja ainda mais rápido.
- **`-provenance=true`**: Anexa metadados seguros sobre como, quando e onde a imagem foi construída.
- **`-push`**: Em vez de carregar a imagem na sua máquina local, envia o manifesto e as imagens de ambas as plataformas diretamente para o Docker Hub.
- **`.`**: Usa o diretório atual como contexto do build.

Espero que esta explicação detalhada e estruturada ajude você a dominar o `docker buildx build`, Gedê. É uma ferramenta fantástica para otimizar seu fluxo de trabalho como desenvolvedor. Se tiver mais alguma dúvida, é só perguntar!