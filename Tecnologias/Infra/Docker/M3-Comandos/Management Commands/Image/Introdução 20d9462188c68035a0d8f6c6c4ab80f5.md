# Introdução

---

## Introdução

No contexto de conteinerização, o conceito de **imagem Docker** é central para o funcionamento do Docker. A imagem é o blueprint, ou seja, a “receita” que define tudo que um container precisa para funcionar: sistema operacional, dependências, aplicações, arquivos de configuração, scripts e comandos para execução.

Neste material, vamos destrinchar o conceito de imagem Docker, seu funcionamento, ciclo de vida, comandos para gerenciamento via terminal, melhores práticas, limitações e um exemplo prático completo — tudo pensado para formar uma base sólida e atual para atuação profissional.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    - Listar imagens
    - Buscar e baixar imagens
    - Remover imagens
    - Criar e construir imagens com Dockerfile
    - Tagging e versionamento
    - Otimizações e limpeza
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#componentes-chave-associados)
    - Dockerfile (instruções essenciais)
    - Camadas de imagem
    - Repositórios (Docker Hub e registros privados)
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/68465468-f320-8013-b0ec-40c431f3c58f#sugest%C3%B5es-para-aprofundamento)

---

## Conceitos Fundamentais

### O que é uma Imagem Docker?

- **Imagem Docker** é um snapshot imutável (read-only) de um ambiente. Pense nela como uma receita pronta, contendo sistema operacional, app, dependências, configurações, scripts, etc.
- Uma imagem não executa nada por si só. Quando você “roda” uma imagem, você na verdade está criando um **container** (um processo isolado, efêmero e customizável a partir da imagem).

### Por que são importantes?

- **Portabilidade**: A imagem é independente do sistema operacional host. “Funciona na minha máquina” vira realidade.
- **Reprodutibilidade**: Cada container criado a partir de uma mesma imagem terá exatamente o mesmo ambiente.
- **Distribuição**: Imagens podem ser publicadas, baixadas e reutilizadas via Docker Hub ou registros privados.

---

## Sintaxe Detalhada e Uso Prático

### Listando Imagens Locais

```
docker images
docker image ls

```

Mostra as imagens armazenadas localmente, com informações como `REPOSITORY`, `TAG`, `IMAGE ID`, `CREATED`, `SIZE`.

---

### Buscando e Baixando Imagens

### Buscar imagens no Docker Hub

```
docker search <nome-da-imagem>
# Exemplo: docker search nginx

```

### Baixar (pull) uma imagem

```
docker pull <repositório>:<tag>
# Exemplo: docker pull nginx:latest

```

Se a tag não for especificada, o padrão é `latest`.

---

### Remover Imagens

```
docker rmi <image_id ou repositório:tag>
# Exemplo: docker rmi nginx:latest

```

- Para remover múltiplas imagens:
    
    ```
    docker rmi $(docker images -q)
    
    ```
    

---

### Criar e Construir Imagens com Dockerfile

### O que é Dockerfile?

Arquivo texto com instruções sequenciais para montar uma imagem personalizada.

### Estrutura básica:

```
# Exemplo de Dockerfile
FROM openjdk:17-jdk-alpine
WORKDIR /app
COPY . .
RUN ./gradlew build
CMD ["java", "-jar", "build/libs/app.jar"]

```

### Construindo a imagem:

```
docker build -t meuapp:1.0 .

```

- O `t` permite definir o nome e a tag (ex: `meuapp:1.0`).
- O `.` indica o diretório do Dockerfile.

---

### Rodando Containers a partir de Imagens

```
docker run -it --rm --name container_teste meuapp:1.0

```

- O comando acima instancia um container da imagem `meuapp:1.0`.
- Flags:
    - `it`: interação com terminal
    - `-rm`: remove o container após finalização
    - `-name`: nome customizado do container

---

### Tagging e Versionamento

```
docker tag meuapp:1.0 registry.meudominio.com.br/meuapp:1.0

```

- Permite renomear, versionar e preparar para envio a outros registros.

---

### Otimização e Limpeza

- **Remover imagens não usadas:**
    
    ```
    docker image prune
    docker image prune -a  # Remove todas as imagens não referenciadas
    
    ```
    
- **Limpar tudo (imagens, containers, volumes):**
    
    ```
    docker system prune
    
    ```
    

---

## Cenários de Restrição ou Não Aplicação

- **Ambientes extremamente restritos em disco**: Imagens podem crescer bastante se não otimizadas.
- **Necessidade de customização dinâmica**: Se precisar mudar muitas configurações em tempo de execução, pode ser melhor usar *volumes* ou variáveis de ambiente do que rebuildar imagens.
- **Softwares com licenças restritas**: Nem tudo pode ser distribuído em imagem Docker (licenciamento).

---

## Componentes Chave Associados

### 1. **Dockerfile (instruções essenciais)**

- **FROM**: Base da imagem (ex: FROM ubuntu:22.04)
- **RUN**: Executa comandos na construção (ex: instalar dependências)
- **COPY/ADD**: Copia arquivos para a imagem
- **WORKDIR**: Define diretório de trabalho padrão
- **CMD/ENTRYPOINT**: Comando executado no container
- **EXPOSE**: Porta que o app “abre” no container
- **ENV**: Define variáveis de ambiente

### 2. **Camadas de Imagem**

- Cada instrução no Dockerfile cria uma camada (layer) — camadas podem ser cacheadas, acelerando builds e economizando espaço.
- Camadas inferiores raramente mudam (ex: sistema base), superiores mudam com mais frequência (app, configs).

### 3. **Repositórios de Imagens**

- **Docker Hub**: Público, gratuito, fácil de usar.
- **Registros privados**: Para ambientes empresariais, segurança, controle de acesso.

---

## Melhores Práticas e Padrões de Uso

- **Sempre fixe versões de base** (`FROM node:18-alpine` e não apenas `node:latest`)
- **Mantenha imagens enxutas**: Utilize imagens slim/alpine, limpe cache de pacotes (ex: `RUN apt-get clean`).
- **Multi-stage builds**: Separe etapas de build (compilar) e runtime para imagens menores.
- **Ignore arquivos desnecessários** usando `.dockerignore`.
- **Tagueie versões e mantenha controle de releases**.
- **Evite copiar arquivos sensíveis para a imagem**.
- **Utilize variáveis de ambiente para configurações dinâmicas**.

---

## Exemplo Prático Completo

### Objetivo: Construir uma imagem para um app Java (Spring Boot), rodar um container, versionar e limpar.

### 1. Estrutura do Projeto

```
meuapp/
  ├── src/
  ├── build/libs/app.jar
  └── Dockerfile

```

### 2. Dockerfile Exemplo

```
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY build/libs/app.jar .
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]

```

### 3. Construir a imagem

```
docker build -t meuapp:1.0 .

```

### 4. Rodar um container

```
docker run -d -p 8080:8080 --name container_meuapp meuapp:1.0

```

- `d`: modo detached (background)
- `p`: mapeamento de portas

### 5. Taggear para registro privado

```
docker tag meuapp:1.0 registry.empresa.com.br/meuapp:1.0

```

### 6. Enviar para o registro

```
docker push registry.empresa.com.br/meuapp:1.0

```

### 7. Limpar imagens não usadas

```
docker image prune -a

```

---

## Sugestões para Aprofundamento

- **Multi-stage builds**: [Documentação Oficial](https://docs.docker.com/build/building/multi-stage/)
- **Imagens mínimas (Alpine Linux)**: Estude como usar o Alpine para apps leves.
- **Security Best Practices**: [Docker Security Best Practices](https://docs.docker.com/engine/security/security/)
- **Docker Compose**: Orquestração de múltiplos containers
- **Repositórios privados e autenticação**
- **CI/CD com Docker**: Integração contínua usando imagens Docker
- **Ferramentas para scan de vulnerabilidades** (ex: Trivy, Snyk)

---

## Resumo Final

Imagens Docker são o alicerce do ecossistema de containers, trazendo reprodutibilidade, portabilidade e automação para o desenvolvimento e deploy de aplicações modernas. Dominar a criação, uso, otimização e gerenciamento de imagens via terminal é fundamental para qualquer desenvolvedor que atue com infraestrutura moderna.

---

Se quiser exemplos mais avançados, comparações com outras tecnologias ou um estudo de impacto na performance, é só pedir!