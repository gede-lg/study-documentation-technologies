# Closures (Clausuras)

## Introdução

As **closures** são um conceito fundamental em JavaScript que permitem que funções internas "lembrem" e acessem o escopo externo mesmo após a função externa ter sido executada. Esse mecanismo é essencial para criar padrões de design poderosos, gerenciar estados privados e implementar funcionalidades avançadas em aplicações JavaScript.

Este módulo visa fornecer uma compreensão completa de closures, abordando desde sua definição até aplicações práticas, garantindo que você possa utilizá-las de forma eficaz em seus projetos.

---

## Sumário

1. [O Que São Closures?](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#o-que-s%C3%A3o-closures)
2. [Como Funcionam as Closures](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#como-funcionam-as-closures)
3. [Criando Closures em JavaScript](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#criando-closures-em-javascript)
4. [Usos Práticos de Closures](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#usos-pr%C3%A1ticos-de-closures)
    - [Encapsulamento de Dados](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#encapsulamento-de-dados)
    - [Funções Geradoras de Valores](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#fun%C3%A7%C3%B5es-geradoras-de-valores)
    - [Memoization](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#memoization)
    - [Implementação de Padrões de Projeto](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#implementa%C3%A7%C3%A3o-de-padr%C3%B5es-de-projeto)
5. [Closures e o Gerenciamento de Memória](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#closures-e-o-gerenciamento-de-mem%C3%B3ria)
6. [Boas Práticas com Closures](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#boas-pr%C3%A1ticas-com-closures)
7. [Problemas Comuns e Como Evitá-los](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#problemas-comuns-e-como-evit%C3%A1-los)
8. [Exemplos de Código](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#exemplos-de-c%C3%B3digo)
9. [Referências para Estudo Independente](https://chatgpt.com/c/6782e6b2-a3b8-8003-9ce5-4e879f5da7e1?model=o1-mini#refer%C3%AAncias-para-estudo-independente)

---

## O Que São Closures?

**Closure**, ou *clausura* em português, é uma característica das linguagens de programação que permite que uma função tenha acesso às variáveis do escopo onde ela foi criada, mesmo quando essa função é executada em um contexto diferente.

Em outras palavras, uma closure dá a uma função acesso às variáveis do seu escopo léxico, mesmo após a função externa ter finalizado sua execução.

### Conceitos Relacionados

- **Escopo Léxico**: Refiere-se à estrutura de escopo que determina onde as variáveis são acessíveis no código, com base na posição de declaração.
- **Funções Aninhadas**: Funções declaradas dentro de outras funções.

---

## Como Funcionam as Closures

Para entender closures, é essencial compreender como o JavaScript gerencia o escopo e o tempo de vida das variáveis.

### Escopo e Tempo de Vida

- **Escopo de Função**: Variáveis declaradas dentro de uma função são acessíveis apenas dentro dessa função e suas funções internas.
- **Tempo de Vida das Variáveis**: Variáveis dentro de uma função são criadas quando a função é invocada e destruídas quando a execução da função é concluída. No entanto, closures permitem que algumas dessas variáveis sobrevivam além do ciclo de vida original.

### Mecanismo das Closures

Quando uma função interna é criada dentro de uma função externa, ela captura referências às variáveis da função externa. Mesmo após a função externa ter sido executada, a função interna mantém acesso a essas variáveis, formando uma closure.

---

## Criando Closures em JavaScript

A criação de closures em JavaScript é simples e ocorre automaticamente quando uma função interna é definida dentro de uma função externa.

### Exemplo Básico

```jsx
function saudacao(nome) {
  const mensagem = `Olá, ${nome}!`;

  function exibirMensagem() {
    console.log(mensagem);
  }

  return exibirMensagem;
}

const saudacaoJoao = saudacao("João");
saudacaoJoao(); // Output: "Olá, João!"

```

**Explicação:**

1. A função `saudacao` recebe um parâmetro `nome` e define uma variável `mensagem`.
2. Dentro de `saudacao`, há uma função interna `exibirMensagem` que acessa a variável `mensagem`.
3. A função `saudacao` retorna a função `exibirMensagem`.
4. Mesmo após `saudacao` ser executada, a função retornada `saudacaoJoao` ainda tem acesso à variável `mensagem` devido à closure.

---

## Usos Práticos de Closures

Closures são amplamente utilizadas em JavaScript para diversas finalidades. A seguir, destacamos alguns dos usos mais comuns:

### Encapsulamento de Dados

Closures permitem simular variáveis privadas, restringindo o acesso direto a determinadas variáveis e expondo apenas as funções necessárias para interagir com esses dados.

**Exemplo:**

```jsx
function criarContador() {
  let contador = 0; // Variável privada

  return {
    incrementar: function() {
      contador++;
      console.log(contador);
    },
    resetar: function() {
      contador = 0;
      console.log(contador);
    }
  };
}

const meuContador = criarContador();
meuContador.incrementar(); // Output: 1
meuContador.incrementar(); // Output: 2
meuContador.resetar();     // Output: 0

```

**Explicação:**

- A variável `contador` não é acessível diretamente de fora da função `criarContador`.
- Apenas as funções `incrementar` e `resetar` têm acesso a `contador` por meio da closure.

### Funções Geradoras de Valores

Closures permitem criar funções que geram valores dinâmicos com base em estados internos.

**Exemplo:**

```jsx
function gerarID() {
  let id = 0;

  return function() {
    id++;
    return id;
  };
}

const obterID = gerarID();
console.log(obterID()); // 1
console.log(obterID()); // 2
console.log(obterID()); // 3

```

### Memoization

Memoization é uma técnica de otimização que armazena os resultados de funções caras para evitar recomputações desnecessárias. Closures são essenciais para implementar memoization.

**Exemplo:**

```jsx
function memoizar(func) {
  const cache = {};

  return function(...args) {
    const chave = JSON.stringify(args);
    if (cache[chave]) {
      return cache[chave];
    } else {
      const resultado = func(...args);
      cache[chave] = resultado;
      return resultado;
    }
  };
}

const calcularFatorial = memoizar(function(n) {
  if (n === 0) return 1;
  return n * calcularFatorial(n - 1);
});

console.log(calcularFatorial(5)); // 120
console.log(calcularFatorial(6)); // 720 (usa resultado anterior para otimizar)

```

### Implementação de Padrões de Projeto

Closures são fundamentais para implementar diversos padrões de projeto em JavaScript, como o *Module Pattern*, *Factory Pattern*, entre outros.

**Exemplo - Module Pattern:**

```jsx
const modulo = (function() {
  let privado = "Valor Privado";

  function metodoPrivado() {
    console.log(privado);
  }

  return {
    metodoPublico: function() {
      metodoPrivado();
    }
  };
})();

modulo.metodoPublico(); // Output: "Valor Privado"

```

---

## Closures e o Gerenciamento de Memória

Embora as closures sejam ferramentas poderosas, elas podem levar a problemas de gerenciamento de memória se não forem usadas com cuidado. Variáveis capturadas por closures permanecem na memória enquanto a função de closure estiver acessível, o que pode resultar em **memory leaks** (vazamentos de memória) se funções de closure forem criadas em excesso ou mantidas desnecessariamente.

**Boas Práticas:**

- Evite criar closures dentro de loops quando não for necessário.
- Garanta que funções de closure não mantenham referências a objetos que já não são necessários.

---

## Boas Práticas com Closures

1. **Mantenha o Escopo Limpo:**
    - Evite capturar mais variáveis do que o necessário na closure.
    - Declare variáveis apenas onde são necessárias para reduzir o uso de memória.
2. **Evite Excessos em Loops:**
    - Tenha cuidado ao criar closures dentro de loops para evitar a criação de múltiplas instâncias desnecessárias.
3. **Use Closures para Encapsulamento:**
    - Utilize closures para proteger dados sensíveis e expor apenas o que for necessário.
4. **Documente o Uso de Closures:**
    - Comentários claros sobre quais variáveis são capturadas ajudam na manutenção do código.

---

## Problemas Comuns e Como Evitá-los

1. **Closures e Loops:**
    
    **Problema:**
    
    Um erro comum ocorre ao criar closures dentro de loops usando `var`, resultando em todas as closures compartilhando a mesma variável.
    
    **Exemplo Errado:**
    
    ```jsx
    for (var i = 0; i < 3; i++) {
      setTimeout(function() {
        console.log(i);
      }, 1000);
    }
    // Output após 1 segundo: 3, 3, 3
    
    ```
    
    **Solução:**
    
    Use `let` para declarar a variável de loop, garantindo um escopo de bloco para cada iteração.
    
    ```jsx
    for (let i = 0; i < 3; i++) {
      setTimeout(function() {
        console.log(i);
      }, 1000);
    }
    // Output após 1 segundo: 0, 1, 2
    
    ```
    
2. **Vazamentos de Memória:**
    
    **Problema:**
    
    Manter referências desnecessárias a closures pode impedir que o coletor de lixo libere memória, levando a vazamentos.
    
    **Solução:**
    
    - Elimine referências a closures quando não forem mais necessárias.
    - Evite armazenar closures em estruturas de dados de longo prazo, a menos que necessário.
3. **Confusão com `this` em Closures:**
    
    **Problema:**
    
    Dentro de uma closure, o valor de `this` pode não ser o esperado, especialmente em funções de callback.
    
    **Solução:**
    
    Use arrow functions para preservar o contexto de `this`, ou utilize métodos como `bind`, `call` ou `apply` para definir explicitamente o contexto.
    
    ```jsx
    function Pessoa(nome) {
      this.nome = nome;
    
      // Usando arrow function para preservar 'this'
      setTimeout(() => {
        console.log(`Olá, meu nome é ${this.nome}`);
      }, 1000);
    }
    
    const joao = new Pessoa("João"); // Output após 1 segundo: "Olá, meu nome é João"
    
    ```
    

---

## Exemplos de Código

### Exemplo 1: Encapsulamento de Dados

```jsx
function criarBanco() {
  let saldo = 0;

  return {
    depositar: function(valor) {
      if (valor > 0) {
        saldo += valor;
        console.log(`Depositado: R$${valor}. Saldo Atual: R$${saldo}`);
      }
    },
    sacar: function(valor) {
      if (valor > 0 && valor <= saldo) {
        saldo -= valor;
        console.log(`Sacado: R$${valor}. Saldo Atual: R$${saldo}`);
      } else {
        console.log("Saldo insuficiente.");
      }
    },
    obterSaldo: function() {
      console.log(`Saldo Atual: R$${saldo}`);
    }
  };
}

const meuBanco = criarBanco();
meuBanco.depositar(100);  // Depositado: R$100. Saldo Atual: R$100
meuBanco.sacar(50);       // Sacado: R$50. Saldo Atual: R$50
meuBanco.obterSaldo();    // Saldo Atual: R$50

```

### Exemplo 2: Memoization de Função

```jsx
function memoizarSoma() {
  const cache = {};

  return function(a, b) {
    const chave = `${a},${b}`;
    if (cache[chave]) {
      console.log("Retornando do cache.");
      return cache[chave];
    } else {
      console.log("Calculando soma.");
      const resultado = a + b;
      cache[chave] = resultado;
      return resultado;
    }
  };
}

const soma = memoizarSoma();

console.log(soma(2, 3)); // Calculando soma. \n 5
console.log(soma(2, 3)); // Retornando do cache. \n 5
console.log(soma(4, 5)); // Calculando soma. \n 9
console.log(soma(2, 3)); // Retornando do cache. \n 5

```

### Exemplo 3: Função Geradora de IDs

```jsx
function gerarID() {
  let id = 0;

  return function() {
    id++;
    return id;
  };
}

const novoID = gerarID();

console.log(novoID()); // 1
console.log(novoID()); // 2
console.log(novoID()); // 3

```

---

## Referências para Estudo Independente

Para aprofundar seu entendimento sobre closures e outros conceitos avançados de JavaScript, consulte os seguintes recursos:

1. **Documentação Oficial do MDN:**
    - [Closures em JavaScript](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Closures)
    - [Escopo Léxico](https://developer.mozilla.org/pt-BR/docs/Glossary/Closure)
2. **Livros:**
    - *"You Don't Know JS: Scope & Closures"* por Kyle Simpson
    - *"JavaScript: The Good Parts"* por Douglas Crockford
3. **Cursos Online:**
    - [JavaScript Closures - Udemy](https://www.udemy.com/course/closures-javascript/)
    - [Closures Explained - freeCodeCamp](https://www.freecodecamp.org/news/closures-in-javascript/)
4. **Artigos e Tutoriais:**
    - [Understanding JavaScript Closures - CSS-Tricks](https://css-tricks.com/understanding-javascript-closures/)
    - [JavaScript Closures - Tutorialspoint](https://www.tutorialspoint.com/javascript/javascript_closures.htm)
5. **Vídeos:**
    - [Closures in JavaScript - Fun Fun Function](https://www.youtube.com/watch?v=1JsJx1x35c0)
    - [JavaScript Closures Explained - Academind](https://www.youtube.com/watch?v=1IsU_MdJspM)
6. **Exercícios Práticos:**
    - [Exercícios de Closures - Exercism](https://exercism.org/tracks/javascript/exercises/closure)
    - [Closures Challenges - Codewars](https://www.codewars.com/kata/search/javascript?q=closures)

---

## Conclusão

Closures são uma ferramenta poderosa em JavaScript que permitem a criação de funções com acesso a um escopo externo, mesmo após a execução da função externa. Compreender e dominar closures é essencial para escrever código JavaScript eficiente, modular e seguro. Ao aplicar closures de forma adequada, você pode criar padrões de design robustos, gerenciar estados de maneira eficaz e otimizar o desempenho de suas aplicações.