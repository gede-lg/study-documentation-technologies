# Axios

---

## Introdução

No mundo do desenvolvimento web moderno, a comunicação entre o cliente (navegador ou aplicativo) e o servidor é fundamental. Essa comunicação geralmente ocorre por meio de **requisições HTTP**, que permitem enviar e receber dados. Para simplificar e padronizar essa tarefa em JavaScript, surgem bibliotecas como o **Axios**. Ele se tornou uma das ferramentas mais populares para lidar com requisições HTTP assíncronas, tanto em navegadores quanto em ambientes Node.js, oferecendo uma API intuitiva e recursos robustos.

---

## Sumário

Esta explicação detalhará o Axios, uma biblioteca JavaScript para fazer requisições HTTP. Abordaremos seus conceitos fundamentais, a sintaxe básica e avançada, todos os seus métodos e propriedades, cenários de uso e restrições, elementos associados, melhores práticas e exemplos completos. O objetivo é fornecer um guia compreensivo para você dominar o uso do Axios em seus projetos.

---

## Conceitos Fundamentais

O **Axios** é um **cliente HTTP** baseado em **Promises** para o navegador e Node.js. Isso significa que ele facilita a comunicação com APIs RESTful ou quaisquer outros endpoints HTTP, retornando Promises que permitem um tratamento assíncrono e encadeado de requisições e respostas.

Seu propósito principal é **simplificar a realização de requisições HTTP**, abstraindo a complexidade da API `XMLHttpRequest` nativa do navegador (ou do módulo `http` do Node.js) e oferecendo uma interface mais limpa e poderosa.

### Por que usar Axios?

- **API Simples e Intuitiva:** Facilita a escrita de código para requisições HTTP.
- **Baseado em Promises:** Oferece uma maneira mais moderna e legível de lidar com operações assíncronas, permitindo usar `async/await` para um código síncrono mais fácil de ler.
- **Transformação Automática de Dados:** Transforma automaticamente dados JSON para objetos JavaScript (e vice-versa).
- **Cancelamento de Requisições:** Permite cancelar requisições em andamento.
- **Interceptors (Interceptadores):** Possibilita interceptar requisições ou respostas antes de serem tratadas, ideal para adicionar cabeçalhos de autenticação ou lidar com erros globais.
- **Tratamento de Erros:** Oferece um tratamento de erros mais robusto e fácil de usar.
- **Suporte a Tipagem (TypeScript):** Possui tipagem definida para projetos TypeScript.

---

## Sintaxe e Uso

### Instalação

Antes de usar o Axios, você precisa instalá-lo.

**Via npm:**

```bash
npm install axios

```

**Via yarn:**

```bash
yarn add axios

```

**Via CDN (para uso em navegadores, sem um bundler como Webpack/Vite):**

```html
<script src="<https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js>"></script>

```

### Importação

Após a instalação, você pode importá-lo em seu projeto JavaScript:

```jsx
import axios from 'axios';

```

### Sintaxe Básica (GET, POST)

A forma mais comum de usar o Axios é com os métodos de atalho para os verbos HTTP.

```jsx
// Exemplo 1: Requisição GET básica para buscar dados
axios.get('/user?ID=12345')
  .then(function (response) {
    // Manipula o sucesso da requisição
    console.log(response.data); // Os dados da resposta estão em response.data
    console.log(response.status); // Código de status HTTP (ex: 200)
    console.log(response.statusText); // Mensagem do status (ex: 'OK')
    console.log(response.headers); // Cabeçalhos da resposta
    console.log(response.config); // Configurações da requisição original
  })
  .catch(function (error) {
    // Manipula erros da requisição
    if (error.response) {
      // O servidor respondeu com um status diferente de 2xx
      console.error("Erro na resposta do servidor:", error.response.data);
      console.error("Status:", error.response.status);
      console.error("Cabeçalhos:", error.response.headers);
    } else if (error.request) {
      // A requisição foi feita, mas não houve resposta
      console.error("Nenhuma resposta recebida:", error.request);
    } else {
      // Algo aconteceu na configuração da requisição que disparou um erro
      console.error("Erro na configuração da requisição:", error.message);
    }
    console.error("Config da requisição:", error.config);
  })
  .finally(function () {
    // Sempre será executado, independentemente do sucesso ou falha
    console.log("Requisição GET finalizada.");
  });

// Exemplo 2: Requisição POST básica para enviar dados
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response.data);
  })
  .catch(function (error) {
    console.error("Erro ao criar usuário:", error);
  });

```

### Sintaxe Avançada (Configurações e `async/await`)

Você pode passar um objeto de configuração para o Axios para maior controle sobre a requisição. Usar `async/await` com Axios é uma prática comum para tornar o código assíncrono mais legível, parecendo síncrono.

```jsx
// Exemplo 3: Requisição GET com configurações e async/await
async function getUserData(userId) {
  try {
    const response = await axios.get(`/user/${userId}`, {
      // Configurações adicionais
      params: {
        // Parâmetros de query string
        _limit: 1 // Exemplo: limita a quantidade de resultados
      },
      headers: {
        'Authorization': 'Bearer meu_token_de_autenticacao',
        'Custom-Header': 'ValorPersonalizado'
      },
      timeout: 5000, // Tempo limite de 5 segundos para a requisição
      responseType: 'json' // Tipo de resposta esperado (pode ser 'json', 'text', 'blob', 'arraybuffer', 'document')
    });
    console.log("Dados do usuário:", response.data);
    return response.data;
  } catch (error) {
    console.error("Erro ao buscar dados do usuário:", error);
    throw error; // Propaga o erro para quem chamou a função
  }
}

getUserData(12345);

// Exemplo 4: Requisição POST com configurações e async/await
async function createUser(userData) {
  try {
    const response = await axios.post('/users', userData, {
      headers: {
        'Content-Type': 'application/json' // Definindo o tipo de conteúdo do corpo da requisição
      }
    });
    console.log("Usuário criado com sucesso:", response.data);
    return response.data;
  } catch (error) {
    console.error("Erro ao criar usuário:", error);
    throw error;
  }
}

createUser({ name: 'Gedê', email: 'gede@example.com' });

```

---

## Métodos e Propriedades

O Axios oferece uma variedade de métodos para cada tipo de requisição HTTP e algumas propriedades para configurações avançadas.

### Métodos Principais (Verbos HTTP)

Todos esses métodos retornam uma **Promise**.

- `axios.request(config)`: O método mais genérico. Aceita um objeto de configuração completo para a requisição.
    
    ```jsx
    axios.request({
      method: 'post',
      url: '/user',
      data: {
        firstName: 'Fred'
      }
    });
    
    ```
    
- `axios.get(url[, config])`: Faz uma requisição GET.
    
    ```jsx
    axios.get('/user', { params: { ID: 12345 } });
    
    ```
    
- `axios.delete(url[, config])`: Faz uma requisição DELETE.
    
    ```jsx
    axios.delete('/user/123');
    
    ```
    
- `axios.head(url[, config])`: Faz uma requisição HEAD (similar ao GET, mas sem o corpo da resposta).
    
    ```jsx
    axios.head('/user/123');
    
    ```
    
- `axios.options(url[, config])`: Faz uma requisição OPTIONS (usado para verificar opções de comunicação de um servidor).
    
    ```jsx
    axios.options('/user/123');
    
    ```
    
- `axios.post(url[, data[, config]])`: Faz uma requisição POST.
    
    ```jsx
    axios.post('/user', { firstName: 'Fred' });
    
    ```
    
- `axios.put(url[, data[, config]])`: Faz uma requisição PUT (substitui completamente um recurso).
    
    ```jsx
    axios.put('/user/123', { id: 123, name: 'Novo Nome' });
    
    ```
    
- `axios.patch(url[, data[, config]])`: Faz uma requisição PATCH (atualiza parcialmente um recurso).
    
    ```jsx
    axios.patch('/user/123', { name: 'Nome Atualizado' });
    
    ```
    

### Métodos Auxiliares

- `axios.all(iterable)`: Recebe um array de Promises (geralmente requisições Axios) e retorna uma única Promise que resolve quando todas as Promises no array forem resolvidas. Se alguma Promise falhar, a Promise resultante falha. Similar a `Promise.all()`.
    
    ```jsx
    function getUserAccount() {
      return axios.get('/user/123');
    }
    
    function getUserPermissions() {
      return axios.get('/permissions/123');
    }
    
    axios.all([getUserAccount(), getUserPermissions()])
      .then(axios.spread(function (account, permissions) {
        // Ambas as requisições foram completas com sucesso
        console.log("Conta:", account.data);
        console.log("Permissões:", permissions.data);
      }))
      .catch(error => {
        console.error("Erro em uma das requisições:", error);
      });
    
    ```
    
- `axios.spread(callback)`: Usado em conjunto com `axios.all()`. Permite que você passe argumentos de um array de respostas (o resultado de `axios.all`) para uma função de callback como argumentos individuais, em vez de um único array.
    
    ```jsx
    // Exemplo acima já demonstra o uso de axios.spread
    
    ```
    

### Propriedades e Métodos de Instância (Criando uma Instância do Axios)

Você pode criar uma instância personalizada do Axios com configurações padrão para não precisar repeti-las em cada requisição.

- `axios.create([config])`: Cria uma nova instância do Axios com uma configuração padrão. Útil para APIs diferentes ou para adicionar interceptadores específicos.
    
    ```jsx
    const api = axios.create({
      baseURL: '<https://api.example.com>',
      timeout: 10000, // 10 segundos
      headers: { 'X-Custom-Header': 'foobar' }
    });
    
    // Agora você pode usar 'api' como se fosse 'axios'
    api.get('/users/1').then(response => console.log(response.data));
    
    ```
    

Os métodos (`get`, `post`, `delete`, etc.) e propriedades (`defaults`, `interceptors`) que você usa diretamente em `axios` também estão disponíveis nas instâncias criadas com `axios.create()`.

### Propriedades de Configuração Global (`axios.defaults`)

- `axios.defaults`: Um objeto que contém as configurações padrão que serão aplicadas a todas as requisições Axios, a menos que sejam sobrescritas em uma requisição específica.
    
    ```jsx
    axios.defaults.baseURL = '<https://api.meusite.com>';
    axios.defaults.headers.common['Authorization'] = 'AUTH_TOKEN_PADRAO';
    axios.defaults.headers.post['Content-Type'] = 'application/json';
    
    // Agora, todas as requisições usarão esses padrões
    axios.get('/products');
    
    ```
    

### Interceptadores (`axios.interceptors`)

Os interceptadores permitem que você intercepte requisições ou respostas antes que elas sejam tratadas pelo `then` ou `catch`. São extremamente úteis para tarefas como adicionar tokens de autenticação, logar requisições, tratar erros globais, etc.

- `axios.interceptors.request.use(fulfilledCallback, rejectedCallback)`: Adiciona um interceptor para requisições. O `fulfilledCallback` é executado antes da requisição ser enviada; o `rejectedCallback` é executado se houver um erro na fase de configuração da requisição.
    
    ```jsx
    // Adiciona um interceptor de requisição
    axios.interceptors.request.use(function (config) {
        // Faça algo antes da requisição ser enviada
        console.log('Requisição enviada:', config.url);
        // Exemplo: Adicionar um token de autenticação
        const token = localStorage.getItem('authToken');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config; // É crucial retornar a configuração modificada
      }, function (error) {
        // Faça algo com erro de requisição
        return Promise.reject(error);
      });
    
    ```
    
- `axios.interceptors.response.use(fulfilledCallback, rejectedCallback)`: Adiciona um interceptor para respostas. O `fulfilledCallback` é executado quando uma resposta é recebida com sucesso; o `rejectedCallback` é executado se a resposta for um erro (status 4xx ou 5xx).
    
    ```jsx
    // Adiciona um interceptor de resposta
    axios.interceptors.response.use(function (response) {
        // Qualquer código de status que esteja no range de 2xx faz com que esta função seja acionada
        console.log('Resposta recebida:', response.status);
        return response; // É crucial retornar a resposta
      }, function (error) {
        // Qualquer código de status que não esteja no range de 2xx faz com que esta função seja acionada
        // Faça algo com erro de resposta
        if (error.response && error.response.status === 401) {
          console.error("Não autorizado! Redirecionando para login...");
          // Exemplo: Redirecionar para página de login
          // window.location.href = '/login';
        }
        return Promise.reject(error);
      });
    
    ```
    
- `axios.interceptors.request.eject(interceptorId)` / `axios.interceptors.response.eject(interceptorId)`: Remove um interceptor. O `interceptorId` é o valor retornado por `use()`.
    
    ```jsx
    const myRequestInterceptor = axios.interceptors.request.use(function (config) {
      // ...
    });
    
    // Para remover:
    axios.interceptors.request.eject(myRequestInterceptor);
    
    ```
    

### Propriedades da Resposta (`response` object)

Quando uma requisição Axios é bem-sucedida, o objeto `response` que você recebe no `.then()` possui as seguintes propriedades:

- `response.data`: O corpo da resposta fornecido pelo servidor. Se a resposta for JSON, o Axios já o parseia para um objeto JavaScript.
- `response.status`: O código de status HTTP da resposta (e.g., `200`, `404`, `500`).
- `response.statusText`: A mensagem de status HTTP (e.g., `'OK'`, `'Not Found'`, `'Internal Server Error'`).
- `response.headers`: Os cabeçalhos HTTP da resposta.
- `response.config`: A configuração da requisição que foi usada.
- `response.request`: O objeto `XMLHttpRequest` (no navegador) ou o objeto `http.ClientRequest` (no Node.js) que originou a requisição.

### Propriedades do Erro (`error` object)

Quando uma requisição Axios falha, o objeto `error` que você recebe no `.catch()` pode ter as seguintes propriedades:

- `error.response`: Contém o objeto de resposta se o servidor respondeu com um código de status fora do intervalo 2xx. Possui as mesmas propriedades de `response` (`data`, `status`, `headers`, etc.).
- `error.request`: Contém o objeto `XMLHttpRequest` ou `http.ClientRequest` se a requisição foi feita mas nenhuma resposta foi recebida (e.g., problema de rede).
- `error.message`: Uma mensagem de erro curta (e.g., "Network Error", "timeout of 5000ms exceeded").
- `error.config`: A configuração da requisição que causou o erro.
- `error.code`: Um código de erro específico (e.g., `'ECONNABORTED'` para timeout, `'ERR_NETWORK'` para erro de rede).
- `error.isAxiosError`: Um booleano que é `true` se o erro foi gerado pelo Axios.

---

## Restrições de Uso

Embora o Axios seja extremamente versátil, existem cenários onde ele pode não ser a melhor escolha ou onde suas capacidades nativas já são suficientes.

- **Projetos Super Pequenos ou Simples:** Para uma única requisição muito simples em um projeto minúsculo, o `fetch API` nativo do navegador pode ser suficiente para evitar adicionar uma dependência extra.
    - **Porquê:** Adicionar uma biblioteca, por menor que seja, sempre adiciona peso ao bundle final do seu aplicativo. Para casos triviais, o overhead pode não valer a pena.
- **Controle de Baixo Nível sobre a Requisição:** Se você precisa de um controle extremamente granular sobre a API `XMLHttpRequest` (por exemplo, manipular diretamente eventos de progresso de upload/download de forma complexa, ou recursos específicos que o Axios pode abstrair demais), pode ser melhor usar a API `fetch` ou `XMLHttpRequest` diretamente.
    - **Porquê:** O Axios, por sua natureza de abstração, esconde algumas das complexidades do `XMLHttpRequest`. Embora isso seja ótimo na maioria dos casos, para necessidades muito específicas e de baixo nível, pode ser limitante.
- **Ambientes Altamente Restritos a Dependências:** Em ambientes onde cada byte e cada dependência importa criticamente (como algumas aplicações IoT ou ambientes legados com restrições severas de recursos), a `fetch API` nativa pode ser preferível.
    - **Porquê:** Reduzir o número de dependências pode simplificar a manutenção e reduzir o tamanho final do código.

Em resumo, o Axios é uma ferramenta poderosa e excelente para a maioria dos casos de uso de requisições HTTP. As "restrições" são mais sobre a minimização de dependências ou quando a API nativa já atende a requisitos muito específicos, sem a necessidade das conveniências do Axios.

---

## Elementos Associados

O Axios opera em um ecossistema que envolve várias outras tecnologias e conceitos JavaScript.

- **Promises:** O Axios é fundamentalmente baseado em Promises. Isso significa que as requisições retornam objetos Promise, permitindo o uso de `.then()`, `.catch()`, `.finally()`, e o sintaxe `async/await`.
    - **Propósito:** Lidar com operações assíncronas de forma mais limpa e organizada, evitando o "callback hell".
    - **Uso:**
        
        ```jsx
        axios.get('/data')
          .then(response => console.log(response.data))
          .catch(error => console.error(error));
        
        async function fetchData() {
          try {
            const response = await axios.get('/data');
            console.log(response.data);
          } catch (error) {
            console.error(error);
          }
        }
        
        ```
        
- **Async/Await:** Uma forma sintática de trabalhar com Promises que torna o código assíncrono mais legível, parecendo síncrono.
    - **Propósito:** Simplificar a escrita de código assíncrono.
    - **Uso:** (Exemplos já mostrados na seção "Sintaxe e Uso").
- **HTTP (Hypertext Transfer Protocol):** O protocolo subjacente que o Axios utiliza para a comunicação entre cliente e servidor. O Axios encapsula os detalhes da criação e envio de mensagens HTTP.
    - **Propósito:** Definir as regras para a comunicação de dados na web.
    - **Conceitos Essenciais:** Verbos HTTP (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS), códigos de status HTTP (200 OK, 404 Not Found, 500 Internal Server Error, etc.), cabeçalhos HTTP.
- **APIs RESTful (Representational State Transfer):** Um estilo arquitetural para sistemas distribuídos que o Axios é frequentemente usado para interagir.
    - **Propósito:** Prover uma maneira escalável e flexível de construir serviços web.
    - **Conceitos Essenciais:** Recursos, URLs, verbos HTTP para operações CRUD (Create, Read, Update, Delete).
- **JSON (JavaScript Object Notation):** O formato de dados mais comum usado para trocar informações entre o cliente e o servidor ao usar APIs RESTful. O Axios automaticamente serializa objetos JavaScript para JSON em requisições POST/PUT/PATCH e deserializa respostas JSON para objetos JavaScript.
    - **Propósito:** Formato leve para troca de dados.
    - **Uso:**
        
        ```jsx
        // Axios automaticamente converte este objeto para JSON no corpo da requisição
        axios.post('/users', { name: 'Gedê', age: 23 });
        
        // Axios automaticamente converte a resposta JSON para um objeto JS
        axios.get('/users/1').then(response => {
          console.log(response.data.name); // Acessa a propriedade 'name' do objeto JS
        });
        
        ```
        
- **Error Handling (Tratamento de Erros):** Crucial ao lidar com requisições de rede, pois falhas podem ocorrer por diversos motivos (rede, servidor, validação).
    - **Propósito:** Garantir que a aplicação se comporte de forma robusta e amigável ao usuário quando algo dá errado.
    - **Uso:** O `.catch()` das Promises, e a estrutura `try...catch` com `async/await`, são as formas padrão de tratar erros no Axios. Como visto, o objeto `error` do Axios fornece informações detalhadas sobre a natureza do erro.

---

## Melhores Práticas e Casos de Uso

### Melhores Práticas

1. **Crie Instâncias do Axios:** Para ter configurações padrão (como `baseURL`, `headers`) e interceptadores específicos para diferentes APIs ou módulos da sua aplicação. Isso evita repetição de código e torna a manutenção mais fácil.
    
    ```jsx
    // api.js
    import axios from 'axios';
    
    const apiClient = axios.create({
      baseURL: '<https://minhaapi.com/v1>',
      headers: {
        'Content-Type': 'application/json',
      },
      timeout: 15000,
    });
    
    // Adicione um interceptor para tokens de autenticação
    apiClient.interceptors.request.use(config => {
      const token = localStorage.getItem('accessToken');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    export default apiClient;
    
    // Em outro arquivo:
    // import api from './api';
    // api.get('/users').then(...)
    
    ```
    
2. **Use `async/await`:** Torna o código assíncrono mais legível e fácil de depurar.
    
    ```jsx
    async function fetchProducts() {
      try {
        const response = await axios.get('/products');
        return response.data;
      } catch (error) {
        console.error("Erro ao buscar produtos:", error);
        // Exemplo: Mostrar uma mensagem de erro na UI
        throw error; // Rejeitar a promise para que quem chamou possa tratar o erro
      }
    }
    
    ```
    
3. **Tratamento de Erros Abrangente:** Sempre inclua blocos `catch` ou `try/catch` para lidar com falhas de rede, erros de servidor e outros problemas. Use as propriedades `error.response`, `error.request`, `error.message` para diagnosticar e informar o usuário adequadamente.
4. **Gerenciamento de Tokens de Autenticação:** Use interceptadores de requisição para adicionar tokens (Bearer, JWT) aos cabeçalhos de todas as requisições autenticadas. Use interceptadores de resposta para lidar com erros de autenticação (e.g., 401 Unauthorized) e, se necessário, refrescar tokens ou redirecionar para a página de login.
5. **Cancelamento de Requisições:** Em Single Page Applications (SPAs), especialmente, é crucial cancelar requisições pendentes quando um componente é desmontado ou quando o usuário navega rapidamente. Isso evita "condições de corrida" e atualizações de estado em componentes já inexistentes, que podem levar a erros.
    
    ```jsx
    const CancelToken = axios.CancelToken;
    let cancel;
    
    axios.get('/user/123', {
      cancelToken: new CancelToken(function executor(c) {
        // Um "executor" recebe uma função de cancelamento como argumento
        cancel = c;
      })
    }).catch(function(thrown) {
      if (axios.isCancel(thrown)) {
        console.log('Requisição cancelada', thrown.message);
      } else {
        // lidar com erro
      }
    });
    
    // Cancela a requisição
    cancel('Operação cancelada pelo usuário.');
    
    ```
    
    Com React/Vue/Angular, isso seria feito no `useEffect` (com cleanup), `beforeDestroy` ou `ngOnDestroy`.
    
6. **Barra de Progresso/Indicadores de Carregamento:** Para melhorar a experiência do usuário, use interceptadores para mostrar/esconder spinners ou barras de progresso durante as requisições.
    
    ```jsx
    let requestsPending = 0;
    
    axios.interceptors.request.use(config => {
      requestsPending++;
      // showLoadingIndicator(); // Função para mostrar o spinner
      return config;
    });
    
    axios.interceptors.response.use(
      response => {
        requestsPending--;
        if (requestsPending === 0) {
          // hideLoadingIndicator(); // Função para esconder o spinner
        }
        return response;
      },
      error => {
        requestsPending--;
        if (requestsPending === 0) {
          // hideLoadingIndicator(); // Função para esconder o spinner
        }
        return Promise.reject(error);
      }
    );
    
    ```
    

### Casos de Uso Comuns

- **Comunicação com APIs RESTful:** O caso de uso mais comum, realizando operações CRUD (GET, POST, PUT, DELETE) em recursos do servidor.
- **Upload de Arquivos:** Enviar arquivos para o servidor usando `FormData`.
    
    ```jsx
    const formData = new FormData();
    formData.append('file', myFile);
    formData.append('description', 'Minha foto');
    
    axios.post('/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    }).then(response => console.log('Upload sucesso!', response.data));
    
    ```
    
- **Autenticação e Autorização:** Gerenciar login, logout e adicionar tokens de autenticação em todas as requisições.
- **Requisições Simultâneas:** Quando você precisa carregar vários recursos independentes da API ao mesmo tempo.
    
    ```jsx
    // api.js (exemplo de instância)
    import api from './api';
    
    async function getDashboardData() {
      try {
        const [usersResponse, productsResponse] = await axios.all([
          api.get('/users'),
          api.get('/products')
        ]);
        console.log("Usuários:", usersResponse.data);
        console.log("Produtos:", productsResponse.data);
      } catch (error) {
        console.error("Erro ao carregar dashboard:", error);
      }
    }
    
    ```
    
- **Tratamento de Erros Centralizado:** Utilizar interceptores de resposta para exibir mensagens de erro globais para o usuário, redirecionar em caso de erros específicos (ex: 401 Não Autorizado), ou logar erros.
- **Mocks de Requisições:** Em desenvolvimento e testes, você pode usar bibliotecas como `axios-mock-adapter` para simular respostas do servidor sem precisar de um backend real.

---

## Exemplo Completo: Gerenciador de Tarefas Simples

Vamos criar um exemplo completo de um aplicativo JavaScript que usa Axios para interagir com uma API de tarefas (um `json-server` pode simular isso).

**Configuração do `json-server` (Backend Fake):**

1. Instale: `npm install -g json-server`
2. Crie um arquivo `db.json` com o seguinte conteúdo:
    
    ```json
    {
      "tasks": [
        { "id": "1", "title": "Aprender Axios", "completed": false },
        { "id": "2", "title": "Fazer compras", "completed": true }
      ]
    }
    
    ```
    
3. Inicie o servidor: `json-server --watch db.json --port 3000`
Sua API estará disponível em `http://localhost:3000/tasks`.

**`index.html`:**

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciador de Tarefas com Axios</title>
    <script src="<https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js>"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        .task-item { display: flex; align-items: center; margin-bottom: 10px; }
        .task-item.completed span { text-decoration: line-through; color: #888; }
        button { margin-left: 10px; cursor: pointer; }
        input[type="text"] { padding: 8px; width: 300px; }
        ul { list-style: none; padding: 0; }
        li { background-color: #f9f9f9; padding: 10px; border-radius: 5px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .error { color: red; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Minhas Tarefas</h1>

    <div id="addTask">
        <input type="text" id="taskInput" placeholder="Nova tarefa...">
        <button id="addTaskBtn">Adicionar Tarefa</button>
        <p id="errorMsg" class="error"></p>
    </div>

    <ul id="taskList">
        </ul>

    <script>
        // Cria uma instância do Axios para a nossa API
        const taskApi = axios.create({
            baseURL: '<http://localhost:3000>', // URL base da nossa API
            timeout: 5000, // Timeout de 5 segundos
            headers: {
                'Content-Type': 'application/json'
            }
        });

        // Interceptor de requisição para fins de debug (opcional)
        taskApi.interceptors.request.use(config => {
            console.log('Enviando requisição:', config.method.toUpperCase(), config.url);
            return config;
        }, error => {
            document.getElementById('errorMsg').textContent = 'Erro ao configurar a requisição: ' + error.message;
            return Promise.reject(error);
        });

        // Interceptor de resposta para tratamento de erros (opcional)
        taskApi.interceptors.response.use(response => {
            console.log('Resposta recebida:', response.status);
            return response;
        }, error => {
            if (error.response) {
                // Erro do servidor (status 4xx ou 5xx)
                const msg = `Erro do servidor: ${error.response.status} - ${error.response.data ? error.response.data.message || JSON.stringify(error.response.data) : 'Erro desconhecido'}`;
                document.getElementById('errorMsg').textContent = msg;
                console.error("Erro na resposta:", error.response);
            } else if (error.request) {
                // Requisição feita, mas sem resposta (erro de rede)
                document.getElementById('errorMsg').textContent = 'Erro de rede: O servidor não respondeu.';
                console.error("Erro na requisição:", error.request);
            } else {
                // Algo deu errado ao configurar a requisição
                document.getElementById('errorMsg').textContent = 'Erro inesperado: ' + error.message;
                console.error("Erro geral:", error.message);
            }
            return Promise.reject(error);
        });

        const taskListElement = document.getElementById('taskList');
        const taskInput = document.getElementById('taskInput');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const errorMsgElement = document.getElementById('errorMsg');

        // Função para exibir as tarefas na UI
        function renderTasks(tasks) {
            taskListElement.innerHTML = ''; // Limpa a lista existente
            tasks.forEach(task => {
                const li = document.createElement('li');
                li.className = `task-item ${task.completed ? 'completed' : ''}`;
                li.dataset.id = task.id;

                const span = document.createElement('span');
                span.textContent = task.title;
                span.style.cursor = 'pointer';
                span.onclick = () => toggleTaskCompleted(task.id, task.completed);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Remover';
                deleteBtn.onclick = () => deleteTask(task.id);

                li.appendChild(span);
                li.appendChild(deleteBtn);
                taskListElement.appendChild(li);
            });
            errorMsgElement.textContent = ''; // Limpa qualquer mensagem de erro anterior
        }

        // Carrega todas as tarefas da API
        async function fetchTasks() {
            try {
                const response = await taskApi.get('/tasks');
                renderTasks(response.data);
            } catch (error) {
                // Erro já tratado pelo interceptor de resposta
                console.error("Falha ao buscar tarefas.");
            }
        }

        // Adiciona uma nova tarefa
        addTaskBtn.addEventListener('click', async () => {
            const title = taskInput.value.trim();
            if (title) {
                try {
                    const newTask = { title, completed: false };
                    const response = await taskApi.post('/tasks', newTask);
                    console.log('Tarefa adicionada:', response.data);
                    taskInput.value = ''; // Limpa o input
                    fetchTasks(); // Recarrega as tarefas
                } catch (error) {
                    // Erro já tratado pelo interceptor de resposta
                    console.error("Falha ao adicionar tarefa.");
                }
            } else {
                errorMsgElement.textContent = 'Por favor, digite o título da tarefa.';
            }
        });

        // Alterna o status de conclusão de uma tarefa
        async function toggleTaskCompleted(id, currentStatus) {
            try {
                const response = await taskApi.patch(`/tasks/${id}`, { completed: !currentStatus });
                console.log('Tarefa atualizada:', response.data);
                fetchTasks(); // Recarrega as tarefas
            } catch (error) {
                // Erro já tratado pelo interceptor de resposta
                console.error("Falha ao atualizar tarefa.");
            }
        }

        // Deleta uma tarefa
        async function deleteTask(id) {
            if (confirm('Tem certeza que deseja remover esta tarefa?')) {
                try {
                    await taskApi.delete(`/tasks/${id}`);
                    console.log('Tarefa removida:', id);
                    fetchTasks(); // Recarrega as tarefas
                } catch (error) {
                    // Erro já tratado pelo interceptor de resposta
                    console.error("Falha ao remover tarefa.");
                }
            }
        }

        // Carrega as tarefas ao carregar a página
        document.addEventListener('DOMContentLoaded', fetchTasks);
    </script>
</body>
</html>

```

Este exemplo demonstra:

- A criação de uma **instância personalizada do Axios** (`taskApi`) com `baseURL` e `headers` padrão.
- O uso de **interceptores de requisição e resposta** para logar requisições/respostas e tratar erros globalmente, exibindo mensagens para o usuário.
- Operações **GET, POST, PATCH, DELETE** usando `async/await`.
- Atualização da interface do usuário após operações bem-sucedidas.
- Tratamento básico de erros.

---

## Tópicos Relacionados para Aprofundamento

Para você, Gedê, que já é desenvolvedor Backend Java e está migrando para GO, e está concluindo Sistemas de Informação, sugiro os seguintes tópicos para aprofundamento:

- **API `Fetch` do JavaScript:** Entender as diferenças e semelhanças com o Axios. A `fetch` é nativa e retorna Promises, mas tem um tratamento de erros diferente e não inclui interceptores por padrão.
- **Design de APIs RESTful:** Aprofundar-se nos princípios REST para criar APIs robustas e bem estruturadas, o que complementa o uso do Axios no cliente.
- **Estratégias de Autenticação (OAuth 2.0, JWT):** Entender como essas estratégias funcionam e como implementá-las de forma segura em suas requisições com o Axios (principalmente o fluxo de refresh token).
- **Gerenciamento de Estado em SPAs:** Como integrar as requisições Axios com bibliotecas de gerenciamento de estado (como Redux, Zustand, Vuex, NGRX) para gerenciar os dados da aplicação de forma centralizada e reativa.
- **Testes de Integração com APIs:** Como testar suas chamadas Axios em cenários de integração, simulando respostas de API (usando ferramentas como `axios-mock-adapter` ou `MSW - Mock Service Worker`).
- **WebSockets:** Para casos onde a comunicação em tempo real é necessária, entender como o Axios se diferencia e quando usar WebSockets em vez de requisições HTTP tradicionais.
- **Performance de Rede e Otimização:** Técnicas para otimizar o desempenho das requisições HTTP (caching, compressão, HTTP/2).

Espero que esta explicação detalhada sobre o Axios seja extremamente útil para você, Gedê\! Se tiver mais alguma dúvida, é só chamar a A.R.I.A\!