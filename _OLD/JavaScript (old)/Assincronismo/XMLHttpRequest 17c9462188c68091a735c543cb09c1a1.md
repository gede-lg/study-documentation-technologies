# XMLHttpRequest

Com certeza, Gedê\! A.R.I.A está pronta para te ajudar com uma explicação super detalhada sobre `XMLHttpRequest` em JavaScript. Como desenvolvedor Backend Java e com a sua busca por Go, entender as nuances de como o frontend se comunica com o backend é fundamental, e o `XMLHttpRequest` é um ótimo ponto de partida para isso.

---

# XMLHttpRequest: A Base das Requisições Assíncronas em JavaScript

---

## Introdução

O `XMLHttpRequest` (XHR) é um objeto API no JavaScript que permite aos navegadores da web fazer requisições HTTP a um servidor de forma assíncrona. Embora o nome sugira XML, ele pode ser usado para enviar e receber dados de qualquer tipo, incluindo JSON, HTML, ou texto simples. Antes da popularização de APIs mais modernas como `Fetch API` e bibliotecas como Axios, o XHR era a principal ferramenta para implementar funcionalidades como autocompletar, carregar conteúdo dinamicamente sem recarregar a página (o que chamamos de AJAX - Asynchronous JavaScript and XML), e enviar dados de formulários em segundo plano.

## Sumário

Esta explicação detalhada cobrirá desde os conceitos fundamentais do `XMLHttpRequest`, passando por sua sintaxe e uso, todos os seus métodos e propriedades essenciais, suas restrições de uso, elementos associados, melhores práticas, casos de uso comuns e exemplos de código completos para ilustrar sua aplicação prática.

---

## Conceitos Fundamentais

O `XMLHttpRequest` opera sob o paradigma **AJAX (Asynchronous JavaScript and XML)**, que é um conjunto de tecnologias de desenvolvimento web que permite que páginas web sejam atualizadas de forma assíncrona, trocando pequenas quantidades de dados com o servidor nos bastidores. Isso significa que é possível atualizar partes de uma página web sem a necessidade de recarregar a página inteira, proporcionando uma experiência de usuário mais fluida e responsiva.

O propósito principal do `XMLHttpRequest` é habilitar a comunicação cliente-servidor sem bloqueio da interface do usuário. Quando uma requisição é feita, o script JavaScript continua sua execução e, quando a resposta do servidor chega, uma função de callback é executada para processar os dados recebidos.

---

## Sintaxe e Uso

A utilização básica do `XMLHttpRequest` envolve a criação de uma nova instância do objeto, a configuração da requisição (método HTTP, URL), o tratamento dos eventos de resposta e o envio da requisição.

### Sintaxe Básica

```jsx
// 1. Criar uma nova instância do XMLHttpRequest
const xhr = new XMLHttpRequest();

// 2. Configurar a requisição
//    método: GET, POST, PUT, DELETE, etc.
//    url: O endpoint para onde a requisição será enviada
//    async: true para assíncrona (recomendado), false para síncrona
xhr.open('GET', '<https://api.example.com/data>', true);

// 3. Definir um "listener" para o evento de carregamento da requisição
xhr.onload = function() {
    // Verificar o status da resposta HTTP
    if (xhr.status >= 200 && xhr.status < 300) {
        // Requisição bem-sucedida
        console.log('Dados recebidos:', xhr.responseText);
    } else {
        // Ocorreu um erro na requisição (ex: 404 Not Found, 500 Internal Server Error)
        console.error('Erro na requisição:', xhr.status, xhr.statusText);
    }
};

// 4. Definir um "listener" para o evento de erro da requisição (ex: problemas de rede)
xhr.onerror = function() {
    console.error('Erro de rede.');
};

// 5. Enviar a requisição
xhr.send();

```

### Sintaxe Mais Complexa e Completa

Para requisições `POST` ou `PUT`, geralmente é necessário enviar dados no corpo da requisição e definir o cabeçalho `Content-Type`. Além disso, o XHR oferece um conjunto de eventos para monitorar o progresso da requisição.

```jsx
// Criar uma nova instância do XMLHttpRequest
const xhrPost = new XMLHttpRequest();

// Configurar a requisição POST
xhrPost.open('POST', '<https://api.example.com/users>', true);

// Definir o cabeçalho Content-Type para indicar que estamos enviando JSON
xhrPost.setRequestHeader('Content-Type', 'application/json');

// Dados a serem enviados (no formato JSON)
const userData = {
    name: 'Gedê',
    age: 23,
    city: 'Colatina - ES'
};

// Converter o objeto JavaScript para string JSON
const jsonData = JSON.stringify(userData);

// Monitorar o progresso do upload (opcional)
xhrPost.upload.onprogress = function(event) {
    if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        console.log(`Progresso do upload: ${percentComplete.toFixed(2)}%`);
    }
};

// Monitorar o estado da requisição (opcional, mas útil para depuração)
xhrPost.onreadystatechange = function() {
    console.log('readyState:', xhrPost.readyState);
    if (xhrPost.readyState === XMLHttpRequest.DONE) {
        // Requisição completa (seja sucesso ou erro)
        console.log('Requisição finalizada.');
    }
};

// Definir o "listener" para o carregamento da requisição
xhrPost.onload = function() {
    if (xhrPost.status >= 200 && xhrPost.status < 300) {
        console.log('Usuário criado com sucesso:', xhrPost.responseText);
    } else {
        console.error('Erro ao criar usuário:', xhrPost.status, xhrPost.statusText, xhrPost.responseText);
    }
};

// Definir o "listener" para erro de rede
xhrPost.onerror = function() {
    console.error('Erro de rede ao tentar criar usuário.');
};

// Enviar a requisição com os dados
xhrPost.send(jsonData);

```

---

## Métodos e Propriedades

O objeto `XMLHttpRequest` possui uma série de métodos e propriedades que permitem controlar e monitorar o estado das requisições.

### Métodos

| Método | Sintaxe de Uso | Conceito e Propósito |
| --- | --- | --- |
| `open()` | `xhr.open(method, url, async, user, password)` | **Inicializa uma nova requisição.**\<br\>- `method`: O método HTTP (GET, POST, PUT, DELETE, etc.).\<br\>- `url`: A URL para enviar a requisição.\<br\>- `async`: Um booleano que indica se a requisição é assíncrona (true) ou síncrona (false). O padrão é true. Requisições síncronas são desencorajadas pois bloqueiam a thread principal do navegador.\<br\>- `user` (opcional): Nome de usuário para autenticação.\<br\>- `password` (opcional): Senha para autenticação. |
| `send()` | `xhr.send(body)` | **Envia a requisição.**\<br\>- `body` (opcional): Os dados a serem enviados no corpo da requisição para métodos como POST ou PUT. Pode ser um `Document`, `BodyInit` (e.g., `FormData`, `Blob`, `ArrayBuffer`, `URLSearchParams`, `string`). Para requisições GET/HEAD, o `body` deve ser `null`. |
| `abort()` | `xhr.abort()` | **Cancela a requisição atual.** Interrompe qualquer requisição pendente. |
| `setRequestHeader()` | `xhr.setRequestHeader(header, value)` | **Define o valor de um cabeçalho HTTP de requisição.** Deve ser chamado APÓS `open()` e ANTES de `send()`.\<br\>- `header`: O nome do cabeçalho (e.g., 'Content-Type', 'Authorization').\<br\>- `value`: O valor do cabeçalho. |
| `getResponseHeader()` | `xhr.getResponseHeader(header)` | **Retorna o valor de um cabeçalho de resposta específico.** Retorna `null` se o cabeçalho não existir. Deve ser chamado APÓS a requisição ter sido concluída e a resposta recebida. |
| `getAllResponseHeaders()` | `xhr.getAllResponseHeaders()` | **Retorna todos os cabeçalhos de resposta HTTP como uma única string.** Os cabeçalhos são separados por CRLF e os pares nome-valor por ': '. |
| `overrideMimeType()` | `xhr.overrideMimeType(mimeType)` | **Sobrescreve o tipo MIME retornado pelo servidor.** Útil para forçar o navegador a interpretar o conteúdo de uma determinada forma, independentemente do cabeçalho `Content-Type` enviado pelo servidor. Deve ser chamado ANTES de `send()`. |

### Propriedades

| Propriedade | Sintaxe de Uso | Conceito e Propósito |
| --- | --- | --- |
| `readyState` | `xhr.readyState` | **Retorna o estado atual da requisição.** É um número inteiro que muda à medida que o progresso da requisição avança. Os valores possíveis são:\<br\>- `0` (`UNSENT`): `open()` ainda não foi chamado.\<br\>- `1` (`OPENED`): `open()` foi chamado.\<br\>- `2` (`HEADERS_RECEIVED`): `send()` foi chamado, e os cabeçalhos e o status estão disponíveis.\<br\>- `3` (`LOADING`): Baixando; `responseText` contém dados parciais.\<br\>- `4` (`DONE`): A operação está completa. |
| `status` | `xhr.status` | **Retorna o código de status HTTP da resposta** (e.g., 200 para OK, 404 para Not Found, 500 para Internal Server Error). Disponível quando `readyState` é 2 (HEADERS\_RECEIVED) ou superior. |
| `statusText` | `xhr.statusText` | **Retorna a mensagem de status HTTP da resposta** (e.g., "OK", "Not Found"). Disponível quando `readyState` é 2 (HEADERS\_RECEIVED) ou superior. |
| `responseText` | `xhr.responseText` | **Retorna a resposta do servidor como uma string de texto.** Disponível quando `readyState` é 3 (LOADING) ou 4 (DONE). Se `responseType` não for definido ou for 'text'. |
| `response` | `xhr.response` | **Retorna o corpo da resposta da requisição.** O tipo do valor depende do valor da propriedade `responseType`. Se `responseType` for 'json', será um objeto JavaScript. Se for 'blob', será um `Blob`. Se for 'arraybuffer', será um `ArrayBuffer`. Se for 'text', será uma string (igual a `responseText`). |
| `responseType` | `xhr.responseType` | **Define o tipo de dados que se espera na resposta.** Pode ser 'text' (padrão), 'json', 'blob', 'arraybuffer', 'document'. Deve ser definido APÓS `open()` e ANTES de `send()`. |
| `responseURL` | `xhr.responseURL` | **Retorna a URL final da resposta**, após quaisquer redirecionamentos. |
| `responseXML` | `xhr.responseXML` | **Retorna a resposta como um objeto `Document` XML** (se o `Content-Type` for `application/xml` ou `text/xml`), que pode ser então manipulado usando DOM. Disponível quando `readyState` é 3 (LOADING) ou 4 (DONE) e `responseType` é 'document' ou padrão para XML. |
| `timeout` | `xhr.timeout` | **Define o tempo limite (em milissegundos) para a requisição.** Se a requisição não for concluída dentro deste tempo, ela será abortada e o evento `timeout` será disparado. O valor 0 significa que não há tempo limite. |
| `ontimeout` | `xhr.ontimeout = function() {...}` | **Manipulador de evento para o evento `timeout`.** Chamado quando a requisição excede o tempo limite. |
| `onreadystatechange` | `xhr.onreadystatechange = function() {...}` | **Manipulador de evento para o evento `readystatechange`.** Chamado sempre que a propriedade `readyState` muda. É o evento mais fundamental para monitorar o progresso da requisição, embora `onload` e `onerror` sejam mais específicos para sucesso/falha. |
| `onload` | `xhr.onload = function() {...}` | **Manipulador de evento para o evento `load`.** Chamado quando a requisição é concluída com sucesso (independentemente do status HTTP). É mais comumente usado do que `onreadystatechange` para verificar o status 2xx. |
| `onerror` | `xhr.onerror = function() {...}` | **Manipulador de evento para o evento `error`.** Chamado quando ocorre um erro de rede na requisição (e.g., servidor offline, problemas de DNS, bloqueio por CORS). Não é disparado para erros HTTP (como 404 ou 500). |
| `onabort` | `xhr.onabort = function() {...}` | **Manipulador de evento para o evento `abort`.** Chamado quando a requisição é abortada usando `xhr.abort()`. |
| `onloadstart` | `xhr.onloadstart = function() {...}` | **Manipulador de evento para o evento `loadstart`.** Chamado quando a requisição começa a carregar. |
| `onprogress` | `xhr.onprogress = function() {...}` | **Manipulador de evento para o evento `progress`.** Chamado periodicamente durante o processo de carregamento/download dos dados. Útil para mostrar barras de progresso. O objeto de evento contém `loaded` e `total` bytes. |
| `onloadend` | `xhr.onloadend = function() {...}` | **Manipulador de evento para o evento `loadend`.** Chamado quando a requisição é concluída (seja sucesso, erro ou aborto). É disparado após `onload`, `onerror` ou `onabort`. |
| `withCredentials` | `xhr.withCredentials` | **Um booleano que indica se as credenciais (cookies, certificados de cliente HTTP ou cabeçalhos de autorização HTTP) devem ser enviadas com a requisição cross-origin.** Por padrão é `false`. Deve ser definido ANTES de `send()`. Essencial para requisições CORS que exigem cookies ou autenticação. |
| `upload` | `xhr.upload` | **Retorna um objeto `XMLHttpRequestUpload`**, que pode ser usado para monitorar o progresso do upload de dados. Este objeto possui os mesmos eventos de progresso que o `XMLHttpRequest` (e.g., `onprogress`, `onload`, `onerror`), mas específicos para a fase de envio. |

---

## Restrições de Uso

Embora poderoso, o `XMLHttpRequest` possui algumas restrições e cenários onde ele não é a melhor escolha:

- **Sincronicidade:** Embora `xhr.open()` aceite um parâmetro `async: false`, o uso de requisições síncronas é **altamente desencorajado**. Elas bloqueiam a thread principal do navegador, congelando a interface do usuário e tornando a página unresponsive até que a requisição seja concluída. Isso resulta em uma experiência de usuário terrível.
- **CORS (Cross-Origin Resource Sharing):** Por questões de segurança, os navegadores implementam a **Política de Mesma Origem (Same-Origin Policy)**. Isso significa que, por padrão, uma página web não pode fazer requisições `XMLHttpRequest` para um domínio diferente do domínio da própria página. Para permitir requisições cross-origin, o servidor deve explicitamente permitir a origem do cliente através de cabeçalhos CORS (`Access-Control-Allow-Origin`, etc.). Sem essa configuração no servidor, as requisições XHR cross-origin falharão silenciosamente no navegador.
- **APIs Mais Modernas:** A `XMLHttpRequest` pode ser um pouco verbosa e baseada em callbacks, o que pode levar ao "callback hell" em requisições aninhadas. APIs mais modernas como a **`Fetch API`** (que usa Promises) e bibliotecas populares como o Axios oferecem uma sintaxe mais limpa, poderosa e baseada em Promises para lidar com requisições HTTP, tornando o código mais legível e fácil de manter, especialmente para Gedê que já trabalha com Java e está buscando GO, onde o gerenciamento assíncrono é comum.
- **Upload de Arquivos Grandes:** Embora `xhr.upload` permita monitorar o progresso, o manuseio de arquivos grandes pode ser mais complexo com XHR puro em comparação com bibliotecas especializadas que encapsulam essa funcionalidade.
- **Serviço Workers:** O `XMLHttpRequest` não pode ser usado diretamente dentro de Service Workers (Web Workers sim, Service Workers não). Service Workers, usados para recursos offline e notificações push, usam a `Fetch API` para fazer requisições de rede.

---

## Elementos Associados

Para um uso eficaz do `XMLHttpRequest`, alguns elementos e conceitos são cruciais:

- **HTTP (Hypertext Transfer Protocol):** O XHR é fundamentalmente um cliente HTTP. Entender os métodos HTTP (GET, POST, PUT, DELETE), códigos de status (200 OK, 404 Not Found, 500 Internal Server Error, etc.) e cabeçalhos HTTP (Content-Type, Authorization, Accept, etc.) é essencial para interagir corretamente com APIs RESTful.
- **JSON (JavaScript Object Notation):** A maioria das APIs modernas se comunica usando JSON. O XHR pode enviar e receber JSON facilmente. Funções como `JSON.stringify()` (para converter objeto JS em string JSON) e `JSON.parse()` (para converter string JSON em objeto JS) são frequentemente usadas em conjunto com XHR.
- **Eventos de Progresso (Progress Events):** O `XMLHttpRequest` e `XMLHttpRequestUpload` disparam eventos para monitorar o progresso da requisição e do upload.
    - `loadstart`: Início da requisição.
    - `progress`: Progresso do carregamento/upload. O objeto de evento tem as propriedades `loaded` (bytes carregados) e `total` (bytes totais).
    - `load`: Requisição concluída com sucesso (status HTTP pode ser qualquer um).
    - `error`: Erro na rede.
    - `abort`: Requisição abortada.
    - `timeout`: Requisição excedeu o tempo limite.
    - `loadend`: Requisição finalizada (sucesso, erro ou aborto).
- **`FormData` API:** Para enviar dados de formulário, especialmente arquivos, a interface `FormData` é extremamente útil. Ela permite construir um conjunto de pares chave/valor que podem ser enviados com `xhr.send()`.
    
    ```jsx
    const formData = new FormData();
    formData.append('username', 'Gedê');
    formData.append('profilePicture', fileInput.files[0]); // Para um input type="file"
    
    xhr.open('POST', '/upload', true);
    // Não precisa definir Content-Type, o navegador faz isso automaticamente para FormData
    xhr.send(formData);
    
    ```
    

---

## Melhores Práticas e Casos de Uso

Ainda que existam alternativas, entender as melhores práticas do XHR é valioso.

### Melhores Práticas

1. **Sempre Use Requisições Assíncronas:** Nunca use `async: false` no método `open()`. Isso bloqueia a interface do usuário e prejudica a experiência.
2. **Tratamento de Erros Abrangente:** Sempre inclua `onerror` para erros de rede e verifique `xhr.status` e `xhr.statusText` dentro de `onload` para lidar com erros de servidor (como 404, 500).
3. **Verificação do `readyState` (se necessário):** Embora `onload` seja suficiente para a maioria dos casos de sucesso, `onreadystatechange` é útil se você precisar de feedback em diferentes estágios da requisição, como exibir um spinner de carregamento quando `readyState` for 3.
4. **Defina `responseType`:** Ao trabalhar com JSON, defina `xhr.responseType = 'json';` para que o navegador automaticamente parseie a resposta para você, evitando `JSON.parse()`.
5. **Gerenciamento de Tempo Limite:** Use `xhr.timeout` e `xhr.ontimeout` para evitar que requisições fiquem penduradas indefinidamente, especialmente em redes instáveis.
6. **Cabeçalhos Corretos:** Sempre defina o `Content-Type` apropriado (`application/json`, `application/x-www-form-urlencoded`, etc.) para requisições que enviam dados no corpo.
7. **`withCredentials` para CORS com Credenciais:** Se sua API cross-origin requer cookies ou cabeçalhos de autenticação, lembre-se de definir `xhr.withCredentials = true;`.

### Casos de Uso Comuns

- **Carregamento de Conteúdo Dinâmico:** Buscar e exibir artigos de blog, comentários, ou produtos em uma página sem recarregar a página inteira.
- **Envio de Formulários Assíncronos:** Submeter dados de formulários (e.g., cadastro, login) sem redirecionamento, exibindo feedback de sucesso ou erro na mesma página.
- **Autocompletar/Busca em Tempo Real:** Fazer requisições ao servidor à medida que o usuário digita em um campo de busca para sugerir resultados.
- **Chat em Tempo Real (polling):** Embora WebSockets sejam melhores, o XHR pode ser usado para polling regular para buscar novas mensagens (menos eficiente).
- **Upload de Arquivos:** Enviar arquivos para o servidor em segundo plano, possivelmente com uma barra de progresso.

---

## Exemplo Completo: Gerenciador de Tarefas Simples

Este exemplo simula um gerenciador de tarefas onde você pode buscar tarefas existentes e adicionar novas tarefas. Ele demonstra requisições GET e POST, tratamento de eventos, e manipulação do DOM.

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciador de Tarefas com XMLHttpRequest</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        input[type="text"] { width: calc(100% - 100px); padding: 8px; margin-right: 10px; border: 1px solid #ccc; }
        button { padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        ul { list-style: none; padding: 0; }
        li { background-color: #f9f9f9; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }
        .error { color: red; margin-top: 10px; }
        .loading { color: grey; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Minhas Tarefas</h1>

        <div>
            <input type="text" id="taskInput" placeholder="Adicionar nova tarefa...">
            <button id="addTaskBtn">Adicionar</button>
        </div>

        <p class="loading" id="loadingMessage" style="display: none;">Carregando tarefas...</p>
        <p class="error" id="errorMessage" style="display: none;"></p>

        <h2>Lista de Tarefas</h2>
        <ul id="taskList">
            </ul>
    </div>

    <script>
        const taskInput = document.getElementById('taskInput');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const taskList = document.getElementById('taskList');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');

        // URL da API de exemplo (usaremos JSONPlaceholder para simular)
        // OBS: Para uma API real de tarefas, você precisaria de um backend.
        // Aqui, vamos simular que 'todos' são nossas tarefas.
        const API_URL = '<https://jsonplaceholder.typicode.com/todos>';

        /**
         * Função para exibir mensagens de erro
         * @param {string} message - A mensagem de erro a ser exibida.
         */
        function displayError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            loadingMessage.style.display = 'none';
        }

        /**
         * Função para limpar mensagens de erro/carregamento
         */
        function clearMessages() {
            errorMessage.style.display = 'none';
            loadingMessage.style.display = 'none';
        }

        /**
         * Função para renderizar as tarefas na lista
         * @param {Array<Object>} tasks - Um array de objetos de tarefa.
         */
        function renderTasks(tasks) {
            taskList.innerHTML = ''; // Limpa a lista existente
            tasks.forEach(task => {
                const li = document.createElement('li');
                li.textContent = task.title; // Ou task.text, dependendo da sua API
                if (task.completed) {
                    li.style.textDecoration = 'line-through';
                    li.style.color = '#888';
                }
                taskList.appendChild(li);
            });
        }

        /**
         * Função para buscar tarefas existentes da API
         */
        function fetchTasks() {
            clearMessages();
            loadingMessage.style.display = 'block';

            const xhr = new XMLHttpRequest();
            xhr.open('GET', API_URL + '?_limit=10', true); // Limita a 10 tarefas para este exemplo
            xhr.responseType = 'json'; // Espera uma resposta JSON
            xhr.timeout = 5000; // Tempo limite de 5 segundos

            xhr.onload = function() {
                loadingMessage.style.display = 'none';
                if (xhr.status >= 200 && xhr.status < 300) {
                    // Requisição bem-sucedida, os dados já são um objeto JavaScript devido a responseType = 'json'
                    renderTasks(xhr.response);
                } else {
                    // Erro no servidor (ex: 404, 500)
                    displayError(`Erro ao buscar tarefas: ${xhr.status} ${xhr.statusText}`);
                    console.error('Erro na resposta:', xhr.status, xhr.statusText, xhr.responseText);
                }
            };

            xhr.onerror = function() {
                loadingMessage.style.display = 'none';
                displayError('Erro de rede: Não foi possível conectar ao servidor.');
                console.error('Erro de rede na requisição GET.');
            };

            xhr.ontimeout = function() {
                loadingMessage.style.display = 'none';
                displayError('A requisição excedeu o tempo limite.');
                console.error('Requisição GET excedeu o tempo limite.');
            };

            xhr.send();
        }

        /**
         * Função para adicionar uma nova tarefa
         * @param {string} taskTitle - O título da nova tarefa.
         */
        function addTask(taskTitle) {
            clearMessages();
            if (!taskTitle.trim()) {
                displayError('O título da tarefa não pode ser vazio!');
                return;
            }

            loadingMessage.textContent = 'Adicionando tarefa...';
            loadingMessage.style.display = 'block';

            const xhr = new XMLHttpRequest();
            xhr.open('POST', API_URL, true);
            xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
            xhr.responseType = 'json'; // Espera uma resposta JSON
            xhr.timeout = 5000;

            const newTask = {
                title: taskTitle,
                completed: false,
                userId: 1 // JSONPlaceholder exige um userId
            };

            xhr.onload = function() {
                loadingMessage.style.display = 'none';
                if (xhr.status >= 200 && xhr.status < 300) {
                    // Tarefa adicionada com sucesso
                    alert('Tarefa adicionada com sucesso!');
                    taskInput.value = ''; // Limpa o input
                    // Para uma aplicação real, você buscaria as tarefas novamente ou adicionaria na lista localmente.
                    // Aqui, vamos apenas exibir uma mensagem e sugerir que a API de exemplo não persiste dados.
                    console.log('Tarefa adicionada (API de exemplo não persiste):', xhr.response);
                    // Para realmente ver a nova tarefa, em uma API real, você chamaria fetchTasks();
                    // fetchTasks(); // Descomente para recarregar todas as tarefas após adicionar
                } else {
                    displayError(`Erro ao adicionar tarefa: ${xhr.status} ${xhr.statusText}`);
                    console.error('Erro na resposta:', xhr.status, xhr.statusText, xhr.responseText);
                }
            };

            xhr.onerror = function() {
                loadingMessage.style.display = 'none';
                displayError('Erro de rede ao adicionar tarefa.');
                console.error('Erro de rede na requisição POST.');
            };

            xhr.ontimeout = function() {
                loadingMessage.style.display = 'none';
                displayError('A requisição de adição de tarefa excedeu o tempo limite.');
                console.error('Requisição POST excedeu o tempo limite.');
            };

            xhr.send(JSON.stringify(newTask));
        }

        // Event Listeners
        addTaskBtn.addEventListener('click', () => {
            addTask(taskInput.value);
        });

        // Carregar tarefas ao iniciar a página
        document.addEventListener('DOMContentLoaded', fetchTasks);
    </script>
</body>
</html>

```

**Observações sobre o Exemplo:**

- Este exemplo usa a API pública [JSONPlaceholder](https://jsonplaceholder.typicode.com/) para simular uma API de backend. Note que as operações de `POST` no JSONPlaceholder não persistem os dados no servidor; elas apenas retornam uma simulação de sucesso. Para um sistema real, você precisaria de um backend implementado por você (talvez em Java ou GO\!).
- A função `fetchTasks()` usa o método `GET` para buscar as tarefas.
- A função `addTask()` usa o método `POST` para enviar uma nova tarefa.
- Ambas as funções demonstram o tratamento de `onload`, `onerror` e `ontimeout`.
- O `responseType = 'json'` é usado para que o navegador parseie automaticamente a resposta JSON.

---

## Sugestões de Tópicos Relacionados para Aprofundamento

Para Ju e você, Gedê, que são da área de TI e buscam aprimoramento, sugiro os seguintes tópicos para aprofundamento:

1. **Fetch API:** A alternativa moderna e baseada em Promises para `XMLHttpRequest`. É mais concisa, flexível e nativa do JavaScript.
2. **Promises e Async/Await:** Fundamentais para o desenvolvimento assíncrono moderno em JavaScript, especialmente ao lidar com a `Fetch API` ou outras operações que retornam Promises.
3. **Axios (Biblioteca):** Uma biblioteca popular de cliente HTTP baseada em Promises para o navegador e Node.js, que simplifica muito a criação de requisições HTTP, adicionando interceptors, cancelamento de requisições e outras funcionalidades úteis.
4. **CORS (Cross-Origin Resource Sharing):** Entender profundamente como o CORS funciona é vital para interações cliente-servidor, especialmente quando frontend e backend estão em domínios diferentes.
5. **WebSockets:** Para comunicação bidirecional em tempo real (como em aplicações de chat ou jogos multiplayer), WebSockets são muito mais eficientes que `XMLHttpRequest`.
6. **Padrões de Comunicação Backend:** Para Gedê, estudar padrões como RESTful APIs (que o `XMLHttpRequest` e `Fetch API` consomem) e gRPC é um ótimo caminho para aprimorar suas habilidades de backend.

Espero que esta explicação detalhada, A.R.I.A, tenha sido clara e útil para você, Gedê\! Se tiver mais alguma dúvida ou quiser aprofundar em outro tópico, é só chamar\!