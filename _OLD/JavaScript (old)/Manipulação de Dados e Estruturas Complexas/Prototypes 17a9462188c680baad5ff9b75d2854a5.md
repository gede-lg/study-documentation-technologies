# Prototypes

## Introdução Breve

Os **prototypes** são um dos pilares fundamentais do JavaScript, permitindo a reutilização de propriedades e métodos entre objetos. Diferente de muitas outras linguagens orientadas a objetos que utilizam classes para herança, o JavaScript implementa herança prototípica. Compreender protótipos é essencial para dominar conceitos avançados da linguagem, como herança, encapsulamento e a criação eficiente de objetos.

A relevância dos protótipos reside na capacidade de criar estruturas de objetos mais eficientes e na compreensão de como o JavaScript gerencia a herança e a reutilização de código. Eles são a base para muitas funcionalidades modernas do JavaScript, incluindo **ES6 Classes**, **Object.create()**, e **Herança de Prototipagem**.

## Sumário

1. [Definição e Conceitos Fundamentais](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#defini%C3%A7%C3%A3o-e-conceitos-fundamentais)
2. [Sintaxe e Estrutura](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#sintaxe-e-estrutura)
    - [Objetos Literais](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#objetos-literais)
    - [Funções Construtoras](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#fun%C3%A7%C3%B5es-construtoras)
    - [Classes ES6](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#classes-es6)
3. [Componentes Principais](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#componentes-principais)
    - [Prototype Property](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#prototype-property)
    - [**proto** e [[Prototype]]](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#__proto__-e-%5B%5Bprototype%5D%5D)
    - [Chain de Prototipagem](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#chain-de-prototipagem)
4. [Uso Avançado](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#uso-avan%C3%A7ado)
    - [Métodos e Propriedades no Prototype](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#m%C3%A9todos-e-propriedades-no-prototype)
    - [Object.create()](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#objectcreate)
    - [Herança Prototípica](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#heran%C3%A7a-protot%C3%ADpica)
    - [Mixins](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#mixins)
5. [Integração com Outras Funcionalidades](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#integra%C3%A7%C3%A3o-com-outras-funcionalidades)
    - [Prototypal Inheritance com ES6 Classes](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#prototypal-inheritance-com-es6-classes)
    - [Interação com Métodos Nativos](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#intera%C3%A7%C3%A3o-com-m%C3%A9todos-nativos)
6. [Exemplos de Código Otimizados](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#exemplos-de-c%C3%B3digo-otimizados)
    - [Exemplo Básico de Prototype](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#exemplo-b%C3%A1sico-de-prototype)
    - [Herança Prototípica com Funções Construtoras](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#heran%C3%A7a-protot%C3%ADpica-com-fun%C3%A7%C3%B5es-construtoras)
    - [Uso de Object.create()](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#uso-de-objectcreate)
    - [Implementação de Mixins](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#implementa%C3%A7%C3%A3o-de-mixins)
7. [Informações Adicionais](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#informa%C3%A7%C3%B5es-adicionais)
    - [Desempenho e Memória](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#desempenho-e-mem%C3%B3ria)
    - [Práticas Recomendas](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#pr%C3%A1ticas-recomendadas)
    - [Proxies e Reflections](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#proxies-e-reflections)
8. [Referências para Estudo Independente](https://chatgpt.com/c/67854f11-92b0-8003-82e2-130f767da90e?model=o1-mini#refer%C3%AAncias-para-estudo-independente)

---

## Definição e Conceitos Fundamentais

### O que são Prototypes?

No JavaScript, **prototype** refere-se a um objeto interno que é usado como um modelo para outros objetos. Cada objeto em JavaScript possui uma referência para seu **prototype**, e essa cadeia de protótipos forma o que é conhecido como **Chain de Prototipagem**. Quando tentamos acessar uma propriedade ou método em um objeto, o JavaScript primeiro verifica se a propriedade existe no próprio objeto. Se não existir, ele procura no seu prototype, e assim por diante até o topo da cadeia.

### Conceitos Básicos vs. Avançados

- **Básicos**:
    - Entendimento de como os objetos possuem um prototype.
    - Diferença entre propriedades próprias e herdadas.
    - Utilização da propriedade `prototype` em funções construtoras.
- **Avançados**:
    - Manipulação direta do `__proto__` (não recomendado em produção).
    - Uso de `Object.create()` para criar objetos com um prototype específico.
    - Implementação de herança prototípica personalizada.
    - Utilização de **Mixins** para compartilhar funcionalidades entre objetos.

## Sintaxe e Estrutura

### Objetos Literais

A forma mais simples de criar um objeto em JavaScript é usando **objetos literais**. Esses objetos têm um prototype que aponta para `Object.prototype` por padrão.

```jsx
const pessoa = {
  nome: 'João',
  saudacao() {
    console.log(`Olá, meu nome é ${this.nome}`);
  }
};

pessoa.saudacao(); // Olá, meu nome é João

```

### Funções Construtoras

Antes das **Classes ES6**, funções construtoras eram a principal maneira de criar objetos com protótipos compartilhados.

```jsx
function Pessoa(nome) {
  this.nome = nome;
}

Pessoa.prototype.saudacao = function() {
  console.log(`Olá, meu nome é ${this.nome}`);
};

const joao = new Pessoa('João');
joao.saudacao(); // Olá, meu nome é João

```

### Classes ES6

As **Classes ES6** são uma sintaxe mais elegante para criar objetos e implementar herança prototípica.

```jsx
class Pessoa {
  constructor(nome) {
    this.nome = nome;
  }

  saudacao() {
    console.log(`Olá, meu nome é ${this.nome}`);
  }
}

const maria = new Pessoa('Maria');
maria.saudacao(); // Olá, meu nome é Maria

```

## Componentes Principais

### Prototype Property

A propriedade `prototype` é uma propriedade de funções em JavaScript que aponta para um objeto. Esse objeto é usado como prototype para todos os objetos criados com a função construtora.

```jsx
function Animal(tipo) {
  this.tipo = tipo;
}

Animal.prototype.falar = function() {
  console.log(`O ${this.tipo} está falando.`);
};

const cachorro = new Animal('cachorro');
cachorro.falar(); // O cachorro está falando.

```

### **proto** e [[Prototype]]

- **`__proto__`**: Uma propriedade acessível em muitos ambientes JavaScript que aponta para o prototype real de um objeto. Embora seja amplamente suportado, seu uso é desencorajado em favor de métodos mais seguros.
- **`[[Prototype]]`**: Um slot interno que todos os objetos possuem, referenciando seu prototype. Não deve ser acessado diretamente; em vez disso, usa-se métodos como `Object.getPrototypeOf()` e `Object.setPrototypeOf()`.

```jsx
const obj = {};
console.log(obj.__proto__ === Object.prototype); // true
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

```

### Chain de Prototipagem

A **Chain de Prototipagem** é a sequência de objetos através dos quais o JavaScript procura propriedades e métodos.

```jsx
function Pessoa(nome) {
  this.nome = nome;
}

Pessoa.prototype.saudacao = function() {
  console.log(`Olá, meu nome é ${this.nome}`);
};

const joao = new Pessoa('João');
console.log(joao.toString()); // [object Object]

```

Nesse exemplo, `joao` não possui o método `toString`, então o JavaScript procura em `Pessoa.prototype`, não o encontra e continua a busca em `Object.prototype`, onde encontra `toString`.

## Uso Avançado

### Métodos e Propriedades no Prototype

Adicionar métodos ao prototype permite que todos os objetos criados com a função construtora compartilhem a mesma implementação, economizando memória.

```jsx
function Carro(modelo) {
  this.modelo = modelo;
}

Carro.prototype.dirigir = function() {
  console.log(`${this.modelo} está dirigindo.`);
};

const meuCarro = new Carro('Tesla');
const seuCarro = new Carro('BMW');

meuCarro.dirigir(); // Tesla está dirigindo.
seuCarro.dirigir(); // BMW está dirigindo.

```

### Object.create()

`Object.create()` permite criar um novo objeto com um prototype específico.

```jsx
const animal = {
  falar() {
    console.log(`O ${this.tipo} está falando.`);
  }
};

const gato = Object.create(animal);
gato.tipo = 'gato';
gato.falar(); // O gato está falando.

```

### Herança Prototípica

Implementar herança entre objetos permite que um objeto herde propriedades e métodos de outro.

```jsx
function Animal(tipo) {
  this.tipo = tipo;
}

Animal.prototype.falar = function() {
  console.log(`O ${this.tipo} está falando.`);
};

function Cachorro(nome) {
  Animal.call(this, 'cachorro'); // Chama o construtor Animal
  this.nome = nome;
}

// Herança prototípica
Cachorro.prototype = Object.create(Animal.prototype);
Cachorro.prototype.constructor = Cachorro;

Cachorro.prototype.latir = function() {
  console.log(`${this.nome} está latindo.`);
};

const rex = new Cachorro('Rex');
rex.falar(); // O cachorro está falando.
rex.latir(); // Rex está latindo.

```

### Mixins

Mixins permitem que objetos compartilhem funcionalidades sem usar herança prototípica.

```jsx
const cano = {
  nadar() {
    console.log(`${this.nome} está nadando.`);
  }
};

const voador = {
  voar() {
    console.log(`${this.nome} está voando.`);
  }
};

function Passaro(nome) {
  this.nome = nome;
}

Object.assign(Passaro.prototype, cano, voador);

const pardal = new Passaro('Pardal');
pardal.nadar(); // Pardal está nadando.
pardal.voar(); // Pardal está voando.

```

## Integração com Outras Funcionalidades

### Prototypal Inheritance com ES6 Classes

Embora as classes ES6 abstraiam a herança prototípica, entender o funcionamento subjacente é crucial.

```jsx
class Animal {
  constructor(tipo) {
    this.tipo = tipo;
  }

  falar() {
    console.log(`O ${this.tipo} está falando.`);
  }
}

class Cachorro extends Animal {
  constructor(nome) {
    super('cachorro');
    this.nome = nome;
  }

  latir() {
    console.log(`${this.nome} está latindo.`);
  }
}

const fido = new Cachorro('Fido');
fido.falar(); // O cachorro está falando.
fido.latir(); // Fido está latindo.

```

Internamente, `Cachorro` está utilizando herança prototípica para herdar de `Animal`.

### Interação com Métodos Nativos

Os métodos nativos do JavaScript também utilizam protótipos. Por exemplo, métodos de array como `map` e `filter` estão disponíveis através de `Array.prototype`.

```jsx
const numeros = [1, 2, 3];
const dobrados = numeros.map(num => num * 2);
console.log(dobrados); // [2, 4, 6]

```

## Exemplos de Código Otimizados

### Exemplo Básico de Prototype

```jsx
// Função construtora
function Pessoa(nome, idade) {
  this.nome = nome;
  this.idade = idade;
}

// Adicionando método ao prototype
Pessoa.prototype.apresentar = function() {
  console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
};

// Criando instâncias
const ana = new Pessoa('Ana', 28);
const bruno = new Pessoa('Bruno', 32);

ana.apresentar(); // Olá, meu nome é Ana e tenho 28 anos.
bruno.apresentar(); // Olá, meu nome é Bruno e tenho 32 anos.

```

### Herança Prototípica com Funções Construtoras

```jsx
// Função construtora base
function Animal(tipo) {
  this.tipo = tipo;
}

Animal.prototype.falar = function() {
  console.log(`O ${this.tipo} está falando.`);
};

// Função construtora derivada
function Gato(nome) {
  Animal.call(this, 'gato'); // Chama o construtor Animal
  this.nome = nome;
}

// Herança prototípica
Gato.prototype = Object.create(Animal.prototype);
Gato.prototype.constructor = Gato;

// Adicionando método específico
Gato.prototype.miar = function() {
  console.log(`${this.nome} está miando.`);
};

const felix = new Gato('Felix');
felix.falar(); // O gato está falando.
felix.miar(); // Felix está miando.

```

### Uso de Object.create()

```jsx
const veiculo = {
  iniciar() {
    console.log(`${this.modelo} está iniciando.`);
  },
  parar() {
    console.log(`${this.modelo} está parando.`);
  }
};

const carro = Object.create(veiculo);
carro.modelo = 'Fusca';
carro.iniciar(); // Fusca está iniciando.
carro.parar(); // Fusca está parando.

```

### Implementação de Mixins

```jsx
const nadador = {
  nadar() {
    console.log(`${this.nome} está nadando.`);
  }
};

const corredor = {
  correr() {
    console.log(`${this.nome} está correndo.`);
  }
};

function Atleta(nome) {
  this.nome = nome;
}

// Aplicando mixins
Object.assign(Atleta.prototype, nadador, corredor);

const atleta1 = new Atleta('Carlos');
atleta1.nadar(); // Carlos está nadando.
atleta1.correr(); // Carlos está correndo.

```

## Informações Adicionais

### Desempenho e Memória

Utilizar protótipos para compartilhar métodos entre objetos é mais eficiente em termos de memória do que definir métodos diretamente em cada instância. Isso ocorre porque todas as instâncias compartilham uma única cópia do método no prototype, em vez de cada uma ter sua própria cópia.

```jsx
function Pessoa(nome) {
  this.nome = nome;
}

// Método no prototype
Pessoa.prototype.dizerOla = function() {
  console.log(`Olá, eu sou ${this.nome}`);
};

// Alternativa menos eficiente
function PessoaIneficiente(nome) {
  this.nome = nome;
  this.dizerOla = function() {
    console.log(`Olá, eu sou ${this.nome}`);
  };
}

```

### Práticas Recomendadas

- **Adicionar Métodos ao Prototype**: Sempre que possível, adicione métodos ao prototype para economizar memória.
- **Evitar Modificar Prototypes de Objetos Nativos**: Modificar o prototype de objetos nativos como `Array` ou `String` pode causar conflitos e comportamentos inesperados.
- **Usar `Object.create()` para Herança Simples**: Para cenários onde a herança é simples, `Object.create()` pode ser mais claro e direto.

### Proxies e Reflections

As **Proxies** permitem interceptar operações em objetos, como leitura e escrita de propriedades. Isso pode ser utilizado em conjunto com protótipos para criar objetos mais dinâmicos.

```jsx
const handler = {
  get(target, prop, receiver) {
    console.log(`Propriedade ${prop} foi acessada.`);
    return Reflect.get(target, prop, receiver);
  }
};

const alvo = {
  nome: 'Proxy'
};

const proxy = new Proxy(alvo, handler);
console.log(proxy.nome); // Propriedade nome foi acessada. Proxy

```

## Referências para Estudo Independente

### Documentação Oficial

- [MDN Web Docs: Prototypes](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [MDN Web Docs: Object.prototype](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype)
- [ECMAScript Language Specification](https://tc39.es/ecma262/#sec-prototype)

### Livros e Leituras

- *You Don't Know JS: this & Object Prototypes* (Kyle Simpson) - [GitHub](https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed)
- *Eloquent JavaScript* (Marijn Haverbeke) - [Online](https://eloquentjavascript.net/)
- *JavaScript: The Good Parts* (Douglas Crockford)

### Cursos e Tutoriais Online

- [FreeCodeCamp: Object-Oriented Programming](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/object-oriented-programming/)
- [Codecademy: Learn JavaScript](https://www.codecademy.com/learn/introduction-to-javascript)
- [Udemy: JavaScript - The Advanced Concepts](https://www.udemy.com/course/advanced-javascript-concepts/)

### Artigos e Blogs

- [Understanding the Prototype Chain in JavaScript](https://www.sitepoint.com/understanding-javascript-prototype-chain/)
- [JavaScript Prototype Inheritance](https://www.digitalocean.com/community/tutorials/javascript-prototype-inheritance)

### Ferramentas e Recursos

- **Playgrounds Online**:
    - [CodeSandbox](https://codesandbox.io/)
    - [JSFiddle](https://jsfiddle.net/)
    - [CodePen](https://codepen.io/)
- **Linters e Formatação**:
    - [ESLint](https://eslint.org/)
    - [Prettier](https://prettier.io/)
- **IDE Extensions**:
    - [ESLint Extension para VSCode](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
    - [JavaScript (ES6) code snippets](https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets)

---

# Conclusão

Os **prototypes** em JavaScript são essenciais para entender como a linguagem gerencia a herança e a reutilização de código. Compreender os protótipos permite criar estruturas de objetos mais eficientes e flexíveis, além de ser a base para conceitos mais avançados como herança prototípica, mixins e a implementação de padrões de design.

Ao dominar os protótipos, você estará mais preparado para enfrentar desafios complexos no desenvolvimento JavaScript, escrevendo código mais limpo, eficiente e sustentável.

**Boa aprendizagem e sucesso na sua jornada com JavaScript!**