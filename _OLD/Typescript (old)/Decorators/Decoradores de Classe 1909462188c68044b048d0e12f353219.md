# Decoradores de Classe

## 1. Introdução

Os **decorators** são uma poderosa funcionalidade do TypeScript (e também do ECMAScript) que permite a modificação e extensão de classes, métodos, propriedades e parâmetros através de anotações. No contexto do desenvolvimento, os decorators facilitam a implementação de padrões como injeção de dependências, logging, monitoramento, e outras funcionalidades transversais, tornando o código mais modular e reutilizável.

**Decoradores de Classe** são uma forma específica de decorator que atua diretamente na definição da classe, permitindo que comportamentos ou metadados sejam adicionados ou modificados de forma declarativa. Essa abordagem melhora a legibilidade e manutenção do código, especialmente em projetos de larga escala.

## 2. Sumário

- [Definição e Conceitos Fundamentais](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#defini%C3%A7%C3%A3o-e-conceitos-fundamentais)
    - [O que são Decorators](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#o-que-s%C3%A3o-decorators)
    - [Decoradores de Classe](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#decoradores-de-classe)
    - [Conceitos Básicos vs. Avançados](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#conceitos-b%C3%A1sicos-vs-avan%C3%A7ados)
- [Sintaxe e Estrutura](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#sintaxe-e-estrutura)
    - [Declaração Básica de Decoradores de Classe](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#declara%C3%A7%C3%A3o-b%C3%A1sica-de-decoradores-de-classe)
    - [Exemplo de Utilização](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#exemplo-de-utiliza%C3%A7%C3%A3o)
- [Componentes Principais](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#componentes-principais)
    - [Função Decoradora](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#fun%C3%A7%C3%A3o-decoradora)
    - [Elementos e Propriedades Modificados](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#elementos-e-propriedades-modificados)
- [Uso Avançado](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#uso-avan%C3%A7ado)
    - [Casos de Uso Específicos e Reais](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#casos-de-uso-espec%C3%ADficos-e-reais)
- [Exemplos de Código Otimizados](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#exemplos-de-c%C3%B3digo-otimizados)
- [Informações Adicionais](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#informa%C3%A7%C3%B5es-adicionais)
- [Referências para Estudo Independente](https://chatgpt.com/c/67a22ce2-8578-8003-a4b4-36cbf36efed4#refer%C3%AAncias-para-estudo-independente)

## 3. Conteúdo Detalhado

### Definição e Conceitos Fundamentais

### O que são Decorators

Decorators são funções especiais que permitem modificar ou anotar classes e membros (métodos, propriedades, parâmetros) durante a declaração, antes mesmo de serem instanciadas. Eles funcionam de maneira similar a *annotations* em outras linguagens, como Java e C#.

### Decoradores de Classe

Os **decoradores de classe** são aplicados diretamente à definição de uma classe e recebem como parâmetro o construtor da classe. Eles podem:

- Modificar ou substituir o construtor da classe.
- Adicionar ou alterar metadados na classe.
- Integrar comportamentos adicionais sem alterar a implementação original.

### Conceitos Básicos vs. Avançados

- **Básicos:**
    - Entendimento da sintaxe e aplicação simples.
    - Uso para anotações e logging.
    - Não modificam drasticamente o comportamento da classe.
- **Avançados:**
    - Modificação e substituição do construtor.
    - Injeção de dependências.
    - Integração com frameworks e bibliotecas que utilizam metaprogramação.

### Sintaxe e Estrutura

### Declaração Básica de Decoradores de Classe

A sintaxe para definir um decorator de classe é simples. Um decorator é uma função que recebe, como parâmetro, o construtor da classe:

```tsx
function MeuDecorator(target: Function) {
  // Aqui, 'target' é o construtor da classe
  console.log(`Decorador aplicado à: ${target.name}`);
}

```

Para aplicá-lo, basta preceder a definição da classe com o `@` seguido do nome do decorator:

```tsx
@MeuDecorator
class Exemplo {
  constructor() {
    console.log("Instância de Exemplo criada");
  }
}

```

### Exemplo de Utilização

Neste exemplo simples, o decorator apenas loga o nome da classe quando ela é definida:

```tsx
function LogClasse(target: Function) {
  console.log(`Classe definida: ${target.name}`);
}

@LogClasse
class Pessoa {
  nome: string;

  constructor(nome: string) {
    this.nome = nome;
  }
}

const p = new Pessoa("João");
// Saída durante a definição: "Classe definida: Pessoa"
// Saída durante a instanciação: "Instância de Pessoa criada" (se adicionarmos esse log no construtor)

```

### Componentes Principais

### Função Decoradora

- **Parâmetro `target`:** Em um decorator de classe, o parâmetro recebido é o construtor da classe. Esse construtor pode ser usado para alterar comportamentos ou metadados da classe.
- **Retorno:** Um decorator pode retornar um novo construtor, substituindo o original, ou simplesmente executar operações sem alterar o construtor.

### Elementos e Propriedades Modificados

Dentro de um decorator de classe, é possível:

- **Adicionar propriedades ou métodos estáticos:** Por exemplo, adicionando metadados ou funções auxiliares.
- **Modificar o construtor:** Envolvendo o construtor original para injetar comportamentos adicionais, como logging ou validações.

Exemplo de modificação do construtor:

```tsx
function LogConstrutor<T extends { new(...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    constructor(...args: any[]) {
      console.log("Antes de chamar o construtor original");
      super(...args);
      console.log("Depois de chamar o construtor original");
    }
  }
}

@LogConstrutor
class Animal {
  nome: string;

  constructor(nome: string) {
    this.nome = nome;
    console.log(`Animal ${nome} criado.`);
  }
}

const animal = new Animal("Leão");
// Saída:
// "Antes de chamar o construtor original"
// "Animal Leão criado."
// "Depois de chamar o construtor original"

```

### Uso Avançado

### Casos de Uso Específicos e Reais

- **Injeção de Dependências:** Decorators podem ser usados para marcar classes ou propriedades para injeção automática de dependências em frameworks como Angular.
    
    ```tsx
    function Injectable(target: Function) {
      // Marcação de metadados para injeção de dependências
      Reflect.defineMetadata("injetavel", true, target);
    }
    
    @Injectable
    class Servico {
      // Lógica do serviço
    }
    
    ```
    
- **Registro e Monitoramento:** Utilizar decorators para registrar instâncias, monitorar a criação de objetos ou medir tempo de execução.
    
    ```tsx
    function MonitorarConstrutor<T extends { new(...args: any[]): {} }>(constructor: T) {
      return class extends constructor {
        constructor(...args: any[]) {
          console.time(`Tempo de criação de ${constructor.name}`);
          super(...args);
          console.timeEnd(`Tempo de criação de ${constructor.name}`);
        }
      }
    }
    
    @MonitorarConstrutor
    class Processamento {
      constructor() {
        // Simulação de processamento
        for (let i = 0; i < 1000000; i++) {}
      }
    }
    
    new Processamento();
    // Saída no console indicará o tempo de criação da instância
    
    ```
    
- **Validação e Transformação:** Decorators podem ser utilizados para validar ou transformar dados durante a instanciação de classes.

## 4. Exemplos de Código Otimizados

### Exemplo 1: Decorador Básico de Classe

```tsx
// Decorador simples que loga o nome da classe definida
function LogClasse(target: Function) {
  console.log(`Classe definida: ${target.name}`);
}

@LogClasse
class Usuario {
  constructor(public nome: string) {}
}

const usuario = new Usuario("Maria");
// Saída: "Classe definida: Usuario"

```

### Exemplo 2: Decorador Avançado Modificando o Construtor

```tsx
// Decorador que envolve o construtor para adicionar comportamento antes e depois da criação da instância
function EnvolverConstrutor<T extends { new(...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    constructor(...args: any[]) {
      console.log("Antes do construtor");
      super(...args);
      console.log("Depois do construtor");
    }
  }
}

@EnvolverConstrutor
class Produto {
  constructor(public nome: string, public preco: number) {
    console.log(`Produto criado: ${nome} - R$ ${preco}`);
  }
}

const produto = new Produto("Notebook", 3500);
// Saída:
// "Antes do construtor"
// "Produto criado: Notebook - R$ 3500"
// "Depois do construtor"

```

## 5. Informações Adicionais

- **Compatibilidade e Configuração:** Para utilizar decorators em TypeScript, é necessário habilitar a opção `experimentalDecorators` no `tsconfig.json`:
    
    ```json
    {
      "compilerOptions": {
        "experimentalDecorators": true
      }
    }
    
    ```
    
- **Metaprogramação:** Decorators podem trabalhar em conjunto com a API de metadata do TypeScript, permitindo armazenar e recuperar metadados através do `Reflect.defineMetadata` e `Reflect.getMetadata`.
- **Limitações:** Embora sejam poderosos, os decorators podem complicar o debug e a manutenção se utilizados de forma inadequada. É importante documentar bem os comportamentos adicionados e manter a consistência em projetos colaborativos.

## 6. Referências para Estudo Independente

- [Documentação Oficial do TypeScript sobre Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [Artigo: "Understanding TypeScript Decorators"](https://blog.bitsrc.io/understanding-typescript-decorators-cf6a2c0f0f3a)
- [Livro: "Pro TypeScript: Application-Scale JavaScript Development"](https://www.apress.com/gp/book/9781484209749)
- [Tutorial no YouTube: "TypeScript Decorators Tutorial"](https://www.youtube.com/results?search_query=typescript+decorators+tutorial)

---

Este guia detalhado abrange desde os conceitos básicos até usos avançados de decoradores de classe em TypeScript. Com exemplos práticos e uma abordagem estruturada, espera-se que desenvolvedores possam integrar essa funcionalidade em seus projetos, melhorando a modularidade e a clareza do código.