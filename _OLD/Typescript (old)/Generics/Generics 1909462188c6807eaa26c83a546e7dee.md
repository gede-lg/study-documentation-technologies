# Generics

## 1. Introdução

Generics são um recurso poderoso do TypeScript que permite a criação de componentes e funções reutilizáveis, proporcionando segurança de tipo sem sacrificar a flexibilidade. Ao permitir que os desenvolvedores escrevam código que funciona com múltiplos tipos, os generics melhoram a escalabilidade e a robustez de aplicações, facilitando a manutenção e a evolução do código.

A utilização de generics é especialmente relevante em contextos onde componentes devem operar com diversos tipos de dados, como em **arrays** e **promises**. Essa abordagem evita a repetição de código e ajuda a detectar erros de tipo durante o desenvolvimento, o que é essencial em projetos de larga escala.

## 2. Sumário

1. [Introdução](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#1-introdu%C3%A7%C3%A3o)
2. [Sumário](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#2-sum%C3%A1rio)
3. [Conteúdo Detalhado](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#3-conte%C3%BAdo-detalhado)
    - [Definição e Conceitos Fundamentais](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#defini%C3%A7%C3%A3o-e-conceitos-fundamentais)
    - [Sintaxe e Estrutura](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#sintaxe-e-estrutura)
    - [Componentes Principais](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#componentes-principais)
    - [Uso Avançado](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#uso-avan%C3%A7ado)
4. [Exemplos de Código Otimizados](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#4-exemplos-de-c%C3%B3digo-otimizados)
5. [Informações Adicionais](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#5-informa%C3%A7%C3%B5es-adicionais)
6. [Referências para Estudo Independente](https://chatgpt.com/c/67a13af9-f1c4-8003-8148-7daff446d1b7#6-refer%C3%AAncias-para-estudo-independente)

## 3. Conteúdo Detalhado

### Definição e Conceitos Fundamentais

- **O que são Generics?**
    
    Generics são uma ferramenta que permite a criação de componentes (funções, classes, interfaces, etc.) que podem trabalhar com diferentes tipos de dados sem perder a segurança de tipos. Eles são definidos como parâmetros de tipo que são especificados no momento da utilização, permitindo que o mesmo bloco de código funcione com diversos tipos.
    
- **Uso Básico vs. Uso Avançado:**
    - **Básico:** Permite a criação de funções e classes genéricas que operam com qualquer tipo.*Exemplo:* Uma função que retorna o mesmo valor que recebe, independentemente do tipo.
    - **Avançado:** Inclui o uso de restrições de tipo (constraints), parâmetros de tipo padrão, e combinações com outros recursos do TypeScript para criar APIs mais robustas.

### Sintaxe e Estrutura

### Declaração Básica

A sintaxe básica para definir um generic é utilizando colchetes angulares (`<T>`) após o nome da função, classe ou interface.

```tsx
function identity<T>(arg: T): T {
  return arg;
}

```

Neste exemplo, `T` é um parâmetro de tipo que pode representar qualquer tipo. A função `identity` aceita um argumento do tipo `T` e retorna um valor do mesmo tipo.

### Arrays e Promises como Exemplos de Generics

- **Arrays:**
O TypeScript utiliza generics para definir a tipagem de arrays.
    
    ```tsx
    let numeros: Array<number> = [1, 2, 3, 4];
    // Ou de forma mais comum:
    let palavras: string[] = ['TypeScript', 'Generics', 'Exemplo'];
    
    ```
    
- **Promises:**
Ao trabalhar com promises, os generics definem o tipo de valor que a promise resolverá.

Neste exemplo, `Promise<string>` indica que a promise resolverá com uma string.
    
    ```tsx
    function fetchData(url: string): Promise<string> {
      return fetch(url)
        .then(response => response.text());
    }
    
    ```
    

### Componentes Principais

### Funções Genéricas

Funções genéricas permitem que o tipo seja inferido ou especificado pelo usuário.

```tsx
function reverseArray<T>(items: T[]): T[] {
  return items.reverse();
}

const numerosRevertidos = reverseArray([1, 2, 3]);  // Tipo inferido: number[]
const stringsRevertidas = reverseArray(['a', 'b', 'c']);  // Tipo inferido: string[]

```

### Classes Genéricas

Classes podem ser definidas com parâmetros de tipo para criar estruturas de dados reutilizáveis.

```tsx
class Caixa<T> {
  private conteudo: T;

  constructor(conteudo: T) {
    this.conteudo = conteudo;
  }

  public obterConteudo(): T {
    return this.conteudo;
  }
}

const caixaDeNumero = new Caixa<number>(123);
const caixaDeString = new Caixa<string>('Olá Generics!');

```

### Interfaces Genéricas

Interfaces genéricas definem contratos que podem ser aplicados a múltiplos tipos.

```tsx
interface Par<K, V> {
  chave: K;
  valor: V;
}

const parExemplo: Par<number, string> = {
  chave: 1,
  valor: "um"
};

```

### Uso Avançado

### Restrições de Generics (Constraints)

Restrições permitem limitar os tipos que podem ser utilizados como argumento para um generic.

```tsx
interface Comprensivel {
  length: number;
}

function exibirComprimento<T extends Comprensivel>(elemento: T): void {
  console.log(elemento.length);
}

exibirComprimento("TypeScript");  // OK: string possui a propriedade length
exibirComprimento([1, 2, 3]);       // OK: array possui a propriedade length
// exibirComprimento(123);         // Erro: number não possui a propriedade length

```

### Parâmetros de Tipo Padrão

É possível definir um tipo padrão para o parâmetro genérico, caso nenhum seja especificado.

```tsx
function criarArray<T = number>(elementos: T[]): T[] {
  return new Array<T>().concat(elementos);
}

const arrayPadrao = criarArray([1, 2, 3]);  // Usa o tipo number por padrão

```

### Uso de Generics em Funções Complexas

Combinar generics com outros recursos, como funções de callback, permite criar APIs robustas.

```tsx
function mapArray<T, U>(array: T[], callback: (item: T) => U): U[] {
  const resultado: U[] = [];
  for (let i = 0; i < array.length; i++) {
    resultado.push(callback(array[i]));
  }
  return resultado;
}

const numeros = [1, 2, 3];
const strings = mapArray(numeros, num => `Número: ${num}`);

```

## 4. Exemplos de Código Otimizados

### Exemplo 1: Função Identity Genérica

```tsx
/**
 * Retorna o mesmo valor que foi passado como argumento.
 * @param arg - Valor de qualquer tipo.
 * @returns O mesmo valor, com o tipo inferido.
 */
function identity<T>(arg: T): T {
  return arg;
}

console.log(identity<number>(42));      // Saída: 42
console.log(identity<string>('Generics')); // Saída: Generics

```

### Exemplo 2: Manipulação de Arrays Genéricos

```tsx
/**
 * Inverte a ordem dos elementos de um array.
 * @param items - Array de elementos genéricos.
 * @returns Um novo array com os elementos em ordem inversa.
 */
function reverseArray<T>(items: T[]): T[] {
  return items.slice().reverse(); // slice() para evitar modificar o array original
}

const numeros = [1, 2, 3, 4, 5];
const numerosInvertidos = reverseArray(numeros);
console.log(numerosInvertidos); // Saída: [5, 4, 3, 2, 1]

```

### Exemplo 3: Utilizando Generics com Promises

```tsx
/**
 * Simula a obtenção de dados de uma API.
 * @param url - URL da API.
 * @returns Uma Promise que resolve para uma string com os dados.
 */
function fetchData(url: string): Promise<string> {
  return fetch(url)
    .then(response => response.text())
    .catch(error => {
      console.error("Erro ao buscar dados:", error);
      throw error;
    });
}

fetchData('https://exemplo.com/api/dados')
  .then(data => console.log(data))
  .catch(error => console.error(error));

```

### Exemplo 4: Classe Genérica com Restrições

```tsx
/**
 * Interface que define que o tipo deve possuir a propriedade 'length'.
 */
interface Comprensivel {
  length: number;
}

/**
 * Classe que trabalha com um conteúdo do tipo que implementa Comprensivel.
 */
class Caixa<T extends Comprensivel> {
  private conteudo: T;

  constructor(conteudo: T) {
    this.conteudo = conteudo;
  }

  /**
   * Retorna o conteúdo e seu comprimento.
   */
  public obterInformacoes(): { conteudo: T; comprimento: number } {
    return {
      conteudo: this.conteudo,
      comprimento: this.conteudo.length,
    };
  }
}

const caixaDeTexto = new Caixa<string>("Olá, Generics!");
console.log(caixaDeTexto.obterInformacoes());

```

## 5. Informações Adicionais

- **Inferência de Tipos:**
    
    O TypeScript é capaz de inferir automaticamente o tipo dos generics em muitos casos, o que pode tornar o código mais limpo e reduz a necessidade de anotações explícitas.
    
- **Vantagens dos Generics:**
    - **Reusabilidade:** Código escrito de forma genérica pode ser reutilizado com diferentes tipos.
    - **Segurança de Tipo:** Reduz erros em tempo de compilação ao garantir que os tipos estejam corretos.
    - **Flexibilidade:** Permite a criação de APIs flexíveis que podem se adaptar a diversas necessidades sem duplicação de código.
- **Cenários de Uso Comum:**
    - Estruturas de dados (listas, filas, pilhas)
    - Funções utilitárias (map, filter, reduce)
    - Integração com bibliotecas e frameworks que exigem manipulação de dados com tipos variados

## 6. Referências para Estudo Independente

- **Documentação Oficial do TypeScript:**
    
    [TypeScript Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
    
- **Artigos e Tutoriais:**
    - [Understanding TypeScript Generics](https://blog.logrocket.com/understanding-typescript-generics/)
    - [Advanced TypeScript Generics](https://dev.to/dabit3/advanced-typescript-generics-3imc)
- **Livros:**
    - *Programming TypeScript* por Boris Cherny
    - *TypeScript Quickly* por Yakov Fain e Anton Moiseev
- **Cursos Online:**
    - [TypeScript Fundamentals](https://www.pluralsight.com/courses/typescript) – Pluralsight
    - [Understanding TypeScript](https://www.udemy.com/course/understanding-typescript/) – Udemy

---

Este guia detalhado sobre **Generics** em TypeScript apresenta desde conceitos básicos até usos avançados, proporcionando uma compreensão sólida e exemplos práticos para desenvolvedores que desejam aprimorar suas habilidades com este recurso essencial da linguagem.