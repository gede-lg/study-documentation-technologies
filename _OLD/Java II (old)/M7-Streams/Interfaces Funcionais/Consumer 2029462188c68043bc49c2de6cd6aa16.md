# Consumer

## Interface Funcional Padrão: `Consumer<T>` em Java

### Introdução

No universo do Java moderno, especialmente a partir da versão 8, a programação funcional ganhou um destaque enorme com a introdução das Expressões Lambda e da Streams API. Nesse contexto, as interfaces funcionais se tornaram pilares para escrever código mais conciso, legível e expressivo. Entre elas, a interface `Consumer<T>` desempenha um papel fundamental, sendo uma das interfaces funcionais padrão mais utilizadas.

A relevância da `Consumer<T>` reside na sua capacidade de encapsular operações que consomem (aceitam) um único argumento de um determinado tipo e não retornam nenhum resultado. Isso a torna ideal para cenários onde você precisa executar uma ação lateral em elementos de uma coleção, como imprimir, logar, ou modificar um estado externo (com cuidado, em programação funcional). Para um desenvolvedor backend como você, Gedê, entender o `Consumer` é crucial, pois ele aparece frequentemente em operações de processamento de dados em lotes, callbacks e manipulação de fluxos em frameworks como o Spring, onde a clareza e a eficiência do código são primordiais.

### Definição e Conceitos Fundamentais

A interface `java.util.function.Consumer<T>` representa uma operação que aceita um único argumento de entrada do tipo `T` e não retorna nenhum resultado. A letra `T` é um parâmetro de tipo genérico que indica o tipo do argumento que será consumido. O principal objetivo do `Consumer` é executar uma ação sobre o dado de entrada.

### Sumário

- **Sintaxe e Estrutura**
- **Componentes Principais: Método `accept()`**
- **Método `andThen()`**
- **Restrições de Uso**
- **Exemplos de Código Otimizados**
- **Informações Adicionais**
- **Referências para Estudo Independente**

### Conteúdo Detalhado

### Sintaxe e Estrutura

Por ser uma interface funcional, `Consumer<T>` possui um único método abstrato (`accept`), o que a torna um alvo perfeito para ser implementada via Expressões Lambda.

A declaração da interface é simples:

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);

    // Métodos default e static adicionados a partir do Java 8
    default Consumer<T> andThen(Consumer<? super T> after) {
        // ... implementação padrão ...
    }
}

```

**Exemplos de declaração e utilização:**

**1. Usando uma classe anônima (forma antiga, mas válida para entender):**

```java
import java.util.function.Consumer;

public class ExemploConsumerAnonimo {
    public static void main(String[] args) {
        Consumer<String> impressor = new Consumer<String>() {
            @Override
            public void accept(String texto) {
                System.out.println("Processando: " + texto);
            }
        };

        impressor.accept("Olá, Gedê!");
    }
}

```

**2. Usando Expressão Lambda (forma mais comum e idiomática no Java moderno):**

```java
import java.util.function.Consumer;

public class ExemploConsumerLambda {
    public static void main(String[] args) {
        // Consumer que imprime o valor
        Consumer<String> impressor = texto -> System.out.println("Mensagem: " + texto);
        impressor.accept("Olá, Ju!");

        // Consumer que dobra um número e imprime
        Consumer<Integer> dobradorEImpressor = numero -> {
            int resultado = numero * 2;
            System.out.println("O dobro de " + numero + " é " + resultado);
        };
        dobradorEImpressor.accept(10);
    }
}

```

**3. Usando Method Reference (referência de método) - a forma mais concisa:**

```java
import java.util.function.Consumer;
import java.util.Arrays;
import java.util.List;

public class ExemploConsumerMethodReference {
    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("Luiz", "Juliana", "João", "Maria");

        // Usando method reference para System.out::println
        nomes.forEach(System.out::println);

        // O forEach do List aceita um Consumer como argumento
        // É equivalente a: nomes.forEach(nome -> System.out.println(nome));
    }
}

```

### Componentes Principais: Método `accept()`

- **`void accept(T t)`**: Este é o único método abstrato da interface `Consumer<T>`. Ele é responsável por "consumir" o argumento `t` do tipo genérico `T`. A implementação deste método define a ação que será executada sobre o valor de entrada. Como o retorno é `void`, significa que não há nenhum valor de saída da operação; ela apenas realiza uma ação.

### Método `andThen()`

Além do método abstrato `accept()`, a interface `Consumer` também possui um método *default* chamado `andThen()`. Este método é super útil para encadear múltiplas operações `Consumer` em sequência.

- **`default Consumer<T> andThen(Consumer<? super T> after)`**: Este método permite compor um `Consumer` com outro. Ele retorna um novo `Consumer` que executa a operação do `Consumer` atual e, em seguida, a operação do `Consumer` `after`. Se a execução do `after` `Consumer` resultar em uma exceção, ela será lançada.

**Exemplo de uso de `andThen()`:**

```java
import java.util.function.Consumer;

public class ExemploConsumerAndThen {
    public static void main(String[] args) {
        Consumer<String> consumer1 = s -> System.out.println("Consumer 1: " + s.toUpperCase());
        Consumer<String> consumer2 = s -> System.out.println("Consumer 2: " + s.toLowerCase());
        Consumer<String> consumer3 = s -> System.out.println("Consumer 3: Tamanho da string = " + s.length());

        // Encadeando consumidores
        Consumer<String> combinedConsumer = consumer1.andThen(consumer2).andThen(consumer3);

        combinedConsumer.accept("Olá Mundo Java");
        // Saída esperada:
        // Consumer 1: OLÁ MUNDO JAVA
        // Consumer 2: olá mundo java
        // Consumer 3: Tamanho da string = 16
    }
}

```

### Restrições de Uso

Embora poderosa, a `Consumer<T>` possui algumas características que devem ser consideradas:

- **Não retorna valor:** Por definição, o método `accept()` é `void`. Se você precisa de uma operação que retorne um valor, outras interfaces funcionais como `Function<T, R>` ou `Supplier<T>` seriam mais apropriadas.
- **Efeitos colaterais:** Embora seja utilizada para operações com efeitos colaterais (como imprimir no console, salvar em um banco de dados, etc.), em um contexto de programação funcional pura, o ideal seria minimizar esses efeitos. No entanto, em um ambiente backend com Java, efeitos colaterais são uma realidade e o `Consumer` é a ferramenta certa para gerenciá-los de forma encapsulada.
- **Tratamento de Exceções:** O método `accept()` não declara checked exceptions. Se a sua implementação interna lançar uma checked exception, você precisará tratá-la dentro do lambda (com `try-catch`) ou reembalá-la como uma `RuntimeException`.

### Exemplos de Código Otimizados

### Caso de Uso 1: Processando elementos em uma lista (Básico)

Imagine que você tem uma lista de produtos e quer aplicar um desconto a cada um deles.

```java
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

class Produto {
    String nome;
    BigDecimal preco;

    public Produto(String nome, BigDecimal preco) {
        this.nome = nome;
        this.preco = preco;
    }

    public void aplicarDesconto(BigDecimal percentual) {
        this.preco = this.preco.subtract(this.preco.multiply(percentual.divide(new BigDecimal(100))));
    }

    @Override
    public String toString() {
        return "Produto{" + "nome='" + nome + '\\'' + ", preco=" + preco + '}';
    }
}

public class ExemploConsumerProduto {
    public static void main(String[] args) {
        List<Produto> produtos = Arrays.asList(
            new Produto("Notebook", new BigDecimal("5000.00")),
            new Produto("Mouse", new BigDecimal("150.00")),
            new Produto("Teclado", new BigDecimal("300.00"))
        );

        // Consumer que aplica um desconto de 10%
        Consumer<Produto> aplicarDesconto10Porcento = produto -> {
            produto.aplicarDesconto(new BigDecimal("10"));
            System.out.println("Desconto aplicado: " + produto.nome + " agora custa " + produto.preco);
        };

        System.out.println("--- Produtos antes do desconto ---");
        produtos.forEach(System.out::println);

        System.out.println("\\n--- Aplicando desconto de 10% ---");
        // Usando forEach da Stream API (ou da Collection) que aceita um Consumer
        produtos.forEach(aplicarDesconto10Porcento);

        System.out.println("\\n--- Produtos depois do desconto ---");
        produtos.forEach(System.out::println);
    }
}

```

### Caso de Uso 2: Logando informações em um serviço (Avançado/Backend)

Em um serviço backend, é comum ter a necessidade de logar eventos ou dados. O `Consumer` pode ser usado para encapsular a lógica de logging.

```java
import java.time.LocalDateTime;
import java.util.function.Consumer;

// Simula um Logger de verdade
class CustomLogger {
    public static void logInfo(String message) {
        System.out.println("[INFO] " + LocalDateTime.now() + " - " + message);
    }

    public static void logError(String message, Throwable t) {
        System.err.println("[ERROR] " + LocalDateTime.now() + " - " + message + " | Exceção: " + t.getMessage());
    }
}

class UserService {
    // Consumer para logar informações de sucesso
    private final Consumer<String> successLogger = msg -> CustomLogger.logInfo("Operação de usuário bem-sucedida: " + msg);

    // Consumer para logar erros, aceitando uma RuntimeException
    private final Consumer<RuntimeException> errorLogger = ex ->
        CustomLogger.logError("Erro na operação de usuário: " + ex.getMessage(), ex);

    public void createUser(String username, String password) {
        try {
            // Lógica para criar usuário no banco de dados
            if (username.isEmpty() || password.isEmpty()) {
                throw new IllegalArgumentException("Nome de usuário e senha não podem ser vazios.");
            }
            System.out.println("Criando usuário: " + username);
            // ... salvar no banco de dados ...
            successLogger.accept("Usuário '" + username + "' criado com sucesso.");
        } catch (IllegalArgumentException e) {
            errorLogger.accept(e); // Consumindo a exceção
        } catch (Exception e) {
            errorLogger.accept(new RuntimeException("Erro inesperado ao criar usuário: " + e.getMessage(), e));
        }
    }
}

public class ExemploConsumerLogging {
    public static void main(String[] args) {
        UserService userService = new UserService();
        userService.createUser("GedeDev", "senhaSegura123");
        System.out.println("----");
        userService.createUser("", "123"); // Simula um erro
    }
}

```

### Caso de Uso 3: Executando múltiplas ações em um pipeline de processamento (Avançado)

Com a Streams API, o `Consumer` é frequentemente usado em operações terminais como `forEach` para realizar ações em cada elemento do stream.

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class ExemploConsumerPipeline {

    public static void main(String[] args) {
        List<String> emails = Arrays.asList(
            "gededev@example.com",
            "ju.fisioterapeuta@dominio.com",
            "suporte@empresa.com",
            "invalido.com" // Simula um e-mail inválido para o filtro
        );

        // Consumer para simular o envio de um e-mail
        Consumer<String> enviarEmailConsumer = email -> System.out.println("Enviando e-mail para: " + email);

        // Consumer para logar o processamento
        Consumer<String> logProcessamentoConsumer = email -> System.out.println("Processado: " + email);

        // Consumer para atualizar um status no banco (simulado)
        Consumer<String> atualizarStatusConsumer = email -> System.out.println("Status atualizado para: " + email);

        System.out.println("--- Processando e-mails válidos ---");
        emails.stream()
              .filter(email -> email.contains("@") && email.contains(".")) // Filtra e-mails básicos
              .peek(logProcessamentoConsumer) // peek aceita um Consumer e executa uma ação sem modificar o stream
              .forEach(enviarEmailConsumer.andThen(atualizarStatusConsumer)); // Encadeando ações para cada email válido

        // Saída esperada (pode variar ligeiramente dependendo do timing):
        // --- Processando e-mails válidos ---
        // Processado: gededev@example.com
        // Enviando e-mail para: gededev@example.com
        // Status atualizado para: gededev@example.com
        // Processado: ju.fisioterapeuta@dominio.com
        // Enviando e-mail para: ju.fisioterapeuta@dominio.com
        // Status atualizado para: ju.fisioterapeuta@dominio.com
        // Processado: suporte@empresa.com
        // Enviando e-mail para: suporte@empresa.com
        // Status atualizado para: suporte@empresa.com
    }
}

```

### Informações Adicionais

- **Composição com `andThen()`**: A capacidade de encadear `Consumer`s usando `andThen()` é um excelente exemplo de como a programação funcional promove a modularidade e a reutilização de código. Você pode construir lógicas complexas a partir de blocos de consumo menores e mais focados.
- **Paralelismo com Streams**: Ao usar `Consumer` com `parallelStream().forEach()`, é crucial garantir que as operações dentro do seu `Consumer` sejam *thread-safe*, especialmente se elas modificarem estados externos. Se as operações não forem thread-safe, você pode ter problemas de `Race Condition`.
- **`BiConsumer<T, U>`**: Para casos onde você precisa consumir dois argumentos em vez de um, o Java oferece a interface `BiConsumer<T, U>`, que possui o método `void accept(T t, U u)`. Isso é útil, por exemplo, para iterar sobre `Map.entrySet()` ou para operações que precisam de dois inputs.
- **Aplicações em Frameworks**: Em frameworks como Spring, `Consumer`s são frequentemente usados em configurações de beans, processamento de mensagens assíncronas (como com RabbitMQ ou Kafka), ou ao definir callbacks para eventos. Por exemplo, em uma configuração do Spring Security, você pode usar um `Consumer` para configurar o `UserDetailsService`.

### Referências para Estudo Independente

Para aprofundar seu conhecimento sobre `Consumer` e programação funcional em Java, Gedê, sugiro os seguintes recursos:

- **Documentação Oficial da Oracle - `Consumer`:**[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Consumer.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Consumer.html)
- **Documentação Oficial da Oracle - `java.util.function` Package:**[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html)
- **Baeldung - Java 8 Consumer Interface:** Um ótimo artigo com muitos exemplos práticos.
[https://www.baeldung.com/java-8-consumer-interface](https://www.baeldung.com/java-8-consumer-interface)
- **GeeksforGeeks - Consumer Interface in Java:** Outro bom recurso com exemplos e explicações.
[https://www.geeksforgeeks.org/consumer-interface-in-java/](https://www.geeksforgeeks.org/consumer-interface-in-java/)

Espero que esta explicação detalhada ajude você a dominar a `Consumer<T>` e a aplicá-la com confiança nos seus projetos de Backend Java\! Me diga qual o próximo tópico que você quer que eu detalhe.