# Function

## **Interface `Function<T, R>` no Java: Transformando Dados de Forma Funcional**

### **1. Introdução**

Com a introdução do Java 8, a linguagem abraçou fortemente os paradigmas da programação funcional, trazendo consigo um conjunto robusto de interfaces funcionais. Entre elas, a interface `Function<T, R>` se destaca por sua simplicidade e poder, atuando como uma ponte para transformar um tipo de dado em outro.

No contexto do desenvolvimento backend, onde a manipulação e transformação de dados são operações diárias, a `Function<T, R>` é de suma importância. Ela permite escrever código mais conciso, legível e testável, facilitando operações comuns como mapeamento de objetos DTOs para entidades, conversão de tipos para persistência ou apresentação, e a criação de pipelines de processamento de dados com a Stream API. Sua relevância reside na capacidade de modelar transformações de forma declarativa, o que é fundamental para a manutenção e evolução de sistemas complexos.

A `Function<T, R>` é uma interface funcional que representa uma função que aceita um argumento de um tipo (`T`) e produz um resultado de outro tipo (`R`). O "para que serve" é exatamente para essa capacidade de mapeamento ou transformação: dado um valor de entrada, ela retorna um valor de saída.

### **2. Sumário**

- **Definição e Conceitos**
- **Sintaxe e Estrutura**
- **Componentes Principais**
- **Exemplos de Código Otimizados**
- **Informações Adicionais**
- **Referências para Estudo Independente**

### **3. Conteúdo Detalhado**

### **Sintaxe e Estrutura**

A `Function<T, R>` é uma interface que possui um único método abstrato, o que a torna uma interface funcional e permite que seja utilizada com expressões Lambda ou referências de métodos.

A sintaxe básica para declarar e utilizar uma `Function` é a seguinte:

```java
import java.util.function.Function;

// Declaração de uma Function que recebe um String e retorna um Integer
Function<String, Integer> stringLengthFunction = (String s) -> s.length();

// Utilização da Function
Integer length = stringLengthFunction.apply("Olá, Gedê!"); // length será 11

```

No exemplo acima:

- `Function<String, Integer>`: Indica que a função receberá um `String` (`T`) e retornará um `Integer` (`R`).
- `(String s) -> s.length()`: É a expressão Lambda que implementa o método `apply`. Ela recebe uma string `s` e retorna o comprimento dessa string.

### **Componentes Principais**

A interface `Function<T, R>` define três métodos principais, sendo um abstrato e dois métodos *default* (que possuem uma implementação padrão e podem ser encadeados):

1. **`R apply(T t)` (Método Abstrato)**
    - **Descrição:** Este é o coração da interface. É o método abstrato que deve ser implementado pela expressão Lambda ou referência de método. Ele recebe um argumento do tipo `T` e retorna um resultado do tipo `R`.
    - **Finalidade:** Realizar a lógica de transformação do objeto de entrada para o objeto de saída.
2. **`default <V> Function<T, V> andThen(Function<? super R, ? extends V> after)`**
    - **Descrição:** Permite encadear outra `Function` (*after*) a esta `Function`. A `Function` *after* será aplicada ao resultado desta `Function*.
    - **Finalidade:** Compor múltiplas transformações de forma sequencial. A saída da primeira função se torna a entrada da próxima.
    - **Exemplo de interação:** Se você tem `f1: A -> B` e `f2: B -> C`, então `f1.andThen(f2)` resulta em `f3: A -> C`. A execução acontece na ordem: primeiro `f1`, depois `f2`.
3. **`default <V> Function<V, R> compose(Function<? super V, ? extends T> before)`**
    - **Descrição:** Permite encadear esta `Function` a outra `Function` (*before*). A `Function` *before* será aplicada primeiro, e seu resultado será a entrada desta `Function`.
    - **Finalidade:** Compor múltiplas transformações de forma sequencial, mas em ordem inversa de aplicação.
    - **Exemplo de interação:** Se você tem `f1: A -> B` e `f2: B -> C`, então `f2.compose(f1)` resulta em `f3: A -> C`. A execução acontece na ordem: primeiro `f1`, depois `f2`. Note que é o oposto do `andThen`.

### **Restrições de Uso**

- **Tipos de Dados:** Os tipos `T` e `R` devem ser tipos de referência (classes). Para tipos primitivos como `int`, `double`, etc., o Java fornece interfaces funcionais especializadas para evitar autoboxing/unboxing, como `IntFunction`, `DoubleFunction`, `ToIntFunction`, `ToDoubleFunction`, `IntToDoubleFunction`, etc. Isso é importante para otimização de performance, especialmente em operações que envolvem grandes volumes de dados.
- **Side Effects:** Embora não seja uma restrição imposta pelo compilador, a boa prática da programação funcional sugere que as funções devem ser *puras*. Isso significa que elas devem produzir o mesmo resultado para as mesmas entradas e não devem causar efeitos colaterais (alterar o estado de variáveis externas ou sistemas). Isso torna o código mais fácil de entender, testar e paralelizar.

### **4. Exemplos de Código Otimizados**

Vamos a alguns exemplos práticos que você, Gedê, pode encontrar no seu dia a dia como desenvolvedor backend:

### **Exemplo Básico: Conversão de String para Int**

```java
import java.util.function.Function;

public class ExemploFunctionBasico {

    public static void main(String[] args) {
        // Cenário: Converter strings que representam números em inteiros.
        // Isso é comum ao ler dados de arquivos ou requisições HTTP.

        Function<String, Integer> stringParaInteiro = s -> Integer.parseInt(s);

        String numeroComoString = "12345";
        Integer numeroInteiro = stringParaInteiro.apply(numeroComoString);

        System.out.println("String original: " + numeroComoString); // Saída: String original: 12345
        System.out.println("Número inteiro: " + numeroInteiro);     // Saída: Número inteiro: 12345
        System.out.println("Tipo da variável: " + numeroInteiro.getClass().getName()); // Saída: Tipo da variável: java.lang.Integer
    }
}

```

### **Exemplo Intermediário: Mapeamento de DTO para Entidade (Comum em REST APIs)**

Imagine que você tem um DTO (`PessoaDTO`) vindo de uma requisição e precisa convertê-lo para uma entidade de banco de dados (`Pessoa`).

```java
import java.util.function.Function;
import java.time.LocalDate;

// Classe de exemplo - DTO (Data Transfer Object)
class PessoaDTO {
    private String nome;
    private String sobrenome;
    private String dataNascimento; // Ex: "19/09/2001"

    public PessoaDTO(String nome, String sobrenome, String dataNascimento) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
    }

    public String getNome() { return nome; }
    public String getSobrenome() { return sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
}

// Classe de exemplo - Entidade de Domínio
class Pessoa {
    private String nomeCompleto;
    private LocalDate dataNascimento;
    private int idade; // Calculada

    public Pessoa(String nomeCompleto, LocalDate dataNascimento) {
        this.nomeCompleto = nomeCompleto;
        this.dataNascimento = dataNascimento;
        this.idade = LocalDate.now().getYear() - dataNascimento.getYear();
    }

    public String getNomeCompleto() { return nomeCompleto; }
    public LocalDate getDataNascimento() { return dataNascimento; }
    public int getIdade() { return idade; }

    @Override
    public String toString() {
        return "Pessoa [Nome Completo=" + nomeCompleto + ", Data Nascimento=" + dataNascimento + ", Idade=" + idade + "]";
    }
}

public class ExemploFunctionDTO {

    public static void main(String[] args) {
        PessoaDTO gededto = new PessoaDTO("Luiz Gustavo", "Damasceno", "19/09/2001");

        // Função para converter PessoaDTO para Pessoa
        // Nota: A conversão de data de String para LocalDate pode ser uma função separada ou inline.
        Function<PessoaDTO, Pessoa> dtoParaPessoa = dto -> {
            String[] partesData = dto.getDataNascimento().split("/");
            LocalDate dataNascimento = LocalDate.of(
                Integer.parseInt(partesData[2]), // Ano
                Integer.parseInt(partesData[1]), // Mês
                Integer.parseInt(partesData[0])  // Dia
            );
            return new Pessoa(dto.getNome() + " " + dto.getSobrenome(), dataNascimento);
        };

        Pessoa gedefinal = dtoParaPessoa.apply(gededto);
        System.out.println("DTO original: " + gededto.getNome() + " " + gededto.getSobrenome());
        System.out.println("Pessoa convertida: " + gedefinal); // Saída: Pessoa [Nome Completo=Luiz Gustavo Damasceno, Data Nascimento=2001-09-19, Idade=23]
    }
}

```

### **Exemplo Avançado: Encadeamento de Funções com `andThen` e `compose` na Stream API**

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class ExemploFunctionComposicao {

    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("gedê", "ju", "maria", "joão");

        // Cenário: Pegar uma lista de nomes em minúsculas, capitalizar a primeira letra,
        // adicionar um sufixo e depois converter para maiúsculas.

        // 1. Função para capitalizar a primeira letra
        Function<String, String> capitalizarPrimeiraLetra = s ->
            s.substring(0, 1).toUpperCase() + s.substring(1);

        // 2. Função para adicionar um sufixo
        Function<String, String> adicionarSufixo = s -> s + "_DEV";

        // 3. Função para converter para maiúsculas
        Function<String, String> paraMaiusculas = String::toUpperCase; // Referência de método

        System.out.println("Nomes originais: " + nomes);

        // Usando andThen: aplica em ordem (capitalizar -> sufixo -> maiusculas)
        Function<String, String> pipelineAndThen = capitalizarPrimeiraLetra
            .andThen(adicionarSufixo)
            .andThen(paraMaiusculas);

        List<String> nomesProcessadosAndThen = nomes.stream()
            .map(pipelineAndThen)
            .collect(Collectors.toList());

        System.out.println("Processado com andThen: " + nomesProcessadosAndThen);
        // Saída esperada: [GEDÊ_DEV, JU_DEV, MARIA_DEV, JOÃO_DEV]

        // Usando compose: aplica em ordem inversa (maiusculas -> sufixo -> capitalizar)
        // CUIDADO com a ordem aqui! compose aplica "before", então a última função no compose é a primeira a ser executada.
        // Para ter o mesmo efeito do andThen, a ordem de composição no compose deve ser invertida
        Function<String, String> pipelineCompose = paraMaiusculas
            .compose(adicionarSufixo)
            .compose(capitalizarPrimeiraLetra); // a última função no compose é a primeira a ser executada

        List<String> nomesProcessadosCompose = nomes.stream()
            .map(pipelineCompose)
            .collect(Collectors.toList());

        System.out.println("Processado com compose (mesma lógica do andThen, ordem invertida de chamada): " + nomesProcessadosCompose);
        // Saída esperada: [GEDÊ_DEV, JU_DEV, MARIA_DEV, JOÃO_DEV]

        // Exemplo de uso direto no map da Stream API sem encadeamento explícito
        List<Integer> comprimentos = nomes.stream()
            .map(String::length) // Reference method para Function<String, Integer>
            .collect(Collectors.toList());
        System.out.println("Comprimentos dos nomes: " + comprimentos); // Saída: [4, 2, 5, 4]
    }
}

```

### **5. Informações Adicionais**

- **Composição de Funções:** A capacidade de encadear funções (usando `andThen` e `compose`) é um dos pilares da programação funcional. Ela permite construir pipelines de processamento de dados complexos a partir de funções menores e mais simples, que são mais fáceis de testar e manter. Isso é particularmente útil com a Stream API, onde você pode aplicar uma série de transformações a uma coleção de dados.
- **`Identity Function`:** A interface `Function` possui um método estático `identity()` que retorna uma `Function` que simplesmente retorna sua entrada. É útil em situações onde você precisa de uma função, mas não quer aplicar nenhuma transformação.
    
    ```java
    Function<String, String> identity = Function.identity();
    String mesmoNome = identity.apply("Gedê"); // mesmoNome será "Gedê"
    
    ```
    
- **Polimorfismo e Reusabilidade:** Ao definir transformações como `Function`s, você aumenta a reusabilidade do seu código. Uma `Function` que mapeia um `Produto` para um `ProdutoDTO` pode ser usada em diferentes pontos da sua aplicação (na camada de serviço, no controlador, etc.).
- **Legibilidade e Expressividade:** O uso de `Function` e expressões Lambda muitas vezes torna o código mais declarativo e mais próximo da linguagem natural, melhorando a legibilidade. Em vez de descrever "como" a transformação ocorre, você descreve "o quê" está sendo transformado.

### **6. Referências para Estudo Independente**

Para aprofundar seus conhecimentos, Gedê, recomendo os seguintes recursos:

- **Documentação Oficial Java:**
    - `Function<T, R>`: [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Function.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Function.html)
    - Pacote `java.util.function`: [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html)
- **Tutoriais e Artigos:**
    - Baeldung - Java 8 Function Interface: [https://www.baeldung.com/java-8-functional-interfaces](https://www.baeldung.com/java-8-functional-interfaces) (Procure pela seção específica de `Function`)
    - GeeksforGeeks - Function Interface in Java: [https://www.geeksforgeeks.org/function-interface-in-java-with-examples/](https://www.geeksforgeeks.org/function-interface-in-java-with-examples/)
- **Livros (para uma compreensão mais profunda da programação funcional em Java):**
    - "Modern Java in Action: Lambdas, Streams, Functional and Reactive Programming" por Raoul-Gabriel Urma, Mario Fusco e Alan Mycroft.
    - "Java SE 8 for the Really Impatient" por Cay S. Horstmann.

Espero que esta explicação detalhada ajude você a dominar a `Function<T, R>` e aplicá-la com confiança nos seus projetos backend! Se tiver mais alguma dúvida, é só chamar, Gedê!