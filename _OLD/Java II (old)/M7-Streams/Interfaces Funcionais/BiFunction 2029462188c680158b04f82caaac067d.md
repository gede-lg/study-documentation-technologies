# BiFunction

Com certeza, Gedê\! Vamos detalhar sobre a `BiFunction` no Java, um dos pilares da programação funcional introduzida no Java 8.

### Introdução

No universo do Java moderno, a introdução das interfaces funcionais e da Streams API no Java 8 revolucionou a forma como interagimos com coleções e implementamos lógicas de processamento de dados. A `BiFunction` é uma dessas interfaces, representando um pilar fundamental da programação funcional ao permitir a abstração de operações que recebem dois argumentos e produzem um resultado. Sua relevância reside na capacidade de escrever código mais conciso, legível e expressivo, especialmente quando combinada com a Streams API para transformações de dados complexas, sendo extremamente útil no dia a dia de um desenvolvedor backend para operações como mapeamento e agregação de informações.

### Sumário

1. Definição e Conceitos Fundamentais
2. Sintaxe e Estrutura
3. Componentes Principais
4. Exemplos de Código Otimizados
5. Informações Adicionais
6. Referências para Estudo Independente

---

### 1\. Definição e Conceitos Fundamentais

A interface `java.util.function.BiFunction<T, U, R>` é uma interface funcional que representa uma função que aceita dois argumentos de tipos diferentes (`T` e `U`) e produz um resultado de um terceiro tipo (`R`). O "Bi" em seu nome indica que ela opera com dois argumentos, distinguindo-a de `Function`, que aceita apenas um. Ela é frequentemente utilizada para mapear ou transformar pares de valores em um único resultado.

Em termos mais práticos, a `BiFunction` é uma forma de encapsular uma lógica de transformação que precisa de duas entradas distintas para gerar uma saída.

---

### 2\. Sintaxe e Estrutura

A `BiFunction` é uma interface funcional, o que significa que ela possui exatamente um método abstrato (SAM - Single Abstract Method). Esse método é o `apply()`.

**Declaração da Interface:**

```java
@FunctionalInterface
public interface BiFunction<T, U, R> {

    R apply(T t, U u);

    // Métodos default e static opcionais
}

```

**Exemplos de Declaração e Utilização:**

Você pode implementar uma `BiFunction` usando expressões lambda, referências de método ou classes anônimas (embora as duas primeiras sejam preferenciais para concisão):

```java
// Usando expressão lambda
BiFunction<Integer, Integer, Integer> soma = (a, b) -> a + b;
Integer resultado = soma.apply(5, 3); // resultado será 8

// Usando referência de método (se houver um método estático ou de instância compatível)
class Calculadora {
    public static Integer multiplicar(Integer a, Integer b) {
        return a * b;
    }
}
BiFunction<Integer, Integer, Integer> multiplicacao = Calculadora::multiplicar;
Integer resultadoMultiplicacao = multiplicacao.apply(5, 3); // resultado será 15

```

---

### 3\. Componentes Principais

A `BiFunction` possui um método abstrato principal e um método *default* para composição.

- **`R apply(T t, U u)`:**
    - Este é o método abstrato da interface. É onde a lógica de transformação que aceita os dois argumentos (`t` de tipo `T` e `u` de tipo `U`) e retorna um resultado (`R`) é implementada.
    - É o coração da `BiFunction`, definindo a operação que ela representa.
- **`default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after)`:**
    - Este é um método *default* que permite compor `BiFunction`s. Ele retorna uma `BiFunction` encadeada que primeiro aplica a função atual (a `BiFunction` original) aos seus argumentos, e depois aplica a função `after` (uma `Function`) ao resultado da primeira operação.
    - `after`: Uma `Function` que aceita o resultado (`R`) da `BiFunction` atual e retorna um novo tipo `V`.
    - Este método é útil para criar cadeias de operações, onde a saída de uma função se torna a entrada da próxima.
    
    **Exemplo de `andThen`:**
    
    ```java
    BiFunction<Integer, Integer, Integer> somar = (a, b) -> a + b;
    Function<Integer, String> paraString = String::valueOf;
    
    // Primeiro soma, depois converte para String
    BiFunction<Integer, Integer, String> somarEConverter = somar.andThen(paraString);
    
    String resultadoConcatenado = somarEConverter.apply(10, 20); // resultadoConcatenado será "30"
    System.out.println(resultadoConcatenado);
    
    ```
    

---

### 4\. Exemplos de Código Otimizados

A `BiFunction` brilha em cenários onde você precisa processar pares de dados e produzir um resultado.

**Caso de Uso 1: Calculando o preço total de itens em um carrinho (quantidade x valor unitário)**

```java
import java.util.function.BiFunction;

public class CarrinhoCompras {

    public static void main(String[] args) {
        // BiFunction para calcular o subtotal de um item
        // Recebe a quantidade (Integer) e o preço unitário (Double), retorna o subtotal (Double)
        BiFunction<Integer, Double, Double> calcularSubtotal = (quantidade, precoUnitario) -> quantidade * precoUnitario;

        // Item 1: 2 unidades de um produto de R$ 15.50
        Double subtotalItem1 = calcularSubtotal.apply(2, 15.50);
        System.out.println("Subtotal do Item 1: R$ " + String.format("%.2f", subtotalItem1)); // Saída: R$ 31,00

        // Item 2: 3 unidades de um produto de R$ 9.99
        Double subtotalItem2 = calcularSubtotal.apply(3, 9.99);
        System.out.println("Subtotal do Item 2: R$ " + String.format("%.2f", subtotalItem2)); // Saída: R$ 29,97

        // Exemplo com andThen: Somar o subtotal e adicionar um imposto fixo de 10%
        Function<Double, Double> adicionarImposto = subtotal -> subtotal * 1.10; // Adiciona 10% de imposto

        BiFunction<Integer, Double, Double> calcularSubtotalComImposto = calcularSubtotal.andThen(adicionarImposto);

        Double subtotalComImpostoItem1 = calcularSubtotalComImposto.apply(2, 15.50);
        System.out.println("Subtotal do Item 1 (com imposto): R$ " + String.format("%.2f", subtotalComImpostoItem1)); // Saída: R$ 34,10
    }
}

```

**Caso de Uso 2: Combinando informações de duas listas (Simulando um JOIN leve)**

Imagine que você tem uma lista de IDs de usuários e outra lista de nomes de usuários, e quer criar um mapa onde a chave é o ID e o valor é o nome.

```java
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

public class CombinarDados {

    public static void main(String[] args) {
        List<Integer> userIds = List.of(1, 2, 3, 4);
        List<String> userNames = List.of("Alice", "Bob", "Charlie", "David");

        // BiFunction para combinar um ID e um Nome em um mapa temporário
        BiFunction<Integer, String, Map<Integer, String>> criarPar = (id, name) -> {
            Map<Integer, String> map = new HashMap<>();
            map.put(id, name);
            return map;
        };

        // Este é um exemplo mais ilustrativo.
        // No mundo real, usaríamos Streams e collectors mais diretamente.
        // Vamos simular a combinação manual para demonstrar a BiFunction.
        Map<Integer, String> userMap = new HashMap<>();
        for (int i = 0; i < userIds.size(); i++) {
            Map<Integer, String> tempMap = criarPar.apply(userIds.get(i), userNames.get(i));
            userMap.putAll(tempMap);
        }
        System.out.println("Mapa de Usuários (abordagem manual): " + userMap);

        // Exemplo mais idiomático com Streams e mergeFunction (que é uma BiFunction)
        // Isso é mais próximo do que você faria como desenvolvedor backend
        // ao combinar dados.
        List<User> users = new ArrayList<>();
        users.add(new User(1, "Alice"));
        users.add(new User(2, "Bob"));
        users.add(new User(3, "Charlie"));

        // Collector.toMap usa uma BiFunction para resolver colisões (mergeFunction)
        // Aqui, a mergeFunction (BiFunction) decide o que fazer se duas chaves forem iguais.
        // Nesse caso, ele apenas pega o valor da direita (último que chega).
        Map<Integer, String> userMapFromStream = users.stream()
                .collect(Collectors.toMap(
                        User::getId, // keyMapper
                        User::getName, // valueMapper
                        (oldValue, newValue) -> newValue // mergeFunction (BiFunction)
                ));
        System.out.println("Mapa de Usuários (com Streams e mergeFunction): " + userMapFromStream);
    }

    static class User {
        private int id;
        private String name;

        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        public int getId() {
            return id;
        }

        public String getName() {
            return name;
        }
    }
}

```

---

### 5\. Informações Adicionais

- **Imutabilidade:** As interfaces funcionais em Java, incluindo `BiFunction`, são intrinsecamente ligadas ao conceito de imutabilidade. Quando você usa uma `BiFunction`, você está definindo uma transformação que, idealmente, não deve ter efeitos colaterais. Isso torna o código mais fácil de testar, depurar e raciocinar, especialmente em ambientes concorrentes.
- **Composição:** O método `andThen()` é uma ferramenta poderosa para a composição de funções. Ele permite construir operações mais complexas a partir de funções mais simples, promovendo a reutilização de código e a modularidade.
- **Performance:** Embora o uso de lambdas e interfaces funcionais adicione uma pequena sobrecarga em tempo de execução comparado a um método diretamente invocado (devido à criação de objetos de interface), o compilador Java e a JVM são altamente otimizados para lidar com isso. Na maioria dos casos, o ganho em legibilidade e manutenibilidade supera qualquer pequena perda de performance.
- **Alternativas e Outras Interfaces:**
    - `Function<T, R>`: Para operações que recebem um argumento e retornam um resultado.
    - `BiConsumer<T, U>`: Para operações que recebem dois argumentos e não retornam nada (efeito colateral).
    - `BinaryOperator<T>`: Uma especialização de `BiFunction` onde todos os tipos (`T`, `U`, `R`) são os mesmos (`T`). É frequentemente usada em operações de redução, como somar elementos de uma lista.

---

### 6\. Referências para Estudo Independente

Para Gedê e Ju aprofundarem seus conhecimentos sobre `BiFunction` e programação funcional em Java, recomendo os seguintes recursos:

- **Documentação Oficial do Java:**
    - `BiFunction` (Oracle JavaDocs): [https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)
    - `Function` (Oracle JavaDocs): [https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)
    - `BiConsumer` (Oracle JavaDocs): [https://docs.oracle.com/javase/8/docs/api/java/util/function/BiConsumer.html](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiConsumer.html)
    - Tutoriais sobre Expressões Lambda (Oracle): [https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- **Artigos e Tutoriais:**
    - **Baeldung - Java 8 BiFunction:** Um excelente recurso com muitos exemplos práticos.
    [https://www.baeldung.com/java-8-bifunction](https://www.baeldung.com/java-8-bifunction)
    - **GeeksforGeeks - BiFunction in Java:** Outro bom tutorial com foco em exemplos.
    [https://www.geeksforgeeks.org/bifunction-interface-in-java-with-examples/](https://www.geeksforgeeks.org/bifunction-interface-in-java-with-examples/)
- **Livros (para aprofundamento geral em Java 8+ e Programação Funcional):**
    - "Java 8 in Action" por Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft: Um livro fundamental para entender as novidades do Java 8, incluindo lambdas e Streams.
    - "Modern Java in Action: Lambdas, Streams, Functional and Reactive Programming" (nova edição do Java 8 in Action, atualizada para versões mais recentes).

Estou à disposição para mais perguntas, Gedê\!