# Predicate

Com certeza, Gedê\! Vamos detalhar sobre a interface `Predicate<T>` em Java. É um conceito fundamental da API de Streams e programação funcional, que você vai usar bastante no seu dia a dia de desenvolvedor backend, especialmente se estiver mirando em Go, onde o pensamento funcional é bastante presente.

## Interface Funcional Padrão: `Predicate<T>`

A interface `Predicate<T>` é uma peça chave da programação funcional introduzida no Java 8, parte do pacote `java.util.function`. Ela é fundamental para trabalhar com a Stream API e outras operações que exigem a avaliação de condições. No contexto de um desenvolvedor backend, `Predicate` é amplamente utilizado para filtrar dados, validar entradas e definir critérios específicos em coleções ou fluxos de informação, otimizando o código e tornando-o mais legível e conciso.

### Sumário

1. **O que é `Predicate<T>` e para que serve?**
2. **Sintaxe e Estrutura**
3. **Componentes Principais: O método `test()` e Métodos `default` e `static`**
    - Método `test(T t)`
    - Método `and(Predicate<? super T> other)`
    - Método `or(Predicate<? super T> other)`
    - Método `negate()`
    - Método `isEqual(Object targetRef)` (static)
    - Método `not(Predicate<? super T> target)` (static)
4. **Restrições de Uso**
5. **Exemplos de Código Otimizados**
6. **Informações Adicionais**
7. **Referências para Estudo Independente**

### Conteúdo Detalhado

### O que é `Predicate<T>` e para que serve?

`Predicate<T>` é uma interface funcional que representa uma função que aceita um argumento de um tipo `T` e retorna um valor booleano (`true` ou `false`). Em termos mais simples, um `Predicate` é um "teste de condição". Ele é usado para definir critérios que um objeto deve satisfazer.

Sua principal utilidade reside em operações de filtragem e validação, especialmente quando combinada com a Stream API do Java. Em vez de escrever laços `for` e `if` para verificar condições, você pode usar `Predicate` para expressar essas condições de forma mais declarativa e concisa. Isso é vital para quem busca um código mais limpo e funcional.

### Sintaxe e Estrutura

Como uma interface funcional, `Predicate<T>` possui um único método abstrato (`test`). Isso permite que ela seja implementada usando expressões lambda, o que simplifica bastante a sintaxe.

A declaração básica de um `Predicate` usando uma expressão lambda é:

```java
Predicate<TipoDoObjeto> nomeDoPredicate = (objeto) -> condição;

```

**Exemplo de declaração e utilização:**

```java
import java.util.function.Predicate;

public class ExemploPredicateBasico {
    public static void main(String[] args) {
        // Exemplo 1: Predicate para verificar se um número é par
        Predicate<Integer> isPar = (numero) -> numero % 2 == 0;

        System.out.println("5 é par? " + isPar.test(5));   // Saída: false
        System.out.println("10 é par? " + isPar.test(10)); // Saída: true

        // Exemplo 2: Predicate para verificar se uma String não é vazia
        Predicate<String> isNaoVazia = (texto) -> !texto.isEmpty();

        System.out.println("'' é não vazia? " + isNaoVazia.test(""));       // Saída: false
        System.out.println("'Olá' é não vazia? " + isNaoVazia.test("Olá")); // Saída: true
    }
}

```

### Componentes Principais: O método `test()` e Métodos `default` e `static`

A interface `Predicate<T>`, além do seu método abstrato `test()`, oferece vários métodos `default` e `static` que permitem combinar e negar condições de forma expressiva.

### Método `test(T t)`

- **Descrição:** Este é o único método abstrato da interface. Ele avalia o `Predicate` para o argumento fornecido.
- **Retorno:** `boolean` (`true` se o argumento corresponde à condição, `false` caso contrário).
- **Interação:** É o método que você implementa (direta ou indiretamente com lambdas) para definir a lógica da sua condição.

### Método `and(Predicate<? super T> other)`

- **Descrição:** Retorna um `Predicate` composto que representa uma conjunção lógica (AND) deste `Predicate` e de outro. Ou seja, a condição resultante será verdadeira apenas se *ambos* os predicados forem verdadeiros para o mesmo argumento.
- **Parâmetro:** `other` - o outro `Predicate` que será logicamente ANDed com este.
- **Retorno:** Um novo `Predicate` que representa a operação lógica `AND`.
- **Interação:** Usado para construir condições mais complexas onde múltiplas regras devem ser satisfeitas.

### Método `or(Predicate<? super T> other)`

- **Descrição:** Retorna um `Predicate` composto que representa uma disjunção lógica (OR) deste `Predicate` e de outro. A condição resultante será verdadeira se *pelo menos um* dos predicados for verdadeiro para o mesmo argumento.
- **Parâmetro:** `other` - o outro `Predicate` que será logicamente ORed com este.
- **Retorno:** Um novo `Predicate` que representa a operação lógica `OR`.
- **Interação:** Útil para definir condições onde alternativas são aceitáveis.

### Método `negate()`

- **Descrição:** Retorna um `Predicate` que representa a negação lógica (NOT) deste `Predicate`. Inverte o resultado do teste.
- **Retorno:** Um novo `Predicate` que representa a operação lógica `NOT`.
- **Interação:** Simplifica a criação de condições inversas sem a necessidade de reescrever a lógica.

### Método `isEqual(Object targetRef)` (static)

- **Descrição:** Retorna um `Predicate` que testa se dois argumentos são iguais de acordo com `Objects.equals(Object, Object)`. É um método estático, o que significa que você o chama diretamente na interface `Predicate`.
- **Parâmetro:** `targetRef` - o objeto com o qual se comparar.
- **Retorno:** Um `Predicate<T>` que verifica a igualdade.
- **Interação:** Conveniente para criar um predicado simples de igualdade.

### Método `not(Predicate<? super T> target)` (static)

- **Descrição:** Retorna um `Predicate` que é a negação do `Predicate` fornecido. Equivalente a `target.negate()`, mas pode ser mais legível em alguns contextos, especialmente com referências a métodos. Introduzido no Java 11.
- **Parâmetro:** `target` - o `Predicate` a ser negado.
- **Retorno:** Um novo `Predicate` negado.
- **Interação:** Alternativa estática para `negate()`.

### Restrições de Uso

- **Interfaces Funcionais Apenas:** `Predicate` é uma interface funcional, o que significa que ela só pode ser usada com expressões lambda ou referências de método se a implementação da lambda tiver exatamente um método abstrato.
- **Imutabilidade:** As operações como `and()`, `or()`, e `negate()` não modificam o `Predicate` original; elas retornam um *novo* `Predicate` composto. Isso é uma boa prática de programação funcional, promovendo a imutabilidade.
- **NullPointerException:** Ao usar `Predicate` em cadeias com `and`, `or`, etc., certifique-se de que nenhum dos predicados resultará em `NullPointerException` se o argumento `test()` for `null`, a menos que essa seja a intenção. A própria interface não impõe verificações de `null` nos métodos `test()`.

### Exemplos de Código Otimizados

Vamos ver como Gedê pode usar `Predicate<T>` em cenários reais de backend.

**Cenário 1: Filtragem de Usuários em um Sistema**

Imagine que você tem uma lista de usuários e precisa filtrar aqueles que estão ativos e têm mais de 18 anos.

```java
import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

class Usuario {
    private String nome;
    private int idade;
    private boolean ativo;

    public Usuario(String nome, int idade, boolean ativo) {
        this.nome = nome;
        this.idade = idade;
        this.ativo = ativo;
    }

    public String getNome() { return nome; }
    public int getIdade() { return idade; }
    public isAtivo() { return ativo; }

    @Override
    public String toString() {
        return "Usuario{" + "nome='" + nome + '\\'' + ", idade=" + idade + ", ativo=" + ativo + '}';
    }
}

public class ExemploFiltragemUsuarios {
    public static void main(String[] args) {
        List<Usuario> usuarios = new ArrayList<>();
        usuarios.add(new Usuario("Alice", 25, true));
        usuarios.add(new Usuario("Bob", 17, true));
        usuarios.add(new Usuario("Carol", 30, false));
        usuarios.add(new Usuario("David", 22, true));
        usuarios.add(new Usuario("Eve", 19, false));

        // Predicate para verificar se o usuário está ativo
        Predicate<Usuario> isAtivo = Usuario::isAtivo; // Usando referência de método

        // Predicate para verificar se o usuário tem mais de 18 anos
        Predicate<Usuario> maisDeDezoito = usuario -> usuario.getIdade() > 18;

        // Combinando os predicados: ativo E maior de 18
        Predicate<Usuario> ativoEMaiorDeDezoito = isAtivo.and(maisDeDezoito);

        // Filtrando a lista de usuários usando o Predicate combinado
        List<Usuario> usuariosElegiveis = usuarios.stream()
                                                .filter(ativoEMaiorDeDezoito)
                                                .collect(Collectors.toList());

        System.out.println("Usuários Ativos e Maiores de 18:");
        usuariosElegiveis.forEach(System.out::println);
        // Saída esperada:
        // Usuario{nome='Alice', idade=25, ativo=true}
        // Usuario{nome='David', idade=22, ativo=true}

        // Exemplo com negate(): Usuários inativos
        Predicate<Usuario> isInativo = isAtivo.negate();
        List<Usuario> usuariosInativos = usuarios.stream()
                                                .filter(isInativo)
                                                .collect(Collectors.toList());
        System.out.println("\\nUsuários Inativos:");
        usuariosInativos.forEach(System.out::println);
        // Saída esperada:
        // Usuario{nome='Carol', idade=30, ativo=false}
        // Usuario{nome='Eve', idade=19, ativo=false}
    }
}

```

**Cenário 2: Validação de Parâmetros de Entrada em uma API REST**

Como desenvolvedor backend, Gedê frequentemente valida dados de entrada. `Predicate` pode ser útil para definir regras de validação.

```java
import java.util.function.Predicate;

public class ExemploValidacaoParametros {

    // Predicate para verificar se um email tem um formato básico válido
    public static Predicate<String> isValidEmail = email ->
            email != null && email.contains("@") && email.contains(".");

    // Predicate para verificar se uma senha tem pelo menos 8 caracteres
    public static Predicate<String> isValidPassword = senha ->
            senha != null && senha.length() >= 8;

    // Predicate para verificar se um nome de usuário não está vazio e tem mais de 3 caracteres
    public static Predicate<String> isValidUsername = username ->
            username != null && !username.trim().isEmpty() && username.trim().length() > 3;

    public static void main(String[] args) {
        String email1 = "teste@example.com";
        String email2 = "invalid-email";
        String email3 = null;

        String password1 = "senha123";
        String password2 = "curta";

        String username1 = "luizgustavo";
        String username2 = "lg";
        String username3 = "   ";

        System.out.println("Validação de Email:");
        System.out.println(email1 + " é válido? " + isValidEmail.test(email1)); // true
        System.out.println(email2 + " é válido? " + isValidEmail.test(email2)); // false
        System.out.println(email3 + " é válido? " + isValidEmail.test(email3)); // false

        System.out.println("\\nValidação de Senha:");
        System.out.println(password1 + " é válida? " + isValidPassword.test(password1)); // true
        System.out.println(password2 + " é válida? " + isValidPassword.test(password2)); // false

        System.out.println("\\nValidação de Nome de Usuário:");
        System.out.println(username1 + " é válido? " + isValidUsername.test(username1)); // true
        System.out.println(username2 + " é válido? " + isValidUsername.test(username2)); // false
        System.out.println(username3 + " é válido? " + isValidUsername.test(username3)); // false

        // Combinando validações para um registro completo
        Predicate<String> isStrongPassword = isValidPassword.and(senha -> senha.matches(".*\\\\d.*")); // Adiciona requisito de número
        System.out.println("\\nSenha 'abc123DEF' é forte? " + isStrongPassword.test("abc123DEF")); // true
        System.out.println("Senha 'abcdefg' é forte? " + isStrongPassword.test("abcdefg"));     // false

        // Usando Predicate.not() para ver se algo NÃO é válido
        Predicate<String> isInvalidEmail = Predicate.not(isValidEmail);
        System.out.println("Email '" + email2 + "' é inválido? " + isInvalidEmail.test(email2)); // true
    }
}

```

### Informações Adicionais

- **Composição de Predicates:** A grande força de `Predicate` e de outras interfaces funcionais (como `Function` e `Consumer`) é a capacidade de composição. Você pode construir lógicas complexas encadeando múltiplos predicados com `and()`, `or()` e `negate()`, tornando o código muito mais legível e modular do que uma série de `if` aninhados.
- **Referências de Métodos:** Como visto nos exemplos, `Predicate` se beneficia muito de referências de métodos (ex: `Usuario::isAtivo`). Isso torna o código ainda mais conciso e expressivo, especialmente quando a lógica do predicado já está encapsulada em um método existente.
- **Lazy Evaluation:** Ao usar `and()` e `or()`, o Java pode aplicar otimizações de curto-circuito (short-circuiting). No `and()`, se o primeiro predicado for `false`, o segundo não é avaliado. No `or()`, se o primeiro for `true`, o segundo também não é avaliado. Isso pode ter implicações de performance e é um detalhe importante em cenários de alta demanda.
- **Legibilidade e Manutenibilidade:** O uso de `Predicate` e a Stream API geralmente leva a um código mais declarativo ("o que fazer" em vez de "como fazer"). Isso aumenta a legibilidade e a manutenibilidade, pois a intenção da operação é mais clara.
- **Integração com Spring Data JPA:** No contexto do Spring Boot e Spring Data JPA, você pode não usar `Predicate` diretamente nas suas `JpaRepository` methods. No entanto, conceitos de filtragem e condições são intrínsecos a queries (JPQL, Criteria API, Query By Example), e o entendimento de `Predicate` solidifica sua base para abordagens mais avançadas de consulta.

### Referências para Estudo Independente

Para aprofundar seus conhecimentos em `Predicate` e programação funcional em Java, Gedê, sugiro os seguintes recursos:

- **Documentação Oficial Java - `Predicate`:**
    - [Java Predicate Javadoc](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html) (Sempre a fonte mais confiável para detalhes técnicos e todos os métodos).
- **Oracle Documentation - Lambda Expressions:**
    - [Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) (Contextualiza o `Predicate` dentro do universo das lambdas).
- **Artigos e Tutoriais:**
    - **Baeldung - Java 8 Predicate:** Um recurso excelente com muitos exemplos práticos.
        - [A Guide to Java 8 Predicate](https://www.google.com/search?q=https://www.baeldung.com/java-8-predicate)
    - **GeeksforGeeks - Predicate in Java 8:** Outro bom tutorial com uma abordagem didática.
        - [Predicate in Java 8](https://www.google.com/search?q=https://www.geeksforgeeks.org/predicate-in-java-8/)
- **Livros:**
    - **"Java™ Programming Language" de James Gosling, Bill Joy, Guy Steele, Richard Gabriel, Gilad Bracha, Alex Buckley:** Para fundamentos da linguagem.
    - **"Modern Java in Action: Lambdas, Streams, Functional and Reactive Programming" de Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft:** Essencial para dominar a programação funcional em Java 8+.

Espero que esta explicação detalhada ajude você a dominar o `Predicate<T>`, Gedê\! Me diga qual o próximo tópico que A.R.I.A deve explicar.