# BiPredicate

Com certeza, Gedê\! Vamos detalhar a `BiPredicate` para você, um conceito que é super útil no dia a dia de um desenvolvedor backend e faz parte daquele conhecimento de `Streams API (Java 8+) e Expressões Lambda` que você vai revisar no Módulo 2.

## Introdução

As Interfaces Funcionais em Java 8+ revolucionaram a forma como lidamos com a programação funcional na linguagem. Elas são a base para o uso das Expressões Lambda, permitindo que tratemos funções como cidadãos de primeira classe. Nesse contexto, a `BiPredicate` surge como uma ferramenta poderosa para realizar testes ou verificações booleanas que dependem de *dois* argumentos de entrada, oferecendo uma maneira concisa e expressiva de escrever lógica condicional.

A relevância da `BiPredicate` no seu contexto de desenvolvimento backend, especialmente se você está de olho em migrar para Go, está na capacidade de escrever código mais limpo, modular e, muitas vezes, mais performático, especialmente quando combinado com a Streams API. Ela permite abstrair lógicas de validação e filtragem que dependem de múltiplas condições, tornando seu código mais fácil de ler, testar e manter. Para quem lida com regras de negócio complexas ou validações de entrada, a `BiPredicate` é uma aliada e tanto.

### Definição e Conceitos Fundamentais

Uma `BiPredicate<T, U>` é uma interface funcional que representa um predicado (uma função que retorna um valor booleano) de dois argumentos. O "Bi" prefixo indica que ela opera sobre dois tipos de entrada diferentes (ou iguais), `T` e `U`. Seu propósito principal é testar se esses dois argumentos satisfazem uma determinada condição, retornando `true` se sim, e `false` caso contrário. Ela é análoga à `Predicate<T>`, mas expandida para aceitar um segundo argumento.

## Sumário

- Sintaxe e Estrutura
- Componentes Principais: O Método `test()`
- Métodos Padrão (`and`, `or`, `negate`)
- Restrições de Uso e Melhores Práticas
- Exemplos de Código Otimizados
- Informações Adicionais: `BiPredicate` vs. Outras Interfaces Funcionais "Bi"
- Referências para Estudo Independente

## Conteúdo Detalhado

### Sintaxe e Estrutura

A `BiPredicate` é uma interface genérica, o que significa que você especifica os tipos dos dois argumentos que ela vai testar.

```java
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);

    // Métodos default e static
    // ...
}

```

**Exemplo de Declaração e Utilização:**

```java
// Declaração de uma BiPredicate para verificar se um número é maior que outro
BiPredicate<Integer, Integer> isGreaterThan = (num1, num2) -> num1 > num2;

// Utilização da BiPredicate
boolean result = isGreaterThan.test(10, 5); // result será true
boolean anotherResult = isGreaterThan.test(3, 7); // anotherResult será false

```

### Componentes Principais: O Método `test()`

O coração da `BiPredicate` é seu único método abstrato, `test(T t, U u)`. Este método recebe dois argumentos, de tipos `T` e `U` respectivamente, e retorna um `boolean`. É dentro da implementação deste método que você define a lógica de sua condição.

- `test(T t, U u)`: Recebe dois argumentos e aplica a lógica de teste definida na expressão lambda ou implementação da interface. Retorna `true` se a condição for satisfeita, `false` caso contrário.

### Métodos Padrão (`and`, `or`, `negate`)

A `BiPredicate` também oferece métodos `default` e `static` que facilitam a composição de lógicas de teste mais complexas, sem a necessidade de criar novas implementações:

- `default BiPredicate<T, U> and(BiPredicate<? super T, ? super U> other)`: Retorna um predicado composto que representa uma conjunção lógica (AND) deste predicado e outro. O teste será `true` somente se ambos os predicados forem `true`.
- `default BiPredicate<T, U> or(BiPredicate<? super T, ? super U> other)`: Retorna um predicado composto que representa uma disjunção lógica (OR) deste predicado e outro. O teste será `true` se pelo menos um dos predicados for `true`.
- `default BiPredicate<T, U> negate()`: Retorna um predicado que representa a negação lógica (NOT) deste predicado. Se o predicado original retorna `true`, o negado retorna `false`, e vice-versa.

### Restrições de Uso e Melhores Práticas

- **Imutabilidade:** As expressões lambda e, por extensão, as `BiPredicate`s, são geralmente usadas para lógica imutável. Evite efeitos colaterais (side effects) dentro da lógica do `test()`, pois isso pode levar a comportamento imprevisível, especialmente em contextos concorrentes ou com Streams.
- **Clareza e Simplicidade:** Embora você possa compor lógicas complexas com `and`, `or` e `negate`, evite criar `BiPredicate`s excessivamente aninhadas que se tornem difíceis de ler. Se a lógica for muito complexa, considere extraí-la para um método privado nomeado.
- **Reuso:** `BiPredicate`s são ótimas para encapsular lógicas de validação ou filtragem que podem ser reutilizadas em diferentes partes do seu código, especialmente com Streams.

## Exemplos de Código Otimizados

Vamos ver alguns exemplos práticos que você, Gedê, pode encontrar no seu dia a dia como desenvolvedor backend:

**Caso de Uso 1: Filtrando uma Lista de Usuários por Múltiplos Critérios**

Imagine que você tem uma lista de objetos `Usuario` e quer filtrar aqueles que são `ativos` E têm um `nível de permissão` específico.

```java
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.function.BiPredicate;
import java.util.ArrayList;

class Usuario {
    private String nome;
    private int nivelPermissao;
    private boolean ativo;

    public Usuario(String nome, int nivelPermissao, boolean ativo) {
        this.nome = nome;
        this.nivelPermissao = nivelPermissao;
        this.ativo = ativo;
    }

    public String getNome() { return nome; }
    public int getNivelPermissao() { return nivelPermissao; }
    public boolean isAtivo() { return ativo; }

    @Override
    public String toString() {
        return "Usuario{" +
               "nome='" + nome + '\\'' +
               ", nivelPermissao=" + nivelPermissao +
               ", ativo=" + ativo +
               '}';
    }
}

public class ExemploBiPredicateUsuarios {
    public static void main(String[] args) {
        List<Usuario> usuarios = new ArrayList<>();
        usuarios.add(new Usuario("Alice", 1, true));
        usuarios.add(new Usuario("Bob", 2, true));
        usuarios.add(new Usuario("Carlos", 1, false));
        usuarios.add(new Usuario("Diana", 3, true));
        usuarios.add(new Usuario("Eduardo", 2, false));

        // BiPredicate para verificar se o usuário é ativo E tem nível de permissão 2
        // Usemos Integer para o nível de permissão, pois o stream nos dará um objeto User,
        // mas a lógica da BiPredicate pode usar o tipo primitivo para comparação interna.
        BiPredicate<Usuario, Integer> isActiveAndLevelTwo =
            (user, requiredLevel) -> user.isAtivo() && user.getNivelPermissao() == requiredLevel;

        // Filtrando usuários que são ativos e têm nível 2
        List<Usuario> usuariosFiltrados = usuarios.stream()
            .filter(user -> isActiveAndLevelTwo.test(user, 2)) // Passamos o usuário e o nível como argumentos
            .collect(Collectors.toList());

        System.out.println("Usuários ativos com nível de permissão 2:");
        usuariosFiltrados.forEach(System.out::println);
        // Saída esperada: Usuario{nome='Bob', nivelPermissao=2, ativo=true}
    }
}

```

**Caso de Uso 2: Validando Parâmetros de Entrada de um Endpoint**

Você pode usar `BiPredicate` para validar dois parâmetros de entrada antes de processar uma requisição. Por exemplo, verificar se um `saldo` é maior que um `valor` a ser debitado.

```java
import java.math.BigDecimal;
import java.util.function.BiPredicate;

public class ExemploBiPredicateTransacao {

    public static void main(String[] args) {
        BigDecimal saldoConta = new BigDecimal("1000.00");
        BigDecimal valorDebito = new BigDecimal("500.00");
        BigDecimal valorExcedente = new BigDecimal("1500.00");

        // BiPredicate para verificar se o saldo é suficiente para o débito
        BiPredicate<BigDecimal, BigDecimal> isSaldoSuficiente =
            (saldo, debito) -> saldo.compareTo(debito) >= 0;

        System.out.println("Débito de " + valorDebito + " com saldo " + saldoConta +
                           " é possível? " + isSaldoSuficiente.test(saldoConta, valorDebito));
        // Saída esperada: true

        System.out.println("Débito de " + valorExcedente + " com saldo " + saldoConta +
                           " é possível? " + isSaldoSuficiente.test(saldoConta, valorExcedente));
        // Saída esperada: false
    }
}

```

**Caso de Uso 3: Compondo `BiPredicate`s para Lógicas Complexas**

Com os métodos `and()`, `or()` e `negate()`, você pode criar lógicas complexas de forma legível.

```java
import java.util.function.BiPredicate;

public class ExemploBiPredicateComposicao {

    public static void main(String[] args) {
        // Predicado 1: O primeiro número é par?
        BiPredicate<Integer, Integer> isFirstEven = (n1, n2) -> n1 % 2 == 0;

        // Predicado 2: O segundo número é maior que 10?
        BiPredicate<Integer, Integer> isSecondGreaterThanTen = (n1, n2) -> n2 > 10;

        // Predicado 3: Ambos são verdadeiros? (AND)
        BiPredicate<Integer, Integer> bothConditionsMet = isFirstEven.and(isSecondGreaterThanTen);

        System.out.println("4 e 12: " + bothConditionsMet.test(4, 12)); // true (4 é par E 12 > 10)
        System.out.println("3 e 12: " + bothConditionsMet.test(3, 12)); // false (3 não é par)
        System.out.println("4 e 8: " + bothConditionsMet.test(4, 8));   // false (8 não é > 10)

        // Predicado 4: O primeiro é par OU o segundo é maior que 10? (OR)
        BiPredicate<Integer, Integer> eitherConditionMet = isFirstEven.or(isSecondGreaterThanTen);

        System.out.println("3 e 12: " + eitherConditionMet.test(3, 12)); // true (12 > 10)
        System.out.println("5 e 7: " + eitherConditionMet.test(5, 7));   // false (nenhum é verdadeiro)

        // Predicado 5: O primeiro NÃO é par? (NEGATE)
        BiPredicate<Integer, Integer> isFirstOdd = isFirstEven.negate();

        System.out.println("Primeiro número 4 é ímpar? " + isFirstOdd.test(4, 5)); // false (4 não é ímpar)
        System.out.println("Primeiro número 3 é ímpar? " + isFirstOdd.test(3, 5)); // true (3 é ímpar)
    }
}

```

## Informações Adicionais

A família de interfaces funcionais "Bi" (`BiPredicate`, `BiConsumer`, `BiFunction`) segue um padrão lógico no Java 8+.

- **`BiPredicate<T, U>`:** Recebe `T` e `U`, retorna `boolean`. Usada para testes e validações com dois inputs.
- **`BiConsumer<T, U>`:** Recebe `T` e `U`, não retorna nada (`void`). Usada para realizar alguma ação ou efeito colateral com dois inputs. Ex: `(item1, item2) -> System.out.println(item1 + " - " + item2);`
- **`BiFunction<T, U, R>`:** Recebe `T` e `U`, retorna um valor do tipo `R`. Usada para transformar dois inputs em um output. Ex: `(num1, num2) -> num1 + num2;`

Entender a finalidade de cada uma dessas interfaces é crucial para escolher a ferramenta certa para cada situação, tornando seu código mais semântico e claro. A `BiPredicate` se destaca especificamente para situações onde o resultado da operação sobre dois elementos é uma decisão binária (verdadeiro/falso).

## Referências para Estudo Independente

Para aprofundar seu conhecimento sobre `BiPredicate` e outras interfaces funcionais, Gedê, recomendo as seguintes fontes:

1. **Documentação Oficial do Java - `BiPredicate`:**
    - [Oracle Java Docs: BiPredicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiPredicate.html) (Para a versão 8, mas os conceitos são os mesmos)
    - [Oracle Java Docs: BiPredicate (versões mais recentes)](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/BiPredicate.html)
2. **Tutorial sobre Expressões Lambda e Interfaces Funcionais:**
    - [Java 8 Lambda Expressions & Functional Interfaces Tutorial - Baeldung](https://www.google.com/search?q=https://www.baeldung.com/java-8-lambda-expressions-functional-interfaces) (Um guia completo e prático sobre o tema)
3. **Artigos sobre Java Streams API:**
    - [Java Stream API Tutorial - GeeksforGeeks](https://www.google.com/search?q=https://www.geeksforgeeks.org/java-8-stream-api-tutorial/) (Explora como `BiPredicate` pode ser usada em conjunto com Streams)

Esses recursos vão te ajudar a solidificar o que você já aprendeu e explorar ainda mais as possibilidades que as interfaces funcionais oferecem no Java moderno. Se precisar de mais alguma explicação, é só chamar\!