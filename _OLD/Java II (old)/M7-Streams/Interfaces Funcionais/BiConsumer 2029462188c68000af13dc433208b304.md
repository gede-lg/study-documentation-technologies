# BiConsumer

Com certeza, Gedê\! Vamos detalhar sobre a `BiConsumer`, um conceito importante no estudo de Streams API e Expressões Lambda que está na sua grade.

## Introdução à Interface Funcional `BiConsumer`

No universo da programação Java, especialmente com a introdução do Java 8 e a Programação Funcional, as interfaces funcionais se tornaram pilares para escrever código mais conciso, legível e expressivo. Elas são a base para o uso de Expressões Lambda e a poderosa Streams API.

A interface `BiConsumer` é uma das interfaces funcionais padrão do Java, projetada para operações que **consomem dois valores de entrada e não retornam nenhum resultado**. Sua importância reside na capacidade de permitir que você execute uma ação ou efeito colateral com base em dois argumentos, sem se preocupar em produzir um novo valor, o que é comum em cenários onde você precisa processar dois dados de forma conjunta.

### Sumário

- **Definição e Conceitos Fundamentais**
- **Sintaxe e Estrutura**
- **Componentes Principais: O Método `accept()`**
- **Exemplos de Código Otimizados**
    - Uso Básico
    - `BiConsumer` com Coleções (`Map`)
    - `BiConsumer` em Operações de Log
    - Composição de `BiConsumer` com `andThen()`
- **Restrições de Uso**
- **Informações Adicionais**
    - Diferenças entre `BiConsumer`, `Consumer` e `BiFunction`
    - Quando usar `BiConsumer`
- **Referências para Estudo Independente**

---

## Conteúdo Detalhado

### Definição e Conceitos Fundamentais

A interface `java.util.function.BiConsumer<T, U>` é uma interface funcional que representa uma operação que aceita dois argumentos de entrada de tipos `T` e `U`, respectivamente, e não retorna nenhum resultado. Ela é "bi" porque trabalha com dois argumentos, e "consumer" porque "consome" esses argumentos para realizar uma ação, sem produzir um retorno.

**Para que serve?**`BiConsumer` é útil em situações onde você precisa executar uma ação para cada par de elementos. Um caso de uso clássico é iterar sobre um `Map`, onde você tem um par de chave-valor e deseja realizar uma operação com ambos.

### Sintaxe e Estrutura

A interface `BiConsumer` possui uma estrutura muito simples, definindo um único método abstrato que a torna uma interface funcional:

```java
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);

    default BiConsumer<T, U> andThen(BiConsumer<? super T, ? super U> after) {
        // ... implementação padrão ...
    }
}

```

- `T`: O tipo do primeiro argumento de entrada.
- `U`: O tipo do segundo argumento de entrada.

**Exemplo de Declaração e Utilização:**

```java
// Declaração de um BiConsumer usando uma expressão lambda
BiConsumer<String, Integer> imprimirMensagemENumero = (mensagem, numero) -> {
    System.out.println("Mensagem: " + mensagem + ", Número: " + numero);
};

// Utilização do BiConsumer
imprimirMensagemENumero.accept("Olá, Gedê!", 2025);
// Saída: Mensagem: Olá, Gedê!, Número: 2025

```

### Componentes Principais: O Método `accept()`

O coração da interface `BiConsumer` é o seu método abstrato `accept(T t, U u)`. É este método que você implementa ao usar uma expressão lambda ou uma classe anônima.

- `void accept(T t, U u)`: Este método recebe dois argumentos dos tipos `T` e `U`, executa a lógica definida em sua implementação e não retorna nada. O objetivo é causar um "efeito colateral", como imprimir no console, modificar um estado (com cuidado em contextos concorrentes), ou registrar informações.

Além do método `accept()`, `BiConsumer` também possui um método `default`:

- `default BiConsumer<T, U> andThen(BiConsumer<? super T, ? super U> after)`: Este método padrão permite a composição de `BiConsumer`s. Ele retorna um novo `BiConsumer` que primeiro executa a operação do `BiConsumer` atual e, em seguida, executa a operação do `BiConsumer` passado como argumento (`after`). Isso é útil para encadear operações.

### Restrições de Uso

A principal restrição de uso da `BiConsumer` é que ela **não retorna nenhum valor**. Se você precisar que sua operação com dois argumentos produza um resultado, a interface funcional apropriada seria `BiFunction<T, U, R>`.

Outro ponto importante é que as operações realizadas dentro de um `BiConsumer` devem ser cuidadosamente projetadas, especialmente em ambientes concorrentes, pois o efeito colateral pode levar a `race conditions` se os recursos compartilhados não forem devidamente sincronizados.

---

## Exemplos de Código Otimizados

### Uso Básico

Este exemplo mostra como usar um `BiConsumer` para processar dois valores simples, como nomes e idades.

```java
import java.util.function.BiConsumer;

public class BiConsumerBasicoExemplo {

    public static void main(String[] args) {
        // BiConsumer para imprimir o nome e a idade
        BiConsumer<String, Integer> exibirDadosPessoa = (nome, idade) ->
            System.out.println("Nome: " + nome + ", Idade: " + idade + " anos.");

        // Usando o BiConsumer
        exibirDadosPessoa.accept("Juliana", 24); // Chamando com Ju e a idade dela
        exibirDadosPessoa.accept("Gedê", 23); // Chamando com você e sua idade
    }
}
/*
Saída esperada:
Nome: Juliana, Idade: 24 anos.
Nome: Gedê, Idade: 23 anos.
*/

```

### `BiConsumer` com Coleções (`Map`)

Um dos casos de uso mais comuns para `BiConsumer` é com a interface `Map`, especificamente com o método `forEach`.

```java
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiConsumer;

public class BiConsumerMapExemplo {

    public static void main(String[] args) {
        Map<String, Double> produtosPrecos = new HashMap<>();
        produtosPrecos.put("Notebook", 4500.00);
        produtosPrecos.put("Mouse", 150.00);
        produtosPrecos.put("Teclado", 300.00);

        // Usando forEach com BiConsumer para iterar sobre o Map
        // A chave e o valor são passados para o BiConsumer automaticamente
        System.out.println("Lista de Produtos:");
        produtosPrecos.forEach((nomeProduto, preco) ->
            System.out.println("- " + nomeProduto + ": R$" + String.format("%.2f", preco))
        );

        // Exemplo mais complexo: aplicando desconto se o preço for alto
        System.out.println("\\nProdutos com Desconto:");
        produtosPrecos.forEach((nomeProduto, preco) -> {
            if (preco > 200.00) {
                double precoComDesconto = preco * 0.9; // 10% de desconto
                System.out.println("- " + nomeProduto + " (com desconto): R$" + String.format("%.2f", precoComDesconto));
            } else {
                System.out.println("- " + nomeProduto + ": R$" + String.format("%.2f", preco));
            }
        });
    }
}
/*
Saída esperada:
Lista de Produtos:
- Notebook: R$4500,00
- Mouse: R$150,00
- Teclado: R$300,00

Produtos com Desconto:
- Notebook (com desconto): R$4050,00
- Mouse: R$150,00
- Teclado (com desconto): R$270,00
*/

```

### `BiConsumer` em Operações de Log

Imagine que você precisa registrar eventos que envolvem dois pedaços de informação, como um ID de usuário e uma mensagem de evento.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.function.BiConsumer;

public class BiConsumerLogExemplo {

    // Simula um sistema de log
    private static void logEvento(String userId, String message) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        System.out.println("[" + LocalDateTime.now().format(formatter) + "] USER: " + userId + " | EVENT: " + message);
    }

    public static void main(String[] args) {
        // BiConsumer para registrar eventos
        BiConsumer<String, String> eventLogger = BiConsumerLogExemplo::logEvento;

        // Simulando eventos
        eventLogger.accept("user_gedê", "Login bem-sucedido.");
        eventLogger.accept("user_ju", "Atualização de perfil.");
        eventLogger.accept("user_aria", "Tentativa de acesso negada."); // Usando ARIA aqui, Gedê!
    }
}
/*
Saída esperada (data/hora será diferente):
[2025-05-29 21:00:00] USER: user_gedê | EVENT: Login bem-sucedido.
[2025-05-29 21:00:01] USER: user_ju | EVENT: Atualização de perfil.
[2025-05-29 21:00:02] USER: user_aria | EVENT: Tentativa de acesso negada.
*/

```

### Composição de `BiConsumer` com `andThen()`

O método `andThen()` permite encadear múltiplas operações `BiConsumer`.

```java
import java.util.function.BiConsumer;

public class BiConsumerAndThenExemplo {

    public static void main(String[] args) {
        BiConsumer<String, Double> imprimirDetalhes = (nome, valor) ->
            System.out.println("Item: " + nome + ", Valor: " + valor);

        BiConsumer<String, Double> aplicarTaxa = (nome, valor) ->
            System.out.println("Item: " + nome + ", Valor com Taxa (5%): " + (valor * 1.05));

        // Encadeando os BiConsumers
        BiConsumer<String, Double> acoesCompletas = imprimirDetalhes.andThen(aplicarTaxa);

        System.out.println("Processando Pedido 1:");
        acoesCompletas.accept("Placa de Vídeo", 2500.00);

        System.out.println("\\nProcessando Pedido 2:");
        acoesCompletas.accept("Memória RAM", 400.00);
    }
}
/*
Saída esperada:
Processando Pedido 1:
Item: Placa de Vídeo, Valor: 2500.0
Item: Placa de Vídeo, Valor com Taxa (5%): 2625.0

Processando Pedido 2:
Item: Memória RAM, Valor: 400.0
Item: Memória RAM, Valor com Taxa (5%): 420.0
*/

```

---

## Informações Adicionais

### Diferenças entre `BiConsumer`, `Consumer` e `BiFunction`

Para que você, Gedê, entenda bem o cenário das interfaces funcionais de "consumo" e "função":

- **`Consumer<T>`:** Aceita **um** argumento de tipo `T` e **não retorna** nenhum resultado. Útil para operações em elementos individuais (e.g., `list.forEach(System.out::println)`).
    - Método: `void accept(T t)`
- **`BiConsumer<T, U>`:** Aceita **dois** argumentos de tipos `T` e `U` e **não retorna** nenhum resultado. Ideal para operações que precisam de dois inputs sem produzir um output (e.g., `map.forEach((k, v) -> System.out.println(k + ":" + v))`).
    - Método: `void accept(T t, U u)`
- **`Function<T, R>`:** Aceita **um** argumento de tipo `T` e **retorna** um resultado de tipo `R`. Usado para transformações de dados (e.g., `stream.map(s -> s.toUpperCase())`).
    - Método: `R apply(T t)`
- **`BiFunction<T, U, R>`:** Aceita **dois** argumentos de tipos `T` e `U` e **retorna** um resultado de tipo `R`. Perfeito para operações que precisam de dois inputs para produzir um output (e.g., calcular a soma de dois números).
    - Método: `R apply(T t, U u)`

### Quando usar `BiConsumer`

Você deve considerar o uso de `BiConsumer` quando:

- Você precisa executar uma ação com dois argumentos de entrada.
- A operação não precisa retornar um valor.
- Você está trabalhando com `Map`s e quer iterar sobre pares chave-valor usando o método `forEach()`.
- Você quer encadear operações que consomem os mesmos dois tipos de entrada.
- Em cenários de log ou observadores, onde dois dados contextuais são usados para um efeito colateral.

---

## Referências para Estudo Independente

Para aprofundar seu conhecimento sobre `BiConsumer` e outras interfaces funcionais, recomendo os seguintes recursos:

- **Documentação Oficial da Oracle - `BiConsumer`:**[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/BiConsumer.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/BiConsumer.html)
- **Tutorial de Java Oracle - Lambda Expressions:**[https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- **Baeldung - Java 8 BiConsumer:** (Excelente para exemplos práticos)
[https://www.baeldung.com/java-8-bicomsumer](https://www.baeldung.com/java-8-bicomsumer)
- **GeeksforGeeks - BiConsumer in Java with Examples:**[https://www.geeksforgeeks.org/bicomsumer-interface-in-java-with-examples/](https://www.geeksforgeeks.org/bicomsumer-interface-in-java-with-examples/)

Espero que esta explicação detalhada ajude você, Gedê, a dominar a `BiConsumer` e outros conceitos de programação funcional em Java\! Me diga qual o próximo tópico que você quer que eu detalhe.