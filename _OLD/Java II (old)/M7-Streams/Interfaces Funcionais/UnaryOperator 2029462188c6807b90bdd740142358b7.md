# UnaryOperator

Com certeza, Gedê\! Vamos detalhar a `UnaryOperator` para você. Essa interface é super útil quando se trabalha com Streams e programação funcional em Java.

## Introdução

No universo do Java 8 e suas evoluções, a programação funcional ganhou um impulso significativo com a introdução das Expressões Lambda e da Streams API. Nesse contexto, as Interfaces Funcionais Padrão, como `UnaryOperator`, são peças-chave que permitem escrever código mais conciso, legível e declarativo.

A relevância da `UnaryOperator` reside na sua capacidade de representar uma operação que recebe um argumento de um determinado tipo e retorna um resultado do *mesmo tipo*. Isso a torna ideal para transformações em sequências de dados, onde cada elemento é processado e retorna um elemento modificado do mesmo tipo. Para você, Gedê, que está buscando um cargo de Backend Go, entender essas interfaces é fundamental, pois o paradigma funcional é muito presente em Go e a forma de pensar que o Java 8 trouxe com as Streams e Lambdas se alinha a essa mentalidade.

### Definição e Conceitos Fundamentais

`UnaryOperator<T>` é uma interface funcional que estende `Function<T, T>`. Ou seja, ela é uma `Function` especializada onde o tipo de entrada (`T`) é o mesmo que o tipo de saída (`T`). Ela representa uma operação unária (que recebe um único argumento) que produz um resultado do mesmo tipo de seu operando. Em termos mais simples, é como uma "transformação de um para um" do mesmo tipo.

## Sumário

- **O que é `UnaryOperator<T>`?**
- **Sintaxe e Estrutura**
- **Componentes Principais**
- **Restrições de Uso**
- **Exemplos de Código Otimizados**
- **Informações Adicionais**
- **Referências para Estudo Independente**

## Conteúdo Detalhado

### O que é `UnaryOperator<T>`?

Como mencionado, `UnaryOperator<T>` é uma interface funcional definida no pacote `java.util.function`. Seu propósito é encapsular uma operação que aceita um único argumento do tipo `T` e retorna um resultado também do tipo `T`. Essa característica a diferencia de uma `Function<T, R>` genérica, onde `T` e `R` podem ser tipos diferentes.

### Sintaxe e Estrutura

A interface `UnaryOperator` possui apenas um método abstrato que precisa ser implementado, herdado de `Function`:

```java
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {

    /**
     * Retorna um UnaryOperator que sempre retorna seu argumento de entrada.
     *
     * @param <T> o tipo do operando e do resultado
     * @return um UnaryOperator que sempre retorna seu argumento de entrada
     */
    static <T> UnaryOperator<T> identity() {
        return t -> t;
    }
}

```

**Exemplos de Declaração e Utilização:**

Você pode declarar e utilizar um `UnaryOperator` de algumas formas:

1. **Usando uma classe anônima (menos comum atualmente):**
    
    ```java
    UnaryOperator<Integer> dobrar = new UnaryOperator<Integer>() {
        @Override
        public Integer apply(Integer num) {
            return num * 2;
        }
    };
    System.out.println(dobrar.apply(5)); // Saída: 10
    
    ```
    
2. **Usando Expressão Lambda (mais comum e concisa):**
    
    ```java
    UnaryOperator<Integer> dobrarLambda = num -> num * 2;
    System.out.println(dobrarLambda.apply(7)); // Saída: 14
    
    UnaryOperator<String> toUpperCase = s -> s.toUpperCase();
    System.out.println(toUpperCase.apply("hello gedê!")); // Saída: HELLO GEDÊ!
    
    ```
    
3. **Usando Referência de Método (quando a operação já existe em um método):**
    
    ```java
    UnaryOperator<String> toUpperCaseMethodRef = String::toUpperCase;
    System.out.println(toUpperCaseMethodRef.apply("olá ju!")); // Saída: OLÁ JU!
    
    ```
    

### Componentes Principais

A interface `UnaryOperator` possui um método principal e um método estático auxiliar:

- **`T apply(T t)` (herdado de `Function<T, T>`):**
    - **Função:** Este é o único método abstrato da interface que você precisa implementar. Ele recebe um argumento do tipo `T` e retorna um resultado do tipo `T`. É a lógica central da transformação.
    - **Interação:** Você define a regra de transformação dentro deste método. Quando o `UnaryOperator` é invocado (geralmente em uma operação de Stream, como `map`), o método `apply` é chamado para cada elemento.
- **`static <T> UnaryOperator<T> identity()`:**
    - **Função:** Este é um método estático de fábrica que retorna um `UnaryOperator` que simplesmente retorna seu argumento de entrada sem modificação. Ou seja, `identity().apply(x)` sempre resultará em `x`.
    - **Interação:** É útil quando você precisa de um operador que não altera os dados, mas ainda precisa de um `UnaryOperator` para preencher um requisito de método (por exemplo, em `reduce` onde a identidade é o valor inicial ou uma etapa intermediária).

### Restrições de Uso

- **Tipos Iguais:** A principal restrição é que o tipo de entrada e o tipo de saída devem ser os mesmos (`T`). Se você precisar de uma transformação que altere o tipo de dados (por exemplo, de `Integer` para `String`), você deve usar a interface `Function<T, R>`.
- **Interfaces Funcionais:** Como toda interface funcional, ela é projetada para ser utilizada com expressões lambda ou referências de método, permitindo um estilo de programação mais funcional e declarativo.
- **Single Responsibility:** Cada `UnaryOperator` deve encapsular uma única operação bem definida.

## Exemplos de Código Otimizados

### Caso de Uso Básico: Dobrar Valores em uma Lista

Um uso comum é transformar cada elemento de uma coleção, mantendo o mesmo tipo.

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

public class UnaryOperatorBasicExample {

    public static void main(String[] args) {
        List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);

        // Cenário: Criar um UnaryOperator para dobrar o valor de um número.
        // Isso é útil para transformações simples e reutilizáveis.
        UnaryOperator<Integer> dobrarNumero = num -> num * 2;

        // Aplica o UnaryOperator para dobrar cada número na lista
        List<Integer> numerosDobrados = numeros.stream()
                                                .map(dobrarNumero) // map aceita um Function, e UnaryOperator é um Function<T, T>
                                                .collect(Collectors.toList());

        System.out.println("Números originais: " + numeros);
        System.out.println("Números dobrados: " + numerosDobrados); // Saída: Números dobrados: [2, 4, 6, 8, 10]

        // Exemplo com String: converter para maiúsculas
        UnaryOperator<String> toUpperCase = String::toUpperCase;
        List<String> nomes = Arrays.asList("gedê", "ju", "maria");
        List<String> nomesMaiusculos = nomes.stream()
                                            .map(toUpperCase)
                                            .collect(Collectors.toList());

        System.out.println("Nomes originais: " + nomes);
        System.out.println("Nomes maiúsculos: " + nomesMaiusculos); // Saída: Nomes maiúsculos: [GEDÊ, JU, MARIA]
    }
}

```

### Caso de Uso Avançado: Composição de Operações e `UnaryOperator.identity()`

Em cenários mais complexos, você pode encadear operações ou usar `identity()` para operações condicionais ou como um valor padrão.

```java
import java.util.function.UnaryOperator;

public class UnaryOperatorAdvancedExample {

    public static void main(String[] args) {
        // Cenário: Compor operações de transformação de string.
        // Primeiro, remover espaços, depois converter para maiúsculas.
        UnaryOperator<String> removerEspacos = s -> s.replace(" ", "");
        UnaryOperator<String> toUpperCase = String::toUpperCase;

        // Composição de UnaryOperators: andThen() executa a primeira e depois a segunda
        UnaryOperator<String> transformarString = removerEspacos.andThen(toUpperCase);

        String textoOriginal = "Olá Gedê e Ju";
        String textoTransformado = transformarString.apply(textoOriginal);
        System.out.println("Texto original: '" + textoOriginal + "'");
        System.out.println("Texto transformado (sem espaços, maiúsculas): '" + textoTransformado + "'");
        // Saída: Texto transformado (sem espaços, maiúsculas): 'OLÁGEDÊEJU'

        // Cenário: Usando UnaryOperator.identity()
        // Imagine uma função que aplica um ajuste de preço, mas pode não fazer nada em alguns casos.
        double preco = 100.0;
        boolean aplicarDesconto = true; // Ou false, dependendo da lógica de negócio

        UnaryOperator<Double> ajustarPreco;

        if (aplicarDesconto) {
            ajustarPreco = p -> p * 0.9; // Aplica 10% de desconto
            System.out.println("Preço ajustado com desconto: " + ajustarPreco.apply(preco)); // Saída: 90.0
        } else {
            ajustarPreco = UnaryOperator.identity(); // Não altera o preço
            System.out.println("Preço ajustado sem desconto: " + ajustarPreco.apply(preco)); // Saída: 100.0
        }

        // Outro uso de identity() em Streams:
        // Se você precisa de um map que ocasionalmente não faz nada, ou como valor padrão em um reduce.
        UnaryOperator<Integer> someOperation = UnaryOperator.identity();
        Integer result = someOperation.apply(50);
        System.out.println("Resultado com identity(): " + result); // Saída: 50
    }
}

```

## Informações Adicionais

- **Herança de `Function<T, T>`:** É importante lembrar que `UnaryOperator` é essencialmente uma `Function` onde o tipo de entrada e saída são os mesmos. Isso significa que tudo o que se aplica a `Function` (como os métodos `andThen` e `compose` para encadeamento de funções) também se aplica a `UnaryOperator`.
- **Concisão e Legibilidade:** O uso de `UnaryOperator` com lambdas ou referências de método promove um código mais conciso e legível, especialmente em operações de transformação de dados dentro da Streams API.
- **Reusabilidade:** Ao definir um `UnaryOperator` para uma transformação específica, você pode reutilizá-lo em diferentes partes do seu código, evitando duplicação e promovendo a modularidade.
- **Integração com Streams API:** A `UnaryOperator` é frequentemente utilizada com métodos da Streams API, como `map`, `reduce`, ou mesmo em operações mais complexas onde uma transformação elemento a elemento é necessária.

## Referências para Estudo Independente

Para aprofundar seus conhecimentos, Gedê, recomendo os seguintes recursos:

- **Documentação Oficial Java - `UnaryOperator`:**
    - [Oracle Java Docs: UnaryOperator](https://www.google.com/search?q=https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/UnaryOperator.html)
- **Documentação Oficial Java - `Function`:** (Como `UnaryOperator` estende `Function`, é útil entender bem a interface pai)
    - [Oracle Java Docs: Function](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Function.html)
- **Baeldung - Java 8 Functional Interfaces:** (Um excelente recurso com muitos exemplos práticos)
    - [Baeldung: Java 8 Functional Interfaces](https://www.baeldung.com/java-8-functional-interfaces)
- **TutorialsPoint - Java 8 UnaryOperator:**
    - [TutorialsPoint: Java 8 UnaryOperator](https://www.google.com/search?q=https://www.tutorialspoint.com/java8/java8_unaryoperator.htm)

Espero que esta explicação detalhada ajude você, Gedê, a dominar a `UnaryOperator` e as interfaces funcionais em Java\! Se tiver mais alguma dúvida, é só chamar a A.R.I.A\!