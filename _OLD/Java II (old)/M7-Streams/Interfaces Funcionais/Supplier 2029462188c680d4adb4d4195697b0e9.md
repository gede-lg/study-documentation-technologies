# Supplier

### Introdução ao `Supplier<T>` em Java

No universo da programação funcional em Java, introduzida de forma mais robusta a partir do Java 8, as interfaces funcionais desempenham um papel central. Elas permitem que você trate a lógica de programação como funções de primeira classe, passando-as como argumentos para métodos, armazenando-as em variáveis e retornando-as de outros métodos. Isso é fundamental para a API de Streams, onde a manipulação de coleções se torna mais expressiva e concisa.

Entre as interfaces funcionais padrão, o `java.util.function.Supplier<T>` é uma das mais simples e fundamentais. Sua relevância reside na capacidade de **fornecer um valor** sem receber nenhum argumento de entrada. Em outras palavras, um `Supplier` representa uma "fábrica" de objetos, uma fonte que produz um resultado sob demanda. Isso é extremamente útil em cenários onde a criação de um objeto é custosa ou deve ser postergada até o momento em que ele realmente será utilizado, otimizando recursos e performance.

### Sumário

1. Definição e Conceitos Fundamentais
2. Sintaxe e Estrutura
3. Componentes Principais
4. Exemplos de Código Otimizados
5. Informações Adicionais
6. Referências para Estudo Independente

---

### Conteúdo Detalhado

### 1\. Definição e Conceitos Fundamentais

A interface `Supplier<T>` é uma interface funcional que representa uma operação que não aceita nenhum argumento e retorna um resultado do tipo `T`. O nome "Supplier" (Fornecedor) já indica sua finalidade: ela "fornece" um valor.

**Para que serve?**

O `Supplier<T>` é ideal para:

- **Atrasar a execução (Lazy Evaluation):** Produzir um valor apenas quando ele for realmente necessário. Isso é crucial para operações de alto custo computacional ou de alocação de recursos que podem não ser sempre utilizadas.
- **Factories de objetos:** Criar novos objetos sob demanda.
- **Retorno de valores padrão ou de fallback:** Fornecer um valor quando uma operação falha ou um valor não está presente (como em `Optional.orElseGet()`).
- **Geração de mensagens:** Construir mensagens de log complexas apenas se o nível de log estiver ativado, evitando processamento desnecessário.

### 2\. Sintaxe e Estrutura

Como uma interface funcional, `Supplier<T>` possui um único método abstrato.

```java
@FunctionalInterface
public interface Supplier<T> {
    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}

```

- `@FunctionalInterface`: Esta anotação indica que a interface é uma interface funcional. É opcional, mas serve para garantir que a interface tenha apenas um método abstrato, o que permite o uso de expressões lambda.
- `T`: É o tipo genérico do valor que será fornecido pelo `Supplier`.

**Exemplos de declaração e utilização:**

Você pode declarar um `Supplier` usando uma expressão lambda, uma referência de método ou uma classe anônima (embora as duas primeiras sejam preferenciais para interfaces funcionais).

```java
// Exemplo 1: Usando expressão lambda
Supplier<String> saudacaoSupplier = () -> "Olá, Gedê!";
String saudacao = saudacaoSupplier.get(); // saudacao agora é "Olá, Gedê!"
System.out.println(saudacao);

// Exemplo 2: Usando referência de método (quando o método não recebe argumentos e retorna um valor)
class GeradorDeNumeros {
    public static double gerarNumeroAleatorio() {
        return Math.random();
    }
}
Supplier<Double> numeroAleatorioSupplier = GeradorDeNumeros::gerarNumeroAleatorio;
double numero = numeroAleatorioSupplier.get(); // numero agora é um valor aleatório
System.out.println("Número aleatório: " + numero);

// Exemplo 3: Usando classe anônima (menos comum hoje em dia para interfaces funcionais)
Supplier<Long> timestampSupplier = new Supplier<Long>() {
    @Override
    public Long get() {
        return System.currentTimeMillis();
    }
};
long timestamp = timestampSupplier.get(); // timestamp agora é o tempo atual em milissegundos
System.out.println("Timestamp: " + timestamp);

```

### 3\. Componentes Principais

A interface `Supplier<T>` possui apenas um método principal:

- **`T get()`**: Este é o método abstrato que deve ser implementado. Ele é responsável por "fornecer" ou "produzir" o valor do tipo `T`. Quando você invoca `supplierInstance.get()`, a lógica definida na sua implementação do `Supplier` é executada para retornar o valor desejado. Não recebe nenhum parâmetro.

### 4\. Exemplos de Código Otimizados e Casos de Uso Reais

Vamos ver alguns exemplos práticos para o dia a dia de um desenvolvedor backend Java, Gedê.

**Caso de Uso 1: Avaliação Lenta (Lazy Evaluation) em Logs**

Imagine que você quer logar uma mensagem que exige um certo processamento para ser construída. Se o nível de log não estiver ativado para essa mensagem, você não quer que o processamento para construir a mensagem seja executado.

```java
import java.util.function.Supplier;

public class LogExample {

    private static final boolean IS_DEBUG_ENABLED = false; // Simula a ativação/desativação do debug

    public static void debug(Supplier<String> messageSupplier) {
        if (IS_DEBUG_ENABLED) {
            System.out.println("[DEBUG] " + messageSupplier.get()); // Só chama get() se o debug estiver ativado
        }
    }

    public static void main(String[] args) {
        // Sem Supplier: A string é construída mesmo que o debug não esteja ativado
        System.out.println("--- Sem Supplier ---");
        long startTime = System.nanoTime();
        if (IS_DEBUG_ENABLED) {
            System.out.println("[DEBUG] Processando dados complexos: " + expensiveDataProcessing());
        }
        long endTime = System.nanoTime();
        System.out.println("Tempo sem Supplier: " + (endTime - startTime) + " ns"); // Tempo gasto mesmo sem logar

        System.out.println("\\n--- Com Supplier ---");
        startTime = System.nanoTime();
        // Com Supplier: A lambda (expensiveDataProcessing()) só é executada se debug() realmente precisar do valor
        debug(() -> "Processando dados complexos: " + expensiveDataProcessing());
        endTime = System.nanoTime();
        System.out.println("Tempo com Supplier: " + (endTime - startTime) + " ns"); // Tempo gasto apenas se logado
    }

    private static String expensiveDataProcessing() {
        System.out.println("Executando processamento de dados caro...");
        try {
            Thread.sleep(100); // Simula um processamento demorado
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return "Dados processados (resultado)";
    }
}

```

Neste exemplo, observe que quando `IS_DEBUG_ENABLED` é `false`, a função `expensiveDataProcessing()` é **chamada** no primeiro caso (sem Supplier), mas **não é chamada** no segundo caso (com Supplier), pois a lambda só é executada quando `messageSupplier.get()` é invocado dentro do `if`. Isso economiza recursos valiosos.

**Caso de Uso 2: Fornecendo Valores Padrão com `Optional`**

A classe `Optional` (também do Java 8+) usa `Supplier` para fornecer um valor de fallback apenas se o `Optional` estiver vazio.

```java
import java.util.Optional;
import java.util.function.Supplier;

public class OptionalSupplierExample {

    public static void main(String[] args) {
        Optional<String> nomeOpcionalExistente = Optional.of("Ju");
        Optional<String> nomeOpcionalVazio = Optional.empty();

        // Usando orElse() - O valor padrão é sempre criado/avaliado
        String nome1 = nomeOpcionalExistente.orElse(getDefaultName("chamado orElse"));
        System.out.println("Nome 1 (orElse): " + nome1); // "Ju"

        String nome2 = nomeOpcionalVazio.orElse(getDefaultName("chamado orElse"));
        System.out.println("Nome 2 (orElse): " + nome2); // "Visitante"

        System.out.println("\\n--- Comparando com orElseGet() ---");

        // Usando orElseGet() - O Supplier só é invocado se o Optional estiver vazio
        String nome3 = nomeOpcionalExistente.orElseGet(() -> getDefaultName("chamado orElseGet"));
        System.out.println("Nome 3 (orElseGet): " + nome3); // "Ju"

        String nome4 = nomeOpcionalVazio.orElseGet(() -> getDefaultName("chamado orElseGet"));
        System.out.println("Nome 4 (orElseGet): " + nome4); // "Visitante"
    }

    private static String getDefaultName(String caller) {
        System.out.println("Gerando nome padrão... (chamado por: " + caller + ")");
        return "Visitante";
    }
}

```

Repare que, quando o `Optional` *não está vazio*, `getDefaultName()` é chamada com `orElse()`, mas **não é chamada** com `orElseGet()`. Isso demonstra a economia de processamento que o `Supplier` proporciona.

**Caso de Uso 3: Factory de Objetos Dinâmica**

Você pode usar `Supplier` para criar instâncias de objetos de forma genérica.

```java
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

interface Product {
    String getName();
}

class Book implements Product {
    @Override
    public String getName() { return "Livro"; }
}

class Electronics implements Product {
    @Override
    public String getName() { return "Eletrônico"; }
}

public class ProductFactory {

    private static final Map<String, Supplier<Product>> productMap = new HashMap<>();

    static {
        productMap.put("book", Book::new); // Supplier para Book
        productMap.put("electronics", Electronics::new); // Supplier para Electronics
        // Adicionar outros produtos conforme necessário
    }

    public static Product createProduct(String type) {
        Supplier<Product> supplier = productMap.get(type.toLowerCase());
        if (supplier != null) {
            return supplier.get(); // Retorna uma nova instância do produto
        }
        throw new IllegalArgumentException("Tipo de produto desconhecido: " + type);
    }

    public static void main(String[] args) {
        Product book = ProductFactory.createProduct("Book");
        System.out.println("Produto criado: " + book.getName());

        Product electronics = ProductFactory.createProduct("Electronics");
        System.out.println("Produto criado: " + electronics.getName());

        try {
            Product unknown = ProductFactory.createProduct("Food");
        } catch (IllegalArgumentException e) {
            System.err.println(e.getMessage());
        }
    }
}

```

Aqui, o `productMap` armazena `Suppliers` que sabem como criar os diferentes tipos de `Product`. A criação do objeto só ocorre quando `supplier.get()` é invocado.

### Restrições de Uso

A principal "restrição" do `Supplier` é que ele **não aceita argumentos**. Se a sua lógica de "fornecimento" de valor precisar de alguma entrada, você precisará de outras interfaces funcionais, como `Function<T, R>` (que aceita um argumento e retorna um resultado) ou `BiFunction<T, U, R>` (que aceita dois argumentos).

### Informações Adicionais

- **Imutabilidade:** O `Supplier` em si não garante imutabilidade do valor fornecido. Cada chamada a `get()` pode retornar uma nova instância ou uma referência a uma instância mutável. Depende da implementação do `Supplier`.
- **Encadeamento:** Embora `Supplier` não tenha métodos default para encadeamento como `Function` (`andThen`, `compose`), ele pode ser combinado com outras interfaces funcionais. Por exemplo, você pode ter um `Supplier` que retorna um objeto, e então usar uma `Function` para transformar esse objeto.
- **Integração com outras APIs:** Além de `Optional` e Streams, `Supplier` é amplamente utilizado em diversas bibliotecas e frameworks Java para otimizar a criação e o acesso a recursos, especialmente em cenários de injeção de dependência tardia ou lazy loading.

### Referências para Estudo Independente

Para Gedê e Ju aprofundarem ainda mais nesse conceito:

1. **Documentação Oficial Oracle - `Supplier<T>`:**
    - [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Supplier.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Supplier.html)
2. **Oracle Tutorials - Lambda Expressions:**
    - Embora não seja direto sobre `Supplier`, entender as expressões lambda é fundamental para usar `Supplier` e outras interfaces funcionais.
    - [https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
3. **Baeldung - Java 8 Supplier Interface:**
    - Um excelente recurso com exemplos e explicações claras.
    - [https://www.baeldung.com/java-supplier](https://www.baeldung.com/java-supplier)
4. **GeeksforGeeks - Java `java.util.function.Supplier` Interface:**
    - Outro bom site com exemplos práticos.
    - [https://www.geeksforgeeks.org/java-util-function-supplier-interface-in-java/](https://www.geeksforgeeks.org/java-util-function-supplier-interface-in-java/)

Espero que esta explicação detalhada sobre `Supplier<T>` seja muito útil para seus estudos, Gedê\! Me diga qual o próximo tópico que A.R.I.A. deve te explicar.