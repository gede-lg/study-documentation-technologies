# Collectors

1. **Introdução**
    
    A Stream API do Java, introduzida no Java 8, representa um marco na forma como processamos coleções de dados de maneira funcional e expressiva. Dentro desse ecossistema, os **Collectors** são ferramentas fundamentais que permitem coletar, agregar e transformar os resultados de operações de stream de forma fácil e eficiente.
    
    - **Visão Geral Concisa:**
    Collectors são classes utilitárias que implementam a interface `Collector<T, A, R>`, definindo como elementos de um `Stream<T>` devem ser acumulados em uma estrutura de resultado `R`.
    - **Relevância e Importância:**
        - Simplificam operações de agrupamento, particionamento, estatísticas e transformação de dados.
        - Promovem código mais legível e conciso, eliminando loops manuais e estruturas intermediárias.
        - Integram-se perfeitamente ao paradigma de programação funcional, aproveitando lambdas e métodos de referência.
    - **Definição e Conceitos Fundamentais:**
        - **Tema Principal:** “Stream API – Collectors” é o conjunto de mecanismos para coletar elementos de uma stream em diferentes formatos (listas, mapas, resumos estatísticos etc.).
        - **Subtemas:** incluem agregações simples (por exemplo, `toList()`), agrupamentos (`groupingBy()`), particionamentos (`partitioningBy()`), coletores de junção de strings (`joining()`), estatísticas (`summarizingInt()`, `averagingDouble()`), entre outros.
        - **Para que servem:** permitem transformar fluxos de dados em coleções, valores estatísticos ou estruturas customizadas sem esforço manual de iteração.

---

1. **Sumário**
    1. Introdução
    2. Sintaxe e Estrutura
    3. Componentes Principais
        - Coletores Básicos
        - Agrupamento e Particionamento
        - Estatísticas e Resumos
        - Transformações Adicionais
    4. Restrições de Uso
    5. Exemplos de Código Otimizados
        - Uso Básico
        - Uso Avançado
    6. Informações Adicionais
    7. Referências para Estudo Independente

---

1. **Conteúdo Detalhado**
    
    ### 3.1 Sintaxe e Estrutura
    
    - **Interface `Collector<T, A, R>`**
        - `T`: tipo dos elementos de entrada no stream.
        - `A`: tipo do acumulador intermediário.
        - `R`: tipo de resultado final.
    - **Definição de um Collector:**
        
        ```java
        Collector<T, A, R> myCollector = Collector.of(
            () -> new A(),          // supplier: cria acumulador
            (a, t) -> a.add(t),     // accumulator: processa cada elemento
            (a1, a2) -> merge(a1,a2), // combiner: une dois acumuladores
            a -> finisher(a));      // finisher: transforma acumulador em resultado
        
        ```
        
    - **Uso Típico:** basta chamar `stream().collect(...)`.
    
    ### 3.2 Componentes Principais
    
    ### 3.2.1 Coletores Básicos
    
    - **`Collectors.toList()`**: cria `List<T>`.
    - **`Collectors.toSet()`**: cria `Set<T>`.
    - **`Collectors.toCollection(Supplier<C>)`**: coleciona em implementação customizada (por ex. `TreeSet`).
    - **`Collectors.toMap(keyMapper, valueMapper)`**: constrói `Map<K,V>`.
    - **Sintaxe Exemplo:**
        
        ```java
        List<String> nomes = pessoas.stream()
            .map(Person::getName)
            .collect(Collectors.toList());
        
        ```
        
    
    ### 3.2.2 Agrupamento e Particionamento
    
    - **`Collectors.groupingBy(classifier)`**
        - Agrupa elementos por uma chave.
        - Retorna `Map<K, List<T>>`.
        - Possui sobrecargas para mapas customizados e coletores downstream.
    - **`Collectors.partitioningBy(predicate)`**
        - Particiona em `Map<Boolean, List<T>>`, útil para separações binárias.
    - **Sintaxe Exemplo:**
        
        ```java
        Map<String, List<Person>> porCidade = pessoas.stream()
            .collect(Collectors.groupingBy(Person::getCity));
        
        Map<Boolean, List<Person>> maioresDeIdade = pessoas.stream()
            .collect(Collectors.partitioningBy(p -> p.getAge() >= 18));
        
        ```
        
    
    ### 3.2.3 Estatísticas e Resumos
    
    - **`Collectors.counting()`**: retorna total de elementos (`Long`).
    - **`Collectors.summingInt(ToIntFunction<T>)`**, `summingLong`, `summingDouble`: soma campos numéricos.
    - **`Collectors.averagingInt(ToIntFunction<T>)`**, etc.: média de valores.
    - **`Collectors.maxBy(Comparator<T>)`**, `minBy`: busca valor máximo/mínimo.
    - **`Collectors.summarizingInt/Long/Double(...)`**: retorna `IntSummaryStatistics` (count, sum, min, max, average).
    - **Sintaxe Exemplo:**
        
        ```java
        IntSummaryStatistics stats = pessoas.stream()
            .collect(Collectors.summarizingInt(Person::getAge));
        System.out.println("Média: " + stats.getAverage());
        
        ```
        
    
    ### 3.2.4 Transformações Adicionais
    
    - **`Collectors.joining(delimiter, prefix, suffix)`**: concatena strings.
    - **`Collectors.mapping(mapper, downstream)`**: aplica mapeamento antes de coletar.
    - **`Collectors.collectingAndThen(downstream, finisher)`**: executa finisher adicional.
    - **Sintaxe Exemplo:**
        
        ```java
        String csv = pessoas.stream()
            .map(Person::getName)
            .collect(Collectors.joining(", ", "[", "]"));
        
        Set<String> nomesSet = pessoas.stream()
            .collect(Collectors.collectingAndThen(
                Collectors.toSet(),
                Collections::unmodifiableSet));
        
        ```
        
    
    ### 3.3 Restrições de Uso
    
    - **Estado Mutável:** ao usar coletores com coletores downstream ou customizados, cuidado com concorrência em streams paralelos: prefira coletores thread-safe ou estruturas imutáveis.
    - **Tipo de Chave em `toMap()`:** gerencie colisões de chave com sobrecarga que recebe um mergeFunction.
    - **Performance:** streams paralelos com coletores pesados (por ex. `groupingBy` em grandes volumes) podem exigir ajustes de lotes (`batchSize`) ou particionamento manual.

---

1. **Exemplos de Código Otimizados**
    
    ```java
    // 1. Coleção Básica: lista de nomes únicos ordenados
    List<String> nomesUnicosOrdenados = pessoas.stream()
        .map(Person::getName)
        .collect(Collectors.toCollection(TreeSet::new))
        .stream()
        .collect(Collectors.toList());
    
    // 2. Agrupamento com downstream e contagem
    Map<String, Long> countPorCidade = pessoas.stream()
        .collect(Collectors.groupingBy(
            Person::getCity,
            Collectors.counting()
        ));
    
    // 3. Particionamento em ativos/inativos
    Map<Boolean, List<User>> ativosInativos = users.stream()
        .collect(Collectors.partitioningBy(User::isActive));
    
    // 4. Estatísticas de vendas
    DoubleSummaryStatistics vendasStats = vendas.stream()
        .collect(Collectors.summarizingDouble(Sale::getAmount));
    System.out.printf("Total: %.2f, Média: %.2f%n",
        vendasStats.getSum(), vendasStats.getAverage());
    
    // 5. Mapear e coletar em Map<K, V> com merge
    Map<String, Integer> totalByCategory = produtos.stream()
        .collect(Collectors.toMap(
            Product::getCategory,
            Product::getQuantity,
            Integer::sum       // mergeFunction para chaves duplicadas
        ));
    
    ```
    
    Em cada exemplo, priorizou-se **legibilidade**, **eficiência** e **uso de lambdas/métodos de referência**, alinhado a boas práticas de código.
    

---

1. **Informações Adicionais**
    - **Streams Paralelos:** use `parallelStream()` combinado a coletores imutáveis ou coletores projetados para concorrência (`Collectors.toConcurrentMap`, `groupingByConcurrent`).
    - **Custom Collectors:** implemente `Collector.of(...)` para requisitos específicos (por ex. agregações customizadas).
    - **Integração com APIs Externas:** combine `Collectors` com calls assíncronas (CompletableFuture) para pipelines complexos.
    - **Performance Tuning:**
        - Avalie custo de instância de coletores downstream.
        - Prefira `toList()` em vez de `toCollection(ArrayList::new)` salvo necessidade especial.
        - Monitore overhead de boxing/unboxing em coletores numéricos.

---

1. **Referências para Estudo Independente**
    - **Documentação Oficial Oracle**
        - Stream API e Collectors:
        [https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html)
    - **Tutorials e Artigos**
        - Baeldung – “Guide to Java 8 Streams”
        [https://www.baeldung.com/java-8-streams](https://www.baeldung.com/java-8-streams)
        - Vogella – “Java 8 Streams by Example”
        [https://www.vogella.com/tutorials/JavaStreams/article.html](https://www.vogella.com/tutorials/JavaStreams/article.html)
    - **Livros**
        - *Modern Java in Action* (Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft) – Capítulo sobre Streams.
        - *Java 8 in Action* (Raoul-Gabriel Urma, Mario Fusco) – Seção detalhada sobre Collectors.

---

> Dica: pratique criando pipelines reais a partir dos seus projetos: por exemplo, agrupe logs por nível, some estatísticas de métricas ou gere relatórios CSV usando joining(). Isso solidifica tanto o entendimento quanto a fluidez no uso da Stream API.
>