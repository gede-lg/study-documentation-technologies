# Criação de Streams

**1. Introdução**

Os *Streams* em Java foram introduzidos na versão 8 como parte do pacote `java.util.stream` e trouxeram para a linguagem o paradigma de programação funcional, permitindo processar coleções de forma declarativa e encadeada.

- **Visão geral concisa:** um *Stream* representa uma sequência de elementos sobre a qual podemos aplicar diversas operações (filtragem, mapeamento, redução etc.) de forma *lazy* (avaliação sob demanda) e, opcionalmente, em paralelo.
- **Relevância e importância:**
    - Facilita o processamento de grandes volumes de dados de maneira concisa e legível.
    - Explora melhor recursos de hardware (paralelismo) sem alterar a lógica do programa.
    - Reduz boilerplate (loops explícitos, acúmulos manuais) e propicia pipelines de transformação de dados.
- **Definição e conceitos fundamentais:**
    - **Tema principal:** “Criação de Streams” — como gerar pipelines de dados a partir de diferentes fontes.
    - **Subtemas:**
        1. **Fontes de Stream:** coleções, arrays, I/O, geradores infinitos.
        2. **Operações intermediárias:** `filter`, `map` etc., que retornam outro stream.
        3. **Operações terminais:** `collect`, `forEach`, `reduce` etc., que produzem um resultado ou efeito colateral.

---

**2. Sumário**

1. Fontes de Stream
2. Sintaxe básica e estruturas de criação
3. Operações intermediárias e terminais
4. Componentes principais da API `Stream`
5. Restrições de uso
6. Exemplos de Código Otimizados
7. Informações Adicionais
8. Referências para Estudo Independente

---

**3. Conteúdo Detalhado**

### 3.1 Fontes de Stream

- **Coleções:**
    
    ```java
    List<String> lista = List.of("a", "bb", "ccc");
    Stream<String> stream = lista.stream();
    
    ```
    
- **Arrays:**
    
    ```java
    String[] arr = {"x","y","z"};
    Stream<String> s1 = Arrays.stream(arr);
    Stream<String> s2 = Stream.of(arr);
    
    ```
    
- **Valores literais / Variadics:**
    
    ```java
    Stream<Integer> nums = Stream.of(1,2,3,4,5);
    
    ```
    
- **Streams infinitos / geradores:**
    
    ```java
    Stream<Double> randoms = Stream.generate(Math::random);
    Stream<Integer> naturais = Stream.iterate(1, n -> n+1);
    
    ```
    

### 3.2 Sintaxe e Estrutura

Um pipeline de stream é composto por:

1. **Fonte** (`Stream<T>`)
2. **Zero ou mais operações intermediárias** → retornam `Stream<T>` ou `Stream<R>`
3. **Uma operação terminal** → produz resultado ou efeito

```java
List<String> nomes = List.of("Ana","Bruno","Carlos");
// pipeline: fonte → filter → map → collect (terminal)
List<String> curtinhos = nomes.stream()
    .filter(s -> s.length() <= 4)        // operação intermediária
    .map(String::toUpperCase)            // operação intermediária
    .collect(Collectors.toList());       // operação terminal

```

### 3.3 Componentes Principais da API `Stream`

| Categoria | Métodos / Elementos |
| --- | --- |
| **Criação** | `stream()`, `of()`, `generate()`, `iterate()` |
| **Filtragem** | `filter(Predicate<? super T>)` |
| **Transformação** | `map(Function<? super T,? extends R>)`, `flatMap(...)` |
| **Ordenação & Distinção** | `sorted()`, `sorted(Comparator)`, `distinct()` |
| **Limitação** | `limit(long)`, `skip(long)` |
| **Visualização** | `peek(Consumer<? super T>)` |
| **Redução / Agregação** | `reduce()`, `count()`, `min()`, `max()`, `sum()` (em primitivos) |
| **Coleta** | `collect(Collector<? super T,A,R>)` |
| **Match & Busca** | `anyMatch()`, `allMatch()`, `noneMatch()`, `findFirst()`, `findAny()` |
| **Execução paralela** | `parallel()`, `parallelStream()` |
- **Interação entre eles:**
    - Operações intermediárias não disparam processamento; apenas constroem o pipeline.
    - A avaliação só ocorre quando chega à operação terminal.
    - Em pipelines paralelos, o framework divide os dados em *chunks*, processa em threads e combina resultados automaticamente.

### 3.4 Restrições de uso

1. **Streams são *one-shot*:** não podem ser reutilizados após uma operação terminal.
2. **Sem efeitos colaterais:** evite mutar variáveis externas dentro de lambdas.
3. **Estado compartilhado em paralelo:** cuidado com operações que dependam de estado mutável.
4. **Ordem de execução:** em alguns casos (`parallel()`), a ordem de processamento não é garantida — use `forEachOrdered` se necessário.

---

**4. Exemplos de Código Otimizados**

### 4.1 Exemplo Básico

Filtrar números pares, elevar ao quadrado e coletar em lista:

```java
List<Integer> numeros = IntStream.rangeClosed(1, 10)
    .boxed()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());
// resultado: [4, 16, 36, 64, 100]

```

### 4.2 Exemplo Intermediário

Agrupar palavras por tamanho e ordenar cada sublista:

```java
List<String> palavras = List.of("maçã","banana","uva","abacate","figo");
Map<Integer, List<String>> porTamanho = palavras.stream()
    .collect(Collectors.groupingBy(
        String::length,
        Collectors.collectingAndThen(
            Collectors.toList(),
            lst -> {
                lst.sort(Comparator.naturalOrder());
                return lst;
            }
        )
    ));
// ex: {4=[figo, uva], 5=[maçã], 6=[banana], 7=[abacate]}

```

### 4.3 Exemplo Avançado (Paralelo)

Somar valores de um grande *array* usando *parallel stream*:

```java
long soma = LongStream.rangeClosed(1, 1_000_000)
    .parallel()       // processa em vários núcleos
    .sum();

```

> Dica: sempre meça performance; nem toda operação paralela é mais rápida (overhead de threads).
> 

---

**5. Informações Adicionais**

- **Lazy vs. Eager:**
    - Intermediárias são *lazy*; só executam de fato quando a terminal é chamada.
- **Operações *stateless* x *stateful*:**
    - *Stateless* (e.g., `map`, `filter`) não mantêm estado entre elementos.
    - *Stateful* (e.g., `sorted`, `distinct`) podem exigir buffering de elementos.
- **Streams infinitos:** use `limit(...)` ou condições de término para evitar loops infinitos.
- **Streams vs. Collections:**
    - Streams não armazenam dados; servem como pipeline.
    - Para reuso de resultados, colete em coleção antes.
- **Integração com `Optional`:** fácil de converter coleções filtradas em `Optional<T>` via `findFirst()`, `findAny()`.
- **Uso com I/O:** `Files.lines(path)` retorna `Stream<String>` de linhas de um arquivo.

---

**6. Referências para Estudo Independente**

- **Documentação Oracle:**
    - Streams — [https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)
    - Tutorial Java Streams — [https://docs.oracle.com/javase/tutorial/collections/streams/](https://docs.oracle.com/javase/tutorial/collections/streams/)
- **Artigos e Tutoriais:**
    - Baeldung “Guide to Java 8 Streams” — [https://www.baeldung.com/java-8-streams](https://www.baeldung.com/java-8-streams)
    - Vogella “Java 8 Streams Tutorial” — [https://www.vogella.com/tutorials/JavaStreams/article.html](https://www.vogella.com/tutorials/JavaStreams/article.html)
- **Livros:**
    - *Java 8 in Action* (Raoul-Gabriel Urma et al.)
    - *Modern Java in Action* (Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft)

---

> Conclusão: dominar a criação e manipulação de Streams em Java é essencial para escrever código mais expressivo, conciso e (potencialmente) mais performático. Aprofunde-se nos métodos da interface Stream, experimente pipelines próprios e sempre teste o comportamento em modo paralelo versus sequencial.
>