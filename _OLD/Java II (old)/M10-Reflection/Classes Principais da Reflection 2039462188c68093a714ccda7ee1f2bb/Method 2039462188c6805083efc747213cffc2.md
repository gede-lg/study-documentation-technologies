# Method

1. **Introdução**
    - **Visão Geral:** A classe `java.lang.reflect.Method` é um dos pilares da Reflection API do Java. Ela representa, em tempo de execução, um método declarado em uma classe ou interface, permitindo inspeção de metadados (nome, parâmetros, tipo de retorno, modificadores) e até a invocação dinâmica de comportamentos.
    - **Relevância:** Em cenários como frameworks de injeção de dependência (Spring), serialização automática, testes dinâmicos, mapeamento objeto-relacional e ferramentas de análise, a capacidade de chamar métodos sem conhecê-los em tempo de compilação é fundamental.
    - **Definição e Conceitos Fundamentais:**
        - **Tema Principal:** A classe `Method`, que abstrai o conceito de “método Java em tempo de execução”.
        - **Subtemas:**
            - *Obtendo um objeto `Method`* (via `Class.getMethod` / `getDeclaredMethod`)
            - *Inspeção de metadados* (`getName`, `getReturnType`, `getParameterTypes`, `getModifiers`)
            - *Invocação dinâmica* (`invoke`)
            - *Controle de acessibilidade* (`setAccessible(true)`)
        - **Para que servem:** Permitem descobrir e executar métodos mesmo quando não há referência direta no código, viabilizando arquiteturas altamente genéricas e extensíveis.
2. **Sumário**
    1. Obtenção de Instâncias de `Method`
    2. Estrutura e Sintaxe
    3. Componentes Principais da API `Method`
    4. Restrições de Uso
    5. Exemplos de Código Otimizados
    6. Informações Adicionais
    7. Referências para Estudo Independente
3. **Conteúdo Detalhado**
    
    ### 3.1 Obtenção de Instâncias de `Method`
    
    - **Públicos vs. Privados**
        
        ```java
        Class<?> cls = MinhaClasse.class;
        // método público
        Method m1 = cls.getMethod("nomeDoMetodo", String.class, int.class);
        // método declarado (pode ser private)
        Method m2 = cls.getDeclaredMethod("metodoPrivado", double.class);
        
        ```
        
    - **Exceções comuns:**
        - `NoSuchMethodException`
        - `SecurityException`
    
    ### 3.2 Sintaxe e Estrutura
    
    ```java
    public final class Method extends Executable implements GenericDeclaration {
        // principais assinaturas:
        public String getName();
        public Class<?> getReturnType();
        public Class<?>[] getParameterTypes();
        public Type[] getGenericParameterTypes();
        public int getModifiers();
        public Object invoke(Object obj, Object... args)
            throws IllegalAccessException, InvocationTargetException;
        public void setAccessible(boolean flag) throws SecurityException;
        // ...
    }
    
    ```
    
    - Herda de `Executable`, compartilhando operações com `Constructor`.
    - Implementa `GenericDeclaration`, fornecendo acesso a parâmetros genéricos.
    
    ### 3.3 Componentes Principais da API `Method`
    
    | Membro | Descrição |
    | --- | --- |
    | `getName()` | Retorna o nome do método. |
    | `getReturnType()` | Retorna a classe do tipo de retorno (ex.: `void.class`, `String.class`). |
    | `getParameterTypes()` | Retorna array de `Class<?>` com os tipos formais dos parâmetros. |
    | `getGenericReturnType()` | Fornece tipo de retorno com informação genérica (`Type`). |
    | `getModifiers()` | Retorna `int` bitmask dos modificadores (`public`, `static`, etc). Use `Modifier.toString(...)` para legibilidade. |
    | `invoke(Object, ...)` | Executa o método no objeto alvo, passando argumentos; retorna o resultado (ou `null` se `void`). |
    | `setAccessible(true)` | Desativa verificações de acessibilidade, permitindo invocar métodos `private` ou `protected`. |
    | `isVarArgs()` | Informa se o método aceita varargs. |
    | `getExceptionTypes()` | Retorna exceções declaradas em `throws`. |
    | `toGenericString()` | Representação completa com generics e modificadores. |
    
    ### Interação Entre Componentes
    
    1. **Inspeção:** Antes de chamar, você pode checar se o método é estático (`Modifier.isStatic(m.getModifiers())`), quantos parâmetros espera e se é acessível.
    2. **Acesso:** Se for privado, chame `m.setAccessible(true)` para habilitar acesso em ambientes sem restrição de `SecurityManager`.
    3. **Invocação:** Em seguida, `m.invoke(instânciaOuNull, args...)`. Se lançar exceção interna, ela virá embrulhada em `InvocationTargetException`.
    
    ### 3.4 Restrições de Uso
    
    - **Performance:** Reflection é mais lento que chamadas diretas; minimize uso em loops críticos.
    - **Segurança:** Sob `SecurityManager` estrito, pode ser proibido desativar verificações de acesso.
    - **Type Safety:** Erros em tempo de execução; sem checagem de tipos em `invoke`, cuidado com `ClassCastException`.
4. **Exemplos de Código Otimizados**
    
    ```java
    // Exemplo 1: Invocando um método público
    public class Usuario {
        public String saudacao(String nome) {
            return "Olá, " + nome;
        }
    }
    // uso reflection:
    Method saud = Usuario.class.getMethod("saudacao", String.class);
    String msg = (String) saud.invoke(new Usuario(), "Juliana");
    System.out.println(msg); // “Olá, Juliana”
    
    // Exemplo 2: Acessando método privado
    public class Segredo {
        private int codigo() { return 1234; }
    }
    Method cod = Segredo.class.getDeclaredMethod("codigo");
    cod.setAccessible(true);
    int valor = (int) cod.invoke(new Segredo());
    System.out.println(valor); // 1234
    
    // Exemplo 3: Chamando método varargs
    public class Formatter {
        public String join(String sep, String... parts) {
            return String.join(sep, parts);
        }
    }
    Method join = Formatter.class.getMethod("join", String.class, String[].class);
    String result = (String) join.invoke(new Formatter(), ", ", new Object[]{ new String[]{"A","B","C"} });
    System.out.println(result); // A, B, C
    
    ```
    
5. **Informações Adicionais**
    - **Cache de `Method`:** Para reduzir overhead, armazene referências a objetos `Method` em mapas estáticos quando for chamar repetidamente.
    - **Alternativas de Performance:** Bibliotecas como [MethodHandles](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/invoke/MethodHandles.html) (Java 7+) são mais rápidas e seguras.
    - **Uso em Frameworks:** Spring, Hibernate e Jackson usam amplamente `Method` para binding dinâmico de propriedades e chamadas de callbacks.
6. **Referências para Estudo Independente**
    - Oracle Reflection API – Classe `Method`:
    [https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html)
    - Artigo “Introduction to Java Reflection” (Baeldung):
    [https://www.baeldung.com/java-reflection](https://www.baeldung.com/java-reflection)
    - Livro *Effective Java* (Joshua Bloch) – Capítulo sobre Reflection e Performance
    - Tutorial “MethodHandles vs Reflection” (Oracle Blog):
    [https://blogs.oracle.com/java/post/methodhandles-vs-reflection](https://blogs.oracle.com/java/post/methodhandles-vs-reflection)

---

> Dica: use reflection com parcimônia—sempre que possível, prefira APIs tipadas ou interfaces de alto nível. Reflection é poderosa, mas requer atenção extra à segurança, performance e manutenibilidade.
>