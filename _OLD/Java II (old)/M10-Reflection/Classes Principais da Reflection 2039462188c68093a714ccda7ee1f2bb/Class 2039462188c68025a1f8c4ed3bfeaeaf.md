# Class

**1. Introdução**

A **Reflection API** do Java permite que programas inspecionem e manipulem classes, métodos, campos e construtores em tempo de execução. O tema principal aqui é a classe `java.lang.Class`, que é o ponto de entrada para obter informações sobre qualquer tipo — seja uma classe concreta, abstrata, interface, enum ou array — e executar operações dinâmicas, como criação de instâncias e invocação de métodos.

- **Relevância:** Reflection é fundamental para frameworks de injeção de dependência (como Spring), ORM (como Hibernate) e ferramentas de teste (JUnit, Mockito). Permite, por exemplo, carregar classes a partir de nomes, descobrir anotações em tempo de execução e construir APIs genéricas que operam sobre objetos desconhecidos em tempo de compilação.
- **Definição de termos:**
    - **Tema principal:** a classe `Class` em si — seu propósito é representar metadados de tipos Java em tempo de execução.
    - **Subtemas:** métodos de obtenção de metadados (`getFields()`, `getMethods()`, etc.), criação de instâncias (`newInstance()`), navegação de hierarquia (superclasses, interfaces).
    - **Para que servem:** permitem inspeção e manipulação dinâmica de tipos, sem depender de código estático.

---

**2. Sumário**

1. Introdução
2. Sumário
3. Conteúdo Detalhado
    - 3.1 Sintaxe e Estrutura
    - 3.2 Componentes Principais da Classe `Class`
    - 3.3 Restrições de Uso
4. Exemplos de Código Otimizados
5. Informações Adicionais
6. Referências para Estudo Independente

---

**3. Conteúdo Detalhado**

### 3.1 Sintaxe e Estrutura

A classe `Class<T>` está no pacote `java.lang`. Cada classe carregada pela JVM teve seu objeto `Class` criado automaticamente. Você não a instancia com `new`, mas obtém referências via:

```java
// A partir de uma instância
String s = "texto";
Class<? extends String> cls1 = s.getClass();

// A partir do nome qualificado
Class<?> cls2 = Class.forName("java.lang.String");

// Direto do literal de tipo
Class<String> cls3 = String.class;

```

### 3.2 Componentes Principais da Classe `Class`

| Método / Grupo | Finalidade |
| --- | --- |
| **Obtenção de informações** |  |
| `getName()` | Retorna o nome completo da classe (e.g., `"com.exemplo.Foo"`). |
| `getSimpleName()` | Nome simples (sem pacote), e.g., `"Foo"`. |
| `getPackage()` | Retorna o pacote `Package`. |
| `getModifiers()` | Bits de modificadores (public, final, etc.), via `Modifier` utilitário. |
| `isInterface()`, `isEnum()` | Testa se é interface, enum, array, anotação, primitivo (`isPrimitive()`), etc. |
| **Campos** |  |
| `getFields()`, `getDeclaredFields()` | Obtém campos públicos (inclui herdados) ou todos declarados na classe. |
| **Métodos** |  |
| `getMethods()`, `getDeclaredMethods()` | Métodos públicos herdados ou todos declarados. |
| **Construtores** |  |
| `getConstructors()`, `getDeclaredConstructors()` | Construtores públicos ou todos. |
| **Hierarquia** |  |
| `getSuperclass()` | Classe pai imediata. |
| `getInterfaces()` | Interfaces implementadas. |
| **Instanciação dinâmica** |  |
| `newInstance()` | (Depreciado em Java 9+) Cria instância com construtor sem parâmetros. |
| `getConstructor(...).newInstance(...)` | Forma recomendada: obtém construtor específico e instancia. |
| **Anotações** |  |
| `getAnnotations()`, `getDeclaredAnnotations()` | Anotações herdadas ou declaradas. |

**Interação entre métodos:**

1. Obter `Class<?>` de um tipo conhecido.
2. Navegar hierarquia (`getSuperclass()`, `getInterfaces()`).
3. Recuperar construtores ou métodos desejados.
4. Redefinir acessibilidade (`setAccessible(true)`) se for necessário acessar elementos não públicos.
5. Invocar `Constructor.newInstance()`, `Method.invoke()` ou `Field.get()/set()`.

### 3.3 Restrições de Uso

- **Segurança:** Reflection pode quebrar encapsulamento e acessar membros privados, por isso requer permissões adequadas em ambientes restritos (SecurityManager).
- **Desempenho:** Acima de métodos estáticos, Reflection é mais lento — use com moderação ou com caching de objetos `Method`/`Field`.
- **Robustez:** Código reflexivo tende a falhar em tempo de execução se a assinatura mudar; sempre trate `ClassNotFoundException`, `NoSuchMethodException`, `IllegalAccessException`, etc.

---

**4. Exemplos de Código Otimizados**

```java
package com.exemplo.reflection;

import java.lang.reflect.*;

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        // 1. Obter Class de uma classe customizada
        Class<?> pessoaClass = Class.forName("com.exemplo.reflection.Pessoa");

        // 2. Listar campos declarados
        for (Field field : pessoaClass.getDeclaredFields()) {
            System.out.println("Campo: " + field.getName()
                + " [modifiers=" + Modifier.toString(field.getModifiers()) + "]");
        }

        // 3. Acessar construtor parametrizado e instanciar
        Constructor<?> ctor = pessoaClass.getConstructor(String.class, int.class);
        Object pessoa = ctor.newInstance("Maria", 30);

        // 4. Invocar método getter dinamicamente
        Method getNome = pessoaClass.getMethod("getNome");
        String nome = (String) getNome.invoke(pessoa);
        System.out.println("Nome obtido via Reflection: " + nome);

        // 5. Modificar campo privado
        Field idadeField = pessoaClass.getDeclaredField("idade");
        idadeField.setAccessible(true); // permite acesso a privado
        idadeField.setInt(pessoa, 35);
        System.out.println("Idade atualizada: "
            + pessoaClass.getMethod("getIdade").invoke(pessoa));
    }
}

// Classe auxiliar
class Pessoa {
    private String nome;
    private int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome; this.idade = idade;
    }
    public String getNome() { return nome; }
    public int getIdade() { return idade; }
}

```

- **Boas práticas:**
    - Reutilize objetos `Method`/`Constructor` cachêados se for chamada repetida.
    - Prefira `getConstructor(...)` a `newInstance()` direto de `Class`.
    - Trate todas exceções refletidas e restaure `setAccessible(false)` se necessário.

---

**5. Informações Adicionais**

- **Caching e Performance:** Use **MethodHandles** (Java 7+) para invocações mais rápidas em cenários de alto desempenho.
- **Annotation Processors vs. Reflection:** Processadores em tempo de compilação podem evitar custo em runtime.
- **Project Loom e Reflection:** Futuras melhorias de JVM podem tornar reflexão ainda mais eficiente.

---

**6. Referências para Estudo Independente**

- Oracle Java Tutorials – Reflection:
[https://docs.oracle.com/javase/tutorial/reflect/index.html](https://docs.oracle.com/javase/tutorial/reflect/index.html)
- Javadoc da `Class`:
[https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html)
- Artigo Baeldung – Intro to Java Reflection:
[https://www.baeldung.com/java-reflection](https://www.baeldung.com/java-reflection)
- Livro **Effective Java**, Joshua Bloch – Capítulo sobre Reflection e Anotações.