# OutputStream

1. **Introdução**
    - **Visão Geral**
    As *Streams de Bytes* em Java são a base para todas as operações de entrada e saída (I/O) de dados em nível de byte. Entre elas, a classe abstrata `OutputStream` define a API para gravar bytes em diferentes destinos: arquivos, buffers de memória, sockets, etc.
    - **Relevância**
    Dominar `OutputStream` é essencial para qualquer desenvolvedor Java que precise manipular arquivos binários (imagens, áudio, vídeo) ou textuais de forma eficiente e controlada. É também o ponto de partida para construções mais avançadas, como streams decoradas (buffers, compressão, criptografia).
    - **Definições e Conceitos Fundamentais**
        - **Tema principal**: Streams de Bytes – `OutputStream`.
        - **Subtemas**:
            - Classes concretas (`FileOutputStream`, `ByteArrayOutputStream`, etc.)
            - Decorators (`BufferedOutputStream`, `DataOutputStream`)
            - Gerenciamento de recursos (try-with-resources)
        - **Para que servem**: prover métodos para enviar dados em formato de byte para um destino específico, garantindo controle de escrita, fechamento e tratamento de exceções.
2. **Sumário**
    1. Introdução
    2. Sumário
    3. Conteúdo Detalhado
        - Sintaxe e Estrutura
        - Componentes Principais
        - Restrições de Uso
    4. Exemplos de Código Otimizados
    5. Informações Adicionais
    6. Referências para Estudo Independente
3. **Conteúdo Detalhado**
    
    ### Sintaxe e Estrutura
    
    ```java
    public abstract class OutputStream implements Closeable, Flushable {
        public abstract void write(int b) throws IOException;
        public void write(byte[] b) throws IOException { /* encaminha a write(b, 0, b.length) */ }
        public void write(byte[] b, int off, int len) throws IOException { /* sobrescrever se necessário */ }
        public void flush() throws IOException { /* opcional, sobrescrever */ }
        public void close() throws IOException { /* opcional, sobrescrever */ }
    }
    
    ```
    
    - **`write(int b)`**: grava o byte de menor ordem de `b`.
    - **`write(byte[] b)` / `write(byte[] b, off, len)`**: gravam arrays de bytes em lote.
    - **`flush()`**: força a gravação de quaisquer bytes em buffer pendentes.
    - **`close()`**: libera recurso de I/O subjacente; sempre invocar ao final.
    
    ### Componentes Principais
    
    - **`OutputStream`**
        - Classe abstrata define a API genérica.
    - **Subclasses mais comuns**
        - `FileOutputStream` – grava em arquivos do sistema.
        - `ByteArrayOutputStream` – grava em buffer de memória que cresce dinamicamente.
        - `BufferedOutputStream` – envolve outra `OutputStream` adicionando buffer interno (padrão 8 KB).
        - `DataOutputStream` – decora para gravar tipos primitivos (int, long, UTF, etc.).
    - **Interação entre elas**
        
        ```java
        try (OutputStream fos = new FileOutputStream("dados.bin");
             BufferedOutputStream bos = new BufferedOutputStream(fos);
             DataOutputStream dos = new DataOutputStream(bos)) {
            dos.writeInt(2025);
            dos.writeUTF("Olá, mundo!");
            dos.flush(); // garante que tudo foi enviado ao disco
        } // o close() do DataOutputStream aciona flush e fecha todos os envolvidos
        
        ```
        
    
    ### Restrições de Uso
    
    - **Não é thread-safe**: sincronize externamente se múltiplas threads gravarem na mesma instância.
    - **Bloqueante**: chamadas podem travar se o destino estiver lento (rede, disco).
    - **Caracteres vs. Bytes**: para texto, prefira `Writer`/`PrintWriter` ou use `OutputStreamWriter` envolvendo `OutputStream`.
    - **Gerenciamento de recursos**: sempre utilizar try-with-resources ou `finally` para garantir `close()`.
4. **Exemplos de Código Otimizados**
    
    ### 4.1 Gravação Simples em Arquivo
    
    ```java
    import java.io.FileOutputStream;
    import java.io.IOException;
    
    public class GravaTexto {
        public static void main(String[] args) {
            String texto = "Exemplo básico";
            try (FileOutputStream fos = new FileOutputStream("saida.txt")) {
                byte[] bytes = texto.getBytes("UTF-8");
                fos.write(bytes);
            } catch (IOException e) {
                // tratamento de erro: log, rethrow ou fallback
                e.printStackTrace();
            }
        }
    }
    
    ```
    
    ### 4.2 Cópia de Arquivo com Buffer
    
    ```java
    import java.io.*;
    
    public class CopiaArquivo {
        public static void copia(File origem, File destino) throws IOException {
            try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(origem));
                 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destino))) {
                byte[] buffer = new byte[16 * 1024]; // 16 KB
                int lidos;
                while ((lidos = bis.read(buffer)) != -1) {
                    bos.write(buffer, 0, lidos);
                }
                // bos.flush() é chamado automaticamente pelo close()
            }
        }
    }
    
    ```
    
    ### 4.3 Uso Avançado: `ByteArrayOutputStream`
    
    ```java
    import java.io.ByteArrayOutputStream;
    import java.io.IOException;
    import java.nio.charset.StandardCharsets;
    
    public class ExemploMemoryStream {
        public static byte[] geraBinario(String s) {
            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                baos.write(s.getBytes(StandardCharsets.UTF_8));
                return baos.toByteArray();
            } catch (IOException e) {
                // ByteArrayOutputStream não lança IOException em write(byte[])
                throw new RuntimeException(e);
            }
        }
    }
    
    ```
    
5. **Informações Adicionais**
    - **Alternativas NIO**: `Files.newOutputStream(Path)` e `FileChannel` (pacote `java.nio.channels`) oferecem melhor performance em operações concorrentes e buffers diretos.
    - **Performance**: use buffers maiores para reduzir chamadas de I/O; medir com ferramentas de profiling.
    - **Decorators**: há streams para compressão (`GZIPOutputStream`), criptografia (`CipherOutputStream`) e checagem de integridade (`CheckedOutputStream`).
6. **Referências para Estudo Independente**
    - **Documentação Oracle** – *Java™ Platform SE 8*:
        - `OutputStream` API: [https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html)
        - *I/O Tutorial*: [https://docs.oracle.com/javase/tutorial/essential/io/](https://docs.oracle.com/javase/tutorial/essential/io/)
    - **Artigos**
        - Baeldung: “Guide to Java I/O” – [https://www.baeldung.com/java-io](https://www.baeldung.com/java-io)
        - Java Code Geeks: “Understanding Java Streams” – [https://www.javacodegeeks.com/java-io-streams-tutorial](https://www.javacodegeeks.com/java-io-streams-tutorial)
    - **Livros**
        - *Effective Java*, J. Bloch (itens sobre I/O e try-with-resources)
        - *Java I/O*, Elliotte Rusty Harold

---

> Este guia fornece desde a base de OutputStream até padrões de uso avançado, para que você possa ler e gravar bytes de forma eficiente e segura em aplicações Java.
>