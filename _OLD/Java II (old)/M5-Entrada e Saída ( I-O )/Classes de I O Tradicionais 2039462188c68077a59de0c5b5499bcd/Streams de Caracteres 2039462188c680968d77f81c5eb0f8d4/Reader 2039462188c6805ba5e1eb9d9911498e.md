# Reader

**1. Introdução**

Em Java, as *streams de caracteres* são abstrações fundamentais para leitura e escrita de texto de forma eficiente e independente de plataforma. O pacote `java.io` define a classe abstrata **`Reader`** como base para todas as implementações de fluxo de entrada de caracteres.

- **Visão Geral:**
    - Um *Reader* converte os dados brutos (bytes) de uma fonte — como arquivo, rede ou memória — em caracteres Unicode, respeitando a codificação de caracteres especificada.
    - Seu contraponto para saída é o **`Writer`**.
- **Relevância e Importância:**
    - Em aplicações modernas, lidar corretamente com diferentes encodings (UTF-8, ISO-8859-1, etc.) é crucial para evitar corrupção de texto e `�` (caracteres substitutos).
    - `Reader` e suas subclasses oferecem métodos de alto nível (leitura por linha, buffering, marcação) que tornam o código mais legível e robusto.
- **Definições e Conceitos Fundamentais:**
    - **Tema Principal:** *Streams de caracteres* em Java, cujo ponto de partida é a classe abstrata `Reader`.
    - **Subtemas:**
        1. *Classes concretas* como `FileReader`, `InputStreamReader`, `BufferedReader`.
        2. *Funcionalidades avançadas* (buffering, marcação/reset, encoding).
    - **Para que servem:** abstrair leitura de texto de várias origens, garantindo conversão correta de bytes em caracteres Unicode.

---

**2. Sumário**

1. Introdução
2. Sumário
3. Conteúdo Detalhado
    1. Sintaxe e Estrutura
    2. Componentes Principais
    3. Restrições de Uso
4. Exemplos de Código Otimizados
5. Informações Adicionais
6. Referências para Estudo Independente

---

**3. Conteúdo Detalhado**

### 3.1 Sintaxe e Estrutura

- **Classe Abstrata `Reader`**
    
    ```java
    public abstract class Reader implements Closeable {
        public abstract int read(char[] cbuf, int off, int len) throws IOException;
        public int read() throws IOException { /* default lê 1 caractere */ }
        public long skip(long n) throws IOException { /* pula caracteres */ }
        public boolean ready() throws IOException { /* pronto para ler sem bloqueio */ }
        public boolean markSupported() { return false; }
        public void mark(int readAheadLimit) throws IOException { /* se suportado */ }
        public void reset() throws IOException { /* retorna ao mark */ }
        public void close() throws IOException; /* fechar stream */
    }
    
    ```
    
- **Estrutura Básica de Uso**
    1. Cria-se uma instância concreta de `Reader`.
    2. Usa-se `read()` ou `read(char[])` para obter caracteres.
    3. Encerra com `close()` (ou try-with-resources).

### 3.2 Componentes Principais

1. **`FileReader`**
    - Lê caracteres diretamente de um arquivo, usando o encoding padrão do sistema.
    - **Métodos-chave:** herda todos de `Reader`.
2. **`InputStreamReader`**
    - Ponte entre `InputStream` (bytes) e `Reader`. Permite especificar `Charset`.
    - **Exemplo de construtor:**
        
        ```java
        new InputStreamReader(new FileInputStream("dados.txt"), StandardCharsets.UTF_8);
        
        ```
        
3. **`BufferedReader`**
    - Envolve outro `Reader` e adiciona buffer interno, melhorando performance e fornecendo método `readLine()`.
    - **Métodos-chave:**
        - `String readLine()` — lê uma linha completa sem incluir terminador de linha.
        - `mark(int)` e `reset()` — marca posição e retorna a ela (se o buffer permitir).
4. **Interação entre eles**
    - Normalmente empilhamos streams:
        
        ```java
        try (Reader ir = new InputStreamReader(fis, charset);
             BufferedReader br = new BufferedReader(ir)) {
            // usar br.readLine()
        }
        
        ```
        

### 3.3 Restrições de Uso

- **Não para dados binários:** Streams de caracteres não devem ser usados para ler imagens ou arquivos não-textuais.
- **Encoding padrão:** `FileReader` usa charset do sistema — cuidado com portabilidade; prefira `InputStreamReader` com `Charset` explícito.
- **Limites de `mark/reset`:** nem todos os `Reader` suportam marcação. Verifique `markSupported()` antes de usar.

---

**4. Exemplos de Código Otimizados**

1. **Leitura básica de caracter único**
    
    ```java
    try (Reader reader = new FileReader("input.txt")) {
        int ch;
        while ((ch = reader.read()) != -1) {
            System.out.print((char) ch);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    
    ```
    
2. **Leitura linha a linha com buffering e encoding**
    
    ```java
    Path path = Paths.get("dados.csv");
    Charset utf8 = StandardCharsets.UTF_8;
    
    try (BufferedReader br = Files.newBufferedReader(path, utf8)) {
        String linha;
        while ((linha = br.readLine()) != null) {
            // processa CSV: separa por vírgula, etc.
            String[] cols = linha.split(",");
            System.out.printf("Coluna1=%s, Coluna2=%s%n", cols[0], cols[1]);
        }
    } catch (IOException e) {
        // melhor tratamento de erro, logging, retry, etc.
        e.printStackTrace();
    }
    
    ```
    
3. **Uso de `mark` e `reset`**
    
    ```java
    try (BufferedReader br = new BufferedReader(new FileReader("texto.txt"))) {
        if (br.markSupported()) {
            br.mark(1000);               // marca posição com 1 000 chars de limite
            char[] buffer = new char[100];
            br.read(buffer, 0, 100);     // lê 100 caracteres
            System.out.println(buffer);
            br.reset();                  // volta à posição marcada
        }
    }
    
    ```
    

---

**5. Informações Adicionais**

- **Performance:** `BufferedReader` melhora significativamente o throughput; evite ler caractere a caractere em loops sem buffer.
- **Arquiteturas reativas:** em projetos modernos, considere `java.nio` e frameworks como Netty para I/O não bloqueante.
- **Alternativas no Java 11+:** `Files.lines(path)` retorna `Stream<String>` de linhas, integrado à API de Streams do Java.

---

**6. Referências para Estudo Independente**

- **Documentação Oracle:**
    - `java.io.Reader` – [https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html](https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html)
    - `java.io.BufferedReader` – [https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html)
- **Artigos e Tutoriais:**
    - Baeldung: “Guide to Java I/O” – [https://www.baeldung.com/java-io](https://www.baeldung.com/java-io)
    - Vogella: “Java IO Tutorial” – [https://www.vogella.com/tutorials/JavaIO/article.html](https://www.vogella.com/tutorials/JavaIO/article.html)
- **Livros:**
    - *Effective Java*, Joshua Bloch — boas práticas de I/O e gerenciamento de recursos.
    - *Java: The Complete Reference*, Herbert Schildt — cobertura completa de fluxo de I/O em Java.