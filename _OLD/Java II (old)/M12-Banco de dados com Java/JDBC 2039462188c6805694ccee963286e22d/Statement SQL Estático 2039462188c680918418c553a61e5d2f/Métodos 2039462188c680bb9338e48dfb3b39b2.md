# Métodos

Olá, Gedê\! Como um desenvolvedor Backend Java, sei que o tema de `Statement` e seus métodos no JDBC é fundamental para a interação com bancos de dados. A.R.I.A está aqui para te ajudar a desvendar todos os detalhes sobre isso.

## Statement - Métodos `execute()`, `executeUpdate()` e `executeQuery()` no JDBC

### 1\. Introdução

No universo do desenvolvimento Java, a persistência de dados é um pilar crucial para a maioria das aplicações. O Java Database Connectivity (JDBC) é a API padrão do Java que permite a conexão e interação com bancos de dados relacionais. Dentro dessa API, a interface `Statement` desempenha um papel central, servindo como o mecanismo primário para enviar comandos SQL ao banco de dados.

A relevância da interface `Statement` reside na sua capacidade de executar diferentes tipos de operações SQL, desde consultas que recuperam dados (`SELECT`) até modificações que alteram o estado do banco (`INSERT`, `UPDATE`, `DELETE`). Compreender seus métodos, como `execute()`, `executeUpdate()` e `executeQuery()`, é essencial para qualquer desenvolvedor que trabalhe com acesso a dados em Java, pois a escolha do método correto impacta diretamente a eficiência, segurança e legibilidade do código.

**Definição e Conceitos Fundamentais:**

A interface `java.sql.Statement` representa uma instrução SQL estática que pode ser executada por um banco de dados. Em termos mais simples, é um objeto que encapsula um comando SQL que você deseja enviar para o seu banco de dados. Ela serve como a base para interagir com o banco de dados, permitindo a execução de operações como criação de tabelas, inserção de registros, atualização de dados e consulta de informações.

Existem também suas especializações, como `PreparedStatement` e `CallableStatement`, que abordaremos brevemente para complementar a compreensão, mas o foco principal será na `Statement` e seus métodos de execução.

### 2\. Sumário

- **Introdução ao JDBC e `Statement`**
- **O Ciclo de Vida de uma Consulta JDBC**
- **Métodos da Interface `Statement`:**
    - `execute()`
    - `executeUpdate()`
    - `executeQuery()`
- **A Interface `ResultSet`**
- **`PreparedStatement` vs. `Statement`**
- **`CallableStatement` para Stored Procedures**
- **Restrições e Boas Práticas de Uso**
- **Exemplos de Código Otimizados**
- **Informações Adicionais**
- **Referências para Estudo Independente**

### 3\. Conteúdo Detalhado

### O Ciclo de Vida de uma Consulta JDBC

Antes de mergulharmos nos métodos, é importante entender o fluxo geral de uma operação JDBC:

1. **Carregamento do Driver:** O driver JDBC do banco de dados é carregado na memória.
2. **Estabelecimento da Conexão:** Uma conexão com o banco de dados é estabelecida através da interface `Connection`.
3. **Criação da Declaração (`Statement`):** Um objeto `Statement` (ou `PreparedStatement`/`CallableStatement`) é criado a partir da conexão.
4. **Execução da Consulta:** O comando SQL é executado usando um dos métodos da `Statement`.
5. **Processamento dos Resultados:** Se a consulta retornar dados (`SELECT`), os resultados são processados usando um `ResultSet`.
6. **Fechamento dos Recursos:** Todos os recursos (Conexão, Statement, ResultSet) são fechados para liberar recursos do banco de dados e evitar vazamentos de memória.

### Métodos da Interface `Statement`

A interface `Statement` define três métodos principais para executar instruções SQL: `execute()`, `executeUpdate()` e `executeQuery()`. A escolha entre eles depende do tipo de instrução SQL que você deseja executar e do tipo de resultado esperado.

### `int executeUpdate(String sql)`

- **Função:** Este método é utilizado para executar instruções SQL que modificam os dados em um banco de dados, ou seja, operações de Data Manipulation Language (DML) como `INSERT`, `UPDATE` e `DELETE`. Ele também pode ser usado para instruções de Data Definition Language (DDL) como `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`, etc.
- **Retorno:** Retorna um `int` que indica o número de linhas afetadas pela operação. Para instruções DDL, o valor retornado geralmente é `0`.
- **Restrições de Uso:** Não deve ser usado para consultas que retornam um conjunto de resultados (como `SELECT`).
- **Exemplo de Declaração e Utilização:**

<!-- end list -->

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class StatementExecuteUpdateExample {

    public static void main(String[] args) {
        String jdbcUrl = "jdbc:mysql://localhost:3306/meubanco"; // Exemplo para MySQL
        String username = "root";
        String password = "password";

        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password)) {
            Statement statement = connection.createStatement();

            // Exemplo de INSERT
            String insertSql = "INSERT INTO produtos (nome, preco, quantidade) VALUES ('Teclado Mecânico', 350.00, 10)";
            int linhasAfetadasInsert = statement.executeUpdate(insertSql);
            System.out.println("Linhas afetadas pelo INSERT: " + linhasAfetadasInsert);

            // Exemplo de UPDATE
            String updateSql = "UPDATE produtos SET preco = 320.00 WHERE nome = 'Teclado Mecânico'";
            int linhasAfetadasUpdate = statement.executeUpdate(updateSql);
            System.out.println("Linhas afetadas pelo UPDATE: " + linhasAfetadasUpdate);

            // Exemplo de DELETE
            String deleteSql = "DELETE FROM produtos WHERE nome = 'Teclado Mecânico'";
            int linhasAfetadasDelete = statement.executeUpdate(deleteSql);
            System.out.println("Linhas afetadas pelo DELETE: " + linhasAfetadasDelete);

            // Exemplo de DDL (CREATE TABLE)
            String createTableSql = "CREATE TABLE IF NOT EXISTS usuarios (id INT PRIMARY KEY AUTO_INCREMENT, nome VARCHAR(100))";
            int linhasAfetadasCreateTable = statement.executeUpdate(createTableSql);
            System.out.println("Linhas afetadas pelo CREATE TABLE: " + linhasAfetadasCreateTable);

        } catch (SQLException e) {
            System.err.println("Erro ao executar operação SQL: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

```

### `ResultSet executeQuery(String sql)`

- **Função:** Este método é estritamente usado para executar instruções SQL que retornam um conjunto de resultados, ou seja, instruções `SELECT`.
- **Retorno:** Retorna um objeto `java.sql.ResultSet`. O `ResultSet` é uma tabela de dados que representa o resultado de uma consulta ao banco de dados. Ele permite iterar sobre as linhas e acessar os valores das colunas.
- **Restrições de Uso:** Não deve ser usado para instruções DML (`INSERT`, `UPDATE`, `DELETE`) ou DDL.
- **Exemplo de Declaração e Utilização:**

<!-- end list -->

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class StatementExecuteQueryExample {

    public static void main(String[] args) {
        String jdbcUrl = "jdbc:mysql://localhost:3306/meubanco"; // Exemplo para MySQL
        String username = "root";
        String password = "password";

        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password)) {
            Statement statement = connection.createStatement();

            // Certificando que a tabela existe e tem dados para consulta
            statement.executeUpdate("CREATE TABLE IF NOT EXISTS produtos (id INT PRIMARY KEY AUTO_INCREMENT, nome VARCHAR(100), preco DECIMAL(10,2), quantidade INT)");
            statement.executeUpdate("INSERT IGNORE INTO produtos (id, nome, preco, quantidade) VALUES (1, 'Monitor Curvo', 1200.00, 5)");
            statement.executeUpdate("INSERT IGNORE INTO produtos (id, nome, preco, quantidade) VALUES (2, 'Mouse Gamer', 150.00, 20)");

            String selectSql = "SELECT id, nome, preco, quantidade FROM produtos WHERE preco > 100";
            ResultSet resultSet = statement.executeQuery(selectSql);

            System.out.println("Produtos encontrados:");
            while (resultSet.next()) { // Itera sobre as linhas do ResultSet
                int id = resultSet.getInt("id");
                String nome = resultSet.getString("nome");
                double preco = resultSet.getDouble("preco");
                int quantidade = resultSet.getInt("quantidade");
                System.out.println("ID: " + id + ", Nome: " + nome + ", Preço: " + preco + ", Quantidade: " + quantidade);
            }

            // Fechando o ResultSet explicitamente (embora o try-with-resources também o faça no final)
            resultSet.close();

        } catch (SQLException e) {
            System.err.println("Erro ao executar consulta SQL: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

```

### `boolean execute(String sql)`

- **Função:** Este é o método mais genérico e flexível. Ele pode executar *qualquer* tipo de instrução SQL, seja DDL, DML ou DQL (Data Query Language, ou seja, `SELECT`).
- **Retorno:** Retorna um `boolean`.
    - `true` se a instrução SQL executada retornar um `ResultSet` (ou seja, uma consulta `SELECT`).
    - `false` se a instrução SQL executada retornar um `int` (ou seja, um número de linhas afetadas por um `INSERT`, `UPDATE`, `DELETE` ou uma instrução DDL).
- **Processamento de Resultados:** Após a execução, você precisa usar os métodos `getResultSet()` ou `getUpdateCount()` para obter o resultado apropriado, dependendo do valor booleano retornado.
- **Restrições de Uso:** Embora seja flexível, seu uso não é recomendado quando o tipo de instrução SQL é conhecido antecipadamente, pois `executeQuery()` e `executeUpdate()` fornecem uma interface mais clara e direta para suas respectivas finalidades. `execute()` é mais útil para situações onde o tipo de instrução SQL a ser executada é desconhecido em tempo de compilação (por exemplo, um utilitário de administração de banco de dados genérico).
- **Exemplo de Declaração e Utilização:**

<!-- end list -->

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class StatementExecuteExample {

    public static void main(String[] args) {
        String jdbcUrl = "jdbc:mysql://localhost:3306/meubanco"; // Exemplo para MySQL
        String username = "root";
        String password = "password";

        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password)) {
            Statement statement = connection.createStatement();

            // Certificando que a tabela existe e tem dados
            statement.executeUpdate("CREATE TABLE IF NOT EXISTS clientes (id INT PRIMARY KEY AUTO_INCREMENT, nome VARCHAR(100), idade INT)");
            statement.executeUpdate("INSERT IGNORE INTO clientes (id, nome, idade) VALUES (1, 'Maria Silva', 30)");
            statement.executeUpdate("INSERT IGNORE INTO clientes (id, nome, idade) VALUES (2, 'João Souza', 25)");

            // Exemplo 1: Executando um INSERT
            String insertSql = "INSERT INTO clientes (nome, idade) VALUES ('Ana Paula', 28)";
            boolean hasResultSetInsert = statement.execute(insertSql);
            if (hasResultSetInsert) {
                System.out.println("INSERT retornou um ResultSet (erro inesperado).");
            } else {
                int linhasAfetadas = statement.getUpdateCount();
                System.out.println("INSERT - Linhas afetadas: " + linhasAfetadas);
            }

            // Exemplo 2: Executando um SELECT
            String selectSql = "SELECT id, nome, idade FROM clientes WHERE idade > 25";
            boolean hasResultSetSelect = statement.execute(selectSql);
            if (hasResultSetSelect) {
                ResultSet resultSet = statement.getResultSet();
                System.out.println("Clientes maiores de 25 anos:");
                while (resultSet.next()) {
                    int id = resultSet.getInt("id");
                    String nome = resultSet.getString("nome");
                    int idade = resultSet.getInt("idade");
                    System.out.println("ID: " + id + ", Nome: " + nome + ", Idade: " + idade);
                }
                resultSet.close(); // Fechar o ResultSet obtido
            } else {
                System.out.println("SELECT retornou um update count (erro inesperado).");
            }

        } catch (SQLException e) {
            System.err.println("Erro ao executar operação SQL: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

```

### A Interface `ResultSet`

Como mencionado, o `ResultSet` é crucial para `executeQuery()` e para quando `execute()` retorna `true`.

- **Função:** Representa o resultado de uma consulta ao banco de dados. Ele atua como um cursor que se move através das linhas do resultado.
- **Métodos Principais:**
    - `boolean next()`: Move o cursor para a próxima linha do `ResultSet`. Retorna `true` se houver uma próxima linha e `false` caso contrário. É o método mais comum para iterar sobre os resultados.
    - `getType(String columnName)`: Retorna o valor da coluna especificada como um tipo Java (`getString()`, `getInt()`, `getDouble()`, `getDate()`, etc.).
    - `getType(int columnIndex)`: Retorna o valor da coluna especificada pelo índice (começando em 1) como um tipo Java.
    - `void close()`: Libera os recursos do `ResultSet`. É fundamental fechar o `ResultSet` quando não for mais necessário.

### `PreparedStatement` vs. `Statement`

Embora o `Statement` seja a base, em aplicações do dia a dia, `PreparedStatement` é geralmente preferível.

- **`Statement`:**
    - Executa instruções SQL estáticas.
    - Não pré-compila a instrução SQL. Cada execução envolve a análise sintática e otimização da consulta pelo banco de dados, o que pode ser ineficiente para execuções repetidas.
    - **Vulnerável a SQL Injection:** Se você concatenar valores diretamente na string SQL, como em `SELECT * FROM users WHERE username = '" + user + "'`, um usuário mal-intencionado pode injetar código SQL.
- **`PreparedStatement`:**
    - Herda de `Statement`.
    - **Pré-compila a instrução SQL:** A instrução SQL é enviada ao banco de dados e pré-compilada uma vez, mesmo que seja executada várias vezes com parâmetros diferentes. Isso resulta em melhor desempenho para consultas repetidas.
    - **Previne SQL Injection:** Utiliza placeholders (`?`) para os parâmetros. Os valores são enviados separadamente da instrução SQL, e o driver JDBC garante que sejam tratados como dados, não como parte do código SQL. Isso é crucial para a segurança.
    - **Sintaxe:**
        
        ```java
        String sql = "INSERT INTO produtos (nome, preco) VALUES (?, ?)";
        PreparedStatement ps = connection.prepareStatement(sql);
        ps.setString(1, "Laptop Gamer"); // Define o valor do primeiro placeholder
        ps.setDouble(2, 5000.00); // Define o valor do segundo placeholder
        ps.executeUpdate();
        
        ```
        

### `CallableStatement` para Stored Procedures

- **`CallableStatement`:**
    - Herda de `PreparedStatement`.
    - Usado para executar stored procedures (procedimentos armazenados) e funções armazenadas no banco de dados.
    - Permite a passagem de parâmetros de entrada (`IN`), saída (`OUT`) e entrada/saída (`INOUT`).
    - **Sintaxe:**
        
        ```java
        String sql = "{CALL get_product_price(?, ?)}"; // Exemplo de stored procedure
        CallableStatement cs = connection.prepareCall(sql);
        cs.setInt(1, 101); // Parâmetro de entrada
        cs.registerOutParameter(2, java.sql.Types.DECIMAL); // Parâmetro de saída
        cs.execute();
        double price = cs.getDouble(2);
        
        ```
        

### 4\. Exemplos de Código Otimizados

Como desenvolvedor Backend Java, a escolha da ferramenta certa para cada situação é fundamental. Aqui, vamos focar em cenários práticos e mostrar a superioridade do `PreparedStatement` para a maioria dos casos de uso, e como a `Statement` pode ser utilizada em situações específicas.

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class JdbcOperationsGede {

    // Configurações do banco de dados (exemplo com MySQL)
    private static final String JDBC_URL = "jdbc:mysql://localhost:3306/minha_loja?useSSL=false&serverTimezone=UTC";
    private static final String USER = "root";
    private static final String PASSWORD = "password";

    public static void main(String[] args) {
        // Inicializa o banco de dados para os exemplos
        setupDatabase();

        // 1. Usando Statement para DDL (criação de tabela)
        // Cenário: Operações que não serão repetidas e não envolvem parâmetros do usuário.
        createProductTable();

        // 2. Usando PreparedStatement para INSERT (seguro e eficiente)
        // Cenário: Inserir novos produtos, dados dinâmicos do usuário.
        insertProduct("Smartphone XYZ", 2500.00, 10);
        insertProduct("Smart TV 4K", 3800.00, 5);
        insertProduct("Fone Bluetooth", 200.00, 50);

        // 3. Usando PreparedStatement para SELECT (seguro e eficiente)
        // Cenário: Buscar produtos por preço mínimo, com valor dinâmico.
        findProductsByMinPrice(2000.00);

        // 4. Usando PreparedStatement para UPDATE (seguro e eficiente)
        // Cenário: Atualizar o preço de um produto específico.
        updateProductPrice("Smartphone XYZ", 2300.00);

        // 5. Usando PreparedStatement para DELETE (seguro e eficiente)
        // Cenário: Remover um produto pelo nome.
        deleteProductByName("Fone Bluetooth");

        // 6. Usando Statement.execute() para cenários genéricos (raros em apps "normais")
        // Cenário: Ferramentas de administração de DB, onde o tipo de query é dinâmico.
        executeGenericQuery("SELECT nome, preco FROM produtos WHERE quantidade > 5");
        executeGenericQuery("DROP TABLE IF EXISTS temp_table"); // Exemplo de DDL
    }

    /**
     * Configura o banco de dados para os exemplos, criando a tabela se não existir.
     */
    private static void setupDatabase() {
        try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
             Statement statement = connection.createStatement()) {
            // Cria a tabela de produtos se não existir
            String createTableSql = "CREATE TABLE IF NOT EXISTS produtos (" +
                    "id INT AUTO_INCREMENT PRIMARY KEY," +
                    "nome VARCHAR(255) NOT NULL UNIQUE," + // UNIQUE para evitar duplicação em INSERTS de teste
                    "preco DECIMAL(10, 2) NOT NULL," +
                    "quantidade INT NOT NULL" +
                    ")";
            statement.executeUpdate(createTableSql);
            System.out.println("Tabela 'produtos' verificada/criada.");
        } catch (SQLException e) {
            System.err.println("Erro ao configurar o banco de dados: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Exemplo de uso de Statement para criar uma tabela (DDL).
     * Geralmente, DDL é executado uma vez e não requer PreparedStatement.
     */
    private static void createProductTable() {
        // Já está no setupDatabase para garantir que a tabela exista.
        // Este método existe para ilustrar o uso específico de Statement para DDL se necessário.
    }

    /**
     * Insere um novo produto usando PreparedStatement.
     * Previne SQL Injection e melhora performance para múltiplas inserções.
     */
    private static void insertProduct(String nome, double preco, int quantidade) {
        String sql = "INSERT INTO produtos (nome, preco, quantidade) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE nome=VALUES(nome)"; // ON DUPLICATE para testes
        try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
             PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

            preparedStatement.setString(1, nome);
            preparedStatement.setDouble(2, preco);
            preparedStatement.setInt(3, quantidade);

            int linhasAfetadas = preparedStatement.executeUpdate();
            System.out.println("Produto '" + nome + "' inserido/atualizado. Linhas afetadas: " + linhasAfetadas);

        } catch (SQLException e) {
            System.err.println("Erro ao inserir produto '" + nome + "': " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Busca produtos com preço maior ou igual ao valor especificado usando PreparedStatement.
     */
    private static void findProductsByMinPrice(double minPrice) {
        String sql = "SELECT id, nome, preco, quantidade FROM produtos WHERE preco >= ?";
        try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
             PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

            preparedStatement.setDouble(1, minPrice);

            System.out.println("\\n--- Produtos com preço >= " + minPrice + " ---");
            try (ResultSet resultSet = preparedStatement.executeQuery()) {
                while (resultSet.next()) {
                    int id = resultSet.getInt("id");
                    String nome = resultSet.getString("nome");
                    double preco = resultSet.getDouble("preco");
                    int quantidade = resultSet.getInt("quantidade");
                    System.out.println("ID: " + id + ", Nome: " + nome + ", Preço: " + preco + ", Quantidade: " + quantidade);
                }
            }
        } catch (SQLException e) {
            System.err.println("Erro ao buscar produtos: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Atualiza o preço de um produto usando PreparedStatement.
     */
    private static void updateProductPrice(String nome, double novoPreco) {
        String sql = "UPDATE produtos SET preco = ? WHERE nome = ?";
        try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
             PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

            preparedStatement.setDouble(1, novoPreco);
            preparedStatement.setString(2, nome);

            int linhasAfetadas = preparedStatement.executeUpdate();
            System.out.println("\\nPreço do produto '" + nome + "' atualizado para " + novoPreco + ". Linhas afetadas: " + linhasAfetadas);

        } catch (SQLException e) {
            System.err.println("Erro ao atualizar preço do produto '" + nome + "': " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Deleta um produto pelo nome usando PreparedStatement.
     */
    private static void deleteProductByName(String nome) {
        String sql = "DELETE FROM produtos WHERE nome = ?";
        try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
             PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

            preparedStatement.setString(1, nome);

            int linhasAfetadas = preparedStatement.executeUpdate();
            System.out.println("\\nProduto '" + nome + "' deletado. Linhas afetadas: " + linhasAfetadas);

        } catch (SQLException e) {
            System.err.println("Erro ao deletar produto '" + nome + "': " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Demonstra o uso de Statement.execute() para lidar com instruções SQL genéricas.
     * Não é recomendado para uso geral em aplicações, mas útil para ferramentas.
     */
    private static void executeGenericQuery(String sql) {
        System.out.println("\\n--- Executando query genérica: " + sql + " ---");
        try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
             Statement statement = connection.createStatement()) {

            boolean hasResultSet = statement.execute(sql);

            if (hasResultSet) {
                // É um SELECT
                try (ResultSet resultSet = statement.getResultSet()) {
                    System.out.println("Resultados da consulta:");
                    // Metadata para imprimir cabeçalhos
                    int columnCount = resultSet.getMetaData().getColumnCount();
                    for (int i = 1; i <= columnCount; i++) {
                        System.out.print(resultSet.getMetaData().getColumnName(i) + "\\t");
                    }
                    System.out.println();
                    while (resultSet.next()) {
                        for (int i = 1; i <= columnCount; i++) {
                            System.out.print(resultSet.getObject(i) + "\\t");
                        }
                        System.out.println();
                    }
                }
            } else {
                // É um DML/DDL
                int updateCount = statement.getUpdateCount();
                System.out.println("Linhas afetadas (ou 0 para DDL): " + updateCount);
            }

        } catch (SQLException e) {
            System.err.println("Erro ao executar query genérica: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

```

**Observações sobre os Exemplos:**

- **`try-with-resources`:** Observe o uso extensivo de `try-with-resources`. Esta é a melhor prática para garantir que os recursos JDBC (`Connection`, `Statement`, `PreparedStatement`, `ResultSet`) sejam fechados automaticamente, mesmo em caso de exceções. Isso evita vazamentos de recursos.
- **Segurança (SQL Injection):** O `PreparedStatement` é a escolha padrão para qualquer operação que envolva dados fornecidos pelo usuário, devido à sua capacidade de prevenir SQL Injection. Nunca concatene strings de entrada do usuário diretamente na sua query SQL ao usar `Statement`.
- **Eficiência:** Para operações repetitivas, `PreparedStatement` é mais eficiente porque a query é pré-compilada pelo banco de dados.

### 5\. Informações Adicionais

- **Batch Updates (Atualizações em Lote):** Para melhorar a performance em operações DML (`INSERT`, `UPDATE`, `DELETE`) em massa, você pode usar a funcionalidade de batch do `Statement` ou `PreparedStatement`. Isso permite enviar múltiplas instruções SQL ao banco de dados em uma única viagem de rede.
    
    ```java
    // Exemplo com PreparedStatement para batch
    String sql = "INSERT INTO produtos (nome, preco) VALUES (?, ?)";
    try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
         PreparedStatement ps = connection.prepareStatement(sql)) {
        connection.setAutoCommit(false); // Desabilita o autocommit para o batch
    
        ps.setString(1, "Produto A");
        ps.setDouble(2, 10.0);
        ps.addBatch(); // Adiciona a instrução ao batch
    
        ps.setString(1, "Produto B");
        ps.setDouble(2, 20.0);
        ps.addBatch();
    
        int[] resultados = ps.executeBatch(); // Executa todas as instruções no batch
        connection.commit(); // Confirma a transação
        System.out.println("Batch executado. Resultados: " + java.util.Arrays.toString(resultados));
    } catch (SQLException e) {
        // Lidar com exceção, e fazer rollback em caso de falha
        try {
            connection.rollback();
        } catch (SQLException rollbackEx) {
            rollbackEx.printStackTrace();
        }
        e.printStackTrace();
    } finally {
        // Reabilitar autocommit se necessário
        // connection.setAutoCommit(true);
    }
    
    ```
    
- **Transações:** É crucial gerenciar transações no JDBC para garantir a atomicidade das operações. Você pode desabilitar o `auto-commit` na conexão (`connection.setAutoCommit(false)`) e usar `connection.commit()` e `connection.rollback()` para controlar quando as alterações são persistidas ou desfeitas.
- **Configurações do `Statement`:** Você pode configurar propriedades do `Statement` ao criá-lo:
    - `connection.createStatement(int resultSetType, int resultSetConcurrency)`: Permite especificar o tipo de `ResultSet` (e.g., `TYPE_SCROLL_INSENSITIVE` para poder navegar para frente e para trás no `ResultSet`) e a concorrência (e.g., `CONCUR_UPDATABLE` para permitir atualizações via `ResultSet`).
    - `statement.setQueryTimeout(int seconds)`: Define um tempo limite em segundos para a execução da consulta. Se a consulta demorar mais do que o tempo limite, uma `SQLException` é lançada.
    - `statement.setMaxRows(int max)`: Limita o número máximo de linhas que um `ResultSet` pode conter.

### 6\. Referências para Estudo Independente

Para aprofundar seus conhecimentos, Gedê, recomendo os seguintes recursos:

- **Documentação Oficial da Oracle (Java JDBC):**
    - [Tutorial JDBC™ Basics](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html)
    - [Using Statements](https://www.google.com/search?q=https://docs.oracle.com/javase/tutorial/jdbc/basics/statement.html)
    - [Interface Statement](https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/Statement.html)
    - [Interface PreparedStatement](https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/PreparedStatement.html)
    - [Interface ResultSet](https://docs.oracle.com/en/java/javase/21/docs/api/java.sql/java/sql/ResultSet.html)
- **Artigos e Tutoriais Confiáveis:**
    - **Baeldung - JDBC Tutorial:** Um recurso muito completo e prático sobre JDBC, com muitos exemplos de código.
        - [Getting Started with JDBC](https://www.baeldung.com/java-jdbc)
        - [PreparedStatement in JDBC](https://www.google.com/search?q=https://www.baeldung.com/java-preparedstatement)
    - **GeeksforGeeks - JDBC Statement:**
        - [JDBC Statement vs PreparedStatement vs CallableStatement](https://www.google.com/search?q=https://www.geeksforgeeks.org/jdbc-statement-vs-preparedstatement-vs-callablestatement/)
- **Livros (para uma compreensão mais aprofundada):**
    - "Core Java, Volume II--Advanced Features" by Cay S. Horstmann (Capítulo sobre JDBC).
    - "JDBC, SQL, and Speicialized SQL Types: An API Guide for Developers" by Mayur D. Madhani. (Mais antigo, mas excelente para os fundamentos).

Espero que esta explicação detalhada sobre os métodos da interface `Statement` e suas nuances, incluindo `PreparedStatement` e `CallableStatement`, seja extremamente útil para você como desenvolvedor Backend Java, Gedê. Lembre-se sempre de priorizar a segurança e a eficiência em suas interações com o banco de dados\! Se tiver mais alguma dúvida, é só perguntar.