# Fundamentos

## Introdução

A API de Criteria foi introduzida no JPA 2.0 como uma alternativa orientada a objetos à construção de consultas por meio de strings JPQL (Java Persistence Query Language). Em vez de escrever JPQL “hard-coded” em formato texto, a API de Criteria permite construir consultas de forma programática, garantindo tipagem em tempo de compilação, maior segurança contra erros de sintaxe e flexibilidade para montar condições de forma dinâmica.

Este guia aborda detalhadamente os componentes centrais da API de Criteria – **CriteriaBuilder**, **CriteriaQuery<T>**, **Root<T>**, **Predicate**, **TypedQuery<T>** – explicando seus papéis, sintaxes e como utilizá-los em cenários práticos. Ao final, um exemplo completo demonstra a montagem de uma consulta ponta a ponta.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    1. Obtenção do *CriteriaBuilder*
    2. Criação do *CriteriaQuery<T>*
    3. Definição do *Root<T>*
    4. Construção de *Predicate(s)*
    5. Geração de *TypedQuery<T>*
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#componentes-chave-associados)
    1. **CriteriaBuilder**
    2. **CriteriaQuery<T>**
    3. **Root<T>**
    4. **Predicate**
    5. **TypedQuery<T>**
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sugest%C3%B5es-para-aprofundamento)

---

## Conceitos Fundamentais

1. **Motivação da API de Criteria**
    - **Tipagem em tempo de compilação**: ao construir consultas por meio de objetos Java, erros de sintaxe passam a ser detectados durante a compilação (antes de executar).
    - **Facilidade para queries dinâmicas**: possibilita montagem condicional de cláusulas (`WHERE`, `ORDER BY`, `JOIN`) de modo mais simples do que concatenar strings.
    - **Manutenção e refatoração**: renomear atributos de entidade ou alterar mapeamentos reflete diretamente nos objetos, evitando que JPQL duro (strings) fique obsoleto.
2. **Visão Geral do Fluxo de Construção de Consulta**
    1. Obter um **CriteriaBuilder** a partir do `EntityManager`.
    2. Criar um **CriteriaQuery<T>**, definindo o tipo de resultado (`T` ≔ classe de entidade ou construtor de DTO).
    3. Definir a raiz do “FROM” com um **Root<T>**.
    4. Construir **Predicate(s)** para as cláusulas `WHERE`, combinando-os via `cb.and(...)`, `cb.or(...)`, etc.
    5. Atribuir seleções, filtros, agrupamentos, ordenações à `CriteriaQuery`.
    6. Criar um **TypedQuery<T>** chamando `entityManager.createQuery(criteriaQuery)`.
    7. Executar (`getResultList()`, `getSingleResult()`, etc.).
3. **Vantagens vs. JPQL Tradicional**
    - **Segurança de tipo**: o compilador valida atributos em vez de precisar testar só em tempo de execução.
    - **Reuso parcimonioso**: partes de consultas (predicados) podem ser armazenadas em variáveis e combinadas dinamicamente.
    - **API fluente**: permite legibilidade às etapas de montagem.
4. **Limitações Gerais**
    - Para consultas muito simples, a verbosidade da API de Criteria pode ser maior que escrever JPQL direto.
    - Em casos de expressões extremamente complexas (subqueries aninhadas demais, funções específicas do banco), às vezes é mais legível usar *NamedQuery* ou *NativeQuery*.

---

## Sintaxe Detalhada e Uso Prático

Nesta seção, veremos passo a passo como montar uma consulta básica com a API de Criteria. Suponha que exista uma entidade `Produto`:

```java
@Entity
public class Produto {
   @Id
   private Long id;
   private String nome;
   private BigDecimal preco;
   @ManyToOne
   private Categoria categoria;
   // getters e setters
}

```

Öbjetivo: buscar produtos cujo preço esteja entre 100 e 500, cujo nome contenha “Ergonomico”, ordenados pelo nome.

### 1. Obtenção do *CriteriaBuilder*

O **CriteriaBuilder** é o ponto de partida. Ele contém métodos para criar expressões, predicados, agregações, funções, etc.

```java
// 1. Obtenha o EntityManager (geralmente injetado ou recuperado via EntityManagerFactory)
EntityManager em = /* … */;

// 2. Obtenha o CriteriaBuilder
CriteriaBuilder cb = em.getCriteriaBuilder();

```

> Comentário:
> 
> - `em.getCriteriaBuilder()` retorna um objeto que implementa as “fábricas” de partes da query: `cb.equal()`, `cb.between()`, `cb.and()`, `cb.like()`, `cb.sum()`, etc.

### 2. Criação do *CriteriaQuery<T>*

Define-se qual será o tipo de retorno da consulta. No exemplo, queremos retornar entidades do tipo `Produto`.

```java
// 3. Crie o CriteriaQuery parametrizado com o tipo de resultado (Produto)
CriteriaQuery<Produto> criteriaQuery = cb.createQuery(Produto.class);

```

> Comentário:
> 
> - Caso fosse uma consulta que retornasse *DTOs* sem mapear diretamente uma entidade, usaríamos `CriteriaQuery<MeuDTO>` e, depois, `criteriaQuery.select(cb.construct(MeuDTO.class, root.get(...), ...))`.

### 3. Definição do *Root<T>*

O **Root<T>** representa o alias/raiz do “FROM” na consulta. Ele indica a partir de qual entidade estamos consultando e permite navegar pelos atributos mapeados.

```java
// 4. Defina a raiz (FROM Produto p)
Root<Produto> root = criteriaQuery.from(Produto.class);

```

> Comentário:
> 
> - `root.get("preco")` ou `root.get(Produto_.preco)` (se estiver usando metamodelo estático).
> - Se houvesse JOIN, faríamos algo como `Join<Produto, Categoria> joinCategoria = root.join("categoria");`.

### 4. Construção de *Predicate(s)*

**Predicates** representam condições booleanas para o `WHERE`. Cada método do `CriteriaBuilder` retorna um `Predicate`. No exemplo:

- `preco` entre 100 e 500
- `nome` contendo “Ergonomico” (LIKE)

```java
// 5. Crie Predicates para as condições:
// 5.1 Entre preço mínimo e máximo
Predicate condicaoPreco = cb.between(root.get("preco"), new BigDecimal("100"), new BigDecimal("500"));

// 5.2 Nome contendo “Ergonomico” (LIKE – equivalente a '%Ergonomico%')
Predicate condicaoNome = cb.like(cb.lower(root.get("nome")), "%ergonomico%");

```

> Comentário:
> 
> - É comum normalizar para `lower(...)` para comparações *case-insensitive*.
> - Para combinar várias condições, usar `cb.and(...)` ou `cb.or(...)`.

Combine os predicados em um único Predicate composto:

```java
// 6. Combine as condições com AND
Predicate filtroFinal = cb.and(condicaoPreco, condicaoNome);

// 7. Aplique o WHERE à consulta
criteriaQuery.where(filtroFinal);

```

### 5. Aplicação de Select, Order By, etc.

Defina o que será retornado. No nosso caso, queremos toda a entidade `Produto`. A cláusula `select(root)` é opcional, pois, por padrão, o `root` já é selecionado. Mas é mais explícito declarar:

```java
// 8. Defina o SELECT (opcional, pois, sem esta linha, root já é o retorno)
criteriaQuery.select(root);

// 9. Defina ORDER BY pelo nome ascendente
criteriaQuery.orderBy(cb.asc(root.get("nome")));

```

Caso houvesse agregação ou *group by*, poderíamos usar `criteriaQuery.groupBy(root.get("categoria"));` etc.

### 6. Geração de *TypedQuery<T>* e Execução

Por fim, cria-se um `TypedQuery` e executa:

```java
// 10. Crie a TypedQuery a partir do CriteriaQuery
TypedQuery<Produto> query = em.createQuery(criteriaQuery);

// 11. Execute para obter resultados
List<Produto> produtosFiltrados = query.getResultList();

// 12. (Opcional) – para obter um único resultado
// Produto produtoUnico = query.getSingleResult();

```

> Comentário:
> 
> - `getResultList()` traz lista vazia se não houver resultados.
> - `getSingleResult()` lança `NoResultException` ou `NonUniqueResultException` caso não haja exatamente um registro.

---

## Cenários de Restrição ou Não Aplicação

1. **Consultas Simples que Não Variam Dinamicamente**
    
    Para uma consulta estática, executada muitas vezes e que não exige montagem condicional, um **NamedQuery** ou JPQL direto pode ser mais enxuto.
    
    Exemplo:
    
    ```java
    List<Produto> lista = em.createQuery(
        "SELECT p FROM Produto p WHERE p.preco > :valor", Produto.class)
        .setParameter("valor", new BigDecimal("200"))
        .getResultList();
    
    ```
    
    – Escrever JPQL direto é mais breve.
    
2. **Casos Muito Complexos de Subqueries Múltiplas ou Funções Específicas de BD**
    
    Quando for necessário usar funções específicas do banco (por exemplo, `FUNCTION('TO_CHAR', ...)` muito customizado), a API de Criteria pode ficar verbosa ou limitada. Nesses casos, usar *Native Query* pode ser justificável.
    
3. **Performance e Otimizações**
    
    A API de Criteria gera o mesmo SQL que JPQL equivalente, mas alguns provedores podem gerar planos menos otimizados em certos cenários muito particulares. Se detectar SQL não performático, investigar o SQL gerado e, se necessário, recorrer a hints ou a *NamedNativeQuery*.
    
4. **Manutenção de Metamodelo**
    
    Ao usar *Static Metamodel* (classes geradas por *apt*), há o esforço adicional de manter as classes `_Produto_`, `_Categoria_`, etc. Se o time optar por não usar metamodelo, há chance de introduzir erros ao passar strings literais nos `root.get("atributo")`.
    

---

## Componentes Chave Associados

A seguir, detalhamos cada componente solicitado, discutindo seus papéis, métodos principais e sintaxe típica de uso.

### 1. CriteriaBuilder

- **O que é**: Fábrica de objetos para construir expressões query (predicados, ordenações, agregações, funções SQL genéricas, operações aritméticas, conversões de tipo, etc.).
- **Principais métodos**:
    - `createQuery(Class<T> resultClass)`: inicializa um `CriteriaQuery<T>`.
    - `equal(Expression<?> x, Object y)`: cria `x = y`.
    - `notEqual(...)`, `greaterThan(...)`, `lessThan(...)`, `between(...)`: operações de comparação.
    - `like(Expression<String> x, String pattern)`: cria `x LIKE pattern`.
    - `and(Predicate... restrictions)`: conjunção lógica.
    - `or(Predicate... restrictions)`: disjunção lógica.
    - `desc(Expression<?> x)`, `asc(Expression<?> x)`: ordenação.
    - `sum(...)`, `avg(...)`, `count(...)`: funções de agregação.
    - `lower(Expression<String> x)`, `upper(Expression<String> x)`: transformações de texto.
    - `function(String name, Class<T> type, Expression<?>... args)`: chamadas a funções SQL genéricas.

**Uso típico**:

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Produto> cq = cb.createQuery(Produto.class);

```

**Observação**: O `CriteriaBuilder` também pode criar `CriteriaDelete<T>` e `CriteriaUpdate<T>` (para operações de remoção e atualização em massa).

---

### 2. CriteriaQuery<T>

- **O que é**: Estrutura que representa a consulta (estrutura abstrata da instrução SQL). Contém lista de seleção (`SELECT`), raiz (`FROM`), restrições (`WHERE`), agrupamentos (`GROUP BY`), ordenações (`ORDER BY`), *having* (`HAVING`), *distinct*, etc.
- **Principais métodos**:
    - `select(Selection<? extends T> selection)`: define o que será retornado.
    - `from(Class<T> entityClass)`: define a raiz da consulta (sempre retorna um `Root<T>`).
    - `where(Predicate... restrictions)`: aplica condições ao filtro.
    - `groupBy(Expression<?>... grouping)`: define agrupamento.
    - `having(Predicate... restrictions)`: condições após o agrupamento.
    - `orderBy(Order... orders)`: define ordenação (obtida via `cb.asc(...)`, `cb.desc(...)`).
    - `distinct(boolean distinct)`: define se o resultado deve ser *distinct*.
    - `multiselect(Selection<?>... selections)`: retorna múltiplos campos (por exemplo, para construir DTOs).
    - `subquery(Class<X> type)`: cria uma subquery aninhada.

**Uso Típico**:

```java
CriteriaQuery<Produto> cq = cb.createQuery(Produto.class);
Root<Produto> root = cq.from(Produto.class);
cq.select(root)
  .where(cb.between(root.get("preco"), min, max))
  .orderBy(cb.asc(root.get("nome")));

```

**Observação**:

- Para retornar *DTOs*, usa-se `cq.select(cb.construct(MeuDTO.class, root.get("campo1"), root.get("campo2"), ...));`
- Subqueries:
    
    ```java
    Subquery<Long> sub = cq.subquery(Long.class);
    Root<Pedido> pedidoRoot = sub.from(Pedido.class);
    sub.select(cb.max(pedidoRoot.get("valor"))).where(cb.equal(pedidoRoot.get("cliente"), clienteRoot));
    cq.where(cb.equal(pedidoRoot.get("id"), sub));
    
    ```
    

---

### 3. Root<T>

- **O que é**: Representa a referência central (root) da entidade usada no `FROM`. É análogo ao alias em JPQL: `FROM Produto p`.
- **Principais métodos**:
    - `get(String attributeName)`: retorna um `Path<?>` que representa o atributo mapeado.
    - `join(String attributeName)`: estabelece um `JOIN` com outra entidade associada (por exemplo, `JOIN p.categoria c`).
    - `fetch(String attributeName, JoinType jt)`: associa *fetch* (para *EAGER fetch*) em vez de `join`, recuperando via *join fetch*.
    - `alias(String name)`: atribui um alias à raiz (útil em consultas nativas que recuperam colunas mapeadas).
- **Exemplo de JOIN**:
    
    ```java
    Root<Produto> root = cq.from(Produto.class);
    Join<Produto, Categoria> joinCategoria = root.join("categoria", JoinType.INNER);
    Predicate condCategoria = cb.equal(joinCategoria.get("nome"), "Eletrônicos");
    cq.where(condCategoria);
    
    ```
    

---

### 4. Predicate

- **O que é**: Representa uma condição booleana para ser usada em `WHERE`, `HAVING`, etc.
- **Principais métodos de criação (via CriteriaBuilder)**:
    - `cb.equal(Expression<?> x, Object y)`
    - `cb.notEqual(...)`
    - `cb.gt/lt/ge/le(...)` (> , < , >= , <= para tipos numéricos)
    - `cb.between(Expression<? extends Y> v, Y x, Y y)`
    - `cb.like(Expression<String> exp, String pattern)`
    - `cb.isNull(Expression<?> x)`, `cb.isNotNull(Expression<?> x)`
    - `cb.and(Predicate... preds)`, `cb.or(Predicate... preds)`, `cb.not(Predicate pred)`
- **Combinação**:
    
    ```java
    Predicate p1 = cb.equal(root.get("status"), Status.ATIVO);
    Predicate p2 = cb.greaterThan(root.get("qtdEstoque"), 0);
    Predicate filtro = cb.and(p1, p2); // status = 'ATIVO' AND qtdEstoque > 0
    cq.where(filtro);
    
    ```
    

---

### 5. TypedQuery<T>

- **O que é**: Representa a consulta compilada pronta para ser executada. É similar aos `javax.persistence.TypedQuery`, mas já reflete o `CriteriaQuery` gerado.
- **Principais métodos**:
    - `getResultList()`: retorna `List<T>`.
    - `getSingleResult()`: espera exatamente um resultado e retorna `T`.
    - `setMaxResults(int max)`: limita o número de resultados.
    - `setFirstResult(int startPosition)`: paginação – define o deslocamento inicial.
    - `setParameter(Parameter<Y> param, Y value)` ou `setParameter(String name, Object value)`: caso a consulta use parâmetros nomeados.
- **Uso Típico**:
    
    ```java
    TypedQuery<Produto> query = em.createQuery(cq);
    query.setFirstResult(0);     // iniciar do 1º registro
    query.setMaxResults(10);     // limitar a 10 resultados
    List<Produto> lista = query.getResultList();
    
    ```
    

---

## Melhores Práticas e Padrões de Uso

1. **Preferir Metamodelo Estático (*Static Metamodel*) Sempre que Possível**
    - Garante segurança de tipo ao referenciar atributos:
        
        ```java
        // Em vez de root.get("preco"), usar Produto_.preco
        Predicate p = cb.between(root.get(Produto_.preco), BigDecimal.ONE, BigDecimal.TEN);
        
        ```
        
    - Evita erros de digitação nos nomes dos atributos.
2. **Fazer Queries Dinâmicas Gradativamente**
    - Inicialize a lista de `Predicate` em tempo de execução e só inclua condições quando necessário:
        
        ```java
        List<Predicate> predicates = new ArrayList<>();
        if (nome != null) {
          predicates.add(cb.like(root.get(Produto_.nome), "%" + nome + "%"));
        }
        if (precoMin != null && precoMax != null) {
          predicates.add(cb.between(root.get(Produto_.preco), precoMin, precoMax));
        }
        cq.where(predicates.toArray(new Predicate[0]));
        
        ```
        
3. **Evitar Consultas que Retornem Muitas Entidades Não Necessárias**
    - Se só precisar de um ou dois campos, utilize projeção em DTO:
        
        ```java
        CriteriaQuery<ProdutoDTO> dtoQuery = cb.createQuery(ProdutoDTO.class);
        Root<Produto> p = dtoQuery.from(Produto.class);
        dtoQuery.select(cb.construct(
            ProdutoDTO.class,
            p.get(Produto_.id),
            p.get(Produto_.nome),
            p.get(Produto_.preco)
        ));
        
        ```
        
4. **Cuidar da Performance de Joins e Fetch**
    - Use `root.fetch("relacao", JoinType.LEFT)` apenas quando for necessário buscar (*eager*) coleções ou associações.
    - Evite *N+1 queries* conferindo o SQL gerado no log.
5. **Paginação e Limites**
    - Sempre pagine resultados grandes:
        
        ```java
        TypedQuery<Produto> query = em.createQuery(cq);
        query.setFirstResult(pagina * tamanhoPagina);
        query.setMaxResults(tamanhoPagina);
        
        ```
        
6. **Uso de Subqueries com Cautela**
    - Subqueries podem impactar a performance; avalie reescrever via `JOIN` quando possível.
    - Quando necessário, use `CriteriaQuery.subquery(...)` e adicione `where(cb.in(root.get("campo"), subquery))`.
7. **Tratar Caso de `getSingleResult()` com `try-catch`**
    - Ao usar `getSingleResult()`, sempre trate `NoResultException` e `NonUniqueResultException` caso possa haver zero ou mais de um resultado.
8. **Reuso de Partes de Consulta**
    - Se vários métodos precisarem de predicados semelhantes, extraia-os para helpers:
        
        ```java
        public Predicate criarFiltroAtivo(CriteriaBuilder cb, Root<Produto> root) {
            return cb.equal(root.get(Produto_.ativo), true);
        }
        
        ```
        

---

## Exemplo Prático Completo

A seguir, um cenário hipotético mais completo: listar **clientes** que possuem **pedidos ativos**, onde o valor total dos pedidos excede determinado valor, ordenados pela data de registro do cliente.

### Entidades Simplificadas

```java
@Entity
public class Cliente {
   @Id
   private Long id;
   private String nome;
   private LocalDate dataRegistro;
   private Boolean ativo;

   @OneToMany(mappedBy = "cliente")
   private List<Pedido> pedidos;
   // getters e setters
}

@Entity
public class Pedido {
   @Id
   private Long id;
   private LocalDate dataPedido;
   private BigDecimal total;
   private Boolean concluido;

   @ManyToOne
   private Cliente cliente;
   // getters e setters
}

```

### Requisitos da Consulta

- Trazer clientes **ativos** (`cliente.ativo = true`)
- Que tenham algum pedido **não concluído** (`pedido.concluido = false`)
- Com `total` de **pedido** maior que 1.000,00
- Ordenar clientes por `dataRegistro` descendente
- Exibir apenas os campos `nome` e `dataRegistro` em um DTO `ClienteResumoDTO`

```java
public class ClienteResumoDTO {
    private String nome;
    private LocalDate dataRegistro;

    public ClienteResumoDTO(String nome, LocalDate dataRegistro) {
        this.nome = nome;
        this.dataRegistro = dataRegistro;
    }
    // getters e setters
}

```

### Montagem da Consulta com Criteria API

1. **Obter `CriteriaBuilder` e iniciar `CriteriaQuery` para DTO**
    
    ```java
    EntityManager em = /* … */;
    CriteriaBuilder cb = em.getCriteriaBuilder();
    
    // Queremos retornar ClienteResumoDTO
    CriteriaQuery<ClienteResumoDTO> cq = cb.createQuery(ClienteResumoDTO.class);
    
    ```
    
2. **Definir `Root<Cliente>`**
    
    ```java
    Root<Cliente> rootCliente = cq.from(Cliente.class);
    
    ```
    
3. **Fazer o JOIN com `Pedido`**
    
    ```java
    // JOIN interno: somente clientes que possuam pedidos
    Join<Cliente, Pedido> joinPedido = rootCliente.join("pedidos", JoinType.INNER);
    
    ```
    
4. **Criar Predicados (filtros)**
    
    ```java
    // 4.1 Cliente ativo
    Predicate clienteAtivo = cb.isTrue(rootCliente.get("ativo"));
    
    // 4.2 Pedido não concluído
    Predicate pedidoNaoConcluido = cb.isFalse(joinPedido.get("concluido"));
    
    // 4.3 Total do pedido > 1000
    Predicate totalMaiorQueMil = cb.greaterThan(joinPedido.get("total"), new BigDecimal("1000.00"));
    
    // Combine todos
    Predicate filtroFinal = cb.and(clienteAtivo, pedidoNaoConcluido, totalMaiorQueMil);
    
    ```
    
5. **Selecionar Campos para DTO**
    - Usando `cb.construct(...)` para projetar diretamente no `ClienteResumoDTO`
    
    ```java
    cq.select(cb.construct(
        ClienteResumoDTO.class,
        rootCliente.get("nome"),
        rootCliente.get("dataRegistro")
    ));
    
    ```
    
6. **Aplicar `WHERE` e `ORDER BY`**
    
    ```java
    cq.where(filtroFinal);
    
    // Ordenar por dataRegistro (descendente)
    cq.orderBy(cb.desc(rootCliente.get("dataRegistro")));
    
    ```
    
7. **Gerar `TypedQuery` e Executar**
    
    ```java
    TypedQuery<ClienteResumoDTO> query = em.createQuery(cq);
    
    // Paginação: trazer apenas 20 registros por página
    int pagina = 0;
    int tamanhoPagina = 20;
    query.setFirstResult(pagina * tamanhoPagina);
    query.setMaxResults(tamanhoPagina);
    
    List<ClienteResumoDTO> resultados = query.getResultList();
    
    ```
    
8. **Resultado**
    - A lista `resultados` conterá instâncias de `ClienteResumoDTO` com `nome` e `dataRegistro` dos clientes que satisfazem as condições.

---

## Sugestões para Aprofundamento

1. **Documentação Oficial do JPA (JSR 338)**
    - Leitura detalhada do capítulo sobre *Criteria API* no *JPA Specification*.
2. **Exemplos de Metamodelo Estático**
    - Gerar classes de metamodelo com `javax.persistence.metamodel` (via *apt* ou *hibernate-jpamodelgen*) e usá-las para referenciar atributos com segurança.
3. **Frameworks de Suporte**
    - Explorar bibliotecas como **Querydsl** ou **Spring Data JPA Specifications**, que fornecem DSLs mais ricas para montagem de consultas, estendendo a facilidade além da API básica de Criteria.
4. **Perfis de Performance e Log de SQL Gerado**
    - Ativar logs SQL no provedor (por exemplo, `hibernate.show_sql`) para analisar o SQL gerado pela *Criteria API*.
    - Benchmark entre JPQL e Criteria para cenários específicos do projeto.
5. **Casos de Uso Avançados**
    - Subqueries aninhadas em `WHERE`.
    - Uso de funções do banco via `cb.function("FUNCTION_NAME", ...)`.
    - Agregações complexas: `avg`, `sum`, `countDistinct`, `rollup` (quando suportado).
6. **Integração com Spring Data JPA**
    - Usar `JpaSpecificationExecutor<T>` para implementar dynamic queries baseadas em `Specification<T>`, que internamente usa Criteria.

---

> Conclusão
> 
> 
> A API de Criteria do JPA oferece poderosa mecanização de consultas de forma programática, garantindo tipagem, facilidade para montar filtros dinâmicos e melhor manutenção de código. Compreender bem cada componente – **CriteriaBuilder, CriteriaQuery<T>, Root<T>, Predicate, TypedQuery<T>** – é fundamental para desenvolver aplicações Java robustas que interagem com bases de dados de forma segura e eficiente.
>