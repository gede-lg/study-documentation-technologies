# Joins

---

## Introdução

O **Criteria API** do JPA é uma forma programática e fortemente tipada de construir consultas dinâmicas em Java, sem recorrer diretamente a strings JPQL. Dentro dele, os **joins** (junções) permitem navegar e associar entidades relacionadas, tornando possível filtrar, projetar ou carregar dados de múltiplas tabelas simultaneamente. Nesta explicação, apresentaremos conceitos, sintaxes e exemplos práticos para entender como usar tipos de `join`, como navegar em relacionamentos (`OneToOne`, `OneToMany`, `ManyToOne`, `ManyToMany`) e como aplicar joins aninhados.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    1. Criando o `CriteriaBuilder` e `CriteriaQuery`
    2. Usando `Root` e `Join`
    3. Diferença entre `join()` e `fetch()`
    4. Exemplos com `JoinType.INNER`, `LEFT` e `RIGHT`
    5. Joins Aninhados
3. [Componentes Chave Associados](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#componentes-chave-associados)
4. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sugest%C3%B5es-para-aprofundamento)

---

## 1. Conceitos Fundamentais

- **Importância dos Joins**
    - Em um modelo relacional, entidades tendem a estar relacionadas por meio de chaves estrangeiras. Um join “liga” essas tabelas para permitir filtros, projeções e carregamento conjunto de dados associados.
    - No **Criteria API**, utilizamos objetos Java (`Root`, `Join`, `Fetch`) para representar essas relações, mantendo tipagem segura e evitando erros de sintaxe em strings JPQL.
- **Tipos de Join em Criteria API**
    1. `join()`
        - Realiza apenas a junção lógica para fins de filtragem e projeção (sem trazer automaticamente coleções relacionadas, a não ser que programas façam “fetch” explícito).
    2. `fetch()`
        - Similar a `join()`, mas instrui o provedor JPA a carregar (EAGER) a associação em uma única consulta, evitando potenciais múltiplas consultas (N+1). Internamente, opera como um `LEFT JOIN FETCH`.
- **Enumerações de Tipo de Join (`JoinType`)**
    - `JoinType.INNER`
    - `JoinType.LEFT`
    - `JoinType.RIGHT`
- **Navegação em Relacionamentos**
    - `@OneToOne`, `@ManyToOne`
        - Normalmente configurados como `FetchType.EAGER` (padrão para muitos provedores), porém podem ser alterados para `LAZY`
        - Exemplo: numa entidade `Pedido`, atributo `cliente: Cliente` com `@ManyToOne`
    - `@OneToMany`, `@ManyToMany`
        - Geralmente `FetchType.LAZY`
        - Exemplo: em `Cliente`, atributo `pedidos: List<Pedido>` com `@OneToMany(mappedBy = "cliente")`
- **Joins Aninhados**
    - É possível realizar joists em múltiplos níveis, como `pedido.join("cliente").join("endereco")` ou, de forma tipada, `root.join(Pedido_.cliente).join(Cliente_.endereco)`.
    - Permite navegar em cadeias de relacionamentos e aplicar filtros profundos.

---

## 2. Sintaxe Detalhada e Uso Prático

### 2.1. Criando o `CriteriaBuilder` e `CriteriaQuery`

```java
// Em um contexto EJB ou EntityManager configurado:
EntityManager em = /* obter EntityManager via injeção ou EntityManagerFactory */;
CriteriaBuilder cb = em.getCriteriaBuilder();

// Definindo o tipo de retorno (ex: consulta que retorna 'Pedido')
CriteriaQuery<Pedido> query = cb.createQuery(Pedido.class);

// Raiz da consulta (equivale ao FROM Pedido p)
Root<Pedido> root = query.from(Pedido.class);

```

- **Comentário:**
    - `CriteriaBuilder` é responsável por construir toda a lógica (predicados, expressões, ordenações).
    - `CriteriaQuery<Pedido>` indica que a consulta vai retornar objetos do tipo `Pedido`.
    - `Root<Pedido>` representa a entidade “raiz” (tabela principal) no critério.

---

### 2.2. Usando `Root` e `Join`

### 2.2.1. Join Básico (INNER JOIN)

```java
// Supondo que Pedido tenha um atributo ManyToOne: Cliente cliente;
Join<Pedido, Cliente> joinCliente = root.join("cliente", JoinType.INNER);

// Exemplo de filtro: somente pedidos de um cliente com nome “Maria”
Predicate filtro = cb.equal(joinCliente.get("nome"), "Maria");

// Construindo a consulta final
query.select(root)
     .where(filtro);

// Executando
List<Pedido> resultados = em.createQuery(query).getResultList();

```

- **Comentário:**
    - `root.join("cliente", JoinType.INNER)` faz um INNER JOIN entre `Pedido` e `Cliente`, usando a FK `pedido.cliente_id = cliente.id`.
    - `joinCliente.get("nome")` acessa o atributo `nome` da entidade `Cliente`.

### 2.2.2. Fetch Join (LEFT JOIN FETCH)

```java
// Carregar o Cliente junto com o Pedido em uma única consulta
// fetch() equivale, por padrão, a LEFT JOIN FETCH
Fetch<Pedido, Cliente> fetchCliente = root.fetch("cliente", JoinType.LEFT);

// Se quisermos usar para filtrar, ainda precisamos do join “normal”
Join<Pedido, Cliente> joinClienteParaFiltro = (Join<Pedido, Cliente>) fetchCliente;

// Exemplo de filtragem: status do pedido seja “ENTREGUE”
Predicate filtroStatus = cb.equal(root.get("status"), StatusPedido.ENTREGUE);

query.select(root).where(filtroStatus).distinct(true);
// distinct(true) evita duplicação de pedidos caso existam múltiplos fetches aninhados

List<Pedido> lista = em.createQuery(query).getResultList();

```

- **Comentário:**
    - `fetch("cliente")` faz com que o JPA gere SQL com `LEFT JOIN FETCH cliente` para trazer o objeto `Cliente` “de uma só vez”, evitando consulta extra.
    - Caso haja relacionamentos de coleção, o JPA pode gerar duplicidade de linhas de `Pedido`. Por isso, usamos `distinct(true)`.

---

### 2.3. Diferença entre `join()` e `fetch()`

- **`join(...)`**
    - Usado quando o foco é filtrar, projetar ou agrupar dados baseados em atributos da associação.
    - NÃO força carregamento da associação no resultado (a menos que explicitamente projetada).
- **`fetch(...)`**
    - Força carregamento imediato (eager) da associação — útil para evitar o problema “N+1 selects”.
    - Gera automaticamente `LEFT JOIN FETCH` (não necessariamente permite `JoinType.INNER`).
    - Não pode ser usado diretamente em projeções que não retornam a entidade raiz (sem cast).

---

### 2.4. Exemplos com `JoinType.INNER`, `LEFT` e `RIGHT`

### 2.4.1. `JoinType.INNER`

```java
// Exemplo: buscar todos os pedidos que tenham itens cujo produto esteja na categoria “Eletrônicos”
Join<Pedido, ItemPedido> joinItem = root.join("itens", JoinType.INNER);
Join<ItemPedido, Produto> joinProduto = joinItem.join("produto", JoinType.INNER);
Join<Produto, Categoria> joinCategoria = joinProduto.join("categoria", JoinType.INNER);

Predicate filtroCategoria = cb.equal(joinCategoria.get("nome"), "Eletrônicos");
query.select(root).where(filtroCategoria).distinct(true);

List<Pedido> pedidosEletronicos = em.createQuery(query).getResultList();

```

- **Comentário:**
    - Todos os joins são `INNER`, então somente pedidos que tenham pelo menos um item cujo produto pertença àquela categoria serão retornados.

### 2.4.2. `JoinType.LEFT`

```java
// Exemplo: buscar todos os clientes e, quando existirem, carregar seus pedidos (carregar mesmo que não tenha pedido)
Root<Cliente> rootCliente = query.from(Cliente.class);

// LEFT JOIN cliente.pedidos
Join<Cliente, Pedido> joinPedidos = rootCliente.join("pedidos", JoinType.LEFT);

// Para filtrar somente clientes “INATIVOS”:
Predicate filtroInativos = cb.equal(rootCliente.get("status"), StatusCliente.INATIVO);
query.select(rootCliente).where(filtroInativos).distinct(true);

List<Cliente> clientesInativos = em.createQuery(query).getResultList();

```

- **Comentário:**
    - Mesmo clientes sem pedidos aparecerão, com atributo `pedidos` vazio.
    - Se quisermos que a associação seja carregada (EntityGraph ou `fetch`), podemos usar `rootCliente.fetch("pedidos", JoinType.LEFT)`.

### 2.4.3. `JoinType.RIGHT`

- **Obs.:** Em muitos bancos e contextos JPA, `RIGHT JOIN` não traz benefícios práticos, pois a entidade raiz é o primeiro membro do FROM. Porém, mostramos sintaxe para referência:

```java
// RIGHT JOIN é menos usual; assume-se que algumas implementações possam nem suportar. Exemplo:
Join<Cliente, Pedido> joinRight = rootCliente.join("pedidos", JoinType.RIGHT);

// Normalmente evite RIGHT JOIN e use LEFT via troca de ordem de tables no JPQL nativo ou Criteria recursivamente.

```

- **Comentário:**
    - Caso seu provedor JPA não suporte `RIGHT`, considere inverter a raiz da consulta (fazer `FROM Pedido p` e `LEFT JOIN p.cliente`).

---

### 2.5. Joins Aninhados

É possível aninhar diversos níveis de relações, por exemplo, de `Pedido` → `Cliente` → `Endereço` → `Cidade`.

```java
// Supondo as seguintes entidades:
// Pedido { Long id; Cliente cliente; List<ItemPedido> itens; }
// Cliente { Long id; String nome; Endereco endereco; }
// Endereco { Long id; String logradouro; Cidade cidade; }
// Cidade { Long id; String nome; String estado; }

// 1) Raiz
Root<Pedido> rootPedido = query.from(Pedido.class);

// 2) Join em Cliente
Join<Pedido, Cliente> joinCliente = rootPedido.join("cliente", JoinType.INNER);

// 3) Join aninhado em Endereco
Join<Cliente, Endereco> joinEndereco = joinCliente.join("endereco", JoinType.INNER);

// 4) Join aninhado em Cidade
Join<Endereco, Cidade> joinCidade = joinEndereco.join("cidade", JoinType.INNER);

// Exemplo de filtro: cidade = “São Paulo”
Predicate filtroCidade = cb.equal(joinCidade.get("nome"), "São Paulo");

// Montando e executando
query.select(rootPedido).where(filtroCidade).distinct(true);
List<Pedido> pedidosSP = em.createQuery(query).getResultList();

```

- **Comentário:**
    - Os joins aninhados permitem navegar várias camadas de relacionamentos.
    - Se houver coleções em algum nível (por exemplo, se `Cliente` tivesse `List<Endereco> enderecos`), o join resultante pode gerar múltiplas linhas para o mesmo cliente. O uso de `distinct(true)` evita duplicidades.

---

## 3. Componentes Chave Associados

1. **`EntityManager`**
    - Ponto de entrada para criação de `CriteriaBuilder` e execução das queries.
2. **`CriteriaBuilder`**
    - Fábrica para criar objetos de critérios: `CriteriaQuery`, `Predicate`, `Expression`, `Order`, etc.
3. **`CriteriaQuery<T>`**
    - Representa a consulta tipada (o retorno é de tipo `T`).
    - Métodos principais:
        - `select(...)` (define a projeção)
        - `where(...)` (predicados de filtro)
        - `groupBy(...)`, `having(...)`, `orderBy(...)`
4. **`Root<X>`**
    - Representa a entidade raiz no FROM.
    - Métodos:
        - `get(String atributo)` → acessa campo simples (para filtros ou seleções).
        - `join(...)`, `fetch(...)` → iniciam junções.
5. **`Join<Z, X>`**
    - Representa o resultado de um JOIN de `Z` para `X`.
    - Métodos:
        - `get(String atributo)` → acessa atributos da entidade associada.
        - `join(...)` → para criar joins aninhados.
6. **`Fetch<Z, X>`**
    - Similar a `Join`, porém usado especificamente para carregamento antecipado (EAGER).
    - NÃO gera objeto `Join` diretamente, mas pode ser convertido via casting se necessário.
7. **`JoinType`**
    - Enum (`INNER`, `LEFT`, `RIGHT`) que define o tipo de junção no SQL subjacente.
8. **Anotações JPA Importantes**
    - `@OneToOne`, `@ManyToOne` (tipicamente `FetchType.EAGER` por padrão)
    - `@OneToMany`, `@ManyToMany` (tipicamente `FetchType.LAZY` por padrão)
    - `mappedBy`, `cascade`, `orphanRemoval` — determinam comportamentos de cascata e carregamento.
9. **Metamodel (Opcional)**
    - Seções geradas via anotações para acesso tipado: `Pedido_`, `Cliente_`, `Endereco_`, `Cidade_`.
    - Exemplo: `root.join(Pedido_.cliente)` em vez de `root.join("cliente")`, evitando string literal.

---

## 4. Cenários de Restrição ou Não Aplicação

1. **Não usar Join em Grandes Coleções Sem Filtro**
    - Se for uma relação `@OneToMany` com milhares de elementos, `root.join("itens")` pode gerar enorme volume de dados; às vezes, é melhor fazer uma consulta separada ou paginar.
2. **Quando o Modelo de Dados Não Precisa de Relações**
    - Se a consulta exigir apenas dados simples de `Pedido`, sem filtrar por atributos de `Cliente`, não há necessidade de join.
3. **Problemas de Performance com `fetch()` Indevido**
    - `fetch()` força EAGER loading. Se a associação não for necessária na resposta final, isso pode gerar sobrecarga de memória e linhas duplicadas (necessitando `distinct`).
4. **`RIGHT JOIN` Raramente Suportado**
    - Muitos provedores JPA não suportam `RIGHT JOIN` em Criteria; preferir inverter a ordem de entidades (usar `LEFT`) ou reescrever em JPQL nativo.
5. **Quando o Banco de Dados Não Possui Relacionamento-Referência**
    - Em cenários de tabelas legadas sem chave estrangeira declarada, um join no Criteria “por string” pode causar erros caso o JPA espere metadados XML ou anotation para mapear.

---

## 5. Melhores Práticas e Padrões de Uso

1. **Evitar Strings Literais em `join("atributo")`**
    - Utilize **Metamodel** gerado automaticamente (`Pedido_.cliente`) para evitar erros de nomeação e facilitar refatoração.
    
    ```java
    Join<Pedido, Cliente> joinCliente = root.join(Pedido_.cliente, JoinType.INNER);
    
    ```
    
2. **Sempre Usar `distinct(true)` ao Fazer Joins em Coleções**
    - Evita duplicação de entidades raiz no resultado quando há relacionamentos `@OneToMany` ou `@ManyToMany`.
3. **Prefira `fetch()` Somente Quando Necessário**
    - `fetch()` traz a entidade associada para dentro do contexto de persistência imediatamente. Use-o se você souber que precisará daquela associação em seguida, evitando consultas adicionais.
4. **Paginação em Consultas com Joins**
    - Se a junção gerar muitas linhas, aplique `setFirstResult()` e `setMaxResults()` no `TypedQuery` para evitar trazer todos os dados de uma só vez.
5. **Evitar “Cartesian Product” (Produto Cartesiano)**
    - Ao usar múltiplos joins em coleções sem filtro adequado, há risco de multiplicar resultados. Combine cuidadosamente condições e use `distinct` ou `groupBy` quando fizer sentido.
6. **Separar Lógicas de Filtro e Projeção**
    - Para cenários muito complexos, distribua a lógica em múltiplas subconsultas ou utilize **DTO Projection** para retornar apenas campos necessários, reduzindo carga na rede.
7. **Documentar Relacionamentos no Modelo**
    - Indicar claramente em `@OneToMany(mappedBy = "cliente", fetch = FetchType.LAZY)` se a relação deve ou não ser carregada por padrão. Isso ajuda a definir quando aplicar `fetch()` manualmente.
8. **Evitar RIGHT JOIN – Reescreva a Consulta**
    - Se precisar fazer “todos X mesmo sem Y”, prefira `LEFT JOIN` invertendo a raiz:
    
    ```java
    CriteriaQuery<Pedido> cq = cb.createQuery(Pedido.class);
    Root<Pedido> pedidoRoot = cq.from(Pedido.class);
    Join<Pedido, Cliente> leftJoinCliente = pedidoRoot.join(Pedido_.cliente, JoinType.LEFT);
    
    ```
    
    - Evita problemas de compatibilidade.

---

## 6. Exemplo Prático Completo

### Cenário Simplificado

- **Entidades:**
    1. **Cliente**
        
        ```java
        @Entity
        public class Cliente {
          @Id
          @GeneratedValue(...)
          private Long id;
        
          private String nome;
        
          @OneToMany(mappedBy = "cliente", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
          private List<Pedido> pedidos = new ArrayList<>();
          // getters e setters
        }
        
        ```
        
    2. **Pedido**
        
        ```java
        @Entity
        public class Pedido {
          @Id
          @GeneratedValue(...)
          private Long id;
        
          private LocalDate dataCriacao;
          private BigDecimal valorTotal;
        
          @ManyToOne(fetch = FetchType.LAZY)
          @JoinColumn(name = "cliente_id")
          private Cliente cliente;
        
          @OneToMany(mappedBy = "pedido", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
          private List<ItemPedido> itens = new ArrayList<>();
          // getters e setters
        }
        
        ```
        
    3. **ItemPedido**
        
        ```java
        @Entity
        public class ItemPedido {
          @Id
          @GeneratedValue(...)
          private Long id;
        
          private Integer quantidade;
          private BigDecimal precoUnitario;
        
          @ManyToOne(fetch = FetchType.LAZY)
          @JoinColumn(name = "pedido_id")
          private Pedido pedido;
        
          @ManyToOne(fetch = FetchType.LAZY)
          @JoinColumn(name = "produto_id")
          private Produto produto;
          // getters e setters
        }
        
        ```
        
    4. **Produto**
        
        ```java
        @Entity
        public class Produto {
          @Id
          @GeneratedValue(...)
          private Long id;
        
          private String nome;
          private String categoria;
          private BigDecimal preco;
          // getters e setters
        }
        
        ```
        

### Objetivo da Consulta

> Listar todos os pedidos de clientes da categoria de produto “Eletrônicos”, carregando o cliente junto (fetch) e filtrando por pedidos com valor total ≥ 1000.00.
> 

### 6.1. Montagem da Criteria

```java
EntityManager em = /* obter EntityManager */;
CriteriaBuilder cb = em.getCriteriaBuilder();

// Passo 1: Criar CriteriaQuery retornando Pedido
CriteriaQuery<Pedido> query = cb.createQuery(Pedido.class);

// Passo 2: Definir a raiz (FROM Pedido)
Root<Pedido> rootPedido = query.from(Pedido.class);

// Passo 3: Fazer FETCH do Cliente para evitar N+1
Fetch<Pedido, Cliente> fetchCliente = rootPedido.fetch("cliente", JoinType.LEFT);
// Caso precise filtrar atributos do cliente, convertemos para Join:
Join<Pedido, Cliente> joinCliente = (Join<Pedido, Cliente>) fetchCliente;

// Passo 4: Join em itens (para filtrar por categoria de produto)
Join<Pedido, ItemPedido> joinItem = rootPedido.join("itens", JoinType.INNER);
// Passo 5: Join em produto
Join<ItemPedido, Produto> joinProduto = joinItem.join("produto", JoinType.INNER);

// Passo 6: Predicados (filtros)
// a) Categoria do produto “Eletrônicos”
Predicate filtroCategoria = cb.equal(joinProduto.get("categoria"), "Eletrônicos");

// b) Valor total do pedido ≥ 1000.00
Predicate filtroValorTotal = cb.ge(rootPedido.get("valorTotal"), new BigDecimal("1000.00"));

// Combinar predicados (AND)
Predicate combinado = cb.and(filtroCategoria, filtroValorTotal);

// Passo 7: Definir seleção e cláusula WHERE
query.select(rootPedido)
     .where(combinado)
     .distinct(true); // Evitar duplicidade se houver múltiplos itens correspondentes

// Opcional: Ordenar por data de criação
query.orderBy(cb.desc(rootPedido.get("dataCriacao")));

// Passo 8: Executar consulta
List<Pedido> resultados = em.createQuery(query).getResultList();

```

### 6.2. Explicação dos Passos

1. **`Root<Pedido> rootPedido = query.from(Pedido.class);`**
    - Define a entidade principal (`Pedido`) na cláusula `FROM`.
2. **`rootPedido.fetch("cliente", JoinType.LEFT)`**
    - Força carregamento antecipado do `Cliente` de forma “EAGER”, evitando que, ao acessar `pedido.getCliente()`, seja disparada outra consulta.
3. **`rootPedido.join("itens", JoinType.INNER)`**
    - Navega de `Pedido` → `ItemPedido`, filtrando apenas pedidos que **tenham** itens.
4. **`joinItem.join("produto", JoinType.INNER)`**
    - Navega de `ItemPedido` → `Produto`, para acessar o atributo `categoria` e filtrar “Eletrônicos”.
5. **`cb.equal(joinProduto.get("categoria"), "Eletrônicos")`**
    - Predicado que seleciona somente produtos com categoria “Eletrônicos”.
6. **`cb.ge(rootPedido.get("valorTotal"), new BigDecimal("1000.00"))`**
    - Predicado que seleciona pedidos cujo valor total seja maior ou igual a 1000.00.
7. **`query.distinct(true)`**
    - Elimina duplicatas de `Pedido` caso haja mais de um `ItemPedido` de categoria “Eletrônicos” no mesmo pedido.
8. **`query.orderBy(...)`**
    - Ordena os resultados, por exemplo, por data de criação de forma decrescente.

---

## 7. Sugestões para Aprofundamento

1. **Criteria API Avançado**
    - **Subqueries:** como criar consultas aninhadas (ex.: buscar pedidos cujo cliente tenha feito mais de 5 compras).
    - **`CriteriaUpdate` e `CriteriaDelete`:** para operações de atualização/exclusão em lote via Criteria.
2. **Metamodel (JPA Static Metamodel)**
    - Gerar classes `_` para permitir acesso tipado em lugar de strings, evitando erros de digitação.
    - Exemplo: `root.join(Pedido_.cliente)` em vez de `root.join("cliente")`.
3. **DTO Projections com Criteria**
    - Retornar somente campos necessários (ex.: somar valores, calcular média), usando `cb.construct(SomeDTO.class, ...)` ou `cb.tuple(...)`.
4. **Desempenho e Monitoramento**
    - Analisar SQL gerado (habilitar `hibernate.show_sql=true`).
    - Ajustar fetch graphs, usar `EntityGraph` para carregar apenas alguns campos.
5. **Comparação com JPQL Tradicional**
    - Como as consultas JPQL análogas ficariam em string.
    - Quais vantagens e desvantagens de cada abordagem.
6. **Integração com Spring Data JPA**
    - Usar `JpaSpecificationExecutor<T>` para incorporar Specifications (Criteria reusable) dentro de repositórios Spring.

---

### Resumo Final

Nesta seção, apresentamos uma visão detalhada sobre como utilizar **joins** no **Criteria API** do JPA, abordando desde conceitos fundamentais até um exemplo prático completo. Vimos a diferença entre `join()` e `fetch()`, os tipos de `JoinType`, como navegar em relacionamentos simples e aninhados (`OneToOne`, `OneToMany`, `ManyToOne`, `ManyToMany`), além de dicas de performance e situações em que joins podem não ser a melhor escolha.

Sinta-se à vontade para explorar os tópicos de aprofundamento sugeridos, especialmente o uso de Metamodel gerado e DTO Projections, para criar consultas cada vez mais robustas, seguras e performáticas.

---

**FIM**