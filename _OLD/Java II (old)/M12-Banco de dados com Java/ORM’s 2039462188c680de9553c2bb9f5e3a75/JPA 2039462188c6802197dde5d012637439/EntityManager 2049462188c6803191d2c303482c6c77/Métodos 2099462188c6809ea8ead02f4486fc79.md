# Métodos

---

## Introdução

O Java Persistence API (JPA) é a especificação padrão para mapeamento objeto-relacional (ORM) no ecossistema Java. No coração dessa especificação, encontra-se o **EntityManager**, que gerencia o ciclo de vida das entidades (objetos persistentes) e coordena operações de persistência, consulta e remoção em um contexto de persistência.

Este material apresenta:

1. **Visão Geral Concisa** (sem exemplos de código)
2. **Explicação Detalhada e Completa** (com código, melhores práticas e exemplos)

---

## Visão Geral Concisa

- **O que é o EntityManager?**
    - Uma interface do JPA responsável por gerenciar o contexto de persistência (first-level cache) e executar operações de CRUD (Create, Read, Update, Delete) sobre entidades.
- **Métodos Essenciais:**
    - `persist(Object entity)` – Torna uma entidade “gerenciada” e a insere no banco ao confirmar a transação.
    - `merge(T entity)` – Atualiza ou acerta o estado da entidade no contexto de persistência, retornando uma instância gerenciada.
    - `remove(Object entity)` – Remove a entidade do contexto e agenda a deleção no banco.
    - `find(Class<T> entityClass, Object primaryKey)` – Busca imediatamente a entidade com a chave primária informada, retornando-a ou `null`.
    - `getReference(Class<T> entityClass, Object primaryKey)` – Retorna um *proxy* da entidade (lazy), que só acessa o banco quando realmente necessário.

Em resumo, o **EntityManager** atua como “controlador” do estado das entidades no contexto transacional e como ponte entre objetos Java e registros no banco de dados.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    1. `persist()`
    2. `merge()`
    3. `remove()`
    4. `find()`
    5. `getReference()`
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#componentes-chave-associados)
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#exemplo-pr%C3%A1tico-completo)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/683cc288-6078-8013-a1a6-48f406dbdfc9#sugest%C3%B5es-para-aprofundamento)

---

## 1. Conceitos Fundamentais

1. **Contexto de Persistência (Persistence Context)**
    - É o “escopo” no qual o EntityManager gerencia entidades.
    - Cada entidade em estado **Managed** está associada a esse contexto. Quaisquer alterações feitas em entidades gerenciadas são automaticamente sincronizadas com o banco ao confirmar a transação.
2. **Estados das Entidades**
    - **Transient**: recém-instanciada, não associada a nenhum EntityManager.
    - **Managed**: associada ao contexto de persistência; alterações ficam “penduradas” até `flush()/commit()`.
    - **Detached**: já foi gerenciada em outro contexto, mas não está mais associada a um EntityManager ativo.
    - **Removed**: marcada para remoção; ao confirmar, é excluída do banco.
3. **Lifecycle do EntityManager**
    - **Obtenção**: via `EntityManagerFactory.createEntityManager()` ou, em ambientes gerenciados (Spring, Java EE), pela injeção `@PersistenceContext`.
    - **Transação Demarcation**: habitualmente, inicia-se uma transação (`em.getTransaction().begin()` ou via contêiner) antes de operar sobre entidades.
    - **Sincronização**: método `flush()` sincroniza o contexto com o banco (gera SQL `INSERT`, `UPDATE`, `DELETE`).
    - **Clear/Close**: `clear()` desfaz associações, tornando entidades **detached**; `close()` fecha o EntityManager, liberando recursos.
4. **Diferença entre EntityManagerFactory e EntityManager**
    - **EntityManagerFactory** – fábrica de EntityManagers; pesado, geralmente criado uma única vez na aplicação.
    - **EntityManager** – leve, usado por unidade de trabalho/transação; idealmente instanciado por requisição ou transação.

---

## 2. Sintaxe Detalhada e Uso Prático

> Observação: nos exemplos abaixo, pressupõe-se a existência de uma entidade simples, @Entity class Produto { @Id Long id; String nome; BigDecimal preco; /* getters/setters */ }.
> 

### 2.1. `persist(Object entity)`

- **Propósito:** inserir uma nova entidade no banco.
- **Comportamento:**
    1. Recebe um objeto em estado **Transient**.
    2. Passa a associá-lo ao contexto de persistência (torna-o **Managed**).
    3. Quando a transação é confirmada, gera `INSERT` para esse registro.

```java
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

try {
    tx.begin();

    Produto p = new Produto();
    p.setNome("Notebook");
    p.setPreco(new BigDecimal("3500.00"));

    em.persist(p);
    // p agora está em estado Managed: p.getId() pode ficar disponível se
    // a geração de ID for automática (GenerationType.IDENTITY ou similar).

    tx.commit();
} catch (Exception e) {
    if (tx.isActive()) tx.rollback();
    throw e;
} finally {
    em.close();
}

```

- **Pontos Importantes:**
    - Se a entidade já possui ID definido e esse ID existir no banco, `persist()` gerará erro de chave primária duplicada.
    - O `persist()` não aciona imediatamente o SQL; o `INSERT` ocorre no `flush()` automático durante o `commit()`.

---

### 2.2. `merge(T entity)`

- **Propósito:** sincronizar ou atualizar uma entidade possivelmente **Detached**; retorna uma instância gerenciada.
- **Comportamento:**
    1. Recebe um objeto em estado **Transient** ou **Detached**.
    2. Copia o estado do objeto para uma instância **Managed** (nova ou existente).
    3. Retorna a referência **Managed**; o objeto passado como parâmetro permanece em estado Detached.
    4. Gera `INSERT` se não existia registro com aquela chave primária; gera `UPDATE` se já existia.

```java
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

Produto detached = new Produto();
detached.setId(10L); // ID que já existe ou não no banco
detached.setNome("Monitor 4K");
detached.setPreco(new BigDecimal("2200.00"));

try {
    tx.begin();

    // Caso exista produto com ID 10: atualiza. Caso contrário: insere um novo.
    Produto managed = em.merge(detached);
    // note: 'detached' continua Detached; 'managed' é a instância no Persistence Context.

    tx.commit();
} catch (Exception e) {
    if (tx.isActive()) tx.rollback();
    throw e;
} finally {
    em.close();
}

```

- **Pontos Importantes:**
    - Nunca assuma que o próprio objeto passado seja gerenciado após `merge()`: use a referência retornada.
    - Útil em cenários de arquitetura *detached*, como quadros web (JSF/Servlet), onde a entidade sai do contexto ao fim da requisição.

---

### 2.3. `remove(Object entity)`

- **Propósito:** remover um objeto gerenciado do banco.
- **Comportamento:**
    1. Recebe uma entidade em estado **Managed** ou *possivelmente* um **Proxy** obtido via `getReference()`.
    2. Transforma-a em estado **Removed** no contexto de persistência.
    3. Quando a transação é confirmada, gera `DELETE` no banco.

```java
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

try {
    tx.begin();

    // 1) Obter a entidade do banco (Managed)
    Produto p = em.find(Produto.class, 5L);
    if (p != null) {
        em.remove(p);
        // agora p está em estado Removed; ao commitar, será gerado DELETE.
    }

    tx.commit();
} catch (Exception e) {
    if (tx.isActive()) tx.rollback();
    throw e;
} finally {
    em.close();
}

```

- **Uso com Proxy (getReference):**
    
    ```java
    tx.begin();
    Produto proxy = em.getReference(Produto.class, 5L);
    em.remove(proxy);
    tx.commit();
    // Se não existia registro 5, ocorre EntityNotFoundException no commit.
    
    ```
    
- **Pontos Importantes:**
    - Se a entidade passada não estiver **Managed**, será levantada `IllegalArgumentException`.
    - Remover objetos dependentes (com relacionamentos `CascadeType.REMOVE`) pode resultar em deleções em cascata, conforme mapeamento.

---

### 2.4. `find(Class<T> entityClass, Object primaryKey)`

- **Propósito:** buscar uma entidade pelo ID imediatamente.
- **Comportamento:**
    1. Verifica no contexto de persistência se já existe instância **Managed** com aquele ID; se sim, retorna-a.
    2. Caso contrário, executa `SELECT ... WHERE id = ?` no banco, carrega os dados e retorna uma entidade **Managed**.
    3. Retorna `null` se não encontrar.

```java
EntityManager em = emf.createEntityManager();

try {
    // NÃO é necessário transação para leituras simples (dependendo do fornecedor e configurações).
    Produto p = em.find(Produto.class, 5L);
    if (p != null) {
        System.out.println("Encontrado: " + p.getNome());
    } else {
        System.out.println("Não encontrado");
    }
} finally {
    em.close();
}

```

- **Pontos Importantes:**
    - Se for chamado dentro de uma transação ativa, a entidade retornada fica **Managed** e participa do flush no commit.
    - Pode lançar `IllegalArgumentException` se `primaryKey` for nulo ou de tipo errado.

---

### 2.5. `getReference(Class<T> entityClass, Object primaryKey)`

- **Propósito:** obter uma referência pŕoxie (“lazy”) para uma entidade.
- **Comportamento:**
    1. Retorna imediatamente um objeto em estado **Proxy** (não carrega dados do banco).
    2. Quando se chama algum getter que acessa dados (ex.: `proxy.getNome()`), o JPA executa `SELECT` para popular a instância antes de retornar valor.
    3. Se a entidade não existir no banco, ao acessar qualquer atributo (que demande a inicialização), gera `EntityNotFoundException`.

```java
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

try {
    tx.begin();

    Produto proxy = em.getReference(Produto.class, 5L);
    // Nenhum SELECT foi executado até agora

    // Somente ao acessar:
    System.out.println("Nome: " + proxy.getNome());
    // Aqui, JPA faz SELECT ... WHERE id = 5 para carregar dados.

    em.remove(proxy);
    // Não é preciso find(): um Proxy bastará para marcar remoção.

    tx.commit();
} catch (EntityNotFoundException enfe) {
    System.err.println("Produto não existe");
    tx.rollback();
} catch (Exception e) {
    if (tx.isActive()) tx.rollback();
    throw e;
} finally {
    em.close();
}

```

- **Pontos Importantes:**
    - Útil quando você quer adiar a *query* até realmente precisar de dados (por exemplo, apenas para remover pelo ID).
    - O proxy pode manter referências não inicializadas se você tentar ler fora do contexto de persistência (LazyInitializationException).

---

## 3. Cenários de Restrição ou Não Aplicação

1. **Operações em Massa (Bulk) sem Gerenciar Contexto**
    - Se você precisa atualizar ou deletar milhares de registros, usar `EntityManager` para cada entidade (em loop) pode ser ineficiente. Preferir *JPQL Bulk Queries* (`UPDATE Produto p SET p.preco = :novoPreco WHERE ...`).
2. **Aplicações Altamente On-Demand (Sem Transações Claras)**
    - Em cenários onde não há suporte transacional (ex.: programação reativa, pipelines não-bloqueantes), JPA e EntityManager podem não se encaixar bem. Ferramentas como R2DBC são mais adequadas.
3. **Sistemas Imutáveis / Somente Leitura**
    - Se todos os acessos forem somente leitura, pode ser mais simples usar consultas JDBC diretas ou frameworks de mapeamento minimalistas (MyBatis, jOOQ) para maior desempenho e controle fino.
4. **Banco de Dados Não-Relacional**
    - JPA foi projetado para bancos relacionais. Em bancos NoSQL (MongoDB, Cassandra), outras APIs (Spring Data Mongo, etc.) são mais apropriadas.
5. **Cenários de Alta Concorrência**
    - Em certas arquiteturas de microserviços, escalar múltiplas instâncias de EntityManagerFactory pode ser pesado. Nestes casos, usar cache de segundo nível (2nd-level cache) ou arquiteturas CQRS/Event Sourcing pode dar melhor resultado.

---

## 4. Componentes Chave Associados

Além dos métodos citados, algumas classes e anotações são fundamentais para trabalhar corretamente com o EntityManager:

1. **Anotações JPA Principais**
    - `@Entity` – marca uma classe como uma entidade JPA.
    - `@Id` – identifica o atributo que corresponde à chave primária. Pode usar `@GeneratedValue` para estratégias de geração automática de IDs.
    - `@Table(name = "...")` – opcional; define o nome da tabela.
    - `@Column(name = "...", nullable = ..., length = ...)` – mapeia colunas específicas, definindo propriedades.
    - `@OneToMany`, `@ManyToOne`, `@OneToOne`, `@ManyToMany` – configuram relacionamentos entre entidades.
    - `@Transactional` (em ambientes com Spring ou Java EE) – gerencia automaticamente a abertura e fechamento de transações, dispensando `em.getTransaction().begin()`.
2. **Interfaces e Classes Principais**
    - `EntityManagerFactory` – fábrica de EntityManagers; instância geralmente criada uma vez (por exemplo, via `Persistence.createEntityManagerFactory("PU")`).
    - `EntityManager` – gerencia o contexto de persistência, manipula entidades e executa operações de CRUD.
    - `EntityTransaction` – quando não há contêiner: usado para “demarcar” (`begin()`, `commit()`, `rollback()`).
    - `PersistenceContext` (Java EE) – injetável em EJBs ou CDI para obter um EntityManager gerenciado pelo contêiner.
    - `PersistenceUnit` – conceito que representa configurações de JPA (nome definido em `persistence.xml`).
    - `Query` – usado para consultas JPQL (`em.createQuery("SELECT p FROM Produto p WHERE p.preco > :v")`).
    - `CriteriaBuilder` e `CriteriaQuery` – API de *typesafe queries*, permitindo montar consultas dinamicamente em Java.
3. **Arquivos de Configuração**
    - **`persistence.xml`** (em `META-INF/`):
        
        ```xml
        <persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.2">
          <persistence-unit name="MinhaPU">
            <class>com.exemplo.modelo.Produto</class>
            <properties>
              <property name="javax.persistence.jdbc.driver" value="org.postgresql.Driver"/>
              <property name="javax.persistence.jdbc.url" value="jdbc:postgresql://localhost:5432/loja"/>
              <property name="javax.persistence.jdbc.user" value="user"/>
              <property name="javax.persistence.jdbc.password" value="senha"/>
              <!-- Dialeto (se usar Hibernate) -->
              <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
              <property name="hibernate.hbm2ddl.auto" value="update"/>
            </properties>
          </persistence-unit>
        </persistence>
        
        ```
        
    - Em **Spring Boot**, não há `persistence.xml`; basta configurar `application.properties` (ou `application.yml`) e usar `@PersistenceContext`.

---

## 5. Melhores Práticas e Padrões de Uso

1. **Gerenciamento de Transações**
    - **Sempre** abra e feche transações corretamente. Em Java SE, use `em.getTransaction().begin()` e `commit()/rollback()`.
    - Em frameworks como Spring, anote métodos de serviço com `@Transactional`, delegando o controle ao contêiner.
    - Evite enterrar lógica de negócio e transações no *layer* de persistência: prefira isolar em um serviço/DAOs.
2. **Escopo do EntityManager**
    - Não compartilhe o mesmo `EntityManager` entre múltiplas threads (não thread-safe). Cada thread/transação deve ter seu próprio.
    - Em aplicações web, configure um EntityManager por requisição ou por transação (Open Session in View é uma opção, mas deve ser usado com cuidado para não vazar sessão).
3. **Gerenciamento do Contexto de Persistência**
    - Monitore o tamanho do contexto: adicionar muitas entidades sem limpar (via `em.clear()` ou limpando referências) pode causar estouro de memória.
    - Para operações em lote (*batch*_), faça `flush()` e `clear()` periodicamente (por exemplo, a cada 50 registros) para evitar crescer demais o *persistence context*.
    - Use `merge()` conscientemente: se precisar atualizar diversas entidades, experimente primeiro recuperar em modo **Managed**, alterar e deixar que o flush ocorra naturalmente. Isso evita criar múltiplas instâncias np contexto.
4. **Evitar LazyInitializationException**
    - Quando usar `getReference()` ou relacionamentos `LAZY`, certifique-se de que o contexto de persistência esteja ativo ao acessar atributos “preguiçosos”.
    - Em camadas de serviço, recupere as entidades necessárias antes de fechar a transação, para não expor proxies sem contexto.
5. **Manipulação de Exceções**
    - Seja específico: trate `EntityNotFoundException`, `OptimisticLockException`, `ConstraintViolationException` etc., quando aplicável.
    - Após um `rollback()`, não reative o mesmo `EntityManager`: feche-o e abra outro.
6. **Naming e Convenções**
    - Prefira nomenclaturas significativas para métodos de serviço (ex.: `salvarProduto`, `atualizarProduto`, `excluirProduto`) e para elementos de mapeamento (`@Column(name = “preco_produto”)`).
    - Mantenha entidades enxutas: evite lógicas de negócio complexas ou dependências desnecessárias (busque *Single Responsibility*).
7. **Uso de Transações Lidas**
    - Se uma operação é estritamente *read-only*, configure a transação ou `Query` para *read-only*, indicando ao provedor que resultados não devem ser “flushados”.
8. **Otimizações de Consulta**
    - Prefira fetches `JOIN FETCH` em JPQL para evitar *N+1 selects*.
    - Use *caching* de segundo nível se necessário (ex.: Hibernate 2nd level cache) para reduzir acessos repetidos.

---

## 6. Exemplo Prático Completo

A seguir, um cenário simplificado de CRUD (Create, Read, Update, Delete) usando JPA puro (sem Spring) com `EntityManager`.

### 6.1. Estrutura do Projeto

```
meu-projeto/
 ├─ src/
 │   └─ main/
 │       ├─ java/
 │       │   └─ com/exemplo/jpa/
 │       │       ├─ entidade/
 │       │       │   └─ Produto.java
 │       │       ├─ util/
 │       │       │   └─ JPAUtil.java
 │       │       └─ App.java
 │       └─ resources/
 │           └─ META-INF/
 │               └─ persistence.xml
 └─ pom.xml

```

### 6.2. `persistence.xml`

```xml
<!-- src/main/resources/META-INF/persistence.xml -->
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.2">
  <persistence-unit name="LojaPU">
    <class>com.exemplo.jpa.entidade.Produto</class>
    <properties>
      <property name="javax.persistence.jdbc.driver" value="org.postgresql.Driver"/>
      <property name="javax.persistence.jdbc.url" value="jdbc:postgresql://localhost:5432/loja"/>
      <property name="javax.persistence.jdbc.user" value="postgres"/>
      <property name="javax.persistence.jdbc.password" value="senha"/>
      <property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/>
      <property name="hibernate.hbm2ddl.auto" value="update"/>
      <property name="hibernate.show_sql" value="true"/>
      <property name="hibernate.format_sql" value="true"/>
    </properties>
  </persistence-unit>
</persistence>

```

### 6.3. Entidade `Produto.java`

```java
// src/main/java/com/exemplo/jpa/entidade/Produto.java
package com.exemplo.jpa.entidade;

import javax.persistence.*;
import java.math.BigDecimal;

@Entity
@Table(name = "produto")
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String nome;

    @Column(precision = 12, scale = 2)
    private BigDecimal preco;

    // Construtor sem-argumentos (obrigatório)
    public Produto() { }

    public Produto(String nome, BigDecimal preco) {
        this.nome = nome;
        this.preco = preco;
    }

    // Getters e Setters
    public Long getId() {
        return id;
    }
    public String getNome() {
        return nome;
    }
    public void setNome(String nome) {
        this.nome = nome;
    }
    public BigDecimal getPreco() {
        return preco;
    }
    public void setPreco(BigDecimal preco) {
        this.preco = preco;
    }

    @Override
    public String toString() {
        return "Produto{" +
               "id=" + id +
               ", nome='" + nome + '\'' +
               ", preco=" + preco +
               '}';
    }
}

```

### 6.4. Utilitário `JPAUtil.java`

```java
// src/main/java/com/exemplo/jpa/util/JPAUtil.java
package com.exemplo.jpa.util;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class JPAUtil {

    private static final EntityManagerFactory emf =
        Persistence.createEntityManagerFactory("LojaPU");

    public static EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public static void fechar() {
        if (emf.isOpen()) {
            emf.close();
        }
    }
}

```

### 6.5. Aplicação Principal `App.java`

```java
// src/main/java/com/exemplo/jpa/App.java
package com.exemplo.jpa;

import com.exemplo.jpa.entidade.Produto;
import com.exemplo.jpa.util.JPAUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;
import java.math.BigDecimal;
import java.util.List;

public class App {
    public static void main(String[] args) {
        // 1. Inserir (persist)
        inserirProduto();

        // 2. Consultar (find)
        Produto p = buscarProdutoPorId(1L);
        System.out.println("Produto encontrado: " + p);

        // 3. Atualizar (merge)
        p.setPreco(new BigDecimal("1800.00"));
        atualizarProduto(p);

        // 4. Consultar todos (JPQL + getResultList())
        listarTodosProdutos();

        // 5. Remover (remove)
        removerProduto(1L);

        // Fechar fábrica de EM ao final
        JPAUtil.fechar();
    }

    private static void inserirProduto() {
        EntityManager em = JPAUtil.getEntityManager();
        EntityTransaction tx = em.getTransaction();

        try {
            tx.begin();

            Produto novo = new Produto("Smartphone", new BigDecimal("1500.00"));
            em.persist(novo);
            System.out.println("ID gerado: " + novo.getId());

            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            e.printStackTrace();
        } finally {
            em.close();
        }
    }

    private static Produto buscarProdutoPorId(Long id) {
        EntityManager em = JPAUtil.getEntityManager();
        try {
            return em.find(Produto.class, id);
        } finally {
            em.close();
        }
    }

    private static void atualizarProduto(Produto detachedProduto) {
        EntityManager em = JPAUtil.getEntityManager();
        EntityTransaction tx = em.getTransaction();

        try {
            tx.begin();

            Produto managed = em.merge(detachedProduto);
            System.out.println("Após merge, preço: " + managed.getPreco());

            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            e.printStackTrace();
        } finally {
            em.close();
        }
    }

    private static void listarTodosProdutos() {
        EntityManager em = JPAUtil.getEntityManager();
        try {
            List<Produto> lista = em
                .createQuery("SELECT p FROM Produto p", Produto.class)
                .getResultList();
            System.out.println("=== Lista de Produtos ===");
            for (Produto p : lista) {
                System.out.println(p);
            }
        } finally {
            em.close();
        }
    }

    private static void removerProduto(Long id) {
        EntityManager em = JPAUtil.getEntityManager();
        EntityTransaction tx = em.getTransaction();

        try {
            tx.begin();

            // Usando getReference para eliminar sem carregar todos dados
            Produto proxy = em.getReference(Produto.class, id);
            em.remove(proxy);
            System.out.println("Produto removido: ID " + id);

            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            e.printStackTrace();
        } finally {
            em.close();
        }
    }
}

```

**Explicação do Exemplo Prático:**

1. **Inserção**: `inserirProduto()` usa `em.persist(novo)`. Após o `commit()`, o framework atribui ID automático ao objeto.
2. **Consulta**: `buscarProdutoPorId(1L)` usa `em.find()`. Se não achar, retorna `null`.
3. **Atualização**: chamamos `merge(detached)` para trazer o objeto ao contexto e fazer `UPDATE`.
4. **Listagem**: `createQuery("SELECT p FROM Produto p", Produto.class)` demonstra uso de JPQL simples.
5. **Remoção**: `getReference()` devolve um *proxy* sem buscar todos os campos; `remove(proxy)` agenda o `DELETE`. Se não existir, ao acessar o proxy (no `remove()`) ou no `commit()`, gera `EntityNotFoundException`.

---

## 7. Sugestões para Aprofundamento

1. **Criteria API** – Aprender a montar consultas tipadas dinamicamente: `CriteriaBuilder`, `CriteriaQuery`, `Root<T>`.
2. **Cache de Segundo Nível** – Configurar provedor (ex.: Ehcache, Infinispan) para reduzir latência em leituras repetidas.
3. **Interceptors e Listeners JPA** – Usar `@PrePersist`, `@PostLoad`, ou `@EntityListeners` para interceptar eventos de ciclo de vida.
4. **Performance e Monitoramento** – Entender *fetch plans*, `@NamedEntityGraph` e monitorar SQL gerado para evitar *N+1 problem*.
5. **Locking (Concorrência)** – Explorar `@Version` (otimista) ou `LockModeType` (pessimista) para controle de concorrência.
6. **Integração com Spring Data JPA** – Facilita geração automática de repositórios e queries, reduzindo boilerplate.

---

> Conclusão:
> 
> 
> O **EntityManager** é a principal porta de entrada para todas as operações de persistência no JPA. Compreender seus métodos principais (`persist`, `merge`, `remove`, `find`, `getReference`) e os conceitos de estado das entidades, contexto de persistência e transações é fundamental para projetar aplicações Java robustas e eficientes. Ademais, seguir as boas práticas apresentadas evita problemas de desempenho, inconsistências de dados e vazamento de recursos.
>