# Herança e Abstração

Olá, Gedê\! Entendido. Como A.R.I.A (Assistente Rápida para Idiotas Atarefados), vou te ajudar com uma explicação detalhada sobre JPA e, especificamente, sobre o conceito de herança em entidades.

### 1\. Introdução

No desenvolvimento de aplicações com Java, especialmente aquelas que interagem com bancos de dados relacionais, o mapeamento objeto-relacional (ORM) é uma prática essencial. A Java Persistence API (JPA) é a especificação padrão do Java para ORM, fornecendo um framework para gerenciar dados relacionais em aplicações Java. Ela simplifica o processo de persistência, permitindo que os desenvolvedores trabalhem com objetos Java de forma natural, enquanto a JPA cuida da tradução desses objetos para registros de banco de dados e vice-versa.

A relevância da JPA reside na sua capacidade de abstrair as complexidades do JDBC (Java Database Connectivity) e das operações SQL diretas. Isso acelera o desenvolvimento, melhora a manutenibilidade do código e permite que os desenvolvedores se concentrem na lógica de negócios em vez dos detalhes de persistência.

O tema principal desta explicação é a **JPA**, com foco nos conceitos de **Entidades (Entities)** e, mais especificamente, como a **herança** é tratada no mapeamento objeto-relacional dentro da JPA. Entidades são classes Java que representam tabelas em um banco de dados, e a capacidade de usar herança nessas entidades permite modelar relacionamentos complexos de forma mais orientada a objetos.

### 2\. Sumário

- **JPA e Entidades**
    - Definição e Importância
- **Herança em Entidades JPA**
    - Visão Geral da Herança Objeto-Relacional
    - @Inheritance
        - Sintaxe e Estratégias
        - SINGLE\_TABLE (Tabela por hierarquia)
        - JOINED (Tabela por subclasse)
        - TABLE\_PER\_CLASS (Tabela por classe concreta)
        - Restrições
    - @DiscriminatorColumn
    - @DiscriminatorValue
    - @MappedSuperclass
    - @PrimaryKeyJoinColumn
- **Exemplos de Código Otimizados**
    - Herança com `SINGLE_TABLE`
    - Herança com `JOINED`
    - Herança com `TABLE_PER_CLASS`
    - `@MappedSuperclass` em ação
- **Informações Adicionais**
    - Escolhendo a Estratégia Correta
    - Desempenho e Considerações
- **Referências para Estudo Independente**

### 3\. Conteúdo Detalhado

### JPA e Entidades

Uma **Entidade JPA** é uma classe Java simples (POJO - Plain Old Java Object) que é mapeada para uma tabela em um banco de dados relacional. Cada instância de uma entidade corresponde a uma linha nessa tabela, e cada propriedade da entidade corresponde a uma coluna. As entidades são a base para o mapeamento objeto-relacional na JPA e são anotadas com `@Entity`.

### Herança em Entidades JPA

A herança é um pilar da programação orientada a objetos, permitindo a reutilização de código e a modelagem de hierarquias de classes. A JPA oferece maneiras de mapear essas hierarquias de classes para estruturas de banco de dados relacionais. Isso permite que você modele um relacionamento "é um tipo de" (is-a-type-of) no seu domínio de objetos e persista isso de forma eficaz.

Existem três estratégias principais de mapeamento de herança definidas pela JPA:

- **`SINGLE_TABLE` (Tabela por hierarquia):** Todas as classes da hierarquia (pai e filhas) são mapeadas para uma única tabela no banco de dados. Uma coluna "discriminadora" é usada para identificar qual tipo de subclasse uma linha específica representa.
- **`JOINED` (Tabela por subclasse):** Cada classe na hierarquia (incluindo a classe pai e cada subclasse) é mapeada para sua própria tabela. As tabelas filhas contêm apenas as colunas específicas de suas subclasses e uma chave estrangeira para a tabela da classe pai.
- **`TABLE_PER_CLASS` (Tabela por classe concreta):** Cada classe concreta (não abstrata) na hierarquia é mapeada para sua própria tabela. A tabela de cada subclasse contém todas as colunas da classe pai e suas próprias colunas, resultando em dados duplicados e sem uma tabela para a classe pai se ela for abstrata.

### `@Inheritance`

A anotação `@Inheritance` é usada na classe pai da hierarquia para especificar a estratégia de mapeamento de herança a ser utilizada.

**Sintaxe:**

```java
@Entity
@Inheritance(strategy = InheritanceType.STRATEGY_NAME)
public abstract class ClassPai {
    // ...
}

```

Onde `STRATEGY_NAME` pode ser:

- `InheritanceType.SINGLE_TABLE`
- `InheritanceType.JOINED`
- `InheritanceType.TABLE_PER_CLASS`

**Restrições:**

- **`SINGLE_TABLE`:** Geralmente é a estratégia mais performática para leitura, pois requer apenas uma única consulta à tabela. No entanto, pode levar a muitas colunas nulas se as subclasses tiverem muitos atributos distintos. Pode gerar uma tabela muito larga.
- **`JOINED`:** Garante a normalização do banco de dados, evitando colunas nulas. No entanto, as operações de leitura e escrita podem ser mais lentas devido à necessidade de realizar `JOINs` entre múltiplas tabelas.
- **`TABLE_PER_CLASS`:** As tabelas são totalmente independentes, o que pode ser bom para algumas operações, mas operações polimórficas (como consultar todos os objetos de uma hierarquia) são ineficientes, pois exigem `UNION` de múltiplas tabelas. Além disso, não é possível ter uma chave primária compartilhada automaticamente entre as tabelas, e a entidade pai deve ser abstrata (ou não ter a anotação `@Entity` diretamente).

### `@DiscriminatorColumn`

Usada em conjunto com `SINGLE_TABLE`, a anotação `@DiscriminatorColumn` especifica a coluna na tabela que será usada para distinguir as subclasses.

**Sintaxe:**

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "tipo_pessoa", discriminatorType = DiscriminatorType.STRING)
public abstract class Pessoa {
    // ...
}

```

- `name`: O nome da coluna discriminadora no banco de dados.
- `discriminatorType`: O tipo de dado da coluna discriminadora (`STRING`, `CHAR`, `INTEGER`).

### `@DiscriminatorValue`

Usada em cada subclasse quando a estratégia `SINGLE_TABLE` está em uso. A anotação `@DiscriminatorValue` especifica o valor que será armazenado na coluna discriminadora para identificar instâncias dessa subclasse.

**Sintaxe:**

```java
@Entity
@DiscriminatorValue("FISICA")
public class PessoaFisica extends Pessoa {
    // ...
}

```

### `@MappedSuperclass`

A anotação `@MappedSuperclass` indica que uma classe cujos atributos persistentes são herdados por subclasses de entidades, mas que ela própria não é uma entidade. Ou seja, a classe `@MappedSuperclass` não será mapeada para uma tabela no banco de dados. Ela é útil para compartilhar atributos comuns e mapeamentos entre várias entidades sem criar uma hierarquia de herança de banco de dados.

**Sintaxe:**

```java
@MappedSuperclass
public class EntidadeBase {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    // ... outros atributos comuns
}

```

**Restrições:**

- Uma classe `@MappedSuperclass` não pode ser uma entidade (`@Entity`).
- Ela não pode ser usada em consultas polimórficas (não pode ser o tipo de retorno de uma consulta).
- Não pode ter associações com entidades ou outras `@MappedSuperclass` se essas associações estiverem mapeadas apenas na superclasse.

### `@PrimaryKeyJoinColumn`

A anotação `@PrimaryKeyJoinColumn` é usada com a estratégia `JOINED` para especificar que a chave primária da tabela da subclasse também é uma chave estrangeira que referencia a chave primária da tabela da superclasse. Se não for especificada, a JPA assume que a chave primária da subclasse tem o mesmo nome da chave primária da superclasse.

**Sintaxe:**

```java
@Entity
@PrimaryKeyJoinColumn(name = "id_aluno", referencedColumnName = "id")
public class Aluno extends Pessoa {
    // ...
}

```

- `name`: O nome da coluna na tabela da subclasse que é a chave estrangeira.
- `referencedColumnName`: O nome da coluna na tabela da superclasse que é referenciada.

### 4\. Exemplos de Código Otimizados

Vamos usar um cenário comum: uma hierarquia de `Pessoa`, com subclasses `PessoaFisica` e `PessoaJuridica`.

### Exemplo 1: Herança com `SINGLE_TABLE` (Tabela por hierarquia)

Esta estratégia mapeia toda a hierarquia de classes para uma única tabela no banco de dados. Uma coluna discriminadora é usada para indicar qual tipo de entidade cada linha representa.

**Entidade Base:**

```java
package com.example.model;

import javax.persistence.*;

@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "tipo_pessoa", discriminatorType = DiscriminatorType.STRING)
@Table(name = "pessoas") // Opcional: Define o nome da tabela
public abstract class Pessoa {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private String email;

    // Construtor padrão
    public Pessoa() {}

    // Construtor com argumentos
    public Pessoa(String nome, String email) {
        this.nome = nome;
        this.email = email;
    }

    // Getters e Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "Pessoa{" +
               "id=" + id +
               ", nome='" + nome + '\\'' +
               ", email='" + email + '\\'' +
               '}';
    }
}

```

**Subclasse Pessoa Física:**

```java
package com.example.model;

import javax.persistence.DiscriminatorValue;
import javax.persistence.Entity;

@Entity
@DiscriminatorValue("FISICA")
public class PessoaFisica extends Pessoa {

    private String cpf;

    public PessoaFisica() {}

    public PessoaFisica(String nome, String email, String cpf) {
        super(nome, email);
        this.cpf = cpf;
    }

    public String getCpf() {
        return cpf;
    }

    public void setCpf(String cpf) {
        this.cpf = cpf;
    }

    @Override
    public String toString() {
        return "PessoaFisica{" +
               "cpf='" + cpf + '\\'' +
               "} " + super.toString();
    }
}

```

**Subclasse Pessoa Jurídica:**

```java
package com.example.model;

import javax.persistence.DiscriminatorValue;
import javax.persistence.Entity;

@Entity
@DiscriminatorValue("JURIDICA")
public class PessoaJuridica extends Pessoa {

    private String cnpj;
    private String nomeFantasia;

    public PessoaJuridica() {}

    public PessoaJuridica(String nome, String email, String cnpj, String nomeFantasia) {
        super(nome, email);
        this.cnpj = cnpj;
        this.nomeFantasia = nomeFantasia;
    }

    public String getCnpj() {
        return cnpj;
    }

    public void setCnpj(String cnpj) {
        this.cnpj = cnpj;
    }

    public String getNomeFantasia() {
        return nomeFantasia;
    }

    public void setNomeFantasia(String nomeFantasia) {
        this.nomeFantasia = nomeFantasia;
    }

    @Override
    public String toString() {
        return "PessoaJuridica{" +
               "cnpj='" + cnpj + '\\'' +
               ", nomeFantasia='" + nomeFantasia + '\\'' +
               "} " + super.toString();
    }
}

```

**Exemplo de Uso (Trecho de Código - Dia a Dia do Desenvolvedor):**

```java
// Supondo um EntityManagerFactory configurado
EntityManagerFactory emf = Persistence.createEntityManagerFactory("minha-unidade-de-persistencia");
EntityManager em = emf.createEntityManager();

em.getTransaction().begin();

// Criando e persistindo uma PessoaFisica
PessoaFisica pf = new PessoaFisica("Gedê", "gedegustavo@example.com", "123.456.789-00");
em.persist(pf);

// Criando e persistindo uma PessoaJuridica
PessoaJuridica pj = new PessoaJuridica("Minha Empresa", "contato@empresa.com", "00.000.000/0001-00", "ME LTDA");
em.persist(pj);

em.getTransaction().commit();

// Consultando todas as Pessoas
List<Pessoa> todasPessoas = em.createQuery("SELECT p FROM Pessoa p", Pessoa.class).getResultList();
System.out.println("Todas as pessoas:");
for (Pessoa p : todasPessoas) {
    System.out.println(p);
}

// Consultando apenas Pessoas Físicas
List<PessoaFisica> pessoasFisicas = em.createQuery("SELECT pf FROM PessoaFisica pf", PessoaFisica.class).getResultList();
System.out.println("\\nPessoas Físicas:");
for (PessoaFisica p : pessoasFisicas) {
    System.out.println(p.getCpf());
}

em.close();
emf.close();

```

**Estrutura da Tabela `pessoas` no Banco de Dados (Exemplo):**

```sql
CREATE TABLE pessoas (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    nome VARCHAR(255),
    email VARCHAR(255),
    tipo_pessoa VARCHAR(255), -- Coluna discriminadora
    cpf VARCHAR(255),         -- NULO para PessoaJuridica
    cnpj VARCHAR(255),        -- NULO para PessoaFisica
    nomeFantasia VARCHAR(255) -- NULO para PessoaFisica
);

```

### Exemplo 2: Herança com `JOINED` (Tabela por subclasse)

Cada classe da hierarquia, incluindo a classe pai e cada subclasse, é mapeada para sua própria tabela.

**Entidade Base:**

```java
package com.example.model;

import javax.persistence.*;

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Table(name = "pessoas")
public abstract class Pessoa {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private String email;

    public Pessoa() {}

    public Pessoa(String nome, String email) {
        this.nome = nome;
        this.email = email;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "Pessoa{" +
               "id=" + id +
               ", nome='" + nome + '\\'' +
               ", email='" + email + '\\'' +
               '}';
    }
}

```

**Subclasse Pessoa Física:**

```java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Table;

@Entity
@Table(name = "pessoas_fisicas")
@PrimaryKeyJoinColumn(name = "pessoa_id", referencedColumnName = "id") // Mapeia a PK da subclasse para a PK da superclasse
public class PessoaFisica extends Pessoa {

    private String cpf;

    public PessoaFisica() {}

    public PessoaFisica(String nome, String email, String cpf) {
        super(nome, email);
        this.cpf = cpf;
    }

    public String getCpf() {
        return cpf;
    }

    public void setCpf(String cpf) {
        this.cpf = cpf;
    }

    @Override
    public String toString() {
        return "PessoaFisica{" +
               "cpf='" + cpf + '\\'' +
               "} " + super.toString();
    }
}

```

**Subclasse Pessoa Jurídica:**

```java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Table;

@Entity
@Table(name = "pessoas_juridicas")
@PrimaryKeyJoinColumn(name = "pessoa_id", referencedColumnName = "id")
public class PessoaJuridica extends Pessoa {

    private String cnpj;
    private String nomeFantasia;

    public PessoaJuridica() {}

    public PessoaJuridica(String nome, String email, String cnpj, String nomeFantasia) {
        super(nome, email);
        this.cnpj = cnpj;
        this.nomeFantasia = nomeFantasia;
    }

    public String getCnpj() {
        return cnpj;
    }

    public void setCnpj(String cnpj) {
        this.cnpj = cnpj;
    }

    public String getNomeFantasia() {
        return nomeFantasia;
    }

    public void setNomeFantasia(String nomeFantasia) {
        this.nomeFantasia = nomeFantasia;
    }

    @Override
    public String toString() {
        return "PessoaJuridica{" +
               "cnpj='" + cnpj + '\\'' +
               ", nomeFantasia='" + nomeFantasia + '\\'' +
               "} " + super.toString();
    }
}

```

**Exemplo de Uso (Trecho de Código):**

```java
// Supondo um EntityManagerFactory configurado
EntityManagerFactory emf = Persistence.createEntityManagerFactory("minha-unidade-de-persistencia");
EntityManager em = emf.createEntityManager();

em.getTransaction().begin();

PessoaFisica pf = new PessoaFisica("Ju", "ju.fisio@example.com", "987.654.321-11");
em.persist(pf);

PessoaJuridica pj = new PessoaJuridica("Loja do Gedê", "vendas@lojagede.com", "11.222.333/0001-44", "Loja Gedê e Ju");
em.persist(pj);

em.getTransaction().commit();

List<Pessoa> todasPessoas = em.createQuery("SELECT p FROM Pessoa p", Pessoa.class).getResultList();
System.out.println("Todas as pessoas (JOINED):");
for (Pessoa p : todasPessoas) {
    System.out.println(p);
}

em.close();
emf.close();

```

**Estrutura das Tabelas no Banco de Dados (Exemplo):**

```sql
CREATE TABLE pessoas (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    nome VARCHAR(255),
    email VARCHAR(255)
);

CREATE TABLE pessoas_fisicas (
    pessoa_id BIGINT PRIMARY KEY,
    cpf VARCHAR(255),
    FOREIGN KEY (pessoa_id) REFERENCES pessoas(id)
);

CREATE TABLE pessoas_juridicas (
    pessoa_id BIGINT PRIMARY KEY,
    cnpj VARCHAR(255),
    nomeFantasia VARCHAR(255),
    FOREIGN KEY (pessoa_id) REFERENCES pessoas(id)
);

```

### Exemplo 3: Herança com `TABLE_PER_CLASS` (Tabela por classe concreta)

Cada classe concreta (não abstrata) na hierarquia é mapeada para sua própria tabela.

**Entidade Base (deve ser abstrata ou não ter `@Entity`):**

```java
package com.example.model;

import javax.persistence.*;

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Pessoa { // Classe base deve ser abstrata para essa estratégia

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO) // Note: GenerationType.IDENTITY não é recomendado para TABLE_PER_CLASS
    private Long id;

    private String nome;
    private String email;

    public Pessoa() {}

    public Pessoa(String nome, String email) {
        this.nome = nome;
        this.email = email;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "Pessoa{" +
               "id=" + id +
               ", nome='" + nome + '\\'' +
               ", email='" + email + '\\'' +
               '}';
    }
}

```

**Subclasse Pessoa Física:**

```java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Table;

@Entity
@Table(name = "pessoas_fisicas_tpc")
public class PessoaFisica extends Pessoa {

    private String cpf;

    public PessoaFisica() {}

    public PessoaFisica(String nome, String email, String cpf) {
        super(nome, email);
        this.cpf = cpf;
    }

    public String getCpf() {
        return cpf;
    }

    public void setCpf(String cpf) {
        this.cpf = cpf;
    }

    @Override
    public String toString() {
        return "PessoaFisica{" +
               "cpf='" + cpf + '\\'' +
               "} " + super.toString();
    }
}

```

**Subclasse Pessoa Jurídica:**

```java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Table;

@Entity
@Table(name = "pessoas_juridicas_tpc")
public class PessoaJuridica extends Pessoa {

    private String cnpj;
    private String nomeFantasia;

    public PessoaJuridica() {}

    public PessoaJuridica(String nome, String email, String cnpj, String nomeFantasia) {
        super(nome, email);
        this.cnpj = cnpj;
        this.nomeFantasia = nomeFantasia;
    }

    public String getCnpj() {
        return cnpj;
    }

    public void setCnpj(String cnpj) {
        this.cnpj = cnpj;
    }

    public String getNomeFantasia() {
        return nomeFantasia;
    }

    public void setNomeFantasia(String nomeFantasia) {
        this.nomeFantasia = nomeFantasia;
    }

    @Override
    public String toString() {
        return "PessoaJuridica{" +
               "cnpj='" + cnpj + '\\'' +
               ", nomeFantasia='" + nomeFantasia + '\\'' +
               "} " + super.toString();
    }
}

```

**Exemplo de Uso (Trecho de Código):**

```java
// Supondo um EntityManagerFactory configurado
EntityManagerFactory emf = Persistence.createEntityManagerFactory("minha-unidade-de-persistencia");
EntityManager em = emf.createEntityManager();

em.getTransaction().begin();

PessoaFisica pf = new PessoaFisica("Fulano", "fulano@example.com", "111.222.333-44");
em.persist(pf);

PessoaJuridica pj = new PessoaJuridica("Outra Empresa", "outra@empresa.com", "55.666.777/0001-88", "Outra ME");
em.persist(pj);

em.getTransaction().commit();

// Consultar todas as Pessoas (requer UNION de tabelas)
List<Pessoa> todasPessoas = em.createQuery("SELECT p FROM Pessoa p", Pessoa.class).getResultList();
System.out.println("Todas as pessoas (TABLE_PER_CLASS):");
for (Pessoa p : todasPessoas) {
    System.out.println(p);
}

em.close();
emf.close();

```

**Estrutura das Tabelas no Banco de Dados (Exemplo):**

```sql
CREATE TABLE pessoas_fisicas_tpc (
    id BIGINT PRIMARY KEY, -- Gerado de forma independente
    nome VARCHAR(255),
    email VARCHAR(255),
    cpf VARCHAR(255)
);

CREATE TABLE pessoas_juridicas_tpc (
    id BIGINT PRIMARY KEY, -- Gerado de forma independente
    nome VARCHAR(255),
    email VARCHAR(255),
    cnpj VARCHAR(255),
    nomeFantasia VARCHAR(255)
);

```

### Exemplo 4: `@MappedSuperclass` em Ação

Vamos criar uma superclasse mapeada para atributos comuns que não representam uma entidade por si só.

**Superclasse Mapeada:**

```java
package com.example.model;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import java.time.LocalDateTime;

@MappedSuperclass
public abstract class EntidadeBase {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDateTime dataCriacao;
    private LocalDateTime ultimaAtualizacao;

    // Construtor
    public EntidadeBase() {
        this.dataCriacao = LocalDateTime.now();
        this.ultimaAtualizacao = LocalDateTime.now();
    }

    // Getters e Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }

    public LocalDateTime getUltimaAtualizacao() {
        return ultimaAtualizacao;
    }

    public void setUltimaAtualizacao(LocalDateTime ultimaAtualizacao) {
        this.ultimaAtualizacao = ultimaAtualizacao;
    }

    @PreUpdate // Método callback para atualizar a data de atualização antes de cada update
    public void preUpdate() {
        this.ultimaAtualizacao = LocalDateTime.now();
    }
}

```

**Entidade Cliente (herdando de `@MappedSuperclass`):**

```java
package com.example.model;

import javax.persistence.Entity;
import javax.persistence.Table;

@Entity
@Table(name = "clientes")
public class Cliente extends EntidadeBase {

    private String nome;
    private String cpf;

    public Cliente() {}

    public Cliente(String nome, String cpf) {
        super(); // Chama o construtor da MappedSuperclass para inicializar datas
        this.nome = nome;
        this.cpf = cpf;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getCpf() {
        return cpf;
    }

    public void setCpf(String cpf) {
        this.cpf = cpf;
    }

    @Override
    public String toString() {
        return "Cliente{" +
               "id=" + getId() +
               ", nome='" + nome + '\\'' +
               ", cpf='" + cpf + '\\'' +
               ", dataCriacao=" + getDataCriacao() +
               ", ultimaAtualizacao=" + getUltimaAtualizacao() +
               '}';
    }
}

```

**Exemplo de Uso (Trecho de Código):**

```java
// Supondo um EntityManagerFactory configurado
EntityManagerFactory emf = Persistence.createEntityManagerFactory("minha-unidade-de-persistencia");
EntityManager em = emf.createEntityManager();

em.getTransaction().begin();

Cliente cliente = new Cliente("Luiz Gustavo", "123.123.123-12");
em.persist(cliente);

em.getTransaction().commit();

// Consultando o cliente
Cliente clienteSalvo = em.find(Cliente.class, cliente.getId());
System.out.println("Cliente salvo: " + clienteSalvo);

// Atualizando o cliente para ver o efeito do @PreUpdate
em.getTransaction().begin();
clienteSalvo.setNome("Luiz Gustavo Damasceno");
em.merge(clienteSalvo);
em.getTransaction().commit();

Cliente clienteAtualizado = em.find(Cliente.class, cliente.getId());
System.out.println("Cliente atualizado: " + clienteAtualizado);

em.close();
emf.close();

```

**Estrutura da Tabela `clientes` no Banco de Dados (Exemplo):**

```sql
CREATE TABLE clientes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    dataCriacao DATETIME,
    ultimaAtualizacao DATETIME,
    nome VARCHAR(255),
    cpf VARCHAR(255)
);

```

### 5\. Informações Adicionais

### Escolhendo a Estratégia Correta

A escolha da estratégia de herança da JPA depende muito do seu modelo de domínio, dos requisitos de desempenho e das características do seu banco de dados:

- **`SINGLE_TABLE`:**
    - **Vantagens:** Mais simples de implementar, melhor desempenho para consultas polimórficas (todos os tipos na hierarquia), evita `JOINs`.
    - **Desvantagens:** Colunas nulas para atributos não presentes em todas as subclasses, tabela única pode ficar muito larga, dificuldade em aplicar restrições de `NOT NULL` em atributos específicos de subclasses.
    - **Melhor uso:** Hierarquias simples e não muito profundas, onde as subclasses não têm muitos atributos distintos ou a maioria dos atributos é comum.
- **`JOINED`:**
    - **Vantagens:** Normalização do banco de dados, evita colunas nulas, facilita a aplicação de restrições de `NOT NULL`.
    - **Desvantagens:** Requer `JOINs` para consultas polimórficas, o que pode impactar o desempenho em grandes volumes de dados.
    - **Melhor uso:** Hierarquias complexas e profundas, onde a normalização é importante e o desempenho de `JOINs` é aceitável. É a estratégia geralmente recomendada por equilibrar bem normalização e desempenho para a maioria dos casos.
- **`TABLE_PER_CLASS`:**
    - **Vantagens:** Cada tabela é independente, consultas a uma única subclasse são eficientes.
    - **Desvantagens:** Consultas polimórficas são muito ineficientes (requerem `UNION ALL`), duplicação de dados, dificuldade na gestão de IDs (requer um gerador de ID global ou UUIDs), não é possível ter uma chave primária compartilhada na tabela base.
    - **Melhor uso:** Raramente recomendado. Talvez em cenários onde a polimorfismo é mínima e as tabelas devem ser totalmente independentes, ou quando migrando de um modelo de banco de dados pré-existente que já adota essa estrutura.
- **`@MappedSuperclass`:**
    - **Vantagens:** Reutilização de código para atributos e mapeamentos comuns sem impactar a estrutura do banco de dados com herança.
    - **Desvantagens:** Não é uma entidade, não pode ser usada em consultas polimórficas, não há uma tabela para a superclasse.
    - **Melhor uso:** Compartilhamento de IDs, datas de criação/atualização, auditoria ou outras propriedades comuns entre entidades não relacionadas por herança de banco de dados.

### Desempenho e Considerações

- **Consultas Polimórficas:** Se você frequentemente precisa consultar todas as instâncias de uma hierarquia (ex: `SELECT p FROM Pessoa p`), `SINGLE_TABLE` e `JOINED` são geralmente mais eficientes que `TABLE_PER_CLASS`.
- **Performance de Inserção/Atualização:** `SINGLE_TABLE` geralmente é a mais rápida, pois envolve apenas uma tabela. `JOINED` envolve inserções/atualizações em múltiplas tabelas, enquanto `TABLE_PER_CLASS` se comporta como inserção em uma única tabela, mas sem a flexibilidade das outras em termos de ID.
- **Manutenção do Esquema:** `SINGLE_TABLE` pode levar a um esquema de banco de dados mais simples, mas a tabela pode ser difícil de gerenciar se o número de subclasses e atributos for grande. `JOINED` e `TABLE_PER_CLASS` tendem a ser mais normalizados.
- **Restrições de Banco de Dados:** Considere como as restrições `NOT NULL` e `UNIQUE` se aplicam a cada estratégia. `SINGLE_TABLE` pode dificultar a imposição de restrições de `NOT NULL` em atributos específicos de subclasses.

### 6\. Referências para Estudo Independente

Para aprofundar seus conhecimentos em JPA e mapeamento de herança, recomendo os seguintes recursos:

- **Documentação Oficial da JPA:**
    - [Jakarta Persistence Specification](https://jakarta.ee/specifications/persistence/3.1/) (Procure a versão mais recente, atualmente 3.1 ou 3.2. A seção 2.1.3 trata de herança).
- **Livros:**
    - **"Pro JPA 2 in Java EE 8"** por Mike Keith, Merrick Schincariol, and Fabio Villani (Um guia abrangente sobre JPA).
    - **"Java Persistence with Hibernate"** por Christian Bauer, Gavin King, and Gary Gregory (Embora focado em Hibernate, é excelente para entender os conceitos de JPA em profundidade, já que Hibernate é a implementação mais popular).
- **Artigos e Tutoriais:**
    - **Baeldung - JPA Inheritance Strategies:** [https://www.baeldung.com/jpa-inheritance](https://www.baeldung.com/jpa-inheritance) (Um recurso excelente e prático para exemplos e explicações).
    - **Stack Overflow:** Sempre uma boa fonte para dúvidas específicas e problemas comuns.

Espero que esta explicação detalhada, Gedê, te ajude a dominar o mapeamento de herança em entidades JPA\! Se tiver mais alguma dúvida, pode me perguntar.