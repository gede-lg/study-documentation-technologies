# Sintaxe de uso

Olá, Gedê\! Como vai? A.R.I.A. está aqui para ajudar com sua solicitação detalhada sobre JPA e Entidades. Entendo sua busca por conhecimento em Java para transição para Go, e dominar o JPA é fundamental para qualquer desenvolvedor Backend Java, como você que já tem 3 anos de experiência. Vamos mergulhar fundo no assunto\!

---

## 1\. Introdução

A Java Persistence API (JPA) é uma especificação da plataforma Java que fornece uma ponte para o mapeamento objeto-relacional (ORM), permitindo que desenvolvedores trabalhem com bancos de dados relacionais usando objetos Java de forma transparente. Em outras palavras, a JPA simplifica o processo de persistir objetos Java em um banco de dados e recuperá-los, abstraindo a complexidade das operações SQL.

No contexto do desenvolvimento backend Java, a JPA é de suma importância porque facilita enormemente a interação com bancos de dados. Em vez de escrever SQL manualmente para cada operação de CRUD (Create, Read, Update, Delete), os desenvolvedores podem manipular objetos Java e deixar que a JPA se encarregue da tradução para o SQL apropriado. Isso acelera o desenvolvimento, reduz a chance de erros relacionados a SQL e torna o código mais limpo e orientado a objetos.

**Definição e Conceitos Fundamentais:**

O tema principal é **JPA**, que é a especificação para persistência de dados em aplicações Java. Ela define como os objetos Java, conhecidos como **Entidades**, são mapeados para tabelas em um banco de dados relacional.

Os subtemas que abordaremos são as **Entidades (Entities)**, que são classes Java comuns (POJOs - Plain Old Java Objects) que representam tabelas no banco de dados. Elas servem como a representação em memória dos dados persistidos. Para que a JPA possa reconhecer e gerenciar essas classes como entidades, é necessário o uso de **Anotações**, que fornecem metadados para o framework JPA sobre como a classe e seus campos devem ser mapeados para o esquema do banco de dados.

---

## 2\. Sumário

1. **Introdução à JPA e Entidades**
2. **Entidades (Entities) em JPA**
    - Sintaxe Básica de uma Entidade
    - Anotações Essenciais para Entidades
        - `@Entity`
        - `@Table`
        \* `name`
        \* `schema`
        \* `catalog`
        \* `uniqueConstraints`
        - `@Id`
        - `@GeneratedValue`
        - `@Column`
        \* `name`
        \* `length`
        \* `nullable`
        \* `unique`
        - `@Transient`
        - `@Temporal`
        - `@Enumerated`
        - `@Embedded` e `@Embeddable`
    - Mapeamento de Relacionamentos (Breve Visão Geral)
3. **Exemplos de Código Otimizados**
    - Exemplo de Entidade `Cliente`
    - Exemplo de Entidade `Produto`
    - Exemplo de Entidade com Relacionamento `Pedido`
4. **Informações Adicionais**
    - Ciclo de Vida das Entidades
    - Diferença entre `javax.persistence` e `jakarta.persistence`
    - Proxies e Lazy Loading
    - Detached vs. Managed Entities
5. **Referências para Estudo Independente**

---

## 3\. Conteúdo Detalhado

### Entidades (Entities) em JPA

As entidades são o cerne do mapeamento objeto-relacional na JPA. Elas são classes Java que representam registros em uma tabela de banco de dados. Cada instância de uma entidade corresponde a uma linha na tabela, e as propriedades (campos) da entidade correspondem às colunas da tabela.

### Sintaxe Básica de uma Entidade

Uma entidade JPA é uma classe Java comum, mas que precisa seguir algumas regras e ser anotada para que o provedor JPA (como Hibernate, EclipseLink, etc.) possa gerenciá-la.

**Regras Essenciais para Entidades:**

- Deve ser anotada com `@Entity`.
- Deve ter um construtor `public` ou `protected` sem argumentos.
- Não pode ser `final` e não pode ter métodos ou campos `final` que sejam persistentes.
- Deve possuir um identificador único (chave primária), anotado com `@Id`.
- Pode estender outras classes e/ou ser uma superclasse.
- Pode implementar interfaces.
- Não precisa implementar `Serializable`, mas é uma boa prática se a entidade for transportada entre JVMs ou armazenada em cache.

### Anotações Essenciais para Entidades

As anotações são a forma como fornecemos metadados para o provedor JPA sobre como a classe e seus campos devem ser mapeados para o banco de dados.

### `@Entity`

- **Função:** Marca uma classe Java como uma entidade JPA. É a anotação mais fundamental para definir uma classe como um tipo persistente.
- **Descrição:** Quando uma classe é anotada com `@Entity`, o provedor JPA entende que essa classe representa uma tabela no banco de dados e que suas instâncias podem ser persistidas, consultadas e removidas.
- **Uso:** É aplicada no nível da classe.

<!-- end list -->

```java
import javax.persistence.Entity;

@Entity // Indica que esta classe é uma entidade JPA
public class Usuario {
    // ... campos e métodos
}

```

### `@Table`

- **Função:** Permite especificar os detalhes da tabela do banco de dados à qual a entidade está mapeada.
- **Descrição:** Embora opcional, é amplamente utilizada para definir explicitamente o nome da tabela, esquema, catálogo e restrições de unicidade. Se `@Table` não for usada, o nome da tabela será o nome da classe da entidade por padrão.
- **Uso:** Aplicada no nível da classe, junto com `@Entity`.

**Propriedades Comuns:**

- `name`: O nome da tabela no banco de dados.
- `schema`: O nome do esquema do banco de dados (ex: `public` no PostgreSQL).
- `catalog`: O nome do catálogo do banco de dados.
- `uniqueConstraints`: Um array de `@UniqueConstraint` para definir restrições de unicidade em uma ou mais colunas.

<!-- end list -->

```java
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "tb_clientes", // Mapeia para a tabela 'tb_clientes'
       schema = "public",    // Mapeia para o esquema 'public' (opcional, dependendo do BD)
       uniqueConstraints = @UniqueConstraint(columnNames = {"email", "cpf"})) // Garante que a combinação de email e cpf seja única
public class Cliente {
    // ... campos e métodos
}

```

### `@Id`

- **Função:** Marca o campo que representa a chave primária da entidade.
- **Descrição:** Toda entidade deve ter uma chave primária para identificação única. Este campo pode ser de qualquer tipo primitivo ou wrapper de tipo primitivo, `String`, ou tipos `java.util.Date`, `java.sql.Date`, `java.math.BigDecimal`, `java.math.BigInteger`.
- **Uso:** Aplicada no nível do campo ou do método getter.

<!-- end list -->

```java
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class Produto {
    @Id // Marca 'id' como a chave primária
    private Long id;
    // ...
}

```

### `@GeneratedValue`

- **Função:** Especifica a estratégia de geração de valores para a chave primária.
- **Descrição:** É usada em conjunto com `@Id` para indicar como o valor da chave primária será gerado automaticamente pelo banco de dados ou pelo provedor JPA.
- **Uso:** Aplicada no nível do campo ou do método getter, junto com `@Id`.

**Estratégias de Geração (`GenerationType`):**

- `AUTO`: A estratégia é selecionada automaticamente pelo provedor JPA, que escolhe a estratégia mais apropriada para o banco de dados subjacente (geralmente `SEQUENCE` ou `IDENTITY`).
- `IDENTITY`: A coluna da chave primária é uma coluna de identidade no banco de dados, e o banco de dados gera o valor automaticamente (ex: `AUTO_INCREMENT` no MySQL, `SERIAL` no PostgreSQL).
- `SEQUENCE`: Utiliza uma sequência de banco de dados para gerar valores (ex: `SEQUENCE` no Oracle, PostgreSQL). Pode ser configurada com `@SequenceGenerator`.
- `TABLE`: Utiliza uma tabela separada no banco de dados para armazenar e gerenciar a próxima chave primária disponível. Pode ser configurada com `@TableGenerator`.

<!-- end list -->

```java
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
public class Usuario {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // O banco de dados gera o ID automaticamente
    private Long id;
    // ...
}

```

### `@Column`

- **Função:** Permite especificar os detalhes da coluna do banco de dados à qual um campo da entidade está mapeado.
- **Descrição:** É opcional. Se não for usada, o nome da coluna será o mesmo nome do campo da entidade por padrão. No entanto, é muito útil para personalizar o mapeamento da coluna, definir restrições e propriedades.
- **Uso:** Aplicada no nível do campo ou do método getter.

**Propriedades Comuns:**

- `name`: O nome da coluna no banco de dados.
- `length`: O comprimento máximo da coluna (para tipos `String`).
- `nullable`: Indica se a coluna pode aceitar valores nulos (`true` por padrão).
- `unique`: Indica se a coluna deve ter valores únicos (`false` por padrão).
- `precision` e `scale`: Para tipos numéricos de ponto flutuante (`BigDecimal`, `Double`, `Float`). `precision` é o número total de dígitos e `scale` é o número de dígitos após o ponto decimal.
- `insertable` e `updatable`: Controlam se a coluna deve ser incluída em operações de `INSERT` e `UPDATE` geradas pela JPA.

<!-- end list -->

```java
import javax.persistence.Column;
import javax.persistence.Entity;

@Entity
public class Funcionario {
    // ... id

    @Column(name = "nome_completo", length = 255, nullable = false) // Mapeia para 'nome_completo', max 255 caracteres, não pode ser nulo
    private String nome;

    @Column(unique = true) // Garante que o email seja único na tabela
    private String email;

    @Column(precision = 10, scale = 2) // Para um valor monetário, ex: 12345678.99
    private BigDecimal salario;
    // ...
}

```

### `@Transient`

- **Função:** Indica que um campo da entidade não deve ser persistido no banco de dados.
- **Descrição:** Campos anotados com `@Transient` serão ignorados pelo provedor JPA durante as operações de persistência e recuperação. São úteis para dados temporários ou calculados que não precisam ser armazenados no banco.
- **Uso:** Aplicada no nível do campo.

<!-- end list -->

```java
import javax.persistence.Entity;
import javax.persistence.Transient;

@Entity
public class RelatorioFinanceiro {
    // ... id

    private BigDecimal valorTotalVendas;

    @Transient // Este campo não será persistido no banco de dados
    private String observacaoTemporaria;

    // ...
}

```

### `@Temporal`

- **Função:** Especifica o tipo de mapeamento para campos de data e hora (`java.util.Date` ou `java.util.Calendar`).
- **Descrição:** Sem `@Temporal`, o tipo padrão para `Date` e `Calendar` é `TIMESTAMP`. Esta anotação permite que você seja mais específico sobre como o valor deve ser armazenado no banco de dados.
- **Uso:** Aplicada no nível do campo ou do método getter.

**Tipos Temporais (`TemporalType`):**

- `DATE`: Mapeia apenas a parte da data (ex: `yyyy-MM-dd`).
- `TIME`: Mapeia apenas a parte da hora (ex: `HH:mm:ss`).
- `TIMESTAMP`: Mapeia data e hora (ex: `yyyy-MM-dd HH:mm:ss.SSS`).

<!-- end list -->

```java
import javax.persistence.Entity;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import java.util.Date;

@Entity
public class Evento {
    // ... id

    @Temporal(TemporalType.DATE) // Apenas a data será persistida
    private Date dataEvento;

    @Temporal(TemporalType.TIME) // Apenas a hora será persistida
    private Date horaInicio;

    @Temporal(TemporalType.TIMESTAMP) // Data e hora completas serão persistidas
    private Date dataHoraCriacao;

    // ...
}

```

Para Java 8 e posterior, é recomendado usar os tipos da API `java.time` (como `LocalDate`, `LocalTime`, `LocalDateTime`, `Instant`). Estes tipos são geralmente mapeados automaticamente sem a necessidade de `@Temporal` pelos provedores JPA modernos (ex: Hibernate 5.x+).

### `@Enumerated`

- **Função:** Define como uma enumeração Java deve ser persistida no banco de dados.
- **Descrição:** Por padrão, enums são persistidos como seu `ordinal` (índice na enumeração). No entanto, é quase sempre melhor persistir como `STRING` para maior legibilidade e resiliência a mudanças na ordem da enumeração.
- **Uso:** Aplicada no nível do campo ou do método getter.

**Tipos de Enumeração (`EnumType`):**

- `ORDINAL`: O valor inteiro da posição da enumeração (0 para o primeiro, 1 para o segundo, etc.).
- `STRING`: O nome da enumeração (ex: "ATIVO", "INATIVO"). **Recomendado.**

<!-- end list -->

```java
import javax.persistence.Entity;
import javax.persistence.Enumerated;
import javax.persistence.EnumType;

@Entity
public class Pedido {
    public enum StatusPedido {
        PENDENTE,
        PROCESSANDO,
        CONCLUIDO,
        CANCELADO
    }

    // ... id

    @Enumerated(EnumType.STRING) // Persiste o nome da enumeração (ex: "PENDENTE")
    private StatusPedido status;

    // ...
}

```

### `@Embedded` e `@Embeddable`

- **Função:** Permitem a composição de classes persistíveis que não são entidades por si só, mas fazem parte de uma entidade.
- **Descrição:**
    - `@Embeddable`: Anota uma classe que será incorporada em outra entidade. Uma classe `Embeddable` não tem sua própria tabela; seus campos são mapeados como colunas na tabela da entidade que a contém.
    - `@Embedded`: Anota um campo dentro de uma entidade para indicar que o campo é uma instância de uma classe `@Embeddable`.
- **Uso:** `@Embeddable` no nível da classe, `@Embedded` no nível do campo.

<!-- end list -->

```java
import javax.persistence.Embeddable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Embedded;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Embeddable // Esta classe pode ser incorporada em outras entidades
public class Endereco {
    @Column(nullable = false, length = 100)
    private String rua;

    @Column(nullable = false, length = 10)
    private String numero;

    @Column(length = 50)
    private String complemento;

    @Column(nullable = false, length = 100)
    private String bairro;

    @Column(nullable = false, length = 100)
    private String cidade;

    @Column(nullable = false, length = 2)
    private String uf;

    @Column(nullable = false, length = 9)
    private String cep;

    // Construtor, getters e setters
    public Endereco() {}
    // ...
}

@Entity
@Table(name = "tb_clientes")
public class Cliente {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 150)
    private String nome;

    @Embedded // Incorpora os campos de Endereco diretamente na tabela tb_clientes
    private Endereco enderecoResidencial;

    // Construtor, getters e setters
    public Cliente() {}
    // ...
}

```

No exemplo acima, a tabela `tb_clientes` terá colunas para `id`, `nome`, `rua`, `numero`, `complemento`, `bairro`, `cidade`, `uf` e `cep`.

### Mapeamento de Relacionamentos (Breve Visão Geral)

Embora o foco seja nas entidades e suas anotações básicas, é crucial mencionar que as entidades em JPA são projetadas para representar relacionamentos entre tabelas. As anotações para mapeamento de relacionamentos incluem:

- `@OneToOne`: Relacionamento um-para-um.
- `@OneToMany`: Relacionamento um-para-muitos.
- `@ManyToOne`: Relacionamento muitos-para-um.
- `@ManyToMany`: Relacionamento muitos-para-muitos.

Cada uma dessas anotações possui propriedades para configurar a cardinalidade, o lado proprietário do relacionamento, estratégias de *fetching* (`LAZY` ou `EAGER`), operações em cascata (`CascadeType`), e colunas de junção (`@JoinColumn`, `@JoinTable`).

---

## 4\. Exemplos de Código Otimizados

Vamos construir alguns exemplos de entidades para ilustrar o uso das anotações em cenários mais realistas.

### Exemplo 1: Entidade `Cliente`

Representa um cliente no sistema, com informações básicas e um endereço embutido.

```java
package com.example.model;

import javax.persistence.*;
import java.io.Serializable;
import java.time.LocalDate; // Usando java.time para datas modernas

/**
 * Entidade Cliente: representa um cliente no sistema.
 * Mapeada para a tabela 'clientes'.
 */
@Entity
@Table(name = "clientes", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"email"}),
    @UniqueConstraint(columnNames = {"cpf"})
})
public class Cliente implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nome;

    @Column(nullable = false, length = 100, unique = true)
    private String email;

    @Column(nullable = false, length = 14, unique = true) // Ex: "123.456.789-00"
    private String cpf;

    @Column(name = "data_nascimento", nullable = false)
    private LocalDate dataNascimento; // JPA 2.1+ mapeia LocalDate automaticamente

    @Embedded // Incorpora os campos de Endereco na tabela 'clientes'
    private Endereco endereco;

    @Column(name = "data_cadastro", nullable = false, updatable = false)
    private LocalDate dataCadastro; // Não pode ser atualizado após a criação

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusCliente status;

    public enum StatusCliente {
        ATIVO,
        INATIVO,
        PENDENTE
    }

    // Construtor padrão (obrigatório para JPA)
    public Cliente() {
        this.dataCadastro = LocalDate.now(); // Define a data de cadastro na criação
    }

    // Construtor com parâmetros para facilitar a criação
    public Cliente(String nome, String email, String cpf, LocalDate dataNascimento, Endereco endereco) {
        this(); // Chama o construtor padrão para inicializar dataCadastro
        this.nome = nome;
        this.email = email;
        this.cpf = cpf;
        this.dataNascimento = dataNascimento;
        this.endereco = endereco;
        this.status = StatusCliente.PENDENTE; // Status inicial
    }

    // Getters e Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getCpf() { return cpf; }
    public void setCpf(String cpf) { this.cpf = cpf; }
    public LocalDate getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(LocalDate dataNascimento) { this.dataNascimento = dataNascimento; }
    public Endereco getEndereco() { return endereco; }
    public void setEndereco(Endereco endereco) { this.endereco = endereco; }
    public LocalDate getDataCadastro() { return dataCadastro; }
    // Nao tem setter para dataCadastro pois é updatable=false
    public StatusCliente getStatus() { return status; }
    public void setStatus(StatusCliente status) { this.status = status; }

    @Override
    public String toString() {
        return "Cliente{" +
               "id=" + id +
               ", nome='" + nome + '\\'' +
               ", email='" + email + '\\'' +
               ", cpf='" + cpf + '\\'' +
               ", dataNascimento=" + dataNascimento +
               ", endereco=" + endereco +
               ", dataCadastro=" + dataCadastro +
               ", status=" + status +
               '}';
    }
}

```

```java
package com.example.model;

import javax.persistence.Column;
import javax.persistence.Embeddable;
import java.io.Serializable;

/**
 * Classe Endereco: um tipo embeddable que será incorporado em outras entidades.
 * Seus campos serão mapeados diretamente nas colunas da tabela da entidade que a contém.
 */
@Embeddable
public class Endereco implements Serializable {

    private static final long serialVersionUID = 1L;

    @Column(nullable = false, length = 100)
    private String rua;

    @Column(nullable = false, length = 10)
    private String numero;

    @Column(length = 50)
    private String complemento;

    @Column(nullable = false, length = 100)
    private String bairro;

    @Column(nullable = false, length = 100)
    private String cidade;

    @Column(nullable = false, length = 2) // Ex: "ES" para Espírito Santo
    private String uf;

    @Column(nullable = false, length = 9) // Ex: "29900-000"
    private String cep;

    // Construtor padrão (obrigatório para JPA)
    public Endereco() {}

    // Construtor com parâmetros para facilitar a criação
    public Endereco(String rua, String numero, String complemento, String bairro, String cidade, String uf, String cep) {
        this.rua = rua;
        this.numero = numero;
        this.complemento = complemento;
        this.bairro = bairro;
        this.cidade = cidade;
        this.uf = uf;
        this.cep = cep;
    }

    // Getters e Setters
    public String getRua() { return rua; }
    public void setRua(String rua) { this.rua = rua; }
    public String getNumero() { return numero; }
    public void setNumero(String numero) { this.numero = numero; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getCidade() { return cidade; }
    public void setCidade(String cidade) { this.cidade = cidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }

    @Override
    public String toString() {
        return "Endereco{" +
               "rua='" + rua + '\\'' +
               ", numero='" + numero + '\\'' +
               ", complemento='" + complemento + '\\'' +
               ", bairro='" + bairro + '\\'' +
               ", cidade='" + cidade + '\\'' +
               ", uf='" + uf + '\\'' +
               ", cep='" + cep + '\\'' +
               '}';
    }
}

```

### Exemplo 2: Entidade `Produto`

Uma entidade simples para representar um produto.

```java
package com.example.model;

import javax.persistence.*;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Entidade Produto: representa um item vendável.
 * Mapeada para a tabela 'produtos'.
 */
@Entity
@Table(name = "produtos")
public class Produto implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 255, unique = true)
    private String nome;

    @Column(length = 500)
    private String descricao;

    @Column(nullable = false, precision = 10, scale = 2) // Ex: 12345678.99
    private BigDecimal preco;

    @Column(nullable = false)
    private Integer estoque;

    @Column(name = "data_ultima_atualizacao", nullable = false)
    private LocalDateTime dataUltimaAtualizacao; // Mapeado automaticamente pelo JPA 2.1+

    @Transient // Este campo não será persistido, é apenas para uso em memória
    private boolean disponivelParaVenda;

    // Construtor padrão
    public Produto() {
        this.dataUltimaAtualizacao = LocalDateTime.now(); // Define a data de atualização na criação
    }

    // Construtor com parâmetros
    public Produto(String nome, String descricao, BigDecimal preco, Integer estoque) {
        this(); // Chama o construtor padrão
        this.nome = nome;
        this.descricao = descricao;
        this.preco = preco;
        this.estoque = estoque;
        this.disponivelParaVenda = (estoque > 0); // Define transient baseado no estoque
    }

    // Getters e Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getDescricao() { return descricao; }
    public void setDescricao(String descricao) { this.descricao = descricao; }
    public BigDecimal getPreco() { return preco; }
    public void setPreco(BigDecimal preco) { this.preco = preco; }
    public Integer getEstoque() { return estoque; }
    public void setEstoque(Integer estoque) {
        this.estoque = estoque;
        this.disponivelParaVenda = (estoque > 0); // Atualiza também o transient
    }
    public LocalDateTime getDataUltimaAtualizacao() { return dataUltimaAtualizacao; }
    public void setDataUltimaAtualizacao(LocalDateTime dataUltimaAtualizacao) { this.dataUltimaAtualizacao = dataUltimaAtualizacao; }
    public boolean isDisponivelParaVenda() { return disponivelParaVenda; }
    // Nao tem setter para disponivelParaVenda pois é calculado

    @Override
    public String toString() {
        return "Produto{" +
               "id=" + id +
               ", nome='" + nome + '\\'' +
               ", preco=" + preco +
               ", estoque=" + estoque +
               '}';
    }
}

```

### Exemplo 3: Entidade `Pedido` (com relacionamento básico `@ManyToOne`)

Este exemplo introduz um relacionamento simples, mostrando como uma entidade `Pedido` pode estar associada a um `Cliente`.

```java
package com.example.model;

import javax.persistence.*;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Entidade Pedido: representa um pedido feito por um cliente.
 * Mapeada para a tabela 'pedidos'.
 * Contém um relacionamento ManyToOne com Cliente.
 */
@Entity
@Table(name = "pedidos")
public class Pedido implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne // Muitos Pedidos para Um Cliente
    @JoinColumn(name = "cliente_id", nullable = false) // Coluna da chave estrangeira na tabela 'pedidos'
    private Cliente cliente; // O cliente que fez o pedido

    @Column(name = "data_pedido", nullable = false)
    private LocalDateTime dataPedido;

    @Column(name = "valor_total", nullable = false, precision = 10, scale = 2)
    private BigDecimal valorTotal;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPedido status;

    public enum StatusPedido {
        ABERTO,
        PAGO,
        ENVIADO,
        ENTREGUE,
        CANCELADO
    }

    // Construtor padrão
    public Pedido() {
        this.dataPedido = LocalDateTime.now();
        this.status = StatusPedido.ABERTO;
    }

    // Construtor com parâmetros
    public Pedido(Cliente cliente, BigDecimal valorTotal) {
        this(); // Chama o construtor padrão
        this.cliente = cliente;
        this.valorTotal = valorTotal;
    }

    // Getters e Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public Cliente getCliente() { return cliente; }
    public void setCliente(Cliente cliente) { this.cliente = cliente; }
    public LocalDateTime getDataPedido() { return dataPedido; }
    public void setDataPedido(LocalDateTime dataPedido) { this.dataPedido = dataPedido; }
    public BigDecimal getValorTotal() { return valorTotal; }
    public void setValorTotal(BigDecimal valorTotal) { this.valorTotal = valorTotal; }
    public StatusPedido getStatus() { return status; }
    public void setStatus(StatusPedido status) { this.status = status; }

    @Override
    public String toString() {
        return "Pedido{" +
               "id=" + id +
               ", clienteId=" + (cliente != null ? cliente.getId() : "null") +
               ", dataPedido=" + dataPedido +
               ", valorTotal=" + valorTotal +
               ", status=" + status +
               '}';
    }
}

```

---

## 5\. Informações Adicionais

### Ciclo de Vida das Entidades

As entidades JPA passam por diferentes estados durante sua vida útil, o que é crucial para entender como o provedor JPA as gerencia:

1. **New/Transient:** Uma instância recém-criada de uma entidade que ainda não foi persistida no banco de dados e não está associada a nenhum `EntityManager`.
2. **Managed/Persistent:** Uma instância de entidade que está associada a um `EntityManager` e representa uma linha no banco de dados. Quaisquer alterações feitas em uma entidade gerenciada são detectadas pelo `EntityManager` e sincronizadas com o banco de dados (geralmente durante um `flush` ou `commit`).
3. **Detached:** Uma instância de entidade que foi persistida no banco de dados, mas não está mais associada a um `EntityManager` ativo. Alterações em uma entidade detached não são sincronizadas automaticamente com o banco de dados. Para persistir as mudanças, a entidade precisa ser reanexada ao `EntityManager` (usando `merge()`).
4. **Removed:** Uma instância de entidade que está associada a um `EntityManager`, mas foi marcada para remoção do banco de dados (usando `remove()`). A remoção ocorre quando as operações pendentes são sincronizadas com o banco de dados.

Compreender esses estados é fundamental para evitar problemas como `LazyInitializationException` ou para garantir que as alterações sejam salvas corretamente.

### Diferença entre `javax.persistence` e `jakarta.persistence`

Historicamente, as especificações Java EE (incluindo JPA) usavam o pacote `javax.*`. Com a transição do Java EE para o Eclipse Foundation e a evolução para Jakarta EE, os pacotes foram renomeados para `jakarta.*`.

- **`javax.persistence`:** Usado em Java EE 8 e versões anteriores.
- **`jakarta.persistence`:** Usado em Jakarta EE 9 e versões posteriores.

Se você está usando Spring Boot 2.x, provavelmente estará usando `javax.persistence` (Hibernate 5.x). Se estiver usando Spring Boot 3.x, já estará no `jakarta.persistence` (Hibernate 6.x). É uma mudança de namespace que não afeta fundamentalmente a lógica da JPA, mas é importante estar ciente para compatibilidade de dependências. Gedê, como você busca Go, essa distinção pode ser mais relevante se for trabalhar com sistemas legados ou migrar para versões mais novas de frameworks Java.

### Proxies e Lazy Loading

A JPA, através de seus provedores (como Hibernate), utiliza proxies para implementar o *lazy loading* (carregamento preguiçoso).

- **Lazy Loading:** Quando um relacionamento (ex: `@OneToMany`, `@ManyToMany` e por padrão `@OneToOne`, `@ManyToOne` em alguns casos) é configurado para *lazy loading*, os dados associados não são carregados do banco de dados imediatamente quando a entidade principal é carregada. Em vez disso, um objeto proxy é colocado no lugar do relacionamento. Os dados reais só são carregados do banco de dados quando o relacionamento é acessado pela primeira vez. Isso otimiza o desempenho, evitando o carregamento de dados desnecessários.
- **Eager Loading:** O carregamento ávido. Os dados associados são carregados imediatamente junto com a entidade principal. Pode ser útil para relacionamentos pequenos e frequentemente acessados, mas pode levar a problemas de desempenho com muitos dados ou relacionamentos aninhados.

**Problemas comuns:** `LazyInitializationException`. Ocorre quando você tenta acessar um relacionamento *lazy loaded* de uma entidade que está em estado `Detached` (fora do contexto de uma sessão JPA). A solução geralmente envolve garantir que o relacionamento seja acessado dentro da sessão do `EntityManager` ou configurar o carregamento como `EAGER` (com cuidado).

### Detached vs. Managed Entities

Reforçando os estados, a distinção entre entidades `Managed` e `Detached` é vital:

- **Managed Entity:** Uma entidade é `managed` (gerenciada) quando ela está associada a uma `PersistenceContext` (representada pelo `EntityManager`). Qualquer alteração feita em uma entidade gerenciada é automaticamente detectada e sincronizada com o banco de dados quando a transação é comitada ou o `EntityManager` é sincronizado (`flush`).
- **Detached Entity:** Uma entidade se torna `detached` (desanexada) quando seu `PersistenceContext` é fechado ou a entidade é explicitamente desanexada (`entityManager.detach(entity)`). Alterações feitas em uma entidade `detached` *não* são salvas automaticamente no banco de dados. Para persistir essas mudanças, a entidade `detached` precisa ser reanexada a um `PersistenceContext` usando `entityManager.merge(entity)`. O método `merge()` retorna uma nova instância `managed` da entidade com as alterações, e a instância original `detached` permanece `detached`.

Entender e gerenciar esses estados é crucial para o controle transacional e para o tratamento correto dos dados em suas aplicações.

---

## 6\. Referências para Estudo Independente

Para aprofundar seu conhecimento em JPA e em persistência em Java, Gedê, A.R.I.A. recomenda os seguintes recursos:

- **Documentação Oficial da Jakarta Persistence (JPA):**
    - [Jakarta Persistence Specification](https://jakarta.ee/specifications/persistence/): A especificação completa é a fonte definitiva para detalhes sobre JPA. Embora densa, é o padrão a ser consultado para dúvidas complexas.
    - [Jakarta Persistence Javadoc](https://jakarta.ee/specifications/persistence/3.1/apidocs/): Javadoc das anotações e interfaces da JPA.
- **Hibernate Documentation (Principal Provedor JPA):**
    - [Hibernate ORM User Guide](https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html): O Hibernate é o provedor JPA mais popular. Sua documentação é extremamente detalhada e prática. Essencial para entender a implementação real da JPA.
- **Livros Recomendados:**
    - **"Pro JPA 2 in Java EE 8"** por Mike Keith, Merrick Schincariol, e Viktor Gamov: Um livro abrangente que cobre a JPA em profundidade, desde os conceitos básicos até os tópicos mais avançados. É uma excelente referência.
    - **"Java Persistence with Hibernate"** por Christian Bauer e Gavin King: Um clássico que aborda não apenas a JPA, mas também os detalhes internos e otimizações do Hibernate. Indispensável para quem usa Hibernate.
- **Tutoriais e Artigos:**
    - **Baeldung JPA Tutorials:** [https://www.baeldung.com/jpa](https://www.baeldung.com/jpa) O Baeldung é um excelente recurso com tutoriais claros e exemplos práticos sobre JPA, Spring Data JPA e Hibernate. Muito útil para aprender conceitos e resolver problemas específicos.
    - **Oracle Documentation (JPA overview):** Embora mais antigos, os tutoriais da Oracle sobre JPA podem fornecer uma boa base inicial.
- **Vídeos e Cursos Online:**
    - Plataformas como Udemy, Alura, Coursera, e YouTube oferecem diversos cursos sobre JPA e Hibernate. Procure por cursos atualizados que abordem Java 11+ e Spring Boot.

Lembre-se que a melhor forma de aprender é praticando. Tente implementar os exemplos e experimentar com diferentes configurações.

---

Espero que esta explicação detalhada sobre JPA e Entidades seja muito útil para você, Gedê, na sua jornada como desenvolvedor Backend\! Se tiver mais dúvidas, A.R.I.A. está sempre pronta para ajudar.