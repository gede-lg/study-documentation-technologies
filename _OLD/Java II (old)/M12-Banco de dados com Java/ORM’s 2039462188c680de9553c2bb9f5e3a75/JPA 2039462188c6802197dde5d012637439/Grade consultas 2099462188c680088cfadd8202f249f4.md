# Grade consultas

## Módulo 2: Sintaxe Básica de JPQL

**Objetivos:**

- Conhecer a estrutura fundamental de uma query JPQL.
- Aprender a mapear seleções básicas de entidades.

**Tópicos:**

1. **Estrutura da Query**
    - Cláusula `SELECT` (selecionar entidades ou campos).
    - Cláusula `FROM` (alias e uso de nomes de entidade).
    - Cláusula `WHERE` (condições em JPQL).
2. **Aliases e Identificadores**
    - Uso de “alias” para objetos de entidade.
    - Regras de nomenclatura (case-sensitive, correspondência exata com nome da entidade).
3. **Tipos de Resultado**
    - Retornar objetos de entidade (ex.: `SELECT c FROM Cliente c`).
    - Projeções parciais (ex.: `SELECT c.nome, c.email FROM Cliente c`).
    - `TypedQuery<T>` vs. `Query`.

**Exercício prático sugerido:**

- Escrever uma consulta que retorne apenas os nomes e datas de cadastro de clientes cadastrados no último mês.

---

## Módulo 3: Filtros e Parâmetros em JPQL

**Objetivos:**

- Saber aplicar condições dinâmicas em consultas JPQL.
- Dominar o uso de parâmetros posicionais e nomeados.

**Tópicos:**

1. **Cláusula `WHERE` Detalhada**
    - Operadores lógicos (`AND`, `OR`, `NOT`).
    - Operadores de comparação (`=`, `<>`, `>`, `<`, `>=`, `<=`).
    - Operadores “`LIKE`” para busca por padrões.
2. **Parâmetros Posicionais (`?1`, `?2`, …)**
    - Como criar e definir valores em `Query.setParameter(index, value)`.
    - Vantagens e limitações.
3. **Parâmetros Nomeados (`:param`)**
    - Convenção de nomes.
    - Uso de `Query.setParameter("nomeParam", valor)`.
4. **Filtros com Datas e Valores Nulos**
    - Comparações de datas (`<`, `>`, `BETWEEN`).
    - Verificar `IS NULL` e `IS NOT NULL`.

**Exercício prático sugerido:**

- Criar uma consulta que receba data de início e fim como parâmetros nomeados para buscar pedidos realizados nesse intervalo.

---

## Módulo 4: Junções (Joins) e Relacionamentos

**Objetivos:**

- Entender como navegar relacionamentos em JPQL.
- Aprender a usar diferentes tipos de `JOIN` (INNER, LEFT, FETCH).

**Tópicos:**

1. **Tipos de Relacionamentos em JPA**
    - `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`.
    - Lazy vs. Eager Fetch.
2. **Junção Implícita (Path Expressions)**
    - Navegar relacionamentos via ponto (`c.pedidos` em vez de JOIN explícito).
    - Limitações e cautelas de performance.
3. **Junção Explícita (`JOIN`, `LEFT JOIN`, `JOIN FETCH`)**
    - Sintaxe de `JOIN`: `SELECT p FROM Pedido p JOIN p.cliente c WHERE c.nome = :nome`.
    - Diferença entre `LEFT JOIN` e `INNER JOIN`.
    - Uso de `JOIN FETCH` para evitar `LazyInitializationException`.
4. **Exemplos de Consultas com Múltiplos Joins**
    - Como unir três ou mais entidades (por ex., `Pedido` → `Cliente` → `Endereço`).

**Exercício prático sugerido:**

- Montar uma consulta que retorne todos os pedidos junto com dados do cliente e do endereço, usando `JOIN FETCH` para cada relacionamento.

---

## Módulo 5: Agrupamento, Ordenação e Funções Agregadas

**Objetivos:**

- Saber agrupar resultados e aplicar funções de agregação em JPQL.
- Aprender a ordenar resultados.

**Tópicos:**

1. **Cláusula `GROUP BY`**
    - Sintaxe: `SELECT c.estado, COUNT(c.id) FROM Cliente c GROUP BY c.estado`.
    - Diferença entre `HAVING` e `WHERE` quando há agregação.
2. **Funções de Agregação**
    - `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()`.
    - Combinar com `GROUP BY` para obter métricas (ex.: valor total de pedidos por cliente).
3. **Cláusula `HAVING`**
    - Filtrar grupos após a agregação (ex.: `HAVING SUM(p.valor) > 10000`).
4. **Cláusula `ORDER BY`**
    - Ordenação ascendente (`ASC`) e descendente (`DESC`).
    - Ordenar por propriedades de entidade ou por valores agregados.
5. **Exemplos de Relatórios Simples**
    - Demonstrar como gerar estatísticas (ex.: melhores clientes, produtos mais vendidos).

**Exercício prático sugerido:**

- Criar uma consulta que retorne a média de valor dos pedidos por mês, ordenada pelo valor médio de forma decrescente.

---

## Módulo 6: Subqueries (Subconsultas) e Consultas Aninhadas

**Objetivos:**

- Aprender a criar subconsultas em JPQL para condições complexas.
- Entender limitações de subqueries correlacionadas.

**Tópicos:**

1. **Subqueries em Cláusula `WHERE`**
    - Sintaxe básica:
        
        ```sql
        sql
        CopiarEditar
        SELECT p
        FROM Pedido p
        WHERE p.valor > (SELECT AVG(p2.valor) FROM Pedido p2)
        
        ```
        
    - Exemplos de comparar registros com a média, máximo ou mínimo.
2. **Subqueries em Cláusula `SELECT`**
    - Retornar valores derivados de outra consulta.
    - Exemplos de buscar dados adicionais (ex.: total de itens em cada pedido).
3. **Subqueries Correlacionadas**
    - Quando usar: depende dos dados da entidade externa.
    - Exemplo:
        
        ```sql
        sql
        CopiarEditar
        SELECT c
        FROM Cliente c
        WHERE c.id IN (
          SELECT p.cliente.id
          FROM Pedido p
          WHERE p.valor > 1000
        )
        
        ```
        
4. **Limitações do JPQL em Subconsultas**
    - Alguns SGBDs podem restringir subqueries correlacionadas.
    - Boas práticas para minimizar problemas de performance.

**Exercício prático sugerido:**

- Montar uma consulta que retorne clientes cujo **pedido mais recente** tenha valor acima de um determinado parâmetro.

---

## Módulo 7: Projeções Avançadas e Consultas de Valores Únicos

**Objetivos:**

- Dominar diferentes tipos de projeção (DTOs, construtores, `Tuple`).
- Aprender a retornar resultados não diretamente vinculados a entidades.

**Tópicos:**

1. **Projeção com Construtor (DTO)**
    - Definir classe DTO (ex.: `ClienteResumoDTO`) com construtor correspondente.
    - Sintaxe:
        
        ```sql
        sql
        CopiarEditar
        SELECT NEW com.minhapacote.dto.ClienteResumoDTO(c.id, c.nome, COUNT(p.id))
        FROM Cliente c JOIN c.pedidos p
        GROUP BY c.id, c.nome
        
        ```
        
2. **Uso de `Tuple` ou Array de Objetos**
    - `SELECT c.nome, c.email FROM Cliente c` retorna `List<Object[]>`.
    - Como mapear resultados para objetos ou variáveis.
3. **Campos Únicos e `DISTINCT`**
    - Eliminar duplicatas: `SELECT DISTINCT c.estado FROM Cliente c`.
    - Impacto de performance.
4. **Consultas de Valores Escalares**
    - Buscar apenas contagens, somas ou valores simples:
        
        ```sql
        sql
        CopiarEditar
        SELECT COUNT(p.id) FROM Pedido p
        
        ```
        

**Exercício prático sugerido:**

- Criar um DTO que contenha nome do produto e quantidade total vendida, preenchido via projeção `NEW` em JPQL.

---

## Módulo 8: Atualizações e Deleções em JPQL

**Objetivos:**

- Aprender a escrever consultas de atualização e exclusão diretamente em JPQL.
- Entender implicações de realizar `UPDATE` e `DELETE` por JPQL em entidades gerenciadas.

**Tópicos:**

1. **Consulta de Atualização (`UPDATE`)**
    - Sintaxe básica:
        
        ```sql
        sql
        CopiarEditar
        UPDATE Produto p SET p.preco = p.preco * 1.1 WHERE p.categoria = :categoria
        
        ```
        
    - Como executar via `EntityManager.createQuery(...).executeUpdate()`.
    - Considerações sobre sincronização do `Persistence Context`.
2. **Consulta de Exclusão (`DELETE`)**
    - Sintaxe:
        
        ```sql
        sql
        CopiarEditar
        DELETE FROM Pedido p WHERE p.data < :dataLimite
        
        ```
        
    - Atenção a relacionamentos (cascades, integridade referencial).
3. **Estados de Entidade e Implicações**
    - Quando a consulta afeta entidades que já estavam carregadas no contexto.
    - Necessidade de limpar (`clear()`) ou sincronizar (`flush()`) o contexto.
4. **Exemplos de Casos de Uso**
    - Marcar vários registros como inativos em lote.
    - Remover registros antigos de logs, etc.

**Exercício prático sugerido:**

- Atualizar o status de todos os clientes que não realizaram pedidos em 12 meses para “inativo” usando JPQL.

---

## Módulo 9: Named Queries e Named Entity Graphs

**Objetivos:**

- Aprender a declarar consultas nomeadas de forma estática em entidades.
- Entender o conceito de Named Entity Graphs para otimizar fetch de associações.

**Tópicos:**

1. **Named Queries**
    - Anotação `@NamedQuery` e `@NamedQueries` em classes de entidade.
    - Exemplo:
        
        ```java
        @NamedQuery(
          name = "Cliente.findByNome",
          query = "SELECT c FROM Cliente c WHERE c.nome LIKE :nome"
        )
        
        ```
        
    - Como invocar:
        
        ```java
        
        em.createNamedQuery("Cliente.findByNome", Cliente.class)
          .setParameter("nome", "%João%")
          .getResultList();
        
        ```
        
2. **Named Native Queries (quando usar SQL nativo)**
    - Diferenças e declarações via `@NamedNativeQuery`.
    - Mapeamento de resultados para entidades.
3. **Named Entity Graphs**
    - Definição de grafos de entidades para controlar fetch de relacionamentos.
    - Exemplo de uso:
        
        ```java
        java
        CopiarEditar
        @NamedEntityGraph(
          name = "Cliente.pedidosGraph",
          attributeNodes = @NamedAttributeNode("pedidos")
        )
        
        ```
        
    - Como aplicar:
        
        ```java
        java
        CopiarEditar
        em.createEntityGraph("Cliente.pedidosGraph");
        
        ```
        
4. **Vantagens e Boas Práticas**
    - Reuso de consultas e padronização.
    - Evitar “query strings” espalhadas pelo código.

**Exercício prático sugerido:**

- Declarar uma NamedQuery para buscar produtos por faixa de preço, e utilizá-la em um método de repositório.

---

## Módulo 10: Otimização de Consultas e Táticas de Performance

**Objetivos:**

- Identificar gargalos de performance em consultas JPQL.
- Aprender técnicas para otimizar e reduzir carga no banco de dados.

**Tópicos:**

1. **Evitar N+1 Selects**
    - Sintoma: várias queries para carregar coleções lazy.
    - Soluções: `JOIN FETCH`, `Entity Graphs`, `batch fetching`.
2. **Paginação de Resultados**
    - Uso de `setFirstResult()` e `setMaxResults()` em `Query`.
    - Princípios de paginação eficiente.
3. **Indexação e Otimização no Banco de Dados**
    - Como índices nos campos usados em `WHERE`, `JOIN` e `ORDER BY` ajudam.
    - Verificar planos de execução (“EXPLAIN”).
4. **Cache de Segundo Nível (Level 2 Cache)**
    - Configuração de cache (ex.: Hibernate Second Level Cache).
    - Diferença entre cache de primeiro e segundo nível.
5. **Monitoramento e Profiling**
    - Ferramentas para analisar queries geradas (ex.: `hibernate.show_sql`).
    - Logging de tempo de execução e contagem de queries.

**Exercício prático sugerido:**

- Implementar paginação em uma consulta de listagem de pedidos, comparando performance com e sem paginação para conjunto de dados volumoso.

---

## Módulo: Criteria JPA

### 1. Introdução ao Criteria API

- Contextualização e motivação
- Diferenças entre JPQL e Criteria
- Vantagens do Criteria (type-safety, refatoração, queries dinâmicas)

### 2. Fundamentos da API de Criteria

- `CriteriaBuilder`
- `CriteriaQuery<T>`
- `Root<T>`
- `Predicate`
- `TypedQuery<T>`

### 3. Metamodel JPA

- Conceito de Metamodel e classes geradas
- Uso de atributos estáticos (ex: `Cliente_.nome`)
- Benefícios para segurança de tipos e refatoração

### 4. Construindo Consultas Básicas

- Criando instância de `CriteriaBuilder`
- Definindo `CriteriaQuery` para seleção de entidades
- Referenciando `Root` e selecionando atributos simples
- Executando a consulta via `EntityManager.createQuery`

### 5. Filtros e Predicados

- Construtores de predicado (`cb.equal`, `cb.like`, `cb.greaterThan`, etc.)
- Combinação de predicados com `cb.and` e `cb.or`
- Uso de `Predicate` em `where`
- Predicados para atributos nulos (`cb.isNull`, `cb.isNotNull`)

### 6. Ordenação e Projeções

- Definindo `orderBy` (ascendente/descendente)
- Selecionando atributos específicos (projeção de colunas)
- Projeções complexas com `cb.construct` e `CriteriaQuery.multiselect`

### 7. Paginação de Resultados

- Uso de `TypedQuery.setFirstResult` e `setMaxResults`
- Boas práticas para paginação em grandes volumes de dados

### 8. Joins em Criteria

- Tipos de join: `join`, `fetch`
- `JoinType.INNER`, `JoinType.LEFT`, `JoinType.RIGHT`
- Navegação em relacionamentos OneToOne, OneToMany, ManyToOne, ManyToMany
- Joins aninhados (join em atributos de relacionamentos múltiplos)

### 9. Subqueries

- Criação de subqueries com `CriteriaQuery.subquery`
- Uso de subqueries em `where` (por exemplo, “buscar pedidos cujo valor seja maior que média”)
- Subqueries correlacionadas

### 10. Agrupamento e Funções de Agrégate

- Uso de `groupBy` e `having`
- Funções agregadas: `cb.count`, `cb.sum`, `cb.avg`, `cb.min`, `cb.max`
- Exemplo de relatórios e contagens

### 11. Consultas Dinâmicas

- Montando filtros condicionalmente (com lista de `Predicate`)
- Construção dinâmica de `CriteriaQuery` a partir de parâmetros de pesquisa
- Uso de `CriteriaQuery.distinct`

### 12. Atualizações e Remoções em Lote

- `CriteriaUpdate<T>` para operações de update sem carregar entidades
- `CriteriaDelete<T>` para operações de delete em lote
- Sintaxe de `set`, `where` e execução com `executeUpdate`

### 13. Integração com Spring Data JPA

- Uso de `JpaSpecificationExecutor` e `Specification<T>`
- Definição de métodos `findAll(Specification<T> spec)`
- Como converter blocos de Criteria em `Specification`

### 14. Tratamento de Consultas Complexas

- Evitando problemas de performance (N+1, consultas excessivas)
- Uso de fetch joins e gráficos de entidade via Criteria
- Combinação de `EntityGraph` e Criteria

### 15. Boas Práticas e Padrões de Uso

- Manter consultas legíveis e reutilizáveis
- Modularização de predicados (métodos auxiliares)
- Testes unitários para query logic com Criteria
- Cuidados com classe `EntityManager` e ciclo de vida de persistência

### 16. Exercícios Práticos e Cenários de Aplicação

- Exemplo 1: Filtro avançado de clientes por múltiplos critérios (nome parcial, data de cadastro, status)
- Exemplo 2: Relatório de vendas mensal com agrupamento e agregação
- Exemplo 3: Atualização em lote de status de pedidos antigos
- Exemplo 4: Paginação e ordenação de resultados em listagem de produtos

### 17. Conclusão e Recomendações

- Recapitulação dos principais conceitos
- Dicas para escolher entre JPQL e Criteria conforme o cenário
- Sugestões de leitura complementar (documentação JPA, guias de provedores)