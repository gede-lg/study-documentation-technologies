# Estado Local no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Estado Local** √© state gerenciado dentro de um componente espec√≠fico usando **useState** ou **useReducer**, sem compartilhamento externo. Representa dados **isolados** e **encapsulados** - contadores, toggle states, form inputs. Complementado por **lifting state up** (elevar state para parent quando m√∫ltiplos components precisam acessar) e **state colocation** (manter state o mais pr√≥ximo poss√≠vel de onde √© usado).

Estado local √© **fundamento** do React - 80% dos cases s√£o resolvidos com useState/useReducer. Global state (Context, Redux) √© exce√ß√£o, n√£o regra. Princ√≠pio: **comece local**, s√≥ generalize quando necess√°rio. Over-engineering state management prematuramente causa complexidade desnecess√°ria.

**Filosofia:** "Start local, lift when needed." State global tem custo (complexidade, performance, manuten√ß√£o). State local √© simples, r√°pido, test√°vel. Lift apenas quando **realmente** necess√°rio.

---

## üìã Sum√°rio Conceitual

1. **useState Revis√£o**: State local b√°sico
2. **useReducer Revis√£o**: State complexo
3. **Lifting State Up**: Compartilhar entre siblings
4. **State Colocation**: Proximity principle
5. **Quando Usar Global State**: Decision framework

---

## üîç An√°lise Conceitual Profunda

### 13.1.1 useState - State Local B√°sico

**Casos cl√°ssicos:**
```javascript
// Toggle
function Toggle() {
  const [isOn, setIsOn] = useState(false);
  return <button onClick={() => setIsOn(!isOn)}>{isOn ? 'ON' : 'OFF'}</button>;
}

// Counter
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

// Form input
function Input() {
  const [value, setValue] = useState('');
  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

**M√∫ltiplos states:**
```javascript
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);

  return (
    <form>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <input value={email} onChange={(e) => setEmail(e.target.value)} />
      <input value={age} onChange={(e) => setAge(Number(e.target.value))} />
    </form>
  );
}
```

**State objeto (consolidated):**
```javascript
function Form() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  return (
    <form>
      <input name="name" value={formData.name} onChange={handleChange} />
      <input name="email" value={formData.email} onChange={handleChange} />
      <input name="age" value={formData.age} onChange={handleChange} />
    </form>
  );
}
```

### 13.1.2 useReducer - State Complexo

**Quando usar useReducer:**
- M√∫ltiplas sub-values relacionados
- Estado com l√≥gica complexa
- Next state depende de previous

**Exemplo: Form com valida√ß√£o:**
```javascript
const initialState = {
  values: { email: '', password: '' },
  errors: {},
  touched: {},
  isSubmitting: false
};

function formReducer(state, action) {
  switch (action.type) {
    case 'CHANGE':
      return {
        ...state,
        values: { ...state.values, [action.field]: action.value }
      };

    case 'TOUCH':
      return {
        ...state,
        touched: { ...state.touched, [action.field]: true }
      };

    case 'SET_ERRORS':
      return { ...state, errors: action.errors };

    case 'SUBMIT_START':
      return { ...state, isSubmitting: true };

    case 'SUBMIT_END':
      return { ...state, isSubmitting: false };

    case 'RESET':
      return initialState;

    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(formReducer, initialState);

  const handleChange = (e) => {
    const { name, value } = e.target;
    dispatch({ type: 'CHANGE', field: name, value });
  };

  const handleBlur = (e) => {
    dispatch({ type: 'TOUCH', field: e.target.name });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    dispatch({ type: 'SUBMIT_START' });

    try {
      await submitForm(state.values);
      dispatch({ type: 'RESET' });
    } catch (error) {
      dispatch({ type: 'SET_ERRORS', errors: { general: error.message } });
    } finally {
      dispatch({ type: 'SUBMIT_END' });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        value={state.values.email}
        onChange={handleChange}
        onBlur={handleBlur}
      />
      {state.touched.email && state.errors.email && (
        <span>{state.errors.email}</span>
      )}

      <button disabled={state.isSubmitting}>Submit</button>
    </form>
  );
}
```

### 13.1.3 Lifting State Up

**Compartilhar state entre siblings:**
```javascript
// ‚ùå Problema: Siblings n√£o compartilham state
function ParentBad() {
  return (
    <div>
      <ComponentA /> {/* Tem pr√≥prio count */}
      <ComponentB /> {/* Tem pr√≥prio count */}
    </div>
  );
}

// ‚úÖ Solu√ß√£o: Lift state to parent
function ParentGood() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <ComponentA count={count} setCount={setCount} />
      <ComponentB count={count} setCount={setCount} />
    </div>
  );
}

function ComponentA({ count, setCount }) {
  return (
    <div>
      <p>A: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

function ComponentB({ count, setCount }) {
  return (
    <div>
      <p>B: {count}</p>
      <button onClick={() => setCount(count - 1)}>-</button>
    </div>
  );
}
```

**Exemplo: Filtro compartilhado:**
```javascript
function App() {
  const [filter, setFilter] = useState('all');

  return (
    <div>
      <FilterButtons filter={filter} setFilter={setFilter} />
      <TodoList filter={filter} />
    </div>
  );
}

function FilterButtons({ filter, setFilter }) {
  return (
    <div>
      <button onClick={() => setFilter('all')}>All</button>
      <button onClick={() => setFilter('active')}>Active</button>
      <button onClick={() => setFilter('completed')}>Completed</button>
    </div>
  );
}

function TodoList({ filter }) {
  const [todos] = useState([...]);
  const filtered = todos.filter(todo => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true;
  });

  return (
    <ul>
      {filtered.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

### 13.1.4 State Colocation

**Princ√≠pio: State deve viver o mais pr√≥ximo poss√≠vel de onde √© usado.**

**‚ùå Ruim: State no top-level sem necessidade:**
```javascript
function App() {
  const [modalOpen, setModalOpen] = useState(false);
  const [accordionOpen, setAccordionOpen] = useState(false);
  const [selectedTab, setSelectedTab] = useState(0);
  // Todos states vivem aqui, mesmo que usados deep down

  return (
    <div>
      <Header />
      <Sidebar />
      <Content
        modalOpen={modalOpen}
        setModalOpen={setModalOpen}
        accordionOpen={accordionOpen}
        setAccordionOpen={setAccordionOpen}
        selectedTab={selectedTab}
        setSelectedTab={setSelectedTab}
      />
    </div>
  );
}
```

**‚úÖ Bom: State colocated:**
```javascript
function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <Content /> {/* Sem props drilling */}
    </div>
  );
}

function Content() {
  return (
    <div>
      <Modal /> {/* modalOpen vive aqui */}
      <Accordion /> {/* accordionOpen vive aqui */}
      <Tabs /> {/* selectedTab vive aqui */}
    </div>
  );
}

function Modal() {
  const [isOpen, setIsOpen] = useState(false);
  // State vive onde √© usado
  return (
    <div>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      {isOpen && <ModalContent onClose={() => setIsOpen(false)} />}
    </div>
  );
}
```

**Benefits:**
- Menos props drilling
- Performance (menos re-renders)
- Easier to maintain
- Testabilidade

### 13.1.5 Quando Usar Global State

**Decision framework:**

**Use LOCAL state quando:**
- State usado em √∫nico component
- State usado por parent + direct children
- State n√£o precisa persistir entre unmount/remount

**Use LIFTED state quando:**
- Siblings precisam compartilhar
- Parent precisa orquestrar children

**Use GLOBAL state quando:**
- Muitos components desconectados precisam acessar
- Deep props drilling (>3 n√≠veis)
- State precisa persistir (theme, auth, user)

**Exemplo: Theme (global makes sense):**
```javascript
// ‚ùå Props drilling nightmare
<App theme={theme}>
  <Header theme={theme}>
    <Nav theme={theme}>
      <NavItem theme={theme} />
    </Nav>
  </Header>
  <Content theme={theme}>
    <Sidebar theme={theme} />
  </Content>
</App>

// ‚úÖ Context/Redux melhor
<ThemeProvider theme={theme}>
  <App>
    <Header>
      <Nav>
        <NavItem /> {/* Acessa theme via useContext */}
      </Nav>
    </Header>
  </App>
</ThemeProvider>
```

**Exemplo: Form state (local is better):**
```javascript
// ‚úÖ Local state suficiente
function ContactForm() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  // N√£o precisa Redux/Context
}

// ‚ùå Over-engineering
// Redux store para form state = overkill
```

---

## üéØ Aplicabilidade e Contextos

### Guidelines

**Start with useState:**
- 90% dos cases
- Simples, direto, r√°pido

**useReducer quando:**
- Estado com m√∫ltiplas sub-values
- L√≥gica complexa de update
- Next state depende de previous

**Lift state quando:**
- Siblings precisam compartilhar
- Parent orquestra children

**Global state quando:**
- Realmente necess√°rio (n√£o prematurely)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Performance

**State no top-level re-renderiza toda √°rvore:**
```javascript
// ‚ùå Problema
function App() {
  const [count, setCount] = useState(0);
  // App re-renderiza, toda √°rvore re-renderiza

  return (
    <div>
      <ExpensiveComponent /> {/* Re-renderiza sem necessidade */}
      <Counter count={count} setCount={setCount} />
    </div>
  );
}

// ‚úÖ Solu√ß√£o: Colocate ou memo
const ExpensiveComponent = React.memo(() => {
  // N√£o re-renderiza se props iguais
});
```

### Props Drilling

**Problema real mas resolver com cautela:**
```javascript
// ‚ö†Ô∏è 2-3 n√≠veis = aceit√°vel
<Parent>
  <Child>
    <GrandChild prop={value} />
  </Child>
</Parent>

// ‚ùå >3 n√≠veis = considerar Context
<A>
  <B>
    <C>
      <D>
        <E prop={value} /> {/* Props drilling hell */}
      </D>
    </C>
  </B>
</A>
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Context

Context para **evitar** props drilling de state local:
```javascript
const CountContext = createContext();

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <CountContext.Provider value={{ count, setCount }}>
      <DeepChild />
    </CountContext.Provider>
  );
}

function DeepChild() {
  const { count } = useContext(CountContext);
  // Sem props drilling
}
```

### Rela√ß√£o com useReducer + Context

Pattern "Redux-like" sem Redux:
```javascript
const StateContext = createContext();
const DispatchContext = createContext();

function StateProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}
```

---

## üöÄ Pr√≥ximos Conceitos

**13.2 Context API para Estado Global** - Compartilhar state sem props drilling

**13.3 Redux** - State management library para apps grandes

---

## üìö Conclus√£o

### Pontos-Chave

1. **useState** para state simples (80% dos cases)
2. **useReducer** para state complexo
3. **Lifting state up** para siblings
4. **State colocation** mant√©m c√≥digo simples
5. **Global state** apenas quando necess√°rio

### Best Practices

1. **Start local, lift when needed**
2. **Colocate state** (proximity principle)
3. **Avoid premature optimization** (Redux/Context)
4. **Props drilling 2-3 n√≠veis √© OK**
5. **Global state tem custo** (complexidade)

### Filosofia

**"The best state management is no state management."**

Maioria dos problems s√£o resolvidos com useState + props. Global state (Context, Redux) √© ferramenta espec√≠fica para problemas espec√≠ficos. Usar prematuramente causa over-engineering.

**Dominar estado local = funda√ß√£o s√≥lida para state management avan√ßado.**
