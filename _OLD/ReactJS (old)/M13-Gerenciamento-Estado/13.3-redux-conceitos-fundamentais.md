# Redux - Conceitos Fundamentais

## ðŸŽ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**Redux** Ã© biblioteca **state management** baseada em arquitetura **Flux** - store Ãºnico, estado imutÃ¡vel, mudanÃ§as via actions + reducers. Core concepts: **Store** (single source of truth), **Actions** (payloads descrevendo "o que aconteceu"), **Reducers** (pure functions `(state, action) => newState`). Dispatch action â†’ reducer processa â†’ store atualiza â†’ components re-renderizam.

Redux resolve **props drilling** e **shared state** via store global. Diferente de Context, Redux tem **DevTools** (time-travel debugging), **middleware** (side effects), **strict patterns** (previsibilidade). Trade-off: **boilerplate** (actions, reducers, types) vs **escalabilidade** (estrutura clara para apps grandes).

**Filosofia:** "Predictable state container." Toda mudanÃ§a Ã© explÃ­cita (action), toda lÃ³gica Ã© pura (reducer), todo state Ã© serializÃ¡vel (JSON). Debug via Redux DevTools = ver todas actions + state changes. Time-travel = voltar/avanÃ§ar no tempo.

### ImportÃ¢ncia no Ecossistema

Redux Ã© **essencial** para:

- **Apps grandes/complexas**: MÃºltiplos devs, features desacopladas
- **Previsibilidade**: Strict patterns, debugging facilitado
- **DevTools**: Time-travel debugging Ãºnico
- **Middleware**: Side effects controlados (thunks, saga)

**Contexto:** Criado por Dan Abramov (2015), 60k+ stars. Inspirado por Flux + Elm. PadrÃ£o de facto (2015-2020), hoje compete com Context, React Query, Zustand. Ainda relevante para apps complexas - **Redux Toolkit** (2019) simplificou boilerplate.

---

## ðŸ“‹ SumÃ¡rio Conceitual

### TÃ³picos Cobertos

1. **Store**: Single source of truth
2. **Actions**: Plain objects descrevendo mudanÃ§as
3. **Reducers**: Pure functions processando actions
4. **Dispatch**: Enviar actions para store
5. **useSelector/useDispatch**: React-Redux hooks
6. **combineReducers**: Modularizar reducers
7. **Middleware**: Side effects (thunks)

---

## ðŸ” AnÃ¡lise Conceitual Profunda

### 13.3.1 TrÃªs PrincÃ­pios do Redux

**1. Single Source of Truth:**
```javascript
// âŒ MÃºltiplos stores (anti-pattern)
const userStore = createStore(userReducer);
const postsStore = createStore(postsReducer);

// âœ… Store Ãºnica com mÃºltiplos reducers
const store = createStore(rootReducer);
// rootReducer combina user + posts
```

**2. State is Read-Only:**
```javascript
// âŒ Mutar state diretamente
state.count = state.count + 1;

// âœ… Dispatch action, reducer retorna novo state
dispatch({ type: 'INCREMENT' });
// Reducer: return { ...state, count: state.count + 1 }
```

**3. Changes Made with Pure Functions:**
```javascript
// âŒ Impure reducer (side effects)
function reducer(state, action) {
  if (action.type === 'FETCH_USER') {
    fetch('/api/user').then(data => state.user = data); // Side effect!
  }
}

// âœ… Pure reducer (no side effects)
function reducer(state = initialState, action) {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    default:
      return state;
  }
}
```

### 13.3.2 Store

**Criar store:**
```javascript
import { createStore } from 'redux';

// Reducer simples
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// Store
const store = createStore(counterReducer);

// API do store
store.getState(); // { count: 0 }
store.dispatch({ type: 'INCREMENT' });
store.getState(); // { count: 1 }
store.subscribe(() => console.log(store.getState()));
```

**Provider (React-Redux):**
```javascript
import { Provider } from 'react-redux';
import { createStore } from 'redux';

function App() {
  return (
    <Provider store={store}>
      <YourApp />
    </Provider>
  );
}
```

### 13.3.3 Actions

**Action = plain object com `type`:**
```javascript
// Action simples
const incrementAction = {
  type: 'INCREMENT'
};

// Action com payload
const addTodoAction = {
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux',
    completed: false
  }
};
```

**Action creators:**
```javascript
// âŒ Inline actions (repetitivo)
dispatch({ type: 'ADD_TODO', payload: { id: 1, text: 'Learn Redux' } });
dispatch({ type: 'ADD_TODO', payload: { id: 2, text: 'Build app' } });

// âœ… Action creator (reutilizÃ¡vel)
function addTodo(text) {
  return {
    type: 'ADD_TODO',
    payload: {
      id: Date.now(),
      text,
      completed: false
    }
  };
}

dispatch(addTodo('Learn Redux'));
dispatch(addTodo('Build app'));
```

**Action types (constants):**
```javascript
// âŒ Strings inline (typo errors)
dispatch({ type: 'ADD_TODOO' }); // Typo! Reducer nÃ£o pega

// âœ… Constants (IDE autocomplete + errors)
const ADD_TODO = 'ADD_TODO';
const TOGGLE_TODO = 'TOGGLE_TODO';

dispatch({ type: ADD_TODO, payload: { text: 'Learn Redux' } });
```

### 13.3.4 Reducers

**Reducer = pure function:**
```javascript
function todosReducer(state = initialState, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };

    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };

    default:
      return state;
  }
}
```

**Initial state:**
```javascript
const initialState = {
  todos: [],
  filter: 'all'
};

function todosReducer(state = initialState, action) {
  // Primeiro call: state = undefined, retorna initialState
  // Calls seguintes: state = current state
}
```

**Regras dos reducers:**

1. **Pure**: Sem side effects, sem mutations
2. **ImutÃ¡vel**: Return new state, nÃ£o mutar
3. **Default case**: Return state inalterado

```javascript
// âŒ Impure reducer
function badReducer(state, action) {
  state.count++; // Mutation!
  fetch('/api'); // Side effect!
  return state;
}

// âœ… Pure reducer
function goodReducer(state, action) {
  return { ...state, count: state.count + 1 }; // Novo objeto
}
```

### 13.3.5 Dispatch

**Dispatch = enviar action:**
```javascript
import { useDispatch } from 'react-redux';

function AddTodoForm() {
  const dispatch = useDispatch();
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();

    // Dispatch action
    dispatch({
      type: 'ADD_TODO',
      payload: {
        id: Date.now(),
        text,
        completed: false
      }
    });

    setText('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Add</button>
    </form>
  );
}
```

**Com action creator:**
```javascript
function AddTodoForm() {
  const dispatch = useDispatch();
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    dispatch(addTodo(text)); // Mais limpo
    setText('');
  };

  return (/* ... */);
}
```

### 13.3.6 useSelector

**Ler state do store:**
```javascript
import { useSelector } from 'react-redux';

function TodoList() {
  // Selector = funÃ§Ã£o que extrai parte do state
  const todos = useSelector((state) => state.todos);

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

**Selector com filtro:**
```javascript
function FilteredTodoList() {
  const filter = useSelector((state) => state.filter);
  const todos = useSelector((state) => {
    if (filter === 'active') {
      return state.todos.filter(todo => !todo.completed);
    }
    if (filter === 'completed') {
      return state.todos.filter(todo => todo.completed);
    }
    return state.todos; // 'all'
  });

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

**MÃºltiplos selectors:**
```javascript
function TodoStats() {
  const todos = useSelector((state) => state.todos);
  const completedCount = useSelector((state) =>
    state.todos.filter(todo => todo.completed).length
  );
  const activeCount = useSelector((state) =>
    state.todos.filter(todo => !todo.completed).length
  );

  return (
    <div>
      <p>Total: {todos.length}</p>
      <p>Completed: {completedCount}</p>
      <p>Active: {activeCount}</p>
    </div>
  );
}
```

### 13.3.7 combineReducers

**Modularizar reducers:**
```javascript
import { combineReducers, createStore } from 'redux';

// Reducer 1: Todos
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    default:
      return state;
  }
}

// Reducer 2: Filter
function filterReducer(state = 'all', action) {
  switch (action.type) {
    case 'SET_FILTER':
      return action.payload;
    default:
      return state;
  }
}

// Combinar
const rootReducer = combineReducers({
  todos: todosReducer,
  filter: filterReducer
});

// State shape: { todos: [...], filter: 'all' }
const store = createStore(rootReducer);
```

**Nested reducers:**
```javascript
// Reducer 3: User
function userReducer(state = null, action) {
  switch (action.type) {
    case 'SET_USER':
      return action.payload;
    case 'LOGOUT':
      return null;
    default:
      return state;
  }
}

// Combinar auth
const authReducer = combineReducers({
  user: userReducer,
  isLoading: loadingReducer
});

// Combinar tudo
const rootReducer = combineReducers({
  todos: todosReducer,
  filter: filterReducer,
  auth: authReducer
});

// State shape: { todos: [...], filter: 'all', auth: { user: null, isLoading: false } }
```

### 13.3.8 Exemplo Completo: Todo App

**1. Actions:**
```javascript
// actions/todos.js
export const ADD_TODO = 'ADD_TODO';
export const TOGGLE_TODO = 'TOGGLE_TODO';
export const DELETE_TODO = 'DELETE_TODO';
export const SET_FILTER = 'SET_FILTER';

export function addTodo(text) {
  return {
    type: ADD_TODO,
    payload: {
      id: Date.now(),
      text,
      completed: false
    }
  };
}

export function toggleTodo(id) {
  return {
    type: TOGGLE_TODO,
    payload: id
  };
}

export function deleteTodo(id) {
  return {
    type: DELETE_TODO,
    payload: id
  };
}

export function setFilter(filter) {
  return {
    type: SET_FILTER,
    payload: filter
  };
}
```

**2. Reducers:**
```javascript
// reducers/todos.js
import { ADD_TODO, TOGGLE_TODO, DELETE_TODO } from '../actions/todos';

const initialState = [];

export function todosReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];

    case TOGGLE_TODO:
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );

    case DELETE_TODO:
      return state.filter(todo => todo.id !== action.payload);

    default:
      return state;
  }
}

// reducers/filter.js
import { SET_FILTER } from '../actions/todos';

export function filterReducer(state = 'all', action) {
  switch (action.type) {
    case SET_FILTER:
      return action.payload;
    default:
      return state;
  }
}

// reducers/index.js
import { combineReducers } from 'redux';
import { todosReducer } from './todos';
import { filterReducer } from './filter';

export const rootReducer = combineReducers({
  todos: todosReducer,
  filter: filterReducer
});
```

**3. Store:**
```javascript
// store.js
import { createStore } from 'redux';
import { rootReducer } from './reducers';

export const store = createStore(
  rootReducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);
```

**4. Components:**
```javascript
// App.js
import { Provider } from 'react-redux';
import { store } from './store';
import AddTodoForm from './components/AddTodoForm';
import TodoList from './components/TodoList';
import FilterButtons from './components/FilterButtons';

function App() {
  return (
    <Provider store={store}>
      <div>
        <h1>Todo App</h1>
        <AddTodoForm />
        <FilterButtons />
        <TodoList />
      </div>
    </Provider>
  );
}

// components/AddTodoForm.js
import { useState } from 'react';
import { useDispatch } from 'react-redux';
import { addTodo } from '../actions/todos';

function AddTodoForm() {
  const dispatch = useDispatch();
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      dispatch(addTodo(text));
      setText('');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add todo..."
      />
      <button type="submit">Add</button>
    </form>
  );
}

// components/TodoList.js
import { useSelector, useDispatch } from 'react-redux';
import { toggleTodo, deleteTodo } from '../actions/todos';

function TodoList() {
  const dispatch = useDispatch();
  const filter = useSelector((state) => state.filter);
  const todos = useSelector((state) => {
    if (filter === 'active') {
      return state.todos.filter(todo => !todo.completed);
    }
    if (filter === 'completed') {
      return state.todos.filter(todo => todo.completed);
    }
    return state.todos;
  });

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => dispatch(toggleTodo(todo.id))}
          />
          <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
            {todo.text}
          </span>
          <button onClick={() => dispatch(deleteTodo(todo.id))}>Delete</button>
        </li>
      ))}
    </ul>
  );
}

// components/FilterButtons.js
import { useSelector, useDispatch } from 'react-redux';
import { setFilter } from '../actions/todos';

function FilterButtons() {
  const dispatch = useDispatch();
  const currentFilter = useSelector((state) => state.filter);

  return (
    <div>
      <button
        onClick={() => dispatch(setFilter('all'))}
        disabled={currentFilter === 'all'}
      >
        All
      </button>
      <button
        onClick={() => dispatch(setFilter('active'))}
        disabled={currentFilter === 'active'}
      >
        Active
      </button>
      <button
        onClick={() => dispatch(setFilter('completed'))}
        disabled={currentFilter === 'completed'}
      >
        Completed
      </button>
    </div>
  );
}
```

### 13.3.9 Middleware

**Middleware = interceptor entre dispatch e reducer:**
```javascript
// Middleware logger
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Dispatching:', action);
  console.log('State before:', store.getState());

  const result = next(action); // Passa action para prÃ³ximo middleware/reducer

  console.log('State after:', store.getState());
  return result;
};

// Aplicar middleware
import { createStore, applyMiddleware } from 'redux';

const store = createStore(
  rootReducer,
  applyMiddleware(loggerMiddleware)
);
```

**Redux Thunk (async actions):**
```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(rootReducer, applyMiddleware(thunk));

// Action creator que retorna funÃ§Ã£o (thunk)
export function fetchTodos() {
  return async (dispatch) => {
    dispatch({ type: 'FETCH_TODOS_START' });

    try {
      const response = await fetch('/api/todos');
      const data = await response.json();
      dispatch({ type: 'FETCH_TODOS_SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'FETCH_TODOS_ERROR', payload: error.message });
    }
  };
}

// Uso
function TodoList() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchTodos()); // Dispatch thunk
  }, [dispatch]);

  // ...
}
```

**Thunk reducer:**
```javascript
function todosReducer(state = { data: [], loading: false, error: null }, action) {
  switch (action.type) {
    case 'FETCH_TODOS_START':
      return { ...state, loading: true, error: null };

    case 'FETCH_TODOS_SUCCESS':
      return { ...state, loading: false, data: action.payload };

    case 'FETCH_TODOS_ERROR':
      return { ...state, loading: false, error: action.payload };

    default:
      return state;
  }
}
```

### 13.3.10 Redux DevTools

**Setup:**
```javascript
import { createStore } from 'redux';

const store = createStore(
  rootReducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);
```

**Features:**
- **Action log**: Todas actions dispatched
- **State diff**: Before/after de cada action
- **Time-travel**: Voltar/avanÃ§ar actions
- **Dispatch**: Dispatch actions manualmente
- **State inspector**: Ver state completo

---

## ðŸŽ¯ Aplicabilidade e Contextos

### Quando Usar Redux

**âœ… Use Redux quando:**
- App grande/complexa (>10 features)
- State compartilhado por muitos components
- LÃ³gica de update complexa
- Precisa DevTools/time-travel
- MÃºltiplos devs (estrutura clara)

**âŒ NÃ£o use Redux quando:**
- App pequena/simples
- Context + useReducer suficiente
- State local resolve (maioria dos cases)
- Boilerplate nÃ£o compensa

### Redux vs Context

**Context:**
- Simples, built-in
- Bom para low-frequency updates
- Sem DevTools

**Redux:**
- Boilerplate, external lib
- DevTools, middleware
- Melhor performance (selectors)

---

## âš ï¸ LimitaÃ§Ãµes e ConsideraÃ§Ãµes

### Boilerplate

**Redux clÃ¡ssico = muito cÃ³digo:**
```javascript
// Action types
const ADD_TODO = 'ADD_TODO';

// Action creators
function addTodo(text) {
  return { type: ADD_TODO, payload: { text } };
}

// Reducer
function todosReducer(state, action) {
  switch (action.type) {
    case ADD_TODO:
      return [...state, action.payload];
    default:
      return state;
  }
}

// Component
dispatch(addTodo('Learn Redux'));
```

**SoluÃ§Ã£o: Redux Toolkit** (prÃ³ximo tÃ³pico) reduz 70% do boilerplate.

### Learning Curve

**Conceitos a aprender:**
- Store, actions, reducers, dispatch
- Immutability patterns
- combineReducers
- Middleware (thunks)
- DevTools

**Redux nÃ£o Ã© simples** - over-engineering para apps pequenas.

### Performance

**Selectors causam re-renders:**
```javascript
// âŒ Selector cria novo array toda vez
const todos = useSelector((state) =>
  state.todos.filter(todo => !todo.completed)
);
// Component re-renderiza mesmo se filtered array igual

// âœ… SoluÃ§Ã£o: Reselect (memoized selectors)
import { createSelector } from 'reselect';

const selectActiveTodos = createSelector(
  (state) => state.todos,
  (todos) => todos.filter(todo => !todo.completed)
);

const todos = useSelector(selectActiveTodos);
```

---

## ðŸ”— InterconexÃµes Conceituais

### RelaÃ§Ã£o com Flux

Redux inspirado em **Flux** (Facebook):
- Flux: MÃºltiplos stores
- Redux: Store Ãºnica

### RelaÃ§Ã£o com Elm

Redux inspirado em **Elm Architecture**:
- Model (state)
- Update (reducer)
- View (React components)

### RelaÃ§Ã£o com useReducer

Redux = useReducer global:
```javascript
// Local
const [state, dispatch] = useReducer(reducer, initialState);

// Global (Redux)
const state = useSelector((state) => state);
const dispatch = useDispatch();
```

---

## ðŸš€ PrÃ³ximos Conceitos

**13.4 Redux Toolkit (RTK)** - Modern Redux API sem boilerplate

**13.5 Alternativas Modernas** - Zustand, Jotai

---

## ðŸ“š ConclusÃ£o

### Pontos-Chave

1. **Redux = store Ãºnica + actions + reducers**
2. **Dispatch action â†’ reducer â†’ new state**
3. **Reducers = pure functions**
4. **useSelector/useDispatch** para React
5. **combineReducers** para modularizar
6. **Middleware (thunks)** para async
7. **DevTools** para debugging

### Best Practices

1. **Action types = constants**
2. **Action creators** para reutilizaÃ§Ã£o
3. **Reducers = pure + immutable**
4. **combineReducers** por feature
5. **Selectors** para computed values
6. **Middleware** para side effects

### Quando Usar

**Redux Ã© ideal para:**
- Apps grandes/complexas
- State compartilhado extenso
- DevTools necessÃ¡rio
- Estrutura clara

**NÃ£o use para:**
- Apps pequenas (Context suficiente)
- State local (useState)
- Over-engineering

**Dominar Redux = base sÃ³lida para state management em scale.**

---

## ðŸ“– Recursos Adicionais

**DocumentaÃ§Ã£o:**
- Redux Docs: https://redux.js.org/
- Redux DevTools: https://github.com/reduxjs/redux-devtools

**PrÃ³ximo: Redux Toolkit** - API moderna sem boilerplate.
