# Context API para Estado Global

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Context API** √© solu√ß√£o nativa do React para **compartilhar state globalmente** sem props drilling. Permite que componentes profundamente aninhados acessem dados sem passar props por cada n√≠vel. Criado via `createContext()`, consumido via `useContext()`, fornecido via `<Provider>`. Ideal para dados **globais de baixa frequ√™ncia de mudan√ßa** (theme, auth, locale).

Context elimina props drilling mas tem **custo**: todo consumer re-renderiza quando context muda. Para dados que mudam frequentemente, Context pode causar performance issues. Pattern comum: **useReducer + Context** para criar "mini-Redux" sem biblioteca externa.

**Filosofia:** "Props drilling is symptom, Context is cure." Mas use com modera√ß√£o - Context n√£o √© state management completo, √© **prop tunnel**.

---

## üìã Sum√°rio Conceitual

1. **createContext & Provider**: Criar e fornecer context
2. **useContext**: Consumir context
3. **useReducer + Context**: Pattern Redux-like
4. **Performance**: Splitting contexts, memoization
5. **Quando Usar**: Context vs Props vs Redux

---

## üîç An√°lise Conceitual Profunda

### 13.2.1 Context B√°sico

**Criar e usar:**
```javascript
import { createContext, useContext, useState } from 'react';

// 1. Criar Context
const ThemeContext = createContext();

// 2. Provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Custom hook (optional, mas recomendado)
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 4. Consumer component
function Button() {
  const { theme, setTheme } = useTheme();

  return (
    <button
      style={{ background: theme === 'light' ? '#fff' : '#000' }}
      onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
    >
      Toggle Theme
    </button>
  );
}

// 5. App
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main>
        <Button /> {/* Acessa theme sem props */}
      </Main>
    </ThemeProvider>
  );
}
```

**Default value:**
```javascript
const ThemeContext = createContext('light'); // Default value

// Se usar sem Provider, retorna 'light'
function Component() {
  const theme = useContext(ThemeContext);
  return <div>{theme}</div>; // 'light'
}
```

### 13.2.2 Auth Context (Exemplo Completo)

```javascript
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check auth ao montar
    const token = localStorage.getItem('token');
    if (token) {
      fetchUser(token).then(setUser).finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);

  const login = async (email, password) => {
    const { user, token } = await loginAPI(email, password);
    localStorage.setItem('token', token);
    setUser(user);
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  const value = { user, login, logout, loading };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Uso
function Profile() {
  const { user, logout } = useAuth();

  if (!user) return <div>Not logged in</div>;

  return (
    <div>
      <p>Welcome, {user.name}</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

### 13.2.3 useReducer + Context Pattern

**"Mini-Redux" sem biblioteca:**
```javascript
import { createContext, useContext, useReducer } from 'react';

// State e actions
const initialState = {
  todos: [],
  filter: 'all'
};

function todosReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };

    case 'SET_FILTER':
      return { ...state, filter: action.payload };

    default:
      return state;
  }
}

// Contexts
const TodosStateContext = createContext();
const TodosDispatchContext = createContext();

// Provider
function TodosProvider({ children }) {
  const [state, dispatch] = useReducer(todosReducer, initialState);

  return (
    <TodosStateContext.Provider value={state}>
      <TodosDispatchContext.Provider value={dispatch}>
        {children}
      </TodosDispatchContext.Provider>
    </TodosStateContext.Provider>
  );
}

// Custom hooks
function useTodosState() {
  const context = useContext(TodosStateContext);
  if (!context) {
    throw new Error('useTodosState must be used within TodosProvider');
  }
  return context;
}

function useTodosDispatch() {
  const context = useContext(TodosDispatchContext);
  if (!context) {
    throw new Error('useTodosDispatch must be used within TodosProvider');
  }
  return context;
}

// Components
function TodoList() {
  const { todos, filter } = useTodosState();
  const dispatch = useTodosDispatch();

  const filtered = todos.filter(todo => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true;
  });

  return (
    <ul>
      {filtered.map(todo => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
          />
          {todo.text}
        </li>
      ))}
    </ul>
  );
}

function AddTodo() {
  const dispatch = useTodosDispatch();
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    dispatch({
      type: 'ADD_TODO',
      payload: { id: Date.now(), text, completed: false }
    });
    setText('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Add</button>
    </form>
  );
}
```

**Vantagens desse pattern:**
- State e dispatch separados (menos re-renders)
- Reducer = l√≥gica centralizada e test√°vel
- Dispatch nunca muda (est√°vel)

### 13.2.4 Performance - Context Splitting

**‚ùå Problema: Tudo em um Context:**
```javascript
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [notifications, setNotifications] = useState([]);

  const value = { user, setUser, theme, setTheme, notifications, setNotifications };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// Problema: Component que usa apenas theme re-renderiza quando user muda!
function Button() {
  const { theme } = useContext(AppContext);
  // Re-renderiza quando user/notifications mudam
  return <button>{theme}</button>;
}
```

**‚úÖ Solu√ß√£o: Split Contexts:**
```javascript
const UserContext = createContext();
const ThemeContext = createContext();
const NotificationsContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [notifications, setNotifications] = useState([]);

  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <NotificationsContext.Provider value={{ notifications, setNotifications }}>
          {children}
        </NotificationsContext.Provider>
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// Agora: Component que usa theme N√ÉO re-renderiza quando user muda
function Button() {
  const { theme } = useContext(ThemeContext);
  return <button>{theme}</button>;
}
```

### 13.2.5 Memoization com Context

**useMemo no Provider value:**
```javascript
function TodosProvider({ children }) {
  const [todos, setTodos] = useState([]);

  // ‚ùå Sem useMemo: value √© novo objeto toda render
  // const value = { todos, setTodos };

  // ‚úÖ Com useMemo: value s√≥ muda quando todos muda
  const value = useMemo(() => ({ todos, setTodos }), [todos]);

  return <TodosContext.Provider value={value}>{children}</TodosContext.Provider>;
}
```

**React.memo em consumers:**
```javascript
const ExpensiveComponent = React.memo(({ data }) => {
  console.log('Expensive render');
  return <div>{/* ... */}</div>;
});

function Parent() {
  const { theme } = useTheme();

  return (
    <div>
      <p>Theme: {theme}</p>
      <ExpensiveComponent data="static" />
      {/* N√£o re-renderiza se props iguais */}
    </div>
  );
}
```

### 13.2.6 M√∫ltiplos Contexts Compostos

```javascript
function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <NotificationsProvider>
          <Router>
            <Layout>
              <Routes />
            </Layout>
          </Router>
        </NotificationsProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

// Ou compor em AppProviders
function AppProviders({ children }) {
  return (
    <AuthProvider>
      <ThemeProvider>
        <NotificationsProvider>
          {children}
        </NotificationsProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

function App() {
  return (
    <AppProviders>
      <Router>
        <Layout>
          <Routes />
        </Layout>
      </Router>
    </AppProviders>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Context

**‚úÖ Use Context para:**
- Theme (light/dark)
- Auth (user, login/logout)
- Locale (i18n)
- Config global (API base URL, feature flags)
- Modal/Toast management

**‚ùå N√£o use Context para:**
- State que muda frequentemente (form inputs, scroll position)
- Cache de API (use React Query/SWR)
- Estado que poucos components precisam (use props)

### Context vs Props vs Redux

**Props:**
- 1-2 n√≠veis de profundidade
- Dados espec√≠ficos de se√ß√£o

**Context:**
- Props drilling (>3 n√≠veis)
- Dados globais de baixa frequ√™ncia

**Redux:**
- Estado global complexo
- Muitas actions/reducers
- DevTools, middleware necess√°rios

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Performance

**Context causa re-render de TODOS consumers:**
```javascript
// Se value muda, TODOS components com useContext re-renderizam
<MyContext.Provider value={value}>
  <A /> {/* Re-renderiza */}
  <B /> {/* Re-renderiza */}
  <C /> {/* Re-renderiza */}
</MyContext.Provider>
```

**Solu√ß√µes:**
1. Split contexts (theme, auth, etc separados)
2. useMemo no value
3. React.memo em consumers
4. Evitar Context para high-frequency updates

### Testing

**Context precisa Provider em tests:**
```javascript
import { render } from '@testing-library/react';

// ‚ùå Sem Provider = erro
render(<ComponentThatUsesContext />);

// ‚úÖ Com Provider
render(
  <MyProvider>
    <ComponentThatUsesContext />
  </MyProvider>
);
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useReducer

useReducer + Context = pattern "Redux-like":
```javascript
const [state, dispatch] = useReducer(reducer, initialState);

<StateContext.Provider value={state}>
  <DispatchContext.Provider value={dispatch}>
    {children}
  </DispatchContext.Provider>
</StateContext.Provider>
```

### Rela√ß√£o com Redux

Context pode **substituir** Redux para apps simples:
- Sem middleware = Context suficiente
- Com middleware (thunks, saga) = Redux melhor

---

## üöÄ Pr√≥ximos Conceitos

**13.3 Redux** - State management library para apps complexos

**13.4 Redux Toolkit** - Modern Redux API

---

## üìö Conclus√£o

### Pontos-Chave

1. **Context elimina props drilling**
2. **useReducer + Context = "mini-Redux"**
3. **Split contexts** para performance
4. **useMemo** no Provider value
5. **Use com modera√ß√£o** (n√£o √© panacea)

### Best Practices

1. **Custom hook** para cada Context (useTheme, useAuth)
2. **Error check** no custom hook (throw se fora Provider)
3. **Split contexts** por concern (theme, auth, etc)
4. **Memoize value** no Provider
5. **Avoid high-frequency updates** em Context

### Quando Usar

**Context √© ideal para:**
- Theme, auth, locale (globals de baixa frequ√™ncia)
- Eliminar props drilling (>3 n√≠veis)
- Apps pequenos/m√©dios sem Redux

**N√£o use para:**
- Form inputs (local state)
- Cache de API (React Query)
- High-frequency updates (performance)

**Dominar Context = base s√≥lida para state management.**
