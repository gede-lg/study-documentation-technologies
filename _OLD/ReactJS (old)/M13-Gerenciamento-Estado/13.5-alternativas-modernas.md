# Alternativas Modernas de State Management

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Alternativas modernas** s√£o libraries **lightweight** de state management que surgiram (2019+) como resposta ao **boilerplate** do Redux - principalmente **Zustand** (~1kb, API minimalista) e **Jotai** (~2kb, atomic state). Filosofia: **simplicidade** > features. Zustand = store via hooks sem Provider, Jotai = atoms independentes (Recoil-like). Ambos eliminam Context wrapping hell e Redux ceremony.

Zustand representa **pragmatismo**: single store, mutations diretas (Immer opcional), zero boilerplate. Jotai representa **composi√ß√£o**: atoms pequenos, bottom-up, derived state autom√°tico. Trade-off comum: **menos features** (sem DevTools robusto, menos ecosystem) vs **simplicidade** (aprender em minutos, bundle tiny).

**Filosofia:** "Just enough state management." Redux = over-engineering para 80% dos apps. Context = performance issues. Zustand/Jotai = sweet spot - simples como Context, performante como Redux, bundle tiny. Ideal para apps modernas que n√£o precisam time-travel debugging.

### Import√¢ncia no Ecossistema

Alternativas modernas s√£o **essenciais** para:

- **Bundle size cr√≠tico**: 1-2kb vs Redux 40kb
- **Simplicidade**: API minimalista, learning curve baixa
- **Performance**: Selective rendering sem Context re-render hell
- **Modern DX**: Hooks-first, TypeScript-native

**Contexto:** Zustand (2019, Poimandres), Jotai (2020, Daishi Kato). Crescimento explosivo (30k+ stars cada). Padr√£o emergente para apps pequenas/m√©dias. Concorrem com Context + Redux, n√£o substituem completamente (trade-offs).

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **Zustand**: Pragmatic state management
2. **Jotai**: Atomic state management
3. **Valtio**: Proxy-based state
4. **Compara√ß√µes**: Zustand vs Jotai vs Redux vs Context
5. **Quando Usar**: Decision framework

---

## üîç An√°lise Conceitual Profunda

### 13.5.1 Zustand

**Instala√ß√£o:**
```bash
npm install zustand
```

**Store b√°sico:**
```javascript
import { create } from 'zustand';

// Create store
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// Uso no component
function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}
```

**Sem Provider:**
```javascript
// ‚úÖ Zustand: Sem wrapping
function App() {
  return <Counter />; // Store acess√≠vel direto
}

// ‚ùå Redux/Context: Provider obrigat√≥rio
function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```

**Selective rendering:**
```javascript
function Counter() {
  // ‚úÖ S√≥ re-renderiza quando count muda
  const count = useStore((state) => state.count);

  // N√£o re-renderiza quando outros values mudam
  return <p>{count}</p>;
}

function Incrementer() {
  // ‚úÖ S√≥ re-renderiza quando increment muda (nunca)
  const increment = useStore((state) => state.increment);

  return <button onClick={increment}>+</button>;
}
```

**Mutations diretas (com Immer):**
```javascript
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

const useStore = create(
  immer((set) => ({
    todos: [],
    addTodo: (text) =>
      set((state) => {
        // Mutation syntax (Immer)
        state.todos.push({
          id: Date.now(),
          text,
          completed: false
        });
      }),
    toggleTodo: (id) =>
      set((state) => {
        const todo = state.todos.find((t) => t.id === id);
        if (todo) todo.completed = !todo.completed;
      })
  }))
);
```

**Async actions:**
```javascript
const useStore = create((set) => ({
  user: null,
  loading: false,
  error: null,

  fetchUser: async (userId) => {
    set({ loading: true, error: null });

    try {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json();
      set({ user, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  }
}));

// Uso
function UserProfile({ userId }) {
  const { user, loading, fetchUser } = useStore();

  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]);

  if (loading) return <div>Loading...</div>;

  return <div>{user?.name}</div>;
}
```

**Persist (localStorage):**
```javascript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useStore = create(
  persist(
    (set) => ({
      theme: 'light',
      setTheme: (theme) => set({ theme })
    }),
    {
      name: 'theme-storage' // localStorage key
    }
  )
);
```

**DevTools:**
```javascript
import { devtools } from 'zustand/middleware';

const useStore = create(
  devtools((set) => ({
    count: 0,
    increment: () => set((state) => ({ count: state.count + 1 }))
  }))
);
```

### 13.5.2 Jotai

**Instala√ß√£o:**
```bash
npm install jotai
```

**Atom b√°sico:**
```javascript
import { atom, useAtom } from 'jotai';

// Criar atom
const countAtom = atom(0);

// Uso no component
function Counter() {
  const [count, setCount] = useAtom(countAtom);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

**Read-only atom:**
```javascript
const countAtom = atom(0);

// Derived atom (read-only)
const doubleCountAtom = atom((get) => get(countAtom) * 2);

function Display() {
  const [count] = useAtom(countAtom);
  const [doubleCount] = useAtom(doubleCountAtom);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>
    </div>
  );
}
```

**Write-only atom:**
```javascript
const countAtom = atom(0);

// Write-only atom (action)
const incrementAtom = atom(
  null, // No read
  (get, set) => {
    set(countAtom, get(countAtom) + 1);
  }
);

function Incrementer() {
  const [, increment] = useAtom(incrementAtom);

  return <button onClick={increment}>+</button>;
}
```

**Async atom:**
```javascript
import { atom, useAtom } from 'jotai';

const userIdAtom = atom(1);

// Async atom (read)
const userAtom = atom(async (get) => {
  const userId = get(userIdAtom);
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
});

function UserProfile() {
  const [user] = useAtom(userAtom);

  // Suspense handling
  return <div>{user.name}</div>;
}

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <UserProfile />
    </Suspense>
  );
}
```

**Complex example:**
```javascript
import { atom, useAtom } from 'jotai';

// Atoms
const todosAtom = atom([]);
const filterAtom = atom('all');

// Derived atom (filtered todos)
const filteredTodosAtom = atom((get) => {
  const todos = get(todosAtom);
  const filter = get(filterAtom);

  if (filter === 'active') {
    return todos.filter((todo) => !todo.completed);
  }
  if (filter === 'completed') {
    return todos.filter((todo) => todo.completed);
  }
  return todos;
});

// Actions (write-only atoms)
const addTodoAtom = atom(null, (get, set, text) => {
  const todos = get(todosAtom);
  set(todosAtom, [
    ...todos,
    { id: Date.now(), text, completed: false }
  ]);
});

const toggleTodoAtom = atom(null, (get, set, id) => {
  const todos = get(todosAtom);
  set(
    todosAtom,
    todos.map((todo) =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    )
  );
});

// Components
function AddTodoForm() {
  const [, addTodo] = useAtom(addTodoAtom);
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    addTodo(text);
    setText('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Add</button>
    </form>
  );
}

function TodoList() {
  const [todos] = useAtom(filteredTodosAtom);
  const [, toggleTodo] = useAtom(toggleTodoAtom);

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          />
          {todo.text}
        </li>
      ))}
    </ul>
  );
}

function FilterButtons() {
  const [filter, setFilter] = useAtom(filterAtom);

  return (
    <div>
      <button onClick={() => setFilter('all')}>All</button>
      <button onClick={() => setFilter('active')}>Active</button>
      <button onClick={() => setFilter('completed')}>Completed</button>
    </div>
  );
}
```

**atomWithStorage (persist):**
```javascript
import { atomWithStorage } from 'jotai/utils';

const themeAtom = atomWithStorage('theme', 'light');

function ThemeToggle() {
  const [theme, setTheme] = useAtom(themeAtom);

  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      {theme}
    </button>
  );
}
```

### 13.5.3 Valtio (Bonus)

**Proxy-based state:**
```javascript
import { proxy, useSnapshot } from 'valtio';

// Proxy state (mutable)
const state = proxy({
  count: 0,
  increment() {
    this.count++;
  },
  decrement() {
    this.count--;
  }
});

// Component
function Counter() {
  const snap = useSnapshot(state);

  return (
    <div>
      <p>{snap.count}</p>
      <button onClick={state.increment}>+</button>
      <button onClick={state.decrement}>-</button>
    </div>
  );
}
```

**Nested objects:**
```javascript
const state = proxy({
  user: {
    name: 'Jo√£o',
    age: 25
  },
  updateName(name) {
    this.user.name = name;
  }
});

function UserProfile() {
  const snap = useSnapshot(state);

  return (
    <div>
      <p>{snap.user.name}</p>
      <button onClick={() => state.updateName('Maria')}>
        Change Name
      </button>
    </div>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Compara√ß√£o: Zustand vs Jotai vs Redux vs Context

| Feature | Zustand | Jotai | Redux (RTK) | Context |
|---------|---------|-------|-------------|---------|
| **Bundle size** | ‚úÖ ~1kb | ‚úÖ ~2kb | ‚ùå ~40kb | ‚úÖ 0kb |
| **API** | ‚úÖ Minimal | ‚úÖ Minimal | ‚ö†Ô∏è Moderate | ‚úÖ Simple |
| **Setup** | ‚úÖ 1 line | ‚úÖ 1 line | ‚ö†Ô∏è Multiple | ‚úÖ 1 line |
| **Provider** | ‚úÖ N√£o precisa | ‚ö†Ô∏è Opcional | ‚ùå Obrigat√≥rio | ‚ùå Obrigat√≥rio |
| **DevTools** | ‚ö†Ô∏è Basic | ‚ö†Ô∏è Basic | ‚úÖ Excellent | ‚ùå Nenhum |
| **Learning curve** | ‚úÖ Minutes | ‚úÖ Minutes | ‚ùå Hours | ‚úÖ Minutes |
| **Performance** | ‚úÖ Selective | ‚úÖ Atomic | ‚úÖ Selective | ‚ùå Re-render |
| **TypeScript** | ‚úÖ Excellent | ‚úÖ Excellent | ‚úÖ Excellent | ‚úÖ Good |
| **Ecosystem** | ‚ö†Ô∏è Growing | ‚ö†Ô∏è Growing | ‚úÖ Mature | ‚úÖ Built-in |

### Filosofias

**Zustand:**
- Single store (Redux-like)
- Mutations diretas (simples)
- Hook-based, no Provider

**Jotai:**
- Atomic state (Recoil-like)
- Composable atoms
- Bottom-up architecture

**Redux:**
- Single store, strict patterns
- Time-travel, DevTools
- Ecosystem maduro

**Context:**
- Built-in React
- Simple, mas performance issues

### Quando Usar Cada Um

**Use Zustand quando:**
- Quer simplicidade + pragmatismo
- Store √∫nica basta
- Bundle size importa

**Use Jotai quando:**
- Prefere atomic state
- State granular/composable
- Suspense-first

**Use Redux (RTK) quando:**
- App grande/complexa
- DevTools essencial
- Ecosystem maduro importa

**Use Context quando:**
- App muito simples
- Low-frequency updates
- Zero dependencies

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Ecosystem

**Redux:**
- ‚úÖ Ecosystem maduro (middlewares, plugins)
- ‚úÖ Milh√µes de recursos, tutorials

**Zustand/Jotai:**
- ‚ö†Ô∏è Ecosystem menor (growing)
- ‚ö†Ô∏è Menos resources

### DevTools

**Redux:**
- ‚úÖ Time-travel debugging completo
- ‚úÖ State inspector robusto

**Zustand/Jotai:**
- ‚ö†Ô∏è DevTools b√°sico
- ‚ö†Ô∏è Sem time-travel completo

### Patterns

**Redux:**
- ‚úÖ Patterns estabelecidos (best practices)
- ‚úÖ Arquitetura clara

**Zustand/Jotai:**
- ‚ö†Ô∏è Menos opinionated (liberdade + responsabilidade)
- ‚ö†Ô∏è Patterns emergentes

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Redux

**Zustand = Redux simplificado:**
- Store √∫nica, mas sem actions/reducers
- Mutations diretas (Immer opcional)

### Rela√ß√£o com Recoil

**Jotai inspirado em Recoil:**
- Atomic state
- Derived atoms
- Suspense-first

### Rela√ß√£o com Context

**Zustand/Jotai resolvem problemas de Context:**
- Performance (selective rendering)
- Sem Provider hell
- API mais simples

---

## üöÄ Pr√≥ximos Conceitos

**13.6 State Management Patterns** - Decision frameworks, best practices

---

## üìö Conclus√£o

### Pontos-Chave

1. **Zustand**: Pragm√°tico, single store, ~1kb
2. **Jotai**: Atomic, composable, ~2kb
3. **Valtio**: Proxy-based, mutable syntax
4. **Todos**: Lightweight alternatives a Redux
5. **Trade-off**: Simplicidade vs Features

### Best Practices

**Zustand:**
1. Selective subscriptions (performance)
2. Immer middleware para complex state
3. Persist middleware para localStorage

**Jotai:**
1. Small atoms (granular state)
2. Derived atoms para computed values
3. Suspense para async atoms

### Quando Usar

**Alternativas modernas s√£o ideais para:**
- Apps pequenas/m√©dias
- Bundle size cr√≠tico
- Simplicidade > features
- Modern stack (hooks, TypeScript, Suspense)

**Redux ainda √© melhor para:**
- Apps grandes/complexas
- DevTools essencial
- Ecosystem maduro importa

**"Right tool for the job." Simplicidade √© vantagem.**

---

## üìñ Recursos Adicionais

**Documenta√ß√£o:**
- Zustand: https://github.com/pmndrs/zustand
- Jotai: https://jotai.org/
- Valtio: https://github.com/pmndrs/valtio

**Compara√ß√µes:**
- State Management Comparison: https://github.com/pmndrs/zustand#comparison

**Pr√≥ximo: State Management Patterns** - Como escolher.
