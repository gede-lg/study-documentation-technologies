# State Management Patterns e Decis√µes

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**State Management Patterns** s√£o frameworks de **decis√£o** e **arquitetura** para escolher e organizar state em React apps - desde **quando usar state** (derived vs stored), **onde colocar** (local vs lifted vs global), **qual ferramenta** (useState vs Context vs Redux), at√© **como estruturar** (feature-based, domain-driven). Core principle: **state complexity cresce exponencialmente** - gerenciar bem = escalar bem.

Patterns incluem **server state vs client state** (React Query para API, Redux para UI), **state colocation** (proximity principle), **state machines** (XState - estados finitos expl√≠citos), **composition patterns** (custom hooks encapsulando l√≥gica). Trade-off universal: **simplicidade** (local state, menos moving parts) vs **escalabilidade** (global state, estrutura clara).

**Filosofia:** "The best code is no code." Minimize state - derive quando poss√≠vel, lift apenas se necess√°rio, globalize com cautela. Over-engineering state management = complexidade prematura. Under-engineering = props drilling hell + re-render chaos. Pattern = navegar esse trade-off conscientemente.

### Import√¢ncia no Ecossistema

State management patterns s√£o **essenciais** para:

- **Decision making**: Qual ferramenta usar quando
- **Arquitetura**: Como organizar state em scale
- **Performance**: Evitar re-renders desnecess√°rios
- **Maintainability**: C√≥digo previs√≠vel, test√°vel

**Contexto:** State management evoluiu: Flux (2014) ‚Üí Redux (2015) ‚Üí Context (2018) ‚Üí Hooks (2019) ‚Üí Zustand/Jotai (2019+) ‚Üí Server State (React Query, 2020+). Hoje = **plural solutions** - escolha depende de context. Patterns = heur√≠sticas para escolher bem.

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **Decision Framework**: Qual ferramenta usar
2. **Server vs Client State**: Separa√ß√£o de concerns
3. **State Colocation**: Proximity principle
4. **Composition Patterns**: Custom hooks
5. **State Machines**: Finite state management
6. **Performance Patterns**: Optimization strategies
7. **Architecture Patterns**: Feature-based, domain-driven

---

## üîç An√°lise Conceitual Profunda

### 13.6.1 Decision Framework

**Perguntas para decidir state management:**

**1. √â server state ou client state?**
```javascript
// Server state (API data)
// ‚úÖ Use React Query / SWR
const { data: users } = useQuery('users', fetchUsers);

// Client state (UI state)
// ‚úÖ Use useState / Context / Redux
const [isModalOpen, setIsModalOpen] = useState(false);
```

**2. Quantos components precisam do state?**
```javascript
// Apenas 1 component
// ‚úÖ Local state (useState)
function Component() {
  const [count, setCount] = useState(0);
}

// Parent + children diretos
// ‚úÖ Lift state up (props)
function Parent() {
  const [count, setCount] = useState(0);
  return <Child count={count} />;
}

// Muitos components desconectados
// ‚úÖ Global state (Context / Redux / Zustand)
```

**3. State muda com que frequ√™ncia?**
```javascript
// High-frequency (input, scroll)
// ‚úÖ Local state (useState)
function Input() {
  const [value, setValue] = useState('');
  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}

// Low-frequency (theme, auth)
// ‚úÖ Global state (Context)
const ThemeContext = createContext();
```

**4. Qu√£o complexo √© o state?**
```javascript
// Simples (primitives)
// ‚úÖ useState
const [count, setCount] = useState(0);

// Complexo (nested objects, m√∫ltiplas sub-values)
// ‚úÖ useReducer
const [state, dispatch] = useReducer(reducer, initialState);

// Muito complexo (muitas features)
// ‚úÖ Redux / Zustand
```

**5. Precisa persistir?**
```javascript
// N√£o precisa persistir
// ‚úÖ useState / Context
const [theme, setTheme] = useState('light');

// Precisa persistir (localStorage)
// ‚úÖ Zustand persist / localStorage hook
const useStore = create(
  persist(
    (set) => ({ theme: 'light', setTheme: (t) => set({ theme: t }) }),
    { name: 'theme' }
  )
);
```

**6. Precisa DevTools?**
```javascript
// N√£o precisa DevTools
// ‚úÖ useState / Context / Zustand
const [count, setCount] = useState(0);

// Precisa DevTools (time-travel, state inspector)
// ‚úÖ Redux
const store = configureStore({ reducer });
```

### 13.6.2 Server State vs Client State

**Separa√ß√£o de concerns:**

**Server State:**
- Data vindo de API
- Cache, refetch, sync
- Loading/error handling
- **Ferramenta**: React Query, SWR

**Client State:**
- UI state (modals, tabs, theme)
- Form inputs (local)
- App logic
- **Ferramenta**: useState, Context, Redux, Zustand

**Exemplo:**
```javascript
// ‚ùå Misturar server + client state no Redux
const store = configureStore({
  reducer: {
    users: usersReducer, // Server state (API data)
    theme: themeReducer, // Client state (UI)
    modals: modalsReducer // Client state (UI)
  }
});

// ‚úÖ Separar: React Query (server) + Zustand (client)
// Server state
const { data: users } = useQuery('users', fetchUsers);

// Client state
const theme = useStore((state) => state.theme);
const isModalOpen = useStore((state) => state.isModalOpen);
```

**Pattern: React Query + Zustand:**
```javascript
// Zustand: Client state
const useUIStore = create((set) => ({
  theme: 'light',
  setTheme: (theme) => set({ theme }),
  isModalOpen: false,
  openModal: () => set({ isModalOpen: true }),
  closeModal: () => set({ isModalOpen: false })
}));

// React Query: Server state
function UsersList() {
  const { data: users, isLoading } = useQuery('users', fetchUsers);
  const theme = useUIStore((state) => state.theme);

  if (isLoading) return <div>Loading...</div>;

  return (
    <div className={theme}>
      {users.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

### 13.6.3 State Colocation

**Princ√≠pio: State deve viver o mais pr√≥ximo poss√≠vel de onde √© usado.**

**‚ùå Anti-pattern: State no top-level:**
```javascript
function App() {
  const [modalOpen, setModalOpen] = useState(false);
  const [accordionIndex, setAccordionIndex] = useState(0);
  const [tabIndex, setTabIndex] = useState(0);

  return (
    <div>
      <Header />
      <Sidebar />
      <Content
        modalOpen={modalOpen}
        setModalOpen={setModalOpen}
        accordionIndex={accordionIndex}
        setAccordionIndex={setAccordionIndex}
        tabIndex={tabIndex}
        setTabIndex={setTabIndex}
      />
    </div>
  );
}
```

**‚úÖ Pattern: State colocation:**
```javascript
function App() {
  return (
    <div>
      <Header />
      <Sidebar />
      <Content />
    </div>
  );
}

function Content() {
  return (
    <div>
      <Modal /> {/* modalOpen vive aqui */}
      <Accordion /> {/* accordionIndex vive aqui */}
      <Tabs /> {/* tabIndex vive aqui */}
    </div>
  );
}

function Modal() {
  const [isOpen, setIsOpen] = useState(false);
  // State colocated, sem props drilling
}
```

**Benefits:**
- Menos props drilling
- Melhor performance (menos re-renders)
- C√≥digo mais maintainable
- Easier to delete (no dependencies)

### 13.6.4 Composition Patterns

**Custom hooks para encapsular l√≥gica:**

**‚ùå L√≥gica espalhada:**
```javascript
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/user')
      .then((res) => res.json())
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error</div>;

  return <div>{user.name}</div>;
}
```

**‚úÖ Custom hook (reus√°vel):**
```javascript
function useUser() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/user')
      .then((res) => res.json())
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  return { user, loading, error };
}

// Uso
function UserProfile() {
  const { user, loading, error } = useUser();

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error</div>;

  return <div>{user.name}</div>;
}
```

**Composi√ß√£o de hooks:**
```javascript
function useAuth() {
  const [user, setUser] = useState(null);

  const login = async (email, password) => {
    const response = await loginAPI(email, password);
    setUser(response.user);
  };

  const logout = () => setUser(null);

  return { user, login, logout };
}

function usePermissions(user) {
  return {
    canEdit: user?.role === 'admin',
    canDelete: user?.role === 'admin',
    canView: !!user
  };
}

function UserDashboard() {
  const { user, logout } = useAuth();
  const permissions = usePermissions(user);

  return (
    <div>
      <p>{user.name}</p>
      {permissions.canEdit && <button>Edit</button>}
      {permissions.canDelete && <button>Delete</button>}
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

### 13.6.5 State Machines

**Finite state machines com XState:**

**‚ùå Boolean soup (hard to reason):**
```javascript
const [isLoading, setIsLoading] = useState(false);
const [isError, setIsError] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);

// Estados imposs√≠veis: isLoading && isSuccess? ü§î
```

**‚úÖ State machine (explicit states):**
```javascript
import { createMachine } from 'xstate';
import { useMachine } from '@xstate/react';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      on: {
        SUCCESS: 'success',
        ERROR: 'error'
      }
    },
    success: {
      on: { FETCH: 'loading' }
    },
    error: {
      on: { RETRY: 'loading' }
    }
  }
});

function DataFetcher() {
  const [state, send] = useMachine(fetchMachine);

  const handleFetch = async () => {
    send('FETCH');

    try {
      const data = await fetch('/api/data');
      send('SUCCESS');
    } catch (error) {
      send('ERROR');
    }
  };

  return (
    <div>
      {state.matches('idle') && (
        <button onClick={handleFetch}>Fetch</button>
      )}
      {state.matches('loading') && <div>Loading...</div>}
      {state.matches('success') && <div>Success!</div>}
      {state.matches('error') && (
        <button onClick={() => send('RETRY')}>Retry</button>
      )}
    </div>
  );
}
```

**Benefits:**
- Estados expl√≠citos (idle, loading, success, error)
- Transi√ß√µes claras (FETCH ‚Üí loading)
- Impossible states imposs√≠veis
- Visualiza√ß√£o (XState Visualizer)

### 13.6.6 Performance Patterns

**Selective rendering:**
```javascript
// ‚ùå Component re-renderiza quando qualquer state muda
function Counter() {
  const state = useStore((state) => state);
  // Re-renderiza quando count, theme, etc mudam

  return <div>{state.count}</div>;
}

// ‚úÖ Selective subscription
function Counter() {
  const count = useStore((state) => state.count);
  // S√≥ re-renderiza quando count muda

  return <div>{count}</div>;
}
```

**Memoization:**
```javascript
// useMemo para expensive computations
function FilteredList({ items, filter }) {
  const filtered = useMemo(() => {
    return items.filter((item) => item.category === filter);
  }, [items, filter]);

  return (
    <ul>
      {filtered.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

// React.memo para prevent re-renders
const ExpensiveComponent = React.memo(({ data }) => {
  console.log('Render');
  return <div>{data}</div>;
});
```

**Split contexts:**
```javascript
// ‚ùå Monolith context
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  return (
    <AppContext.Provider value={{ user, setUser, theme, setTheme }}>
      {children}
    </AppContext.Provider>
  );
}

// ‚úÖ Split contexts
const UserContext = createContext();
const ThemeContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        {children}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}
```

### 13.6.7 Architecture Patterns

**Feature-based folders:**
```
src/
  features/
    todos/
      todosSlice.js
      TodoList.js
      AddTodoForm.js
    users/
      usersSlice.js
      UserProfile.js
      UsersList.js
```

**Domain-driven:**
```
src/
  domains/
    authentication/
      authSlice.js
      LoginForm.js
      useAuth.js
    todos/
      todosSlice.js
      TodoList.js
      useTodos.js
```

**Layered architecture:**
```
src/
  data/         # State management (Redux, Zustand)
    store.js
    slices/
  domain/       # Business logic (hooks, utils)
    useTodos.js
    useAuth.js
  ui/           # Components
    TodoList.js
    LoginForm.js
```

### 13.6.8 Decision Tree

```
START: Preciso de state?
‚îú‚îÄ N√£o ‚Üí Derive from props/state existente
‚îî‚îÄ Sim
   ‚îú‚îÄ √â server state (API data)?
   ‚îÇ  ‚îú‚îÄ Sim ‚Üí React Query / SWR
   ‚îÇ  ‚îî‚îÄ N√£o (client state)
   ‚îÇ     ‚îú‚îÄ Quantos components precisam?
   ‚îÇ     ‚îÇ  ‚îú‚îÄ 1 component ‚Üí useState (local)
   ‚îÇ     ‚îÇ  ‚îú‚îÄ Parent + children ‚Üí Lift state up (props)
   ‚îÇ     ‚îÇ  ‚îî‚îÄ Muitos desconectados
   ‚îÇ     ‚îÇ     ‚îú‚îÄ High-frequency updates?
   ‚îÇ     ‚îÇ     ‚îÇ  ‚îú‚îÄ Sim ‚Üí useState + props (Context re-render issue)
   ‚îÇ     ‚îÇ     ‚îÇ  ‚îî‚îÄ N√£o (low-frequency)
   ‚îÇ     ‚îÇ     ‚îÇ     ‚îú‚îÄ App pequena/m√©dia ‚Üí Context / Zustand / Jotai
   ‚îÇ     ‚îÇ     ‚îÇ     ‚îî‚îÄ App grande/complexa
   ‚îÇ     ‚îÇ     ‚îÇ        ‚îú‚îÄ Precisa DevTools? ‚Üí Redux (RTK)
   ‚îÇ     ‚îÇ     ‚îÇ        ‚îî‚îÄ Simplicidade > features ‚Üí Zustand
```

---

## üéØ Aplicabilidade e Contextos

### Stacks Recomendados

**Small App (< 10 components, 1-2 features):**
- State: useState + props
- Server: Fetch nativo / Axios
- Total: 0kb extras

**Medium App (10-50 components, 3-5 features):**
- Client state: Context / Zustand
- Server state: React Query / SWR
- Total: ~3-10kb extras

**Large App (50+ components, 5+ features):**
- Client state: Redux (RTK) / Zustand
- Server state: React Query
- DevTools: Redux DevTools
- Total: ~40-50kb extras

**Enterprise App:**
- Client state: Redux (RTK)
- Server state: React Query
- State machines: XState (optional)
- Architecture: Feature-based / DDD
- Total: ~60-80kb extras

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Over-engineering

**Problema:** Usar Redux em app pequena = complexidade desnecess√°ria.

**Solu√ß√£o:** Start simple (useState), evolve quando necess√°rio.

### Under-engineering

**Problema:** Props drilling hell, Context re-render chaos.

**Solu√ß√£o:** Lift/globalize quando realmente necess√°rio.

### Performance

**Trade-off:** Simplicidade (Context) vs Performance (selective subscriptions).

**Solu√ß√£o:** Profile antes de otimizar. Context suficiente para 80% dos cases.

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com React Query

React Query = **server state specialist**. Complementa Redux/Zustand (client state).

### Rela√ß√£o com XState

State machines = **explicit states**. Complementa Redux (state container).

### Rela√ß√£o com Custom Hooks

Custom hooks = **composition**. Encapsulam l√≥gica, reutiliz√°veis.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Tend√™ncias

**2024+:**
- Server state libs (React Query) dominant
- Lightweight client state (Zustand, Jotai)
- Redux declining (mas ainda relevante para apps grandes)
- State machines emerging (XState)

**React 19:**
- Server Components (less client state)
- Actions (form state simplificado)

---

## üìö Conclus√£o

### Pontos-Chave

1. **Decision framework**: Server vs client, frequency, complexity
2. **State colocation**: Proximity principle
3. **Composition**: Custom hooks
4. **Performance**: Selective rendering, memoization
5. **Architecture**: Feature-based, layered

### Best Practices

1. **Start simple** (useState)
2. **Derive quando poss√≠vel**
3. **Colocate state** (proximity)
4. **Separate server/client state**
5. **Lift/globalize apenas quando necess√°rio**
6. **Profile before optimizing**

### Decision Framework Summary

**Quick guide:**
- **Server state** ‚Üí React Query / SWR
- **1 component** ‚Üí useState
- **Parent + children** ‚Üí Lift state + props
- **Many disconnected, low-frequency** ‚Üí Context / Zustand
- **Many disconnected, high-frequency** ‚Üí Zustand / Redux
- **Large/complex app** ‚Üí Redux (RTK)
- **Need DevTools** ‚Üí Redux

**Filosofia final:** "Start local, lift when needed, globalize with caution."

**Dominar patterns = escolher ferramenta certa, arquitetar bem, escalar sem dor.**

---

## üìñ Recursos Adicionais

**Artigos:**
- Kent C. Dodds: "Application State Management with React"
- Mark Erikson: "Redux vs Context"

**Documenta√ß√£o:**
- React Query: https://tanstack.com/query
- Zustand: https://github.com/pmndrs/zustand
- XState: https://xstate.js.org/

**M√≥dulo 13 - GERENCIAMENTO DE ESTADO completo! üéâ**

Pr√≥ximo: **M√≥dulo 14 - TESTES** (Jest, React Testing Library, E2E)
