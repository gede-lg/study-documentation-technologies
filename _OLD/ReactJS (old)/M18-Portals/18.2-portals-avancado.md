# Portals Avan√ßado no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Portals Avan√ßado** refere-se ao uso sofisticado de `ReactDOM.createPortal` que vai al√©m da renderiza√ß√£o b√°sica fora da hierarquia DOM, abordando **propaga√ß√£o de eventos (event bubbling)**, **gerenciamento de foco (focus management)**, **acessibilidade (a11y)**, e **padr√µes complexos** como focus trap, m√∫ltiplos portals, e composi√ß√£o avan√ßada. Conceitualmente, representa o **dom√≠nio completo da separa√ß√£o l√≥gica/visual** - n√£o apenas renderizar fora, mas orquestrar comportamentos complexos (eventos, foco, ARIA) mantendo consist√™ncia entre √°rvores React e DOM.

Na ess√™ncia, Portals Avan√ßado trata de **preservar UX e acessibilidade** quando componentes s√£o fisicamente deslocados no DOM - garantindo que teclado, leitores de tela, e intera√ß√µes funcionem como se o componente estivesse em sua posi√ß√£o l√≥gica original.

### Contexto Hist√≥rico e Motiva√ß√£o

Com a introdu√ß√£o de Portals (React 16), resolver problemas de CSS (overflow, z-index) ficou trivial. Mas surgiram **novos desafios**:

**Problemas que Portals Avan√ßado resolve**:

1. **Event Bubbling Confuso**: Eventos propagam na √°rvore React, n√£o DOM - comportamento n√£o-intuitivo
2. **Focus Management**: Modal renderizado no body precisa capturar foco e retornar quando fecha
3. **Acessibilidade Quebrada**: Leitores de tela se perdem quando conte√∫do aparece "magicamente" fora da hierarquia
4. **Escape de Modal**: Usu√°rio pode tab para fora do modal - precisa "prender" foco (focus trap)

**A evolu√ß√£o**: De renderiza√ß√£o simples para **gerenciamento completo de comportamento** em componentes portal.

### Problema Fundamental que Resolve

**1. Event Bubbling na √Årvore React**:

```jsx
// Comportamento especial: eventos seguem √°rvore React, n√£o DOM
function Parent() {
  const handleClick = () => console.log('Parent clicked');

  return (
    <div onClick={handleClick}>
      <p>Parent Content</p>

      {/* Portal renderizado no body (fora do div no DOM) */}
      {createPortal(
        <button>Click Me</button>,
        document.body
      )}
    </div>
  );
}

// Clicar no button:
// - DOM: button no body, div no #root (n√£o relacionados)
// - React: button filho de div (evento borbulha at√© Parent!)
```

**2. Focus Trap em Modais**:

```jsx
// Problema: usu√°rio pode tab para fora do modal
<Modal>
  <input />
  <button>OK</button>
</Modal>

// Tab ‚Üí foco vai para elementos atr√°s do modal!

// Solu√ß√£o: Focus Trap
// - Capturar Tab key
// - Circular foco entre elementos do modal
// - Prevenir escape para elementos externos
```

**3. Acessibilidade (ARIA)**:

```jsx
// Modal precisa comunicar ao leitor de tela:
// - Que √© um di√°logo
// - Qual t√≠tulo/descri√ß√£o
// - Que background est√° "inerte" (n√£o interativo)

<div
  role="dialog"
  aria-modal="true"
  aria-labelledby="modal-title"
  aria-describedby="modal-description"
>
  <h2 id="modal-title">T√≠tulo</h2>
  <p id="modal-description">Descri√ß√£o</p>
</div>
```

### Import√¢ncia no Ecossistema

Portals Avan√ßado s√£o **cr√≠ticos** para:
- **Bibliotecas de Componentes**: Material-UI, Chakra, Radix implementam focus trap e ARIA
- **Acessibilidade**: Garantir que aplica√ß√µes sejam us√°veis com teclado e leitores de tela
- **UX Complexa**: Modais aninhados, wizards, overlays gerenciados
- **Conformidade**: WCAG 2.1 exige gerenciamento de foco e ARIA em modais

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Event Bubbling React**: Eventos propagam na √°rvore React, n√£o DOM
2. **Focus Management**: Capturar, retornar, e prender foco em portals
3. **Focus Trap**: Impedir foco de escapar de modal/dialog
4. **ARIA Attributes**: Comunicar sem√¢ntica para tecnologias assistivas
5. **Background Inert**: Tornar conte√∫do atr√°s de modal n√£o-interativo

### Pilares Fundamentais

- **Event Propagation**: `stopPropagation()`, bubbling na √°rvore React
- **Focus Control**: `autoFocus`, `ref.current.focus()`, retorno de foco
- **Focus Trap**: Tab cycling, primeira/√∫ltima focusable
- **ARIA**: `role="dialog"`, `aria-modal`, `aria-labelledby`, `aria-describedby`
- **Inert**: `inert` attribute ou aria-hidden no background

---

## üß† Fundamentos Te√≥ricos

### Event Bubbling Especial em Portals

**Comportamento √önico**: Portals mant√™m a √°rvore React para propaga√ß√£o de eventos.

**Conceito Interno**:
- **DOM Real**: Portal renderizado fora, eventos DOM propagam na hierarquia DOM
- **React Sint√©tico**: React intercepta eventos e propaga na √°rvore de componentes React

**Visualiza√ß√£o**:

```
√Årvore React:            DOM Real:
<Parent>                 <div id="root">
  <Child>                  <div class="parent">
    <Portal>                 <div class="child">
      <Button />               <!-- vazio -->
    </Portal>                </div>
  </Child>                  </div>
</Parent>                 </div>
                          <div id="modal-root">
                            <button>Click</button>
                          </div>

Evento click em Button:
- DOM: button ‚Üí modal-root ‚Üí body (n√£o passa por parent/child)
- React: Button ‚Üí Portal ‚Üí Child ‚Üí Parent (segue √°rvore React!)
```

**Implica√ß√£o**: Handlers em parents funcionam mesmo com portal renderizado fisicamente fora.

### Focus Management Lifecycle

**Ciclo de foco em modal**:

1. **Antes de abrir**: Guardar elemento com foco (`document.activeElement`)
2. **Ao abrir**: Mover foco para primeiro elemento focus√°vel do modal
3. **Durante**: Manter foco preso no modal (focus trap)
4. **Ao fechar**: Retornar foco ao elemento original

```
Usu√°rio clica bot√£o "Abrir Modal"
  ‚Üì
Salvar: previousFocus = document.activeElement (bot√£o)
  ‚Üì
Abrir modal via portal
  ‚Üì
Mover foco: modal.querySelector('button').focus()
  ‚Üì
[Modal aberto - focus trap ativo]
  ‚Üì
Usu√°rio fecha modal
  ‚Üì
Restaurar: previousFocus.focus()
  ‚Üì
Foco volta ao bot√£o original
```

---

## üîç An√°lise Conceitual Profunda

### Event Bubbling Detalhado

#### Propaga√ß√£o na √Årvore React

```jsx
function App() {
  const handleAppClick = () => console.log('App');

  return (
    <div onClick={handleAppClick}>
      <Sidebar />
    </div>
  );
}

function Sidebar() {
  const handleSidebarClick = () => console.log('Sidebar');

  return (
    <div onClick={handleSidebarClick}>
      <Modal />
    </div>
  );
}

function Modal() {
  const handleModalClick = () => console.log('Modal');

  return createPortal(
    <div onClick={handleModalClick}>
      <button onClick={() => console.log('Button')}>
        Click
      </button>
    </div>,
    document.body
  );
}

// Clicar no button:
// Logs: "Button" ‚Üí "Modal" ‚Üí "Sidebar" ‚Üí "App"
// Evento borbulha na √°rvore React!
```

**An√°lise**: Apesar de `<div>` do Modal estar no `body` (DOM), eventos propagam como se estivesse dentro de `Sidebar` (React).

#### Controle de Propaga√ß√£o

```jsx
function Modal() {
  const handleOverlayClick = () => {
    console.log('Overlay clicked - fechar modal');
  };

  const handleContentClick = (e) => {
    e.stopPropagation(); // Impede propaga√ß√£o para overlay
    console.log('Content clicked - n√£o fechar');
  };

  return createPortal(
    <div className="modal-overlay" onClick={handleOverlayClick}>
      <div className="modal-content" onClick={handleContentClick}>
        <h2>Modal</h2>
        <button>OK</button>
      </div>
    </div>,
    document.body
  );
}
```

**Padr√£o**: Click no overlay fecha, click no content n√£o - `stopPropagation` previne bubbling.

### Focus Management

#### Captura e Retorno de Foco

```jsx
function Modal({ isOpen, onClose, children }) {
  const previousFocusRef = useRef(null);
  const modalRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      // Salvar elemento com foco antes de abrir
      previousFocusRef.current = document.activeElement;

      // Mover foco para modal
      modalRef.current?.focus();
    } else {
      // Retornar foco quando fecha
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return createPortal(
    <div
      ref={modalRef}
      tabIndex={-1} // Permite foco program√°tico
      className="modal"
    >
      {children}
    </div>,
    document.body
  );
}
```

**Conceito**:
- `previousFocusRef`: Guarda refer√™ncia ao elemento focado antes do modal
- `modalRef.current.focus()`: Move foco para modal ao abrir
- `previousFocusRef.current.focus()`: Retorna foco ao fechar

#### AutoFocus no Primeiro Elemento

```jsx
function Modal({ isOpen, children }) {
  const firstFocusableRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      // Focar primeiro elemento focus√°vel ao abrir
      firstFocusableRef.current?.focus();
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return createPortal(
    <div className="modal">
      <input ref={firstFocusableRef} placeholder="Nome" />
      <button>OK</button>
    </div>,
    document.body
  );
}
```

### Focus Trap (Pris√£o de Foco)

**Conceito**: Impedir que foco escape do modal via Tab/Shift+Tab.

#### Implementa√ß√£o Manual

```jsx
function Modal({ isOpen, onClose, children }) {
  const modalRef = useRef(null);

  useEffect(() => {
    if (!isOpen) return;

    const handleTab = (e) => {
      if (e.key !== 'Tab') return;

      const modal = modalRef.current;
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (e.shiftKey) {
        // Shift+Tab: se no primeiro, ir para √∫ltimo
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        // Tab: se no √∫ltimo, ir para primeiro
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };

    document.addEventListener('keydown', handleTab);
    return () => document.removeEventListener('keydown', handleTab);
  }, [isOpen]);

  if (!isOpen) return null;

  return createPortal(
    <div ref={modalRef} className="modal">
      {children}
    </div>,
    document.body
  );
}
```

**An√°lise**:
- Captura tecla Tab
- Identifica todos elementos focus√°veis
- Circular entre primeiro e √∫ltimo ao atingir extremidades

#### Focus Trap com Biblioteca

```jsx
import FocusTrap from 'focus-trap-react';

function Modal({ isOpen, children }) {
  if (!isOpen) return null;

  return createPortal(
    <FocusTrap>
      <div className="modal">
        {children}
      </div>
    </FocusTrap>,
    document.body
  );
}
```

**Bibliotecas comuns**:
- `focus-trap-react`
- `react-focus-lock`
- `@radix-ui/react-focus-scope`

### Acessibilidade (ARIA)

#### Modal Acess√≠vel Completo

```jsx
function AccessibleModal({ isOpen, onClose, title, children }) {
  const titleId = useId();
  const descriptionId = useId();

  useEffect(() => {
    if (isOpen) {
      // Tornar background inerte
      document.body.style.overflow = 'hidden';
      const app = document.getElementById('root');
      app?.setAttribute('aria-hidden', 'true');
    } else {
      document.body.style.overflow = '';
      const app = document.getElementById('root');
      app?.removeAttribute('aria-hidden');
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return createPortal(
    <div
      role="dialog"           // Identifica como di√°logo
      aria-modal="true"       // Modal (bloqueia intera√ß√£o com background)
      aria-labelledby={titleId}    // Associa t√≠tulo
      aria-describedby={descriptionId} // Associa descri√ß√£o
      className="modal"
    >
      <h2 id={titleId}>{title}</h2>

      <div id={descriptionId}>
        {children}
      </div>

      <button onClick={onClose} aria-label="Fechar modal">
        √ó
      </button>
    </div>,
    document.body
  );
}
```

**ARIA Attributes**:
- `role="dialog"`: Define como di√°logo para leitores de tela
- `aria-modal="true"`: Indica que √© modal (bloqueia background)
- `aria-labelledby`: Associa t√≠tulo (leitor anuncia ao abrir)
- `aria-describedby`: Associa descri√ß√£o (contexto adicional)
- `aria-label`: Label para bot√£o fechar (√≠cone √ó n√£o tem texto)

#### Background Inerte

```jsx
useEffect(() => {
  if (isOpen) {
    const mainContent = document.getElementById('root');

    // Op√ß√£o 1: aria-hidden (oculta de leitores de tela)
    mainContent?.setAttribute('aria-hidden', 'true');

    // Op√ß√£o 2: inert (torna n√£o-interativo)
    // mainContent?.setAttribute('inert', '');

    return () => {
      mainContent?.removeAttribute('aria-hidden');
      // mainContent?.removeAttribute('inert');
    };
  }
}, [isOpen]);
```

**Conceito**: Background n√£o deve ser interativo quando modal aberto.

### Padr√µes Avan√ßados

#### M√∫ltiplos Portals com Z-Index

```jsx
function PortalManager() {
  const [modals, setModals] = useState([]);

  const openModal = (content) => {
    setModals(prev => [...prev, { id: Date.now(), content }]);
  };

  const closeModal = (id) => {
    setModals(prev => prev.filter(m => m.id !== id));
  };

  return (
    <>
      <button onClick={() => openModal(<ModalContent1 />)}>
        Modal 1
      </button>

      {modals.map((modal, index) =>
        createPortal(
          <div
            key={modal.id}
            style={{ zIndex: 1000 + index }} // Z-index crescente
            className="modal"
          >
            {modal.content}
            <button onClick={() => closeModal(modal.id)}>
              Fechar
            </button>
          </div>,
          document.body
        )
      )}
    </>
  );
}
```

**Conceito**: Gerenciar m√∫ltiplos modals com z-index din√¢mico.

#### Portal com Posicionamento Din√¢mico (Tooltip)

```jsx
function Tooltip({ children, content }) {
  const [show, setShow] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const triggerRef = useRef(null);

  const handleMouseEnter = () => {
    const rect = triggerRef.current.getBoundingClientRect();

    setPosition({
      top: rect.bottom + window.scrollY + 8,
      left: rect.left + window.scrollX
    });

    setShow(true);
  };

  return (
    <>
      <span
        ref={triggerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={() => setShow(false)}
      >
        {children}
      </span>

      {show && createPortal(
        <div
          className="tooltip"
          style={{
            position: 'absolute',
            top: `${position.top}px`,
            left: `${position.left}px`
          }}
        >
          {content}
        </div>,
        document.body
      )}
    </>
  );
}
```

**Conceito**: Calcular posi√ß√£o do trigger e posicionar portal absolutamente.

#### Composi√ß√£o de Portais

```jsx
function ModalWithTooltip() {
  return createPortal(
    <div className="modal">
      <h2>Modal com Tooltip</h2>

      <Tooltip content="Ajuda aqui">
        <button>Hover me</button>
      </Tooltip>
    </div>,
    document.body
  );
}

function Tooltip({ children, content }) {
  // Tooltip tamb√©m √© portal (nested portal)
  return createPortal(
    <div className="tooltip">{content}</div>,
    document.getElementById('tooltip-root')
  );
}
```

**Conceito**: Portals podem conter outros portals - cada renderizado em seu pr√≥prio container.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Portals Avan√ßado

#### Modal Acess√≠vel

```jsx
import FocusTrap from 'focus-trap-react';

function Modal({ isOpen, onClose, title, children }) {
  const titleId = useId();
  const previousFocusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return createPortal(
    <FocusTrap>
      <div
        role="dialog"
        aria-modal="true"
        aria-labelledby={titleId}
        className="modal-overlay"
        onClick={onClose}
      >
        <div className="modal-content" onClick={e => e.stopPropagation()}>
          <h2 id={titleId}>{title}</h2>
          {children}
          <button onClick={onClose}>Fechar</button>
        </div>
      </div>
    </FocusTrap>,
    document.body
  );
}
```

**Uso**: Sempre que criar modal/dialog - focus trap e ARIA s√£o obrigat√≥rios para acessibilidade.

#### Notification System

```jsx
function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);

  const addNotification = (message) => {
    const id = Date.now();
    setNotifications(prev => [...prev, { id, message }]);

    setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== id));
    }, 3000);
  };

  return (
    <>
      <NotificationContext.Provider value={{ addNotification }}>
        {children}
      </NotificationContext.Provider>

      {createPortal(
        <div className="notification-container">
          {notifications.map(notif => (
            <div key={notif.id} className="notification">
              {notif.message}
            </div>
          ))}
        </div>,
        document.body
      )}
    </>
  );
}
```

### Quando Evitar

1. **Componentes Simples**: Dropdown sem limita√ß√µes de overflow - portal adiciona complexidade desnecess√°ria
2. **Sem Necessidade de Foco**: Tooltips puramente visuais (sem intera√ß√£o) n√£o precisam focus trap
3. **SEO Cr√≠tico**: Conte√∫do importante para indexa√ß√£o - preferir renderiza√ß√£o normal

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Armadilhas Comuns

#### 1. Esquecer de Retornar Foco

```jsx
// ‚ùå Foco perdido ao fechar
function Modal({ isOpen }) {
  if (!isOpen) return null;

  return createPortal(<div>Modal</div>, document.body);
  // Ao fechar, foco fica "perdido" no body
}

// ‚úÖ Retornar foco ao elemento original
function Modal({ isOpen }) {
  const previousFocusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
    } else {
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);

  // ...
}
```

#### 2. Event Propagation Inesperada

```jsx
// Cuidado: eventos propagam na √°rvore React!
function Parent() {
  return (
    <div onClick={() => console.log('Parent')}>
      {createPortal(
        <button>Click</button>, // Trigger Parent onClick!
        document.body
      )}
    </div>
  );
}

// Solu√ß√£o: stopPropagation se n√£o quiser propaga√ß√£o
<button onClick={e => e.stopPropagation()}>Click</button>
```

#### 3. aria-hidden sem Remover ao Fechar

```jsx
// ‚ùå Background fica oculto permanentemente
useEffect(() => {
  if (isOpen) {
    document.getElementById('root').setAttribute('aria-hidden', 'true');
  }
  // Esqueceu de remover!
}, [isOpen]);

// ‚úÖ Cleanup
useEffect(() => {
  const root = document.getElementById('root');
  if (isOpen) {
    root.setAttribute('aria-hidden', 'true');
  }
  return () => {
    root.removeAttribute('aria-hidden');
  };
}, [isOpen]);
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Outros Conceitos

#### Portals + useEffect (Lifecycle)

```jsx
function Modal({ isOpen }) {
  useEffect(() => {
    // Mount: adicionar event listeners
    const handleEscape = (e) => {
      if (e.key === 'Escape') onClose();
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
    }

    // Cleanup: remover listeners
    return () => {
      document.removeEventListener('keydown', handleEscape);
    };
  }, [isOpen]);

  // ...
}
```

#### Portals + Custom Hooks

```jsx
// Hook reutiliz√°vel para focus management
function useFocusManagement(isOpen) {
  const previousFocusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
    } else {
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);

  return previousFocusRef;
}

function Modal({ isOpen }) {
  useFocusManagement(isOpen);
  // ...
}
```

#### Portals + Context API

```jsx
// Provider para gerenciar modals globalmente
const ModalContext = createContext();

function ModalProvider({ children }) {
  const [modals, setModals] = useState([]);

  const openModal = (content) => {
    setModals(prev => [...prev, { id: Date.now(), content }]);
  };

  return (
    <ModalContext.Provider value={{ openModal }}>
      {children}
      {modals.map(modal =>
        createPortal(
          <div key={modal.id}>{modal.content}</div>,
          document.body
        )
      )}
    </ModalContext.Provider>
  );
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Portals Avan√ßado prepara para:

1. **Error Boundaries** (M√≥dulo 19):
   - Como capturar erros em portals
   - Fallback UI em modals

2. **Acessibilidade** (M√≥dulo 25):
   - Focus management avan√ßado
   - ARIA patterns (dialog, tooltip, dropdown)
   - Screen reader testing

3. **Libraries Ecosystem** (M√≥dulo 29):
   - Headless UI (Radix, Headless UI)
   - Component libraries (Material-UI modals internamente usam portals)

4. **Testing** (M√≥dulo 24):
   - Testar portals com React Testing Library
   - Simular eventos em elementos renderizados via portal

### Construindo Sobre Portals

Portals Avan√ßado s√£o **funda√ß√£o** para:
- **Design Systems**: Componentes de overlay padronizados (Modal, Drawer, Popover)
- **Notification Systems**: Toast, Snackbar com gerenciamento de stack
- **Accessibility Libraries**: Implementa√ß√µes WCAG-compliant
- **Overlay Managers**: Gerenciar z-index, m√∫ltiplos layers, backdrop

---

## üéØ Conclus√£o

Portals Avan√ßado elevam portais b√°sicos a **componentes production-ready**:

**Conceitos Centrais**:
- Event bubbling na √°rvore React (n√£o DOM)
- Focus management (captura, trap, retorno)
- ARIA attributes para acessibilidade
- Background inerte

**Principais Padr√µes**:
- Focus trap para modals
- Retorno de foco ao fechar
- ARIA roles e labels
- Event propagation control

**Quando Usar**: Qualquer portal que requer intera√ß√£o (modals, dropdowns com keyboard nav, tooltips interativos).

**Cuidados**: Sempre implementar focus management e ARIA - essenciais para acessibilidade e UX.

Portals Avan√ßado transformam separa√ß√£o DOM em **experi√™ncia coesa e acess√≠vel** - mantendo promessa do React de UI declarativa mesmo quando componentes escapam hierarquia visual.
