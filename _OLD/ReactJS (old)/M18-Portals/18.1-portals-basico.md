# Portals B√°sico no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Portals** s√£o um mecanismo do React que permite **renderizar componentes filhos em um n√≥ DOM diferente** do n√≥ pai na hierarquia de componentes, mantendo intacta a **√°rvore de componentes React**. Conceitualmente, representam uma **"ponte dimensional"** - permitindo que um componente viva em um lugar na √°rvore React (para herdar contexto, props, eventos), mas seja renderizado em outro lugar no DOM real (para escapar limita√ß√µes visuais de CSS).

Na ess√™ncia, Portals resolvem o problema de **separa√ß√£o entre hierarquia l√≥gica e hierarquia visual** - um componente pode precisar estar logicamente dentro de um parent (para comunica√ß√£o, contexto), mas visualmente fora (para overlay, modal, tooltip que n√£o podem ser limitados por `overflow: hidden`, `z-index`, ou clipping).

### Contexto Hist√≥rico e Motiva√ß√£o

Antes dos Portals (React 16, 2017), renderizar componentes fora da hierarquia DOM natural era **extremamente complicado**:

**Problemas pr√©-Portals**:

1. **Limita√ß√µes de CSS**: Um modal dentro de um container com `overflow: hidden` ou `z-index` baixo ficava cortado ou atr√°s de outros elementos
2. **Workarounds Complexos**: Desenvolvedores usavam `document.body.appendChild()` manualmente, perdendo benef√≠cios do React (contexto, eventos)
3. **Quebra de Abstra√ß√£o**: Manipula√ß√£o direta do DOM quebrava o modelo declarativo
4. **Event Handling Quebrado**: Eventos n√£o propagavam corretamente na √°rvore React

**A solu√ß√£o**: `ReactDOM.createPortal()` - permite renderizar em qualquer n√≥ DOM, mantendo todos benef√≠cios do React.

### Problema Fundamental que Resolve

**1. Escape de Overflow e Z-Index**:

```jsx
// ‚ùå Sem Portal - Modal cortado por overflow
function App() {
  return (
    <div style={{ overflow: 'hidden', position: 'relative' }}>
      <Modal> {/* Ser√° cortado pelo overflow do pai! */}
        <h1>Conte√∫do do Modal</h1>
      </Modal>
    </div>
  );
}

// ‚úÖ Com Portal - Modal renderizado no body
function Modal({ children }) {
  return ReactDOM.createPortal(
    <div className="modal-overlay">
      {children}
    </div>,
    document.body // Renderiza direto no body!
  );
}
```

**2. Hierarquia L√≥gica vs Visual**:

```jsx
// Hierarquia React (l√≥gica):
<App>
  <Sidebar>
    <UserProfile>
      <Tooltip /> {/* Logicamente dentro de UserProfile */}
    </UserProfile>
  </Sidebar>
</App>

// DOM Real (visual) com Portal:
<body>
  <div id="root">
    <div class="app">
      <div class="sidebar">
        <div class="user-profile">
          <!-- Tooltip N√ÉO est√° aqui no DOM -->
        </div>
      </div>
    </div>
  </div>
  <!-- Tooltip renderizado aqui, fora da hierarquia -->
  <div class="tooltip-container">
    <div class="tooltip">...</div>
  </div>
</body>
```

**3. Manuten√ß√£o de Contexto e Eventos**:

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div onClick={() => console.log('Parent clicked')}>
      <p>Count: {count}</p>

      {/* Portal renderiza fora, MAS mant√©m contexto e eventos */}
      <ModalPortal>
        <button onClick={() => setCount(c => c + 1)}>
          Increment {/* Acessa setCount do Parent normalmente! */}
        </button>
      </ModalPortal>
    </div>
  );
}
```

### Import√¢ncia no Ecossistema

Portals s√£o **fundamentais** para:

- **UI Overlay Components**: Modals, Dialogs, Tooltips, Dropdowns
- **Bibliotecas de Componentes**: Todas bibliotecas modernas (Material-UI, Chakra, Radix) usam portals
- **Acessibilidade**: Posicionar elementos corretamente na √°rvore de acessibilidade
- **SSR (Server-Side Rendering)**: Renderizar partes da UI em diferentes pontos do HTML gerado

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Separa√ß√£o L√≥gica/Visual**: Componente em um lugar na √°rvore React, renderizado em outro no DOM
2. **Preserva√ß√£o de Contexto**: Context API, props, state funcionam normalmente
3. **Event Bubbling React**: Eventos propagam na √°rvore React, n√£o na DOM
4. **Controle de Destino**: Pode renderizar em qualquer n√≥ DOM existente

### Pilares Fundamentais

- **API**: `ReactDOM.createPortal(children, domNode)`
- **children**: Qualquer elemento React renderiz√°vel
- **domNode**: N√≥ DOM de destino (geralmente fora de `#root`)
- **Comportamento**: Renderiza√ß√£o f√≠sica fora, l√≥gica dentro

---

## üß† Fundamentos Te√≥ricos

### Como Portals Funcionam Internamente

**Processo interno**:

1. **Fase de Render**: React processa componente normalmente na √°rvore virtual
2. **Fase de Commit**: Ao inv√©s de renderizar no parent DOM normal, React:
   - Identifica `createPortal` call
   - Renderiza `children` no `domNode` especificado
   - Mant√©m refer√™ncia na √°rvore React (para contexto, eventos)

**Visualiza√ß√£o**:

```
√Årvore React (virtual):        DOM Real:
-----------------              ---------
<App>                          <div id="root">
  <Component>                    <div>
    <Portal>      ------------>    <!-- vazio aqui -->
      <Modal />                   </div>
    </Portal>                   </div>
  </Component>                  <div id="modal-root">
</App>                            <div class="modal">
                                    <!-- Modal renderizado aqui -->
                                  </div>
                                </div>
```

### Event Bubbling Especial

**Diferen√ßa crucial**: Eventos em Portals seguem a **√°rvore React**, n√£o a DOM:

```jsx
function Parent() {
  const handleClick = () => console.log('Parent clicked');

  return (
    <div onClick={handleClick}>
      <p>Parent content</p>

      {ReactDOM.createPortal(
        <button>Click me</button>, // Renderizado fora no DOM
        document.body
      )}
    </div>
  );
}

// Clicar no bot√£o:
// DOM: button est√° no body, n√£o dentro do div
// React: evento "borbulha" at√© o div (chama handleClick)
```

Isso √© **intencional** - mant√©m consist√™ncia da √°rvore de componentes.

---

## üîç An√°lise Conceitual Profunda

### Sintaxe B√°sica

#### createPortal API

```jsx
import { createPortal } from 'react-dom';

function Component() {
  return createPortal(
    children,    // Elemento React a ser renderizado
    domNode,     // N√≥ DOM de destino
    key?         // Opcional: key √∫nica (para listas)
  );
}
```

**Par√¢metros**:
- `children`: Qualquer coisa que React possa renderizar (JSX, string, array, etc)
- `domNode`: Refer√™ncia a um n√≥ DOM existente (obtido via `document.getElementById`, `useRef`, etc)
- `key` (opcional): Key para reconcilia√ß√£o quando em listas

#### Exemplo Completo de Modal

```jsx
import { createPortal } from 'react-dom';
import { useState } from 'react';

function Modal({ children, isOpen }) {
  if (!isOpen) return null;

  // Renderiza no body, fora da hierarquia normal
  return createPortal(
    <div className="modal-overlay">
      <div className="modal-content">
        {children}
      </div>
    </div>,
    document.body
  );
}

function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <div className="app">
      <button onClick={() => setShowModal(true)}>
        Abrir Modal
      </button>

      <Modal isOpen={showModal}>
        <h2>Modal Title</h2>
        <p>Conte√∫do do modal</p>
        <button onClick={() => setShowModal(false)}>
          Fechar
        </button>
      </Modal>
    </div>
  );
}
```

**An√°lise**:
- `Modal` logicamente dentro de `App` (acessa `showModal`, `setShowModal`)
- Renderizado fisicamente no `document.body` (escapa overflow, z-index)
- Bot√£o "Fechar" acessa `setShowModal` normalmente (closure preservada)

### Padr√£o com Container Dedicado

**Melhor pr√°tica**: Criar container espec√≠fico para portals no HTML:

```html
<!-- public/index.html -->
<body>
  <div id="root"></div>
  <div id="modal-root"></div>  <!-- Container para portals -->
  <div id="tooltip-root"></div>
</body>
```

```jsx
function Modal({ children }) {
  const modalRoot = document.getElementById('modal-root');

  return createPortal(
    <div className="modal">{children}</div>,
    modalRoot
  );
}
```

**Vantagens**:
- **Organiza√ß√£o**: Separa√ß√£o clara entre app e overlays
- **CSS Scoping**: Estilos espec√≠ficos para containers
- **SSR**: Facilita hidrata√ß√£o no servidor

### Portal com useRef para Destino Din√¢mico

```jsx
function Tooltip({ children, target }) {
  const [tooltipContainer] = useState(() => {
    const div = document.createElement('div');
    document.body.appendChild(div);
    return div;
  });

  useEffect(() => {
    // Cleanup: remover container quando desmonta
    return () => {
      document.body.removeChild(tooltipContainer);
    };
  }, [tooltipContainer]);

  return createPortal(
    <div className="tooltip">{children}</div>,
    tooltipContainer
  );
}
```

**Conceito**: Cria container dinamicamente quando componente monta, remove quando desmonta.

### M√∫ltiplos Portals

```jsx
function App() {
  const [showModal, setShowModal] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);

  return (
    <div>
      {/* Portal 1: Modal */}
      {showModal && createPortal(
        <div className="modal">Modal Content</div>,
        document.getElementById('modal-root')
      )}

      {/* Portal 2: Tooltip */}
      {showTooltip && createPortal(
        <div className="tooltip">Tooltip Content</div>,
        document.getElementById('tooltip-root')
      )}

      <button onClick={() => setShowModal(true)}>Modal</button>
      <button onClick={() => setShowTooltip(true)}>Tooltip</button>
    </div>
  );
}
```

**Conceito**: M√∫ltiplos portals podem coexistir, cada um renderizado em seu pr√≥prio container.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Portals

#### 1. Modais e Dialogs

**Cen√°rio**: Modal precisa cobrir toda tela, sem limita√ß√µes de `overflow` ou `z-index` do parent.

```jsx
function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;

  return createPortal(
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        {children}
      </div>
    </div>,
    document.body
  );
}
```

**Por que Portal?**:
- Escapa de `overflow: hidden` em containers pais
- Z-index sempre no topo (renderizado no body)
- Overlay cobre toda viewport

#### 2. Tooltips

**Cen√°rio**: Tooltip em elemento profundo na hierarquia, mas precisa estar posicionado absolutamente no viewport.

```jsx
function Tooltip({ children, text }) {
  const [show, setShow] = useState(false);

  return (
    <>
      <span
        onMouseEnter={() => setShow(true)}
        onMouseLeave={() => setShow(false)}
      >
        {children}
      </span>

      {show && createPortal(
        <div className="tooltip">{text}</div>,
        document.getElementById('tooltip-root')
      )}
    </>
  );
}
```

#### 3. Dropdowns

**Cen√°rio**: Dropdown que n√£o pode ser cortado por `overflow` do container pai.

```jsx
function Dropdown({ trigger, items }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <div onClick={() => setIsOpen(!isOpen)}>
        {trigger}
      </div>

      {isOpen && createPortal(
        <ul className="dropdown-menu">
          {items.map(item => (
            <li key={item.id}>{item.label}</li>
          ))}
        </ul>,
        document.body
      )}
    </>
  );
}
```

### Quando N√ÉO Usar Portals

1. **Elementos Inline**: Texto, bot√µes que fazem parte do fluxo normal
2. **Sem Necessidade de Escape**: Se parent n√£o tem `overflow` ou `z-index` problem√°tico
3. **SEO Cr√≠tico**: Portals podem complicar SSR e indexa√ß√£o (preferir solu√ß√£o CSS quando poss√≠vel)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes e Cuidados

#### 1. Container Deve Existir Antes

```jsx
// ‚ùå Erro: modalRoot n√£o existe
const modalRoot = document.getElementById('modal-root'); // null!

function Modal({ children }) {
  return createPortal(children, modalRoot); // Erro!
}

// ‚úÖ Garantir que existe
function Modal({ children }) {
  const modalRoot = document.getElementById('modal-root');

  if (!modalRoot) {
    console.error('modal-root n√£o encontrado');
    return null;
  }

  return createPortal(children, modalRoot);
}
```

#### 2. SSR (Server-Side Rendering)

**Problema**: `document` n√£o existe no servidor.

```jsx
// ‚ùå Quebra SSR
function Modal({ children }) {
  return createPortal(children, document.body); // document undefined!
}

// ‚úÖ Renderizar apenas no cliente
function Modal({ children }) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) return null;

  return createPortal(children, document.body);
}
```

#### 3. Event Bubbling "M√°gico"

Eventos seguem √°rvore React, **n√£o DOM**:

```jsx
function App() {
  return (
    <div onClick={() => console.log('Div clicado')}>
      {createPortal(
        <button>Click</button>,
        document.body
      )}
    </div>
  );
}

// Clicar no button:
// - DOM: button est√° fora do div (no body)
// - React: evento borbulha at√© div (log aparece!)
```

Isso pode ser **confuso** - eventos propagam onde voc√™ n√£o espera visualmente.

#### 4. Cleanup Manual

Se criar container dinamicamente, **sempre limpar**:

```jsx
function Component() {
  const [container] = useState(() => {
    const div = document.createElement('div');
    document.body.appendChild(div);
    return div;
  });

  useEffect(() => {
    return () => {
      document.body.removeChild(container); // Cleanup!
    };
  }, [container]);

  return createPortal(<div>Content</div>, container);
}
```

**Sem cleanup**: Memory leak - containers acumulam no body.

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Outros Conceitos

#### Portals + useRef

```jsx
function Modal({ children }) {
  const containerRef = useRef(null);

  useEffect(() => {
    containerRef.current = document.createElement('div');
    document.body.appendChild(containerRef.current);

    return () => {
      document.body.removeChild(containerRef.current);
    };
  }, []);

  if (!containerRef.current) return null;

  return createPortal(children, containerRef.current);
}
```

#### Portals + Context API

```jsx
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value={{ theme: 'dark' }}>
      <Modal>
        {/* Modal pode acessar ThemeContext normalmente! */}
        <ThemedContent />
      </Modal>
    </ThemeContext.Provider>
  );
}

function Modal({ children }) {
  return createPortal(
    children, // Herda contexto do parent React
    document.body
  );
}
```

**Conceito**: Portal mant√©m contexto da √°rvore React, mesmo renderizando em DOM diferente.

#### Portals + Event Handlers

```jsx
function Parent() {
  const handleClick = (e) => {
    console.log('Parent interceptou:', e.target);
  };

  return (
    <div onClick={handleClick}>
      {createPortal(
        <button>Portal Button</button>,
        document.body
      )}
    </div>
  );
}

// Click em button ‚Üí handleClick chamado
// Evento "borbulha" na √°rvore React at√© Parent
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para Conceitos Avan√ßados

Portais B√°sicos preparam para:

1. **Portals Avan√ßado** (18.2):
   - Event bubbling detalhado
   - Focus management em modals
   - Acessibilidade (ARIA, focus trap)

2. **Acessibilidade** (M√≥dulo 25):
   - Modal acess√≠vel com portal
   - Focus trap implementation
   - ARIA attributes

3. **Error Boundaries** (M√≥dulo 19):
   - Como error boundaries interagem com portals
   - Captura de erros em componentes renderizados via portal

4. **Server Components** (M√≥dulo 21):
   - Portals em SSR
   - Hidrata√ß√£o de portals

### Padr√µes de Constru√ß√£o

Portal b√°sico √© **funda√ß√£o** para:
- Sistemas de Modal/Dialog completos
- Bibliotecas de UI (Material-UI, Chakra usam portals internamente)
- Overlay managers (gerenciar m√∫ltiplos modals, z-index)
- Notification systems (toast, snackbar)

---

## üéØ Conclus√£o

Portals s√£o **ferramenta essencial** para componentes de overlay:

**Conceito Central**: Separar hierarquia l√≥gica (React) de hierarquia visual (DOM).

**Principais Benef√≠cios**:
- Escapa limita√ß√µes de CSS (overflow, z-index)
- Mant√©m contexto, props, eventos
- Event bubbling segue √°rvore React

**Quando Usar**: Modals, tooltips, dropdowns, notifica√ß√µes.

**Cuidados**: SSR, cleanup de containers din√¢micos, event bubbling "m√°gico".

Portals tornam poss√≠vel criar **UI overlay robusta** mantendo todos benef√≠cios do modelo declarativo React - uma ponte elegante entre l√≥gica e apresenta√ß√£o.
