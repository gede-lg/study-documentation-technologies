# Forms Acess√≠veis no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Forms Acess√≠veis** s√£o formul√°rios que funcionam para **todos os usu√°rios**, incluindo pessoas com defici√™ncias visuais, motoras, cognitivas ou auditivas. Acessibilidade em forms envolve **WCAG compliance** (Web Content Accessibility Guidelines), **ARIA attributes** (roles, labels, live regions), **keyboard navigation**, **focus management**, e **error announcement**. N√£o √© "feature extra" - √© **requisito fundamental**.

Acessibilidade significa que screen readers (leitores de tela) conseguem **anunciar** labels, erros, e estados; que usu√°rios conseguem **navegar** apenas com teclado (sem mouse); que foco visual √© **claro**; que mensagens de erro s√£o **associadas** corretamente aos inputs. React n√£o oferece acessibilidade "de gra√ßa" - voc√™ precisa **construir**.

**Filosofia:** "Accessibility is not a feature, it's a right." ~15% da popula√ß√£o tem alguma defici√™ncia. Formul√°rios inacess√≠veis **excluem** milh√µes de pessoas. Al√©m disso, muitos pa√≠ses t√™m **leis** exigindo acessibilidade (ADA nos EUA, LBI no Brasil).

### Import√¢ncia no Ecossistema

Forms acess√≠veis s√£o **obrigat√≥rios** para:

- **Compliance legal**: ADA, Section 508, LBI
- **Inclus√£o**: Deficientes visuais, motores, cognitivos
- **SEO**: Google considera acessibilidade
- **UX universal**: Melhor para todos (ex: labels claros)

**Contexto:** WCAG 2.1 Level AA √© padr√£o global. Sites governamentais e grandes empresas **devem** cumprir. Ignorar acessibilidade = risco legal + exclus√£o.

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **Labels e Associa√ß√£o**: `<label>` e `htmlFor`
2. **ARIA Attributes**: `aria-label`, `aria-describedby`, `aria-invalid`
3. **Error Announcement**: `role="alert"`, `aria-live`
4. **Keyboard Navigation**: Tab order, Enter, Escape
5. **Focus Management**: `autoFocus`, `focus()`, trap focus
6. **Required e Valida√ß√£o**: Indicar obrigatoriedade

---

## üîç Fundamentos Te√≥ricos

### WCAG 2.1 Guidelines

**N√≠veis:**
- **A**: M√≠nimo (ex: alt text em imagens)
- **AA**: Padr√£o (ex: contrast ratio 4.5:1)
- **AAA**: Ideal (ex: contrast ratio 7:1)

**Level AA √© objetivo** para maioria dos sites.

### Four Principles (POUR)

**Perceivable:** Usu√°rio deve **perceber** informa√ß√£o
- Labels vis√≠veis e associados
- Erros anunciados

**Operable:** Usu√°rio deve **operar** interface
- Teclado naveg√°vel
- Tempo suficiente para preencher

**Understandable:** Usu√°rio deve **entender** conte√∫do
- Labels claros
- Mensagens de erro descritivas

**Robust:** Funcionar em **assistive technologies**
- Sem√¢ntica HTML correta
- ARIA quando necess√°rio

---

## üîç An√°lise Conceitual Profunda

### 10.6.1 Labels e Associa√ß√£o

**‚ùå Sem label (inacess√≠vel):**
```javascript
function BadForm() {
  return (
    <div>
      Nome: <input type="text" /> {/* Screen reader n√£o sabe o que √© */}
    </div>
  );
}
```

**‚úÖ Com label (acess√≠vel):**
```javascript
function GoodForm() {
  return (
    <div>
      <label htmlFor="name">Nome:</label>
      <input id="name" type="text" />
      {/* Screen reader anuncia: "Nome, edit text" */}
    </div>
  );
}
```

**Label impl√≠cito (tamb√©m v√°lido):**
```javascript
<label>
  Nome:
  <input type="text" />
</label>
// N√£o precisa htmlFor/id, mas menos flex√≠vel para styling
```

**M√∫ltiplos inputs com mesmo prop√≥sito:**
```javascript
function PhoneNumber() {
  return (
    <fieldset>
      <legend>Telefone</legend>
      <label htmlFor="ddd">DDD:</label>
      <input id="ddd" type="tel" maxLength="2" />

      <label htmlFor="number">N√∫mero:</label>
      <input id="number" type="tel" maxLength="9" />
    </fieldset>
  );
}
// fieldset agrupa, legend anuncia contexto
```

### 10.6.2 ARIA Attributes

**aria-label (label invis√≠vel):**
```javascript
function SearchForm() {
  return (
    <form>
      {/* Sem label visual, mas screen reader anuncia */}
      <input
        type="search"
        aria-label="Buscar produtos"
        placeholder="Buscar..."
      />
      <button aria-label="Enviar busca">üîç</button>
    </form>
  );
}
```

**aria-labelledby (referenciar elemento existente):**
```javascript
function FormSection() {
  return (
    <div>
      <h2 id="section-title">Informa√ß√µes Pessoais</h2>
      <input
        type="text"
        aria-labelledby="section-title"
        placeholder="Nome completo"
      />
      {/* Screen reader anuncia: "Informa√ß√µes Pessoais, Nome completo" */}
    </div>
  );
}
```

**aria-describedby (descri√ß√£o adicional):**
```javascript
function PasswordInput() {
  return (
    <div>
      <label htmlFor="password">Senha:</label>
      <input
        id="password"
        type="password"
        aria-describedby="password-hint"
      />
      <span id="password-hint">
        M√≠nimo 8 caracteres, 1 mai√∫scula, 1 n√∫mero
      </span>
      {/* Screen reader anuncia label + hint */}
    </div>
  );
}
```

**aria-invalid (indicar erro):**
```javascript
function EmailInput() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  const validate = () => {
    if (!/\S+@\S+/.test(email)) {
      setError('Email inv√°lido');
    } else {
      setError('');
    }
  };

  return (
    <div>
      <label htmlFor="email">Email:</label>
      <input
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        onBlur={validate}
        aria-invalid={!!error}
        aria-describedby={error ? 'email-error' : undefined}
      />
      {error && (
        <span id="email-error" role="alert">
          {error}
        </span>
      )}
    </div>
  );
}
```

**aria-required (indicar obrigatoriedade):**
```javascript
<label htmlFor="name">
  Nome: <span aria-hidden="true">*</span>
</label>
<input
  id="name"
  type="text"
  required
  aria-required="true"
/>
// required (HTML5) + aria-required (ARIA) = m√°xima compatibilidade
```

### 10.6.3 Error Announcement

**role="alert" (anuncia imediatamente):**
```javascript
function FormWithAlert() {
  const [error, setError] = useState('');

  return (
    <form>
      <input
        type="email"
        onBlur={(e) => {
          if (!e.target.value.includes('@')) {
            setError('Email inv√°lido');
          }
        }}
        aria-invalid={!!error}
        aria-describedby="email-error"
      />

      {error && (
        <span id="email-error" role="alert">
          {error}
        </span>
      )}
      {/* role="alert" faz screen reader anunciar automaticamente */}
    </form>
  );
}
```

**aria-live (announcements din√¢micos):**
```javascript
function LiveRegion() {
  const [message, setMessage] = useState('');

  return (
    <div>
      <button onClick={() => setMessage('Dados salvos com sucesso!')}>
        Salvar
      </button>

      <div aria-live="polite" aria-atomic="true">
        {message}
      </div>
      {/* aria-live="polite": anuncia quando screen reader terminar frase atual */}
      {/* aria-live="assertive": anuncia IMEDIATAMENTE (use com cuidado) */}
    </div>
  );
}
```

**Associar erro com input:**
```javascript
function AccessibleError() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  return (
    <div>
      <label htmlFor="email">Email:</label>
      <input
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        aria-invalid={!!error}
        aria-describedby={error ? 'email-error' : undefined}
      />

      {error && (
        <span
          id="email-error"
          role="alert"
          style={{ color: 'red' }}
        >
          {error}
        </span>
      )}
    </div>
  );
}
// aria-describedby conecta input ao erro
// role="alert" anuncia erro
// aria-invalid="true" indica estado inv√°lido
```

### 10.6.4 Keyboard Navigation

**Tab order natural:**
```javascript
function TabOrder() {
  return (
    <form>
      {/* Tab order: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 */}
      <input type="text" placeholder="Nome" />
      <input type="email" placeholder="Email" />
      <select>
        <option>Brasil</option>
      </select>
      <button type="submit">Enviar</button>
    </form>
  );
}
// Ordem natural do DOM = tab order
```

**tabIndex (controlar ordem):**
```javascript
function CustomTabOrder() {
  return (
    <div>
      <input type="text" tabIndex="1" /> {/* Primeiro */}
      <input type="text" tabIndex="3" /> {/* Terceiro */}
      <input type="text" tabIndex="2" /> {/* Segundo */}
      <button tabIndex="0">Enviar</button> {/* Ordem natural */}
      <div tabIndex="-1">N√£o foc√°vel por Tab, mas foc√°vel via JS</div>
    </div>
  );
}
// ‚ö†Ô∏è Evite tabIndex positivo (confuso). Use ordem natural do DOM.
```

**Enter para submit:**
```javascript
function EnterSubmit() {
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Submitted!');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" />
      <input type="text" />
      {/* Enter em qualquer input = submit */}
      <button type="submit">Enviar</button>
    </form>
  );
}
// Comportamento nativo de <form> - n√£o precisa implementar
```

**Escape para fechar modal:**
```javascript
function Modal({ isOpen, onClose, children }) {
  useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
      >
        {children}
      </div>
    </div>
  );
}
```

### 10.6.5 Focus Management

**autoFocus (focar ao montar):**
```javascript
function AutoFocusForm() {
  return (
    <form>
      <input type="text" autoFocus placeholder="Nome" />
      {/* Foca automaticamente ao renderizar */}
    </form>
  );
}
// ‚ö†Ô∏è Use com cuidado - pode confundir screen reader users
```

**Focar programaticamente:**
```javascript
function ProgrammaticFocus() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <button onClick={handleFocus}>Focar input</button>
      <input ref={inputRef} type="text" />
    </div>
  );
}
```

**Focus trap em modal:**
```javascript
function ModalWithFocusTrap({ isOpen, onClose, children }) {
  const modalRef = useRef(null);

  useEffect(() => {
    if (!isOpen) return;

    // Salvar elemento com foco anterior
    const previousFocus = document.activeElement;

    // Focar primeiro elemento foc√°vel do modal
    const firstFocusable = modalRef.current?.querySelector(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    firstFocusable?.focus();

    // Trap focus
    const handleTab = (e) => {
      const focusableElements = modalRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (e.key === 'Tab') {
        if (e.shiftKey && document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };

    document.addEventListener('keydown', handleTab);

    // Cleanup: restaurar foco
    return () => {
      document.removeEventListener('keydown', handleTab);
      previousFocus?.focus();
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      ref={modalRef}
      className="modal"
      role="dialog"
      aria-modal="true"
    >
      {children}
      <button onClick={onClose}>Fechar</button>
    </div>
  );
}
```

**Focus visible (outline apenas para teclado):**
```css
/* Mostrar outline apenas quando navegar por teclado */
:focus {
  outline: none; /* Remove outline padr√£o */
}

:focus-visible {
  outline: 2px solid blue; /* Outline apenas para keyboard navigation */
}
```

```javascript
function FocusVisibleExample() {
  return (
    <button style={{
      outline: 'none', // Remove outline padr√£o
      ':focus-visible': {
        outline: '2px solid blue'
      }
    }}>
      Click ou Tab
    </button>
  );
}
// Usu√°rios de mouse: sem outline
// Usu√°rios de teclado: outline azul
```

### 10.6.6 Required e Valida√ß√£o Acess√≠vel

**Indicar obrigatoriedade:**
```javascript
function RequiredField() {
  return (
    <div>
      <label htmlFor="email">
        Email:
        <span aria-hidden="true" style={{ color: 'red' }}> *</span>
      </label>
      <input
        id="email"
        type="email"
        required
        aria-required="true"
      />
      {/* aria-hidden="true" no * evita screen reader anunciar "asterisco" */}
      {/* aria-required="true" anuncia "Email, obrigat√≥rio, edit text" */}
    </div>
  );
}
```

**Form com valida√ß√£o completa:**
```javascript
function AccessibleForm() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const validate = () => {
    const newErrors = {};

    if (!formData.name) {
      newErrors.name = 'Nome √© obrigat√≥rio';
    }

    if (!formData.email) {
      newErrors.email = 'Email √© obrigat√≥rio';
    } else if (!/\S+@\S+/.test(formData.email)) {
      newErrors.email = 'Email inv√°lido';
    }

    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    const validationErrors = validate();

    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      setTouched({ name: true, email: true });

      // Focar primeiro campo com erro
      const firstErrorField = Object.keys(validationErrors)[0];
      document.getElementById(firstErrorField)?.focus();

      return;
    }

    console.log('Form v√°lido:', formData);
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));

    // Limpar erro ao digitar
    if (touched[name]) {
      const fieldErrors = validate();
      setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));
    }
  };

  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));

    const fieldErrors = validate();
    setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));
  };

  return (
    <form onSubmit={handleSubmit} noValidate>
      <div>
        <label htmlFor="name">
          Nome:
          <span aria-hidden="true"> *</span>
        </label>
        <input
          id="name"
          name="name"
          type="text"
          value={formData.name}
          onChange={handleChange}
          onBlur={handleBlur}
          required
          aria-required="true"
          aria-invalid={!!(touched.name && errors.name)}
          aria-describedby={errors.name ? 'name-error' : undefined}
        />
        {touched.name && errors.name && (
          <span id="name-error" role="alert" style={{ color: 'red' }}>
            {errors.name}
          </span>
        )}
      </div>

      <div>
        <label htmlFor="email">
          Email:
          <span aria-hidden="true"> *</span>
        </label>
        <input
          id="email"
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          required
          aria-required="true"
          aria-invalid={!!(touched.email && errors.email)}
          aria-describedby={errors.email ? 'email-error' : undefined}
        />
        {touched.email && errors.email && (
          <span id="email-error" role="alert" style={{ color: 'red' }}>
            {errors.email}
          </span>
        )}
      </div>

      <button type="submit">Enviar</button>
    </form>
  );
}
```

### 10.6.7 Checkboxes e Radios Acess√≠veis

**Checkbox group:**
```javascript
function CheckboxGroup() {
  const [selected, setSelected] = useState([]);

  const handleChange = (value) => {
    setSelected(prev =>
      prev.includes(value)
        ? prev.filter(v => v !== value)
        : [...prev, value]
    );
  };

  return (
    <fieldset>
      <legend>Selecione seus interesses:</legend>

      <label>
        <input
          type="checkbox"
          checked={selected.includes('tech')}
          onChange={() => handleChange('tech')}
        />
        Tecnologia
      </label>

      <label>
        <input
          type="checkbox"
          checked={selected.includes('sports')}
          onChange={() => handleChange('sports')}
        />
        Esportes
      </label>

      <label>
        <input
          type="checkbox"
          checked={selected.includes('music')}
          onChange={() => handleChange('music')}
        />
        M√∫sica
      </label>
    </fieldset>
  );
}
// fieldset agrupa, legend anuncia contexto
```

**Radio group:**
```javascript
function RadioGroup() {
  const [selected, setSelected] = useState('');

  return (
    <fieldset>
      <legend>Escolha seu plano:</legend>

      <label>
        <input
          type="radio"
          name="plan"
          value="free"
          checked={selected === 'free'}
          onChange={(e) => setSelected(e.target.value)}
        />
        Gratuito
      </label>

      <label>
        <input
          type="radio"
          name="plan"
          value="pro"
          checked={selected === 'pro'}
          onChange={(e) => setSelected(e.target.value)}
        />
        Pro
      </label>

      <label>
        <input
          type="radio"
          name="plan"
          value="enterprise"
          checked={selected === 'enterprise'}
          onChange={(e) => setSelected(e.target.value)}
        />
        Enterprise
      </label>
    </fieldset>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Cada T√©cnica

**Labels:** SEMPRE (exceto se houver aria-label)

**aria-describedby:** Hints, instru√ß√µes, erros

**aria-invalid:** Quando campo tem erro

**role="alert":** Erros que devem ser anunciados imediatamente

**aria-live:** Status updates, notifica√ß√µes

**Focus trap:** Modais, dialogs

### Testing Accessibility

**Ferramentas:**
- **axe DevTools**: Chrome extension, detecta issues automaticamente
- **WAVE**: Web accessibility evaluation tool
- **Lighthouse**: Audit de acessibilidade (Chrome DevTools)
- **Screen readers**: NVDA (Windows), VoiceOver (Mac), JAWS

**Teste manual:**
1. Navegar apenas com teclado (Tab, Enter, Escape)
2. Usar screen reader
3. Zoom 200% (texto deve permanecer leg√≠vel)
4. Contrast checker (4.5:1 m√≠nimo)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### ARIA Overuse

**‚ùå ARIA desnecess√°rio:**
```javascript
// ‚ùå Redundante
<button role="button" aria-label="Clique aqui">
  Clique aqui
</button>

// ‚úÖ Sem√¢ntica HTML suficiente
<button>Clique aqui</button>
```

**Regra:** "No ARIA is better than bad ARIA."

### Focus Outline

**‚ùå NUNCA remova outline sem substituir:**
```css
/* ‚ùå P√âSSIMO - usu√°rios de teclado ficam perdidos */
* {
  outline: none !important;
}

/* ‚úÖ BOM - substituir por :focus-visible */
:focus {
  outline: none;
}

:focus-visible {
  outline: 2px solid blue;
}
```

### Color Contrast

**M√≠nimo WCAG AA:**
- Text normal: 4.5:1
- Text grande (‚â•18pt): 3:1

**Ferramentas:** WebAIM Contrast Checker

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Valida√ß√£o

Valida√ß√£o acess√≠vel = valida√ß√£o visual + ARIA:
```javascript
<input
  aria-invalid={!!error}
  aria-describedby="error-id"
/>
{error && <span id="error-id" role="alert">{error}</span>}
```

### Rela√ß√£o com Forms Controlados

Controlled forms facilitam ARIA din√¢mico:
```javascript
const [value, setValue] = useState('');
const error = validate(value);

<input
  value={value}
  aria-invalid={!!error}
  aria-describedby={error ? 'error-id' : undefined}
/>
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Tend√™ncias

**HTML5 attributes melhorando:**
- `inputmode`: Teclado mobile otimizado
- `autocomplete`: Preenchimento autom√°tico
- `autofocus`: Foco inicial

**ARIA 1.3 (em desenvolvimento):**
- Novos roles e properties
- Melhor suporte a widgets complexos

### React e Acessibilidade

**React Hook Form tem √≥timo suporte:**
```javascript
const { register } = useForm();

<input
  {...register('email', { required: true })}
  aria-invalid={!!errors.email}
/>
// Library gera IDs automaticamente
```

### Pr√≥ximos Passos

M√≥dulo 10 (FORMUL√ÅRIOS) completo! Pr√≥ximo: **M√≥dulo 11** (depende do curr√≠culo).

---

## üìö Conclus√£o

### Pontos-Chave

Forms acess√≠veis requerem:

1. **Labels associados** (htmlFor/id)
2. **ARIA attributes** (aria-invalid, aria-describedby, role="alert")
3. **Keyboard navigation** (Tab order, Enter, Escape)
4. **Focus management** (autoFocus, trap em modais)
5. **Error announcement** (role="alert", aria-live)
6. **Required indication** (aria-required, visual)

### Checklist de Acessibilidade

**Essencial:**
- [ ] Todos inputs t√™m labels associados
- [ ] Erros t√™m `role="alert"` e `aria-describedby`
- [ ] Campos obrigat√≥rios t√™m `required` e `aria-required`
- [ ] Form naveg√°vel apenas com teclado
- [ ] Focus visible (outline ou :focus-visible)
- [ ] Contrast ratio ‚â• 4.5:1

**Bom ter:**
- [ ] Focus trap em modais
- [ ] aria-live para status updates
- [ ] Instru√ß√µes via aria-describedby
- [ ] Testado com screen reader

### Best Practices

1. **Use HTML sem√¢ntico** (menos ARIA = melhor)
2. **NUNCA remova outline** sem substituir
3. **Teste com teclado** e screen reader
4. **Ferramentas autom√°ticas** (axe, Lighthouse)
5. **Contrast checker** para cores

### Filosofia

**"Accessibility is not optional."**

~15% da popula√ß√£o tem alguma defici√™ncia. Formul√°rios inacess√≠veis **excluem** milh√µes. Al√©m de √©tica, h√° **leis** (ADA, LBI) exigindo acessibilidade. E b√¥nus: forms acess√≠veis s√£o **melhores para todos** (labels claros, erros descritivos, keyboard shortcuts).

**Dominar acessibilidade = inclus√£o + compliance legal + melhor UX universal.**

---

## üìñ Recursos Adicionais

**Documenta√ß√£o:**
- WCAG 2.1: https://www.w3.org/WAI/WCAG21/quickref/
- MDN ARIA: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA
- WebAIM: https://webaim.org/

**Ferramentas:**
- axe DevTools: Chrome extension
- WAVE: https://wave.webaim.org/
- Contrast Checker: https://webaim.org/resources/contrastchecker/

**Screen Readers:**
- NVDA (Windows): https://www.nvaccess.org/
- VoiceOver (Mac): Built-in (Cmd+F5)
- JAWS (Windows): https://www.freedomscientific.com/products/software/jaws/

**M√≥dulo 10 - FORMUL√ÅRIOS completo! üéâ**
