# Formul√°rios N√£o Controlados no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Formul√°rios N√£o Controlados** representam uma abordagem onde o **DOM** mant√©m o estado dos inputs, ao inv√©s do estado React. O componente acessa valores atrav√©s de **refs** apenas quando necess√°rio (ex: no submit), eliminando sincroniza√ß√£o cont√≠nua entre DOM e React. √â o padr√£o **tradicional HTML** - valores vivem no DOM, React l√™ sob demanda.

Essa abordagem **inverte** o fluxo de formul√°rios controlados: ao inv√©s de `state ‚Üí DOM` (controlled), temos `DOM ‚Üí ref.current.value` (uncontrolled). √ötil para **forms simples**, **integra√ß√£o com libs n√£o-React**, ou quando **performance de sincroniza√ß√£o** √© cr√≠tica. Trade-off: menos controle imediato, mais simplicidade.

**Filosofia:** "Sometimes the DOM knows best." Nem todo input precisa ser sincronizado com React state. Para forms read-only-on-submit (ex: login b√°sico), uncontrolled reduz boilerplate e re-renders. **Pragmatismo sobre purismo.**

### Import√¢ncia no Ecossistema

Formul√°rios n√£o controlados s√£o **essenciais** para:

- **Simplicidade**: Forms pequenos sem valida√ß√£o complexa
- **Performance**: Evitar re-renders a cada keystroke
- **Integra√ß√£o**: Trabalhar com jQuery, D3, ou libs DOM-diretas
- **File inputs**: `<input type="file">` s√£o **sempre** n√£o controlados

**Contexto:** N√£o s√£o "antipattern" - s√£o **ferramenta certa** para casos espec√≠ficos. React docs recomendam **controlled como padr√£o**, mas uncontrolled para casos pontuais.

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **useRef para Formul√°rios**: Acessar valores sem state
2. **defaultValue vs value**: Diferen√ßas cr√≠ticas
3. **Form Submit Pattern**: Ler todos valores no submit
4. **File Inputs**: Sempre n√£o controlados
5. **Quando Usar**: Controlled vs Uncontrolled

---

## üîç Fundamentos Te√≥ricos

### Source of Truth: DOM vs React

**Controlled:**
```
User digita ‚Üí onChange ‚Üí setState ‚Üí value prop ‚Üí DOM atualiza
```

**Uncontrolled:**
```
User digita ‚Üí DOM atualiza diretamente ‚Üí React l√™ via ref quando necess√°rio
```

### useRef: Ponte para o DOM

`useRef` cria uma **refer√™ncia mut√°vel** que persiste entre renders:

```javascript
const inputRef = useRef(null);
// inputRef.current === DOM element ap√≥s mount
```

Diferente de `useState`:
- `useRef` **n√£o causa re-render** ao mudar `.current`
- Acesso **direto** ao DOM element
- Ideal para leitura **pontual** de valores

---

## üîç An√°lise Conceitual Profunda

### 10.2.1 useRef para Acessar Valores

**Exemplo b√°sico:**
```javascript
function UncontrolledForm() {
  const nameRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Nome:', nameRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={nameRef}
        type="text"
        name="name"
        defaultValue="Jo√£o"
      />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Sem sincroniza√ß√£o cont√≠nua** - valor s√≥ √© lido no submit.

**M√∫ltiplos inputs:**
```javascript
function MultiInputUncontrolled() {
  const nameRef = useRef(null);
  const emailRef = useRef(null);
  const passwordRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();

    const formData = {
      name: nameRef.current.value,
      email: emailRef.current.value,
      password: passwordRef.current.value
    };

    console.log('Form data:', formData);
    // Enviar para API
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={nameRef} type="text" name="name" />
      <input ref={emailRef} type="email" name="email" />
      <input ref={passwordRef} type="password" name="password" />
      <button type="submit">Login</button>
    </form>
  );
}
```

### 10.2.2 defaultValue vs value

**Diferen√ßa crucial:**

```javascript
// ‚ùå ERRO: Controlled input sem onChange
<input value="Jo√£o" />
// Warning: You provided a `value` prop without an `onChange` handler.

// ‚úÖ Uncontrolled: defaultValue define valor inicial
<input defaultValue="Jo√£o" />
// Valor inicial "Jo√£o", mas usu√°rio pode editar livremente
```

**value (controlled):**
```javascript
const [name, setName] = useState('Jo√£o');
<input value={name} onChange={(e) => setName(e.target.value)} />
// value SEMPRE sincronizado com state
```

**defaultValue (uncontrolled):**
```javascript
const nameRef = useRef(null);
<input ref={nameRef} defaultValue="Jo√£o" />
// defaultValue define inicial, depois DOM controla
```

**Exemplo: Valor inicial din√¢mico**
```javascript
function EditProfile({ user }) {
  const nameRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Novo nome:', nameRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={nameRef}
        defaultValue={user.name} // Valor inicial do usu√°rio
      />
      <button type="submit">Atualizar</button>
    </form>
  );
}
```

### 10.2.3 FormData API: Pattern Moderno

**Alternativa a m√∫ltiplos refs:**
```javascript
function FormDataExample() {
  const handleSubmit = (e) => {
    e.preventDefault();

    // FormData extrai TODOS valores do form
    const formData = new FormData(e.target);

    // Converter para objeto
    const data = Object.fromEntries(formData);

    console.log(data);
    // { name: "Jo√£o", email: "joao@example.com", age: "25" }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" type="text" defaultValue="Jo√£o" />
      <input name="email" type="email" defaultValue="joao@example.com" />
      <input name="age" type="number" defaultValue="25" />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Vantagens:**
- Sem refs necess√°rios
- Funciona com qualquer n√∫mero de inputs
- Nativo do browser (√≥tima performance)

**Enviar para API:**
```javascript
const handleSubmit = async (e) => {
  e.preventDefault();
  const formData = new FormData(e.target);

  // Enviar como JSON
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(Object.fromEntries(formData))
  });

  // OU enviar como multipart (com arquivos)
  const response = await fetch('/api/upload', {
    method: 'POST',
    body: formData // FormData suporta files nativamente
  });
};
```

### 10.2.4 File Inputs: Sempre N√£o Controlados

**File inputs s√£o SEMPRE uncontrolled:**
```javascript
function FileUpload() {
  const fileRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();

    const file = fileRef.current.files[0];
    console.log('File:', file.name, file.size);

    // Upload
    const formData = new FormData();
    formData.append('file', file);

    fetch('/api/upload', {
      method: 'POST',
      body: formData
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={fileRef} type="file" />
      <button type="submit">Upload</button>
    </form>
  );
}
```

**Por que sempre uncontrolled?**
- File inputs s√£o **read-only** por seguran√ßa (n√£o pode setar valor programaticamente)
- `value` sempre retorna `C:\\fakepath\\file.txt` (fake path)
- Acesso real via `files` array: `input.files[0]`

**Multiple files:**
```javascript
function MultiFileUpload() {
  const filesRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();

    const files = Array.from(filesRef.current.files);
    console.log(`${files.length} arquivos selecionados`);

    files.forEach(file => {
      console.log(file.name, file.type, file.size);
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={filesRef} type="file" multiple />
      <button type="submit">Upload</button>
    </form>
  );
}
```

**Preview de imagem:**
```javascript
function ImageUploadWithPreview() {
  const fileRef = useRef(null);
  const [preview, setPreview] = useState(null);

  const handleFileChange = () => {
    const file = fileRef.current.files[0];

    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreview(reader.result);
      };
      reader.readAsDataURL(file);
    }
  };

  return (
    <div>
      <input
        ref={fileRef}
        type="file"
        accept="image/*"
        onChange={handleFileChange}
      />
      {preview && <img src={preview} alt="Preview" style={{ maxWidth: '200px' }} />}
    </div>
  );
}
```

### 10.2.5 Reset de Formul√°rio

**Pattern para resetar:**
```javascript
function FormWithReset() {
  const formRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    console.log(Object.fromEntries(formData));

    // Reset nativo do form
    formRef.current.reset();
  };

  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input name="name" type="text" defaultValue="Jo√£o" />
      <input name="email" type="email" />
      <button type="submit">Enviar</button>
      <button type="button" onClick={() => formRef.current.reset()}>
        Limpar
      </button>
    </form>
  );
}
```

**Reset program√°tico de input espec√≠fico:**
```javascript
function ResetSpecificInput() {
  const nameRef = useRef(null);

  const handleReset = () => {
    nameRef.current.value = ''; // Reset manual
    nameRef.current.focus();
  };

  return (
    <div>
      <input ref={nameRef} type="text" defaultValue="Jo√£o" />
      <button onClick={handleReset}>Limpar Nome</button>
    </div>
  );
}
```

### 10.2.6 Valida√ß√£o em Formul√°rios N√£o Controlados

**HTML5 validation:**
```javascript
function UncontrolledValidation() {
  const handleSubmit = (e) => {
    e.preventDefault();

    // checkValidity() retorna true/false
    if (e.target.checkValidity()) {
      const formData = new FormData(e.target);
      console.log('Valid:', Object.fromEntries(formData));
    } else {
      console.log('Form inv√°lido');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        type="email"
        required
        pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$"
      />
      <input
        name="age"
        type="number"
        min="18"
        max="120"
        required
      />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Valida√ß√£o custom com refs:**
```javascript
function CustomValidationUncontrolled() {
  const emailRef = useRef(null);
  const passwordRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();

    const email = emailRef.current.value;
    const password = passwordRef.current.value;

    // Valida√ß√£o manual
    if (!email.includes('@')) {
      alert('Email inv√°lido');
      emailRef.current.focus();
      return;
    }

    if (password.length < 6) {
      alert('Senha deve ter no m√≠nimo 6 caracteres');
      passwordRef.current.focus();
      return;
    }

    console.log('Form v√°lido', { email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={emailRef} type="email" name="email" />
      <input ref={passwordRef} type="password" name="password" />
      <button type="submit">Login</button>
    </form>
  );
}
```

### 10.2.7 Mixando Controlled e Uncontrolled

**√â poss√≠vel combinar ambos:**
```javascript
function MixedForm() {
  // Controlled: Campo que precisa valida√ß√£o real-time
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');

  // Uncontrolled: Campos simples
  const nameRef = useRef(null);
  const phoneRef = useRef(null);

  const handleEmailChange = (e) => {
    const value = e.target.value;
    setEmail(value);

    // Valida√ß√£o real-time
    if (!value.includes('@')) {
      setEmailError('Email inv√°lido');
    } else {
      setEmailError('');
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    const formData = {
      name: nameRef.current.value,
      email: email, // Do state
      phone: phoneRef.current.value
    };

    console.log(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Uncontrolled */}
      <input ref={nameRef} type="text" name="name" />

      {/* Controlled (valida√ß√£o real-time) */}
      <div>
        <input
          type="email"
          value={email}
          onChange={handleEmailChange}
        />
        {emailError && <span style={{ color: 'red' }}>{emailError}</span>}
      </div>

      {/* Uncontrolled */}
      <input ref={phoneRef} type="tel" name="phone" />

      <button type="submit">Enviar</button>
    </form>
  );
}
```

### 10.2.8 Integra√ß√£o com Bibliotecas N√£o-React

**Exemplo: jQuery plugin**
```javascript
function JQueryIntegration() {
  const datePickerRef = useRef(null);

  useEffect(() => {
    // jQuery datepicker (exemplo hipot√©tico)
    $(datePickerRef.current).datepicker({
      dateFormat: 'dd/mm/yy',
      onSelect: (dateText) => {
        console.log('Data selecionada:', dateText);
      }
    });

    // Cleanup
    return () => {
      $(datePickerRef.current).datepicker('destroy');
    };
  }, []);

  const handleSubmit = (e) => {
    e.preventDefault();
    // Ler valor do jQuery datepicker
    const date = datePickerRef.current.value;
    console.log('Data:', date);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={datePickerRef} type="text" />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Exemplo: Web Component**
```javascript
function WebComponentIntegration() {
  const customInputRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    // Ler valor de web component custom
    const value = customInputRef.current.value;
    console.log('Custom value:', value);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Web Component custom (n√£o-React) */}
      <custom-input ref={customInputRef} />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Formul√°rios N√£o Controlados

**‚úÖ Use uncontrolled quando:**

1. **Form simples de submit**
   ```javascript
   // Login b√°sico - s√≥ l√™ no submit
   <form onSubmit={handleLogin}>
     <input name="email" type="email" />
     <input name="password" type="password" />
     <button>Login</button>
   </form>
   ```

2. **Performance cr√≠tica**
   ```javascript
   // Textarea grande - evitar re-render a cada keystroke
   <textarea ref={textRef} defaultValue={initialText} />
   ```

3. **File inputs (sempre)**
   ```javascript
   <input ref={fileRef} type="file" />
   ```

4. **Integra√ß√£o com libs n√£o-React**
   ```javascript
   // jQuery, D3, Web Components
   <input ref={jQueryPluginRef} />
   ```

5. **Formul√°rios legados**
   ```javascript
   // Migrar HTML tradicional para React
   <form onSubmit={handleSubmit}>
     {/* Manter comportamento HTML nativo */}
   </form>
   ```

### Quando N√ÉO Usar (Usar Controlled)

**‚ùå Evite uncontrolled quando:**

1. **Valida√ß√£o em tempo real necess√°ria**
   ```javascript
   // Mostrar erro enquanto digita
   const [email, setEmail] = useState('');
   const error = !email.includes('@') && email.length > 0;
   ```

2. **Valores interdependentes**
   ```javascript
   // Senha e confirmar senha devem ser comparadas
   const [password, setPassword] = useState('');
   const [confirmPassword, setConfirmPassword] = useState('');
   const match = password === confirmPassword;
   ```

3. **Formatting/masking inputs**
   ```javascript
   // CPF, telefone com m√°scara
   const [phone, setPhone] = useState('');
   const masked = formatPhone(phone); // (11) 99999-9999
   ```

4. **Conditional rendering baseado em input**
   ```javascript
   // Mostrar campo extra se tipo === 'outro'
   const [tipo, setTipo] = useState('');
   {tipo === 'outro' && <input name="outro_especificar" />}
   ```

5. **Submit disabled at√© valid**
   ```javascript
   const [valid, setValid] = useState(false);
   <button disabled={!valid}>Enviar</button>
   ```

### Decision Matrix: Controlled vs Uncontrolled

| Crit√©rio | Controlled | Uncontrolled |
|----------|-----------|-------------|
| **Valida√ß√£o real-time** | ‚úÖ Ideal | ‚ùå Complexo |
| **Formatting** | ‚úÖ F√°cil | ‚ùå Manual |
| **Performance** | ‚ö†Ô∏è Re-renders | ‚úÖ Sem re-renders |
| **Simplicidade** | ‚ö†Ô∏è Boilerplate | ‚úÖ Menos c√≥digo |
| **Conditional logic** | ‚úÖ Natural | ‚ùå Dif√≠cil |
| **File inputs** | ‚ùå Imposs√≠vel | ‚úÖ √önica op√ß√£o |
| **Integra√ß√£o externa** | ‚ö†Ô∏è Dif√≠cil | ‚úÖ F√°cil |

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Performance

**Uncontrolled N√ÉO significa sempre melhor:**
```javascript
// ‚ùå Mito: "Uncontrolled √© sempre mais r√°pido"
// Para forms pequenos, diferen√ßa √© impercept√≠vel

// Controlled com 5 inputs: ~0.5ms extra per keystroke
// Impacto real: ZERO para usu√°rio

// ‚úÖ Use uncontrolled por simplicidade, n√£o por micro-otimiza√ß√£o
```

### Testabilidade

**Uncontrolled √© mais dif√≠cil de testar:**
```javascript
// Controlled: f√°cil
render(<ControlledInput />);
fireEvent.change(screen.getByRole('textbox'), { target: { value: 'test' } });
expect(screen.getByRole('textbox')).toHaveValue('test');

// Uncontrolled: precisa mockar refs
const ref = createRef();
render(<input ref={ref} />);
ref.current.value = 'test'; // N√£o dispara eventos React
```

### Acessibilidade

**Valida√ß√£o uncontrolled pode atrasar feedback:**
```javascript
// ‚ùå Erro s√≥ aparece no submit (UX ruim)
<form onSubmit={validate}>
  <input name="email" />
</form>

// ‚úÖ Erro aparece enquanto digita (controlled)
<input value={email} onChange={handleChange} />
{error && <span>{error}</span>}
```

### Refs e SSR

**useRef n√£o funciona em SSR:**
```javascript
// ‚ö†Ô∏è ref.current √© null no servidor
const inputRef = useRef(null);

// Sempre checar antes de usar
if (inputRef.current) {
  inputRef.current.value;
}
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useState

**Controlled = useState + input**
```javascript
const [value, setValue] = useState('');
<input value={value} onChange={(e) => setValue(e.target.value)} />
```

**Uncontrolled = useRef + input**
```javascript
const valueRef = useRef(null);
<input ref={valueRef} defaultValue="" />
```

### Rela√ß√£o com useEffect

**Sincronizar ref com state (se necess√°rio):**
```javascript
const inputRef = useRef(null);
const [value, setValue] = useState('');

// Ler ref ao montar
useEffect(() => {
  setValue(inputRef.current.value);
}, []);
```

### Rela√ß√£o com Custom Hooks

**Abstrair pattern uncontrolled:**
```javascript
function useFormData() {
  const formRef = useRef(null);

  const getFormData = useCallback(() => {
    if (!formRef.current) return {};
    const formData = new FormData(formRef.current);
    return Object.fromEntries(formData);
  }, []);

  const resetForm = useCallback(() => {
    formRef.current?.reset();
  }, []);

  return { formRef, getFormData, resetForm };
}

// Uso
function MyForm() {
  const { formRef, getFormData, resetForm } = useFormData();

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(getFormData());
    resetForm();
  };

  return (
    <form ref={formRef} onSubmit={handleSubmit}>
      <input name="name" />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### De Uncontrolled para Controlled

**Migration path:**
```javascript
// 1. Uncontrolled (inicial)
<input ref={nameRef} defaultValue="" />

// 2. Adicionar state
const [name, setName] = useState('');
<input ref={nameRef} defaultValue={name} />

// 3. Sincronizar onChange
<input
  ref={nameRef}
  value={name}
  onChange={(e) => setName(e.target.value)}
/>

// 4. Remover ref (totalmente controlled)
<input value={name} onChange={(e) => setName(e.target.value)} />
```

### Pr√≥ximos Passos

Este m√≥dulo introduziu formul√°rios n√£o controlados. Pr√≥ximos t√≥picos:

1. **10.3 Valida√ß√£o de Formul√°rios** - Schemas, yup/zod
2. **10.4 Formul√°rios Complexos** - Multi-step, arrays din√¢micos
3. **10.5 Form Libraries** - React Hook Form, Formik

**Prepara√ß√£o:** Formul√°rios n√£o controlados s√£o base para entender como bibliotecas como React Hook Form funcionam (usam uncontrolled + refs internamente).

---

## üìö Conclus√£o

### Pontos-Chave

Formul√°rios n√£o controlados representam abordagem **pragm√°tica** para forms simples:

1. **DOM como source of truth** (vs state React)
2. **useRef para acesso pontual** de valores
3. **defaultValue** (n√£o value) para valores iniciais
4. **FormData API** para extrair todos valores
5. **File inputs sempre uncontrolled**

### Quando Usar

**Use uncontrolled para:**
- Forms simples de submit
- File uploads
- Integra√ß√£o com libs n√£o-React
- Performance cr√≠tica (textarea grande)

**Use controlled para:**
- Valida√ß√£o em tempo real
- Formatting/masking
- L√≥gica condicional
- Valores interdependentes

### Filosofia

**"Use controlled by default, uncontrolled when pragmatic."**

React docs recomendam controlled como padr√£o, mas uncontrolled n√£o √© antipattern - √© ferramenta para casos espec√≠ficos. Escolha baseada em **necessidade**, n√£o dogma.

**Dominar ambos paradigmas = flexibilidade para escolher solu√ß√£o certa.**
