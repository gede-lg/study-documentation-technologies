# ValidaÃ§Ã£o de FormulÃ¡rios no React

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**ValidaÃ§Ã£o de FormulÃ¡rios** Ã© o processo de **verificar** se dados do usuÃ¡rio atendem critÃ©rios especÃ­ficos antes de processÃ¡-los. No React, validaÃ§Ã£o pode ocorrer em **trÃªs momentos**: **onChange** (tempo real), **onBlur** (ao sair do campo), ou **onSubmit** (ao enviar). Cada timing tem trade-offs de **UX vs performance**.

ValidaÃ§Ã£o envolve **regras** (required, email, min/max length) e **feedback** (mensagens de erro, estilos visuais). React oferece flexibilidade total - desde **HTML5 validation** nativa atÃ© **schemas complexos** com Yup/Zod. O objetivo: **prevenir erros** antes de chegarem ao backend, melhorando UX e reduzindo requisiÃ§Ãµes invÃ¡lidas.

**Filosofia:** "Validate early, fail fast, guide clearly." UsuÃ¡rios merecem feedback **imediato** e **claro** sobre o que estÃ¡ errado e como corrigir. Boa validaÃ§Ã£o Ã© **invisÃ­vel quando funciona** e **Ãºtil quando falha**.

### ImportÃ¢ncia no Ecossistema

ValidaÃ§Ã£o Ã© **crÃ­tica** para:

- **SeguranÃ§a**: Prevenir SQL injection, XSS
- **Integridade de dados**: Garantir formato correto
- **UX**: Feedback antes de submit (economiza tempo do usuÃ¡rio)
- **Performance**: Evitar requisiÃ§Ãµes invÃ¡lidas ao backend

**Contexto:** Frontend validation Ã© **primeira linha de defesa**, mas **nunca substitui** backend validation (usuÃ¡rio pode bypassar frontend).

---

## ğŸ“‹ SumÃ¡rio Conceitual

### TÃ³picos Cobertos

1. **ValidaÃ§Ã£o HTML5 Nativa**: required, pattern, min/max
2. **ValidaÃ§Ã£o onChange**: Tempo real
3. **ValidaÃ§Ã£o onBlur**: Ao sair do campo
4. **ValidaÃ§Ã£o onSubmit**: No envio
5. **Custom Validators**: Regras complexas
6. **Yup/Zod Schemas**: ValidaÃ§Ã£o declarativa

---

## ğŸ” Fundamentos TeÃ³ricos

### Timings de ValidaÃ§Ã£o

**1. onChange (Real-time):**
- Valida **enquanto** usuÃ¡rio digita
- **Pros:** Feedback instantÃ¢neo
- **Cons:** Pode ser intrusivo (mostrar erro antes de terminar)

**2. onBlur (On exit):**
- Valida quando campo **perde foco**
- **Pros:** Menos intrusivo, valida campo completo
- **Cons:** Atrasa feedback atÃ© sair do campo

**3. onSubmit (On submit):**
- Valida ao **submeter** form
- **Pros:** NÃ£o interrompe digitaÃ§Ã£o
- **Cons:** Feedback tardio (usuÃ¡rio jÃ¡ preencheu tudo)

**Best practice:** **HÃ­brido** - onSubmit primeira vez, onChange apÃ³s primeiro erro.

### Client-Side vs Server-Side

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Input     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client Validate â”‚ â—„â”€â”€ Previne erros Ã³bvios, UX
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Server Validate â”‚ â—„â”€â”€ SeguranÃ§a, fonte de verdade
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Database      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**NUNCA confie apenas em client-side validation.**

---

## ğŸ” AnÃ¡lise Conceitual Profunda

### 10.3.1 ValidaÃ§Ã£o HTML5 Nativa

**Atributos de validaÃ§Ã£o:**
```javascript
function HTML5Validation() {
  return (
    <form>
      {/* Required */}
      <input type="text" name="name" required />

      {/* Email */}
      <input type="email" name="email" required />

      {/* Pattern (regex) */}
      <input
        type="text"
        name="cpf"
        pattern="\d{3}\.\d{3}\.\d{3}-\d{2}"
        title="Formato: 123.456.789-00"
      />

      {/* Min/Max length */}
      <input
        type="password"
        name="password"
        minLength="8"
        maxLength="20"
        required
      />

      {/* Min/Max value */}
      <input
        type="number"
        name="age"
        min="18"
        max="120"
        required
      />

      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Mensagens custom:**
```javascript
function CustomMessages() {
  const handleInvalid = (e) => {
    e.target.setCustomValidity('Este campo Ã© obrigatÃ³rio!');
  };

  const handleInput = (e) => {
    e.target.setCustomValidity(''); // Reset mensagem
  };

  return (
    <input
      type="email"
      required
      onInvalid={handleInvalid}
      onInput={handleInput}
    />
  );
}
```

**Desabilitar validaÃ§Ã£o nativa:**
```javascript
// Ãštil quando usar validaÃ§Ã£o custom
<form noValidate onSubmit={handleSubmit}>
  {/* ValidaÃ§Ã£o manual via JS */}
</form>
```

### 10.3.2 ValidaÃ§Ã£o onChange (Tempo Real)

**Exemplo bÃ¡sico:**
```javascript
function RealtimeValidation() {
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');

  const validateEmail = (value) => {
    if (!value) {
      return 'Email Ã© obrigatÃ³rio';
    }
    if (!/\S+@\S+\.\S+/.test(value)) {
      return 'Email invÃ¡lido';
    }
    return '';
  };

  const handleChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    setEmailError(validateEmail(value));
  };

  return (
    <div>
      <input
        type="email"
        value={email}
        onChange={handleChange}
        style={{ borderColor: emailError ? 'red' : 'initial' }}
      />
      {emailError && <span style={{ color: 'red' }}>{emailError}</span>}
    </div>
  );
}
```

**Problema: Feedback prematuro**
```javascript
// âŒ Mostra erro antes de terminar
// UsuÃ¡rio digita "j" â†’ "Email invÃ¡lido"
// UsuÃ¡rio digita "jo" â†’ "Email invÃ¡lido"
// Ruim!
```

**SoluÃ§Ã£o: Validar sÃ³ apÃ³s perder foco pela primeira vez**
```javascript
function SmartValidation() {
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');
  const [touched, setTouched] = useState(false);

  const validateEmail = (value) => {
    if (!value) return 'Email Ã© obrigatÃ³rio';
    if (!/\S+@\S+\.\S+/.test(value)) return 'Email invÃ¡lido';
    return '';
  };

  const handleChange = (e) => {
    const value = e.target.value;
    setEmail(value);

    // SÃ³ valida se jÃ¡ tocou no campo
    if (touched) {
      setEmailError(validateEmail(value));
    }
  };

  const handleBlur = () => {
    setTouched(true);
    setEmailError(validateEmail(email));
  };

  return (
    <div>
      <input
        type="email"
        value={email}
        onChange={handleChange}
        onBlur={handleBlur}
        style={{ borderColor: emailError ? 'red' : 'initial' }}
      />
      {emailError && <span style={{ color: 'red' }}>{emailError}</span>}
    </div>
  );
}
```

### 10.3.3 ValidaÃ§Ã£o onBlur

**Validar ao sair do campo:**
```javascript
function BlurValidation() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  const [errors, setErrors] = useState({});

  const validators = {
    name: (value) => {
      if (!value) return 'Nome Ã© obrigatÃ³rio';
      if (value.length < 3) return 'Nome deve ter no mÃ­nimo 3 caracteres';
      return '';
    },
    email: (value) => {
      if (!value) return 'Email Ã© obrigatÃ³rio';
      if (!/\S+@\S+\.\S+/.test(value)) return 'Email invÃ¡lido';
      return '';
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleBlur = (e) => {
    const { name, value } = e.target;
    const error = validators[name](value);
    setErrors(prev => ({ ...prev, [name]: error }));
  };

  return (
    <form>
      <div>
        <input
          name="name"
          value={formData.name}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>

      <div>
        <input
          name="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>
    </form>
  );
}
```

### 10.3.4 ValidaÃ§Ã£o onSubmit

**Validar ao submeter:**
```javascript
function SubmitValidation() {
  const [formData, setFormData] = useState({ name: '', email: '', password: '' });
  const [errors, setErrors] = useState({});

  const validateForm = () => {
    const newErrors = {};

    if (!formData.name) {
      newErrors.name = 'Nome Ã© obrigatÃ³rio';
    }

    if (!formData.email) {
      newErrors.email = 'Email Ã© obrigatÃ³rio';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email invÃ¡lido';
    }

    if (!formData.password) {
      newErrors.password = 'Senha Ã© obrigatÃ³ria';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Senha deve ter no mÃ­nimo 8 caracteres';
    }

    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    const validationErrors = validateForm();

    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    // Form vÃ¡lido
    console.log('Enviando:', formData);
    setErrors({});
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));

    // Limpar erro ao digitar (apÃ³s primeiro submit)
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>

      <div>
        <input
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>

      <div>
        <input
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
        />
        {errors.password && <span style={{ color: 'red' }}>{errors.password}</span>}
      </div>

      <button type="submit">Enviar</button>
    </form>
  );
}
```

### 10.3.5 Validadores Custom Complexos

**ValidaÃ§Ã£o assÃ­ncrona (check username disponÃ­vel):**
```javascript
function AsyncValidation() {
  const [username, setUsername] = useState('');
  const [usernameError, setUsernameError] = useState('');
  const [checking, setChecking] = useState(false);

  const checkUsernameAvailable = async (username) => {
    setChecking(true);
    try {
      const response = await fetch(`/api/check-username?username=${username}`);
      const data = await response.json();
      return data.available;
    } finally {
      setChecking(false);
    }
  };

  const handleBlur = async () => {
    if (!username) {
      setUsernameError('Username Ã© obrigatÃ³rio');
      return;
    }

    const available = await checkUsernameAvailable(username);
    if (!available) {
      setUsernameError('Username jÃ¡ estÃ¡ em uso');
    } else {
      setUsernameError('');
    }
  };

  return (
    <div>
      <input
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        onBlur={handleBlur}
      />
      {checking && <span>Verificando...</span>}
      {usernameError && <span style={{ color: 'red' }}>{usernameError}</span>}
      {!usernameError && username && !checking && (
        <span style={{ color: 'green' }}>âœ“ DisponÃ­vel</span>
      )}
    </div>
  );
}
```

**ValidaÃ§Ã£o com debounce:**
```javascript
function DebouncedValidation() {
  const [username, setUsername] = useState('');
  const [usernameError, setUsernameError] = useState('');
  const [checking, setChecking] = useState(false);

  // Debounce para evitar chamar API a cada keystroke
  useEffect(() => {
    if (!username) {
      setUsernameError('');
      return;
    }

    setChecking(true);
    const timeoutId = setTimeout(async () => {
      const response = await fetch(`/api/check-username?username=${username}`);
      const data = await response.json();

      if (!data.available) {
        setUsernameError('Username jÃ¡ estÃ¡ em uso');
      } else {
        setUsernameError('');
      }
      setChecking(false);
    }, 500); // 500ms debounce

    return () => clearTimeout(timeoutId);
  }, [username]);

  return (
    <div>
      <input
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      {checking && <span>Verificando...</span>}
      {usernameError && <span style={{ color: 'red' }}>{usernameError}</span>}
      {!usernameError && username && !checking && (
        <span style={{ color: 'green' }}>âœ“ DisponÃ­vel</span>
      )}
    </div>
  );
}
```

**ValidaÃ§Ã£o dependente (senha e confirmar senha):**
```javascript
function DependentValidation() {
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [errors, setErrors] = useState({});

  const validatePasswords = () => {
    const newErrors = {};

    if (!password) {
      newErrors.password = 'Senha Ã© obrigatÃ³ria';
    } else if (password.length < 8) {
      newErrors.password = 'Senha deve ter no mÃ­nimo 8 caracteres';
    }

    if (!confirmPassword) {
      newErrors.confirmPassword = 'Confirme sua senha';
    } else if (password !== confirmPassword) {
      newErrors.confirmPassword = 'Senhas nÃ£o conferem';
    }

    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const validationErrors = validatePasswords();

    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
    } else {
      console.log('Senhas vÃ¡lidas!');
      setErrors({});
    }
  };

  // Validar em tempo real apÃ³s digitar em ambos campos
  useEffect(() => {
    if (password && confirmPassword) {
      setErrors(validatePasswords());
    }
  }, [password, confirmPassword]);

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Senha"
        />
        {errors.password && <span style={{ color: 'red' }}>{errors.password}</span>}
      </div>

      <div>
        <input
          type="password"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          placeholder="Confirmar senha"
        />
        {errors.confirmPassword && (
          <span style={{ color: 'red' }}>{errors.confirmPassword}</span>
        )}
      </div>

      <button type="submit">Enviar</button>
    </form>
  );
}
```

### 10.3.6 ValidaÃ§Ã£o com Yup

**Schema declarativo:**
```javascript
import * as yup from 'yup';

const schema = yup.object().shape({
  name: yup
    .string()
    .required('Nome Ã© obrigatÃ³rio')
    .min(3, 'Nome deve ter no mÃ­nimo 3 caracteres'),
  email: yup
    .string()
    .required('Email Ã© obrigatÃ³rio')
    .email('Email invÃ¡lido'),
  age: yup
    .number()
    .required('Idade Ã© obrigatÃ³ria')
    .min(18, 'Deve ser maior de 18 anos')
    .max(120, 'Idade invÃ¡lida'),
  password: yup
    .string()
    .required('Senha Ã© obrigatÃ³ria')
    .min(8, 'Senha deve ter no mÃ­nimo 8 caracteres')
    .matches(/[A-Z]/, 'Senha deve conter ao menos uma letra maiÃºscula')
    .matches(/[0-9]/, 'Senha deve conter ao menos um nÃºmero'),
  confirmPassword: yup
    .string()
    .oneOf([yup.ref('password')], 'Senhas nÃ£o conferem')
    .required('Confirme sua senha')
});

function YupValidation() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState({});

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      // Valida dados contra schema
      await schema.validate(formData, { abortEarly: false });

      // Se chegou aqui, estÃ¡ vÃ¡lido
      console.log('Form vÃ¡lido:', formData);
      setErrors({});
    } catch (err) {
      // err.inner contÃ©m todos erros
      const validationErrors = {};
      err.inner.forEach((error) => {
        validationErrors[error.path] = error.message;
      });
      setErrors(validationErrors);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input name="name" value={formData.name} onChange={handleChange} />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>

      <div>
        <input name="email" value={formData.email} onChange={handleChange} />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>

      <div>
        <input name="age" type="number" value={formData.age} onChange={handleChange} />
        {errors.age && <span style={{ color: 'red' }}>{errors.age}</span>}
      </div>

      <div>
        <input
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
        />
        {errors.password && <span style={{ color: 'red' }}>{errors.password}</span>}
      </div>

      <div>
        <input
          name="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleChange}
        />
        {errors.confirmPassword && (
          <span style={{ color: 'red' }}>{errors.confirmPassword}</span>
        )}
      </div>

      <button type="submit">Enviar</button>
    </form>
  );
}
```

**ValidaÃ§Ã£o individual de campo:**
```javascript
const handleBlur = async (e) => {
  const { name, value } = e.target;

  try {
    // Valida apenas um campo
    await schema.validateAt(name, { [name]: value });
    setErrors(prev => ({ ...prev, [name]: '' }));
  } catch (err) {
    setErrors(prev => ({ ...prev, [name]: err.message }));
  }
};
```

### 10.3.7 ValidaÃ§Ã£o com Zod

**Schema com Zod:**
```javascript
import { z } from 'zod';

const schema = z.object({
  name: z
    .string()
    .min(3, 'Nome deve ter no mÃ­nimo 3 caracteres')
    .max(50, 'Nome muito longo'),
  email: z
    .string()
    .email('Email invÃ¡lido'),
  age: z
    .number()
    .min(18, 'Deve ser maior de 18 anos')
    .max(120, 'Idade invÃ¡lida'),
  password: z
    .string()
    .min(8, 'Senha deve ter no mÃ­nimo 8 caracteres')
    .regex(/[A-Z]/, 'Senha deve conter letra maiÃºscula')
    .regex(/[0-9]/, 'Senha deve conter nÃºmero'),
  confirmPassword: z.string()
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Senhas nÃ£o conferem',
  path: ['confirmPassword']
});

function ZodValidation() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0,
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState({});

  const handleSubmit = (e) => {
    e.preventDefault();

    const result = schema.safeParse(formData);

    if (!result.success) {
      // Converter erros do Zod para objeto
      const validationErrors = {};
      result.error.errors.forEach((err) => {
        validationErrors[err.path[0]] = err.message;
      });
      setErrors(validationErrors);
    } else {
      console.log('Form vÃ¡lido:', result.data);
      setErrors({});
    }
  };

  const handleChange = (e) => {
    const { name, value, type } = e.target;
    const parsedValue = type === 'number' ? parseInt(value, 10) : value;
    setFormData(prev => ({ ...prev, [name]: parsedValue }));
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Similar ao exemplo Yup */}
    </form>
  );
}
```

### 10.3.8 Custom Hook para ValidaÃ§Ã£o

**Abstrair lÃ³gica de validaÃ§Ã£o:**
```javascript
function useFormValidation(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));

    // Validar se campo jÃ¡ foi tocado
    if (touched[name]) {
      const fieldErrors = validate({ ...values, [name]: value });
      setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));
    }
  };

  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));

    const fieldErrors = validate(values);
    setErrors(prev => ({ ...prev, [name]: fieldErrors[name] }));
  };

  const handleSubmit = (onSubmit) => (e) => {
    e.preventDefault();

    const validationErrors = validate(values);

    // Marcar todos campos como tocados
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);

    if (Object.keys(validationErrors).length === 0) {
      onSubmit(values);
    } else {
      setErrors(validationErrors);
    }
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit
  };
}

// Uso
function MyForm() {
  const validate = (values) => {
    const errors = {};

    if (!values.email) {
      errors.email = 'Email Ã© obrigatÃ³rio';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email invÃ¡lido';
    }

    if (!values.password) {
      errors.password = 'Senha Ã© obrigatÃ³ria';
    } else if (values.password.length < 8) {
      errors.password = 'Senha deve ter no mÃ­nimo 8 caracteres';
    }

    return errors;
  };

  const { values, errors, handleChange, handleBlur, handleSubmit } = useFormValidation(
    { email: '', password: '' },
    validate
  );

  const onSubmit = (values) => {
    console.log('Form enviado:', values);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          name="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>

      <div>
        <input
          name="password"
          type="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {errors.password && <span style={{ color: 'red' }}>{errors.password}</span>}
      </div>

      <button type="submit">Enviar</button>
    </form>
  );
}
```

---

## ğŸ¯ Aplicabilidade e Contextos

### Quando Usar Cada Timing

**onChange (tempo real):**
- Password strength meter
- Username availability (com debounce)
- Character counter
- Formatting (CPF, telefone)

**onBlur (ao sair):**
- Email, nome, endereÃ§o
- Campos que usuÃ¡rio digita de uma vez
- ValidaÃ§Ã£o que nÃ£o precisa ser instantÃ¢nea

**onSubmit (ao enviar):**
- Forms simples (2-3 campos)
- ValidaÃ§Ãµes complexas/pesadas
- ValidaÃ§Ã£o cross-field (senha === confirmPassword)

### Escolhendo Schema Library

**Yup:**
- âœ… Mais maduro, comunidade maior
- âœ… IntegraÃ§Ã£o nativa com Formik
- âŒ Bundle size maior (~15kb)

**Zod:**
- âœ… TypeScript-first (inferÃªncia de tipos)
- âœ… Bundle size menor (~8kb)
- âœ… Performance melhor
- âŒ Menos recursos que Yup

**Escolha:**
- TypeScript project â†’ **Zod**
- Formik â†’ **Yup**
- Performance crÃ­tica â†’ **Zod**

---

## âš ï¸ LimitaÃ§Ãµes e ConsideraÃ§Ãµes

### Security

**âŒ NUNCA confie apenas em frontend:**
```javascript
// Frontend validation Ã© UX, nÃ£o seguranÃ§a
// UsuÃ¡rio pode:
// - Desabilitar JS
// - Editar cÃ³digo no DevTools
// - Enviar request direto (curl, Postman)

// âœ… SEMPRE valide no backend tambÃ©m
```

### Performance

**ValidaÃ§Ã£o sÃ­ncrona pode bloquear:**
```javascript
// âŒ Regex complexo em onChange pode travar UI
const complexRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

// âœ… Use debounce ou valide em onBlur
const handleBlur = () => {
  setError(complexRegex.test(value) ? '' : 'Senha fraca');
};
```

### Accessibility

**Erros devem ser anunciados:**
```javascript
function AccessibleError({ error }) {
  return (
    <span
      role="alert"
      aria-live="polite"
      style={{ color: 'red' }}
    >
      {error}
    </span>
  );
}

// aria-live="polite" anuncia erro para screen readers
```

**Associar erro com input:**
```javascript
<input
  id="email"
  aria-describedby="email-error"
  aria-invalid={!!emailError}
/>
{emailError && (
  <span id="email-error" role="alert">
    {emailError}
  </span>
)}
```

---

## ğŸ”— InterconexÃµes Conceituais

### RelaÃ§Ã£o com Forms Controlados

ValidaÃ§Ã£o funciona melhor com controlled forms:
```javascript
// Controlled = acesso imediato ao valor
const [email, setEmail] = useState('');
const error = validateEmail(email); // FÃ¡cil!
```

### RelaÃ§Ã£o com Custom Hooks

ValidaÃ§Ã£o Ã© caso perfeito para custom hook:
```javascript
const { values, errors, handleChange, handleSubmit } = useForm(initialValues, validate);
```

### RelaÃ§Ã£o com useEffect

ValidaÃ§Ã£o assÃ­ncrona com debounce usa useEffect:
```javascript
useEffect(() => {
  const timeoutId = setTimeout(() => {
    checkUsernameAvailable(username);
  }, 500);
  return () => clearTimeout(timeoutId);
}, [username]);
```

---

## ğŸš€ EvoluÃ§Ã£o e PrÃ³ximos Conceitos

### PrÃ³ximos Passos

Este mÃ³dulo cobriu validaÃ§Ã£o fundamental. PrÃ³ximos tÃ³picos:

1. **10.4 FormulÃ¡rios Complexos** - Multi-step, arrays dinÃ¢micos
2. **10.5 Form Libraries** - React Hook Form, Formik (validaÃ§Ã£o integrada)
3. **10.6 Forms AcessÃ­veis** - ARIA, WCAG compliance

**PreparaÃ§Ã£o:** ValidaÃ§Ã£o Ã© base para form libraries - React Hook Form e Formik abstraem validaÃ§Ã£o com Yup/Zod de forma elegante.

---

## ğŸ“š ConclusÃ£o

### Pontos-Chave

ValidaÃ§Ã£o de formulÃ¡rios no React envolve:

1. **TrÃªs timings**: onChange (real-time), onBlur (on exit), onSubmit
2. **HTML5 validation** para casos simples
3. **Custom validators** para lÃ³gica complexa
4. **Schemas (Yup/Zod)** para validaÃ§Ã£o declarativa
5. **ValidaÃ§Ã£o assÃ­ncrona** com debounce
6. **Feedback claro** e acessÃ­vel

### Best Practices

1. **HÃ­brido:** onSubmit primeiro, onChange apÃ³s erro
2. **Debounce** validaÃ§Ãµes assÃ­ncronas
3. **SEMPRE valide no backend** (seguranÃ§a)
4. **Accessibility:** aria-live, aria-invalid
5. **DRY:** Custom hooks para reutilizar lÃ³gica

### Filosofia

**"Validate early, fail fast, guide clearly."**

ValidaÃ§Ã£o frontend Ã© sobre **UX** - prevenir erros antes de submit, economizar tempo do usuÃ¡rio, fornecer feedback claro. Mas **nunca substitui** backend validation (seguranÃ§a).

**Dominar validaÃ§Ã£o = forms robustos e user-friendly.**
