# Refs Avan√ßados: Callback Refs no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Callback Refs** s√£o uma forma alternativa de criar refs onde, ao inv√©s de passar objeto ref (`useRef`), voc√™ passa uma **fun√ß√£o callback** que React chama com o elemento DOM como argumento quando o elemento monta/desmonta. Conceitualmente, representam **controle fino sobre lifecycle de refs** - permitindo executar c√≥digo exatamente quando ref conecta/desconecta, sem depend√™ncias de `useEffect`, ideal para medi√ß√µes, integra√ß√µes com libs externas, e cen√°rios onde refs s√£o din√¢micas.

Na ess√™ncia, callback refs transformam refs de **containers passivos** (objeto com `.current`) em **hooks ativos** (fun√ß√µes executadas em momentos espec√≠ficos).

### Contexto Hist√≥rico e Motiva√ß√£o

Callback refs **precedem `useRef`** - existem desde primeiras vers√µes do React como √∫nica forma de acessar DOM em components funcionais (pr√©-Hooks). Com Hooks (2019), `useRef` tornou-se padr√£o por simplicidade, mas callback refs permaneceram para casos avan√ßados.

**Problemas que callback refs resolvem**:

1. **Timing Preciso**: `useRef` + `useEffect` tem delay. Callback executa **exatamente** quando elemento monta.

2. **Refs Din√¢micas**: Lista onde quantidade de elementos muda - dif√≠cil com `useRef` (quantos refs criar?).

3. **Cleanup Garantido**: Callback √© chamada com `null` quando elemento desmonta - cleanup autom√°tico.

4. **Medi√ß√µes S√≠ncronas**: Medir elemento logo ao montar, antes de qualquer pintura.

### Problema Fundamental que Resolve

**1. Timing de useEffect vs Callback Ref**:

```jsx
// useEffect - delay de um frame
function Component() {
  const divRef = useRef();

  useEffect(() => {
    console.log('Height:', divRef.current.offsetHeight);
    // Executa AP√ìS render e commit
  }, []);

  return <div ref={divRef}>Content</div>;
}

// Callback ref - imediato
function Component() {
  const measureRef = useCallback((node) => {
    if (node) {
      console.log('Height:', node.offsetHeight);
      // Executa DURANTE commit, antes de efeitos
    }
  }, []);

  return <div ref={measureRef}>Content</div>;
}
```

**2. Refs para Listas Din√¢micas**:

```jsx
// ‚ùå Dif√≠cil com useRef
function List({ items }) {
  // Quantos refs criar? items.length muda!
  const itemRefs = useRef([]);

  return items.map((item, i) => (
    <div key={item.id} ref={/* ??? */}>
      {item.text}
    </div>
  ));
}

// ‚úÖ F√°cil com callback ref
function List({ items }) {
  const itemRefs = useRef(new Map());

  const setRef = useCallback((node, id) => {
    if (node) {
      itemRefs.current.set(id, node);
    } else {
      itemRefs.current.delete(id);
    }
  }, []);

  return items.map(item => (
    <div key={item.id} ref={node => setRef(node, item.id)}>
      {item.text}
    </div>
  ));
}
```

**3. Integra√ß√£o com Lib Externa**:

```jsx
function Chart({ data }) {
  const chartInstanceRef = useRef();

  const chartRef = useCallback((canvas) => {
    if (canvas) {
      // Mount: criar chart
      chartInstanceRef.current = new ChartJS(canvas, { data });
    } else {
      // Unmount: destruir chart
      chartInstanceRef.current?.destroy();
    }
  }, [data]);

  return <canvas ref={chartRef} />;
}
```

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Fun√ß√£o como Ref**: Passar fun√ß√£o ao inv√©s de objeto
2. **Chamada Autom√°tica**: React chama fun√ß√£o quando elemento monta/desmonta
3. **Argumentos**: `node` (elemento DOM) ou `null` (unmount)
4. **Timing**: Durante commit phase, antes de `useLayoutEffect`
5. **Estabilidade**: Usar `useCallback` para evitar reconex√µes

### Pilares Fundamentais

- **Sintaxe**: `<element ref={(node) => { /* ... */ }} />`
- **Mount**: Callback chamada com DOM node
- **Unmount**: Callback chamada com `null`
- **Update**: Se callback muda, chamada com `null` (cleanup) e depois com novo node
- **Memoiza√ß√£o**: `useCallback` estabiliza callback

---

## üß† Fundamentos Te√≥ricos

### Como Callback Refs Funcionam

**Processo interno**:

```jsx
<div ref={(node) => console.log('Ref callback:', node)} />
```

1. **Render**: React cria elemento virtual com ref callback
2. **Commit**: React cria DOM node `<div>`
3. **Ref callback**: React chama `callback(domNode)`
4. **Unmount**: React chama `callback(null)` antes de remover DOM

**Timing preciso**:
```
Render ‚Üí DOM criado ‚Üí Ref callback ‚Üí useLayoutEffect ‚Üí Paint ‚Üí useEffect
```

**Compara√ß√£o**:
```jsx
// useRef object
<div ref={divRef} />
// React faz: divRef.current = domNode

// Callback ref
<div ref={(node) => console.log(node)} />
// React faz: callback(domNode)
```

---

## üîç An√°lise Conceitual Profunda

### Sintaxe B√°sica

#### Callback Inline

```jsx
function Component() {
  return (
    <div ref={(node) => {
      if (node) {
        console.log('Div mounted:', node);
        console.log('Height:', node.offsetHeight);
      } else {
        console.log('Div unmounted');
      }
    }}>
      Content
    </div>
  );
}
```

**An√°lise**:
- `node` √© DOM element quando monta
- `node` √© `null` quando desmonta
- Sempre checar `if (node)` antes de usar

#### Callback Est√°vel com useCallback

```jsx
function Component() {
  const divRef = useCallback((node) => {
    if (node) {
      console.log('Mounted');
    }
  }, []); // Depend√™ncias vazias = callback est√°vel

  return <div ref={divRef}>Content</div>;
}
```

**Import√¢ncia de useCallback**:

```jsx
// ‚ùå Sem useCallback - callback recriada toda render
function Component() {
  const divRef = (node) => { /* ... */ }; // Nova fun√ß√£o cada render

  return <div ref={divRef}>Content</div>;
  // React v√™ nova fun√ß√£o, chama antiga com null, nova com node
  // Reconecta ref toda render!
}

// ‚úÖ Com useCallback - callback est√°vel
function Component() {
  const divRef = useCallback((node) => { /* ... */ }, []);

  return <div ref={divRef}>Content</div>;
  // Mesma fun√ß√£o toda render, ref n√£o reconecta
}
```

### Casos de Uso

#### 1. Medi√ß√£o de Elemento ao Montar

```jsx
function Component() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  const measureRef = useCallback((node) => {
    if (node) {
      const { offsetWidth, offsetHeight } = node;
      setDimensions({ width: offsetWidth, height: offsetHeight });
    }
  }, []);

  return (
    <div ref={measureRef}>
      <p>Width: {dimensions.width}px</p>
      <p>Height: {dimensions.height}px</p>
    </div>
  );
}
```

**Vantagem**: Medi√ß√£o acontece imediatamente ao montar, sem delay de `useEffect`.

#### 2. Refs para Lista Din√¢mica

```jsx
function TodoList({ todos }) {
  const itemRefs = useRef(new Map());

  const setItemRef = useCallback((node, id) => {
    if (node) {
      itemRefs.current.set(id, node);
    } else {
      itemRefs.current.delete(id);
    }
  }, []);

  const scrollToItem = (id) => {
    const node = itemRefs.current.get(id);
    node?.scrollIntoView({ behavior: 'smooth' });
  };

  return (
    <ul>
      {todos.map(todo => (
        <li
          key={todo.id}
          ref={node => setItemRef(node, todo.id)}
        >
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

**Conceito**: Map armazena refs por ID. Items adicionados/removidos atualizam Map automaticamente.

#### 3. Focus Condicional

```jsx
function Input({ shouldAutoFocus }) {
  const inputRef = useCallback((node) => {
    if (node && shouldAutoFocus) {
      node.focus();
    }
  }, [shouldAutoFocus]);

  return <input ref={inputRef} />;
}
```

**Nota**: Se `shouldAutoFocus` muda, callback reconecta e pode re-focar.

#### 4. Integra√ß√£o com Lib Externa (Intersection Observer)

```jsx
function LazyImage({ src, alt }) {
  const [isVisible, setIsVisible] = useState(false);

  const imgRef = useCallback((node) => {
    if (node) {
      const observer = new IntersectionObserver(([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.disconnect();
        }
      });

      observer.observe(node);

      // Cleanup impl√≠cito quando callback com null
      return () => observer.disconnect();
    }
  }, []);

  return (
    <img
      ref={imgRef}
      src={isVisible ? src : placeholder}
      alt={alt}
    />
  );
}
```

**Conceito**: Observer criado quando img monta, destru√≠do quando desmonta.

### Combinar Callback Ref + useRef

```jsx
function Component() {
  const divRef = useRef();

  const callbackRef = useCallback((node) => {
    divRef.current = node; // Atualiza useRef object

    if (node) {
      console.log('Mounted, measuring...');
      console.log('Height:', node.offsetHeight);
    }
  }, []);

  // Pode usar divRef.current em outros lugares
  const scrollToTop = () => {
    divRef.current?.scrollTo(0, 0);
  };

  return <div ref={callbackRef}>Content</div>;
}
```

**Conceito**: Callback ref para timing preciso + useRef para acesso posterior.

### M√∫ltiplas Refs no Mesmo Elemento

```jsx
function Component() {
  const ref1 = useRef();
  const ref2 = useCallback((node) => {
    if (node) console.log('Callback ref:', node);
  }, []);

  const combinedRef = useCallback((node) => {
    // Atualiza ref object
    ref1.current = node;

    // Chama callback ref
    ref2(node);
  }, [ref2]);

  return <div ref={combinedRef}>Content</div>;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Callback Refs

1. **Medi√ß√µes Imediatas**: Quando precisa dimens√µes exatamente ao montar
2. **Listas Din√¢micas**: Quando quantidade de elementos √© vari√°vel
3. **Integra√ß√µes Externas**: Observers, event listeners que precisam cleanup
4. **Timing Cr√≠tico**: Quando `useEffect` delay √© inaceit√°vel

### Quando Usar useRef

1. **Acesso DOM Simples**: Focus, scroll, sele√ß√£o
2. **Quantidade Fixa**: Sabe quantos refs precisa antecipadamente
3. **Simplicidade**: Callback ref adiciona complexidade desnecess√°ria

---

## ‚ö†Ô∏è Limita√ß√µes

### Restri√ß√µes

#### 1. Callback N√£o Est√°vel Reconecta

```jsx
// ‚ùå Reconecta toda render
const ref = (node) => console.log(node);

// ‚úÖ Est√°vel
const ref = useCallback((node) => console.log(node), []);
```

#### 2. Closure Stale em Callbacks

```jsx
const [count, setCount] = useState(0);

// ‚ùå Callback captura count inicial
const ref = useCallback((node) => {
  if (node) {
    node.textContent = count; // count do momento da cria√ß√£o
  }
}, []); // Sem count em deps!

// ‚úÖ Atualiza quando count muda
const ref = useCallback((node) => {
  if (node) {
    node.textContent = count;
  }
}, [count]);
```

---

## üöÄ Conclus√£o

Callback refs s√£o **ferramenta avan√ßada** para controle preciso:

**Vantagens**:
- Timing exato (sem delay)
- Cleanup autom√°tico
- Ideal para listas din√¢micas
- Integra√ß√µes complexas

**Quando usar**: Timing cr√≠tico, listas din√¢micas, integra√ß√µes externas.

**Quando evitar**: Casos simples (use `useRef`).

Callback refs s√£o escape hatch para cen√°rios onde `useRef` + `useEffect` n√£o s√£o suficientes.
