# Fundamentos de SSG (Static Site Generation)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**SSG (Static Site Generation)** √© a t√©cnica de **renderizar p√°ginas React em HTML est√°tico durante build time**, gerando **arquivos HTML pr√©-renderizados** que s√£o servidos via **CDN**, resultando em **velocidade m√°xima** e **custo m√≠nimo**. Conceitualmente, representa **compila√ß√£o antecipada** - fazer todo o trabalho de renderiza√ß√£o uma vez no build, n√£o repetir a cada request.

### Contexto Hist√≥rico

```
1990s: Static HTML (escrito √† m√£o)
2000s: Jekyll, Hugo (static site generators)
2015: JAMstack (JavaScript, APIs, Markup)
2016: Gatsby (React SSG)
2020: Next.js SSG (hybrid SSR/SSG)
2023: SSG + ISR (Incremental Static Regeneration)
```

### Problema que Resolve

**SSR (Server-Side Rendering)**:
- Renderiza a cada request (lento, caro)
- Server load alto
- TTFB vari√°vel

**SSG (Static Site Generation)**:
- Renderiza uma vez no build (r√°pido, barato)
- Zero server load
- TTFB consistente (<50ms)
- Servido via CDN global

---

## ‚ö° Como SSG Funciona

### Fluxo Detalhado

```
1. Build Time:
   npm run build
   ‚Üì
   Next.js/Gatsby renderiza TODAS as p√°ginas
   ‚Üì
   Gera HTML est√°tico para cada rota
   ‚Üì
   out/
   ‚îú‚îÄ‚îÄ index.html
   ‚îú‚îÄ‚îÄ about.html
   ‚îú‚îÄ‚îÄ products/
   ‚îÇ   ‚îú‚îÄ‚îÄ 1.html
   ‚îÇ   ‚îú‚îÄ‚îÄ 2.html
   ‚îÇ   ‚îî‚îÄ‚îÄ 3.html
   ‚îî‚îÄ‚îÄ _next/static/...

2. Deploy:
   Upload para CDN (Vercel, Netlify, S3)

3. Request (Usu√°rio):
   GET /products/1
   ‚Üì
   CDN retorna products/1.html (pr√©-gerado)
   ‚Üì
   Browser exibe instantaneamente (<50ms) ‚ö°
   ‚Üì
   Download JS (background)
   ‚Üì
   Hydrate (interatividade)
```

### Build-Time Rendering

```tsx
// Build time (npm run build)
const products = await fetchAllProducts(); // [1, 2, 3, ...]

for (const product of products) {
  const html = renderToString(
    <ProductPage product={product} />
  );

  fs.writeFileSync(
    `out/products/${product.id}.html`,
    html
  );
}

// Result:
// out/products/1.html
// out/products/2.html
// out/products/3.html
```

---

## üîß Implementa√ß√£o (Next.js)

### getStaticProps

```tsx
// pages/products/[id].tsx
type Product = {
  id: string;
  name: string;
  price: number;
};

type Props = {
  product: Product;
};

// Executado em BUILD TIME (n√£o em runtime)
export async function getStaticProps(context) {
  const { id } = context.params;

  // Fetch data do banco/API
  const product = await db.products.findById(id);

  if (!product) {
    return { notFound: true };
  }

  return {
    props: {
      product
    },
    // Revalidate a cada 60 segundos (ISR)
    revalidate: 60
  };
}

function ProductPage({ product }: Props) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>${product.price}</p>
    </div>
  );
}

export default ProductPage;
```

### getStaticPaths

```tsx
// Gerar caminhos din√¢micos em build time
export async function getStaticPaths() {
  // Fetch todos os produtos
  const products = await db.products.findAll();

  // Gerar path para cada produto
  const paths = products.map(product => ({
    params: { id: product.id.toString() }
  }));

  return {
    paths,
    // fallback: false ‚Üí 404 se path n√£o existe
    // fallback: true ‚Üí gera sob demanda
    // fallback: 'blocking' ‚Üí aguarda gerar antes de mostrar
    fallback: 'blocking'
  };
}

// Build gera:
// /products/1.html
// /products/2.html
// /products/3.html
// ...
```

### Fallback Strategies

```tsx
// fallback: false
export async function getStaticPaths() {
  const paths = [
    { params: { id: '1' } },
    { params: { id: '2' } }
  ];

  return { paths, fallback: false };
}
// /products/1 ‚úÖ
// /products/2 ‚úÖ
// /products/3 ‚ùå 404 (n√£o foi gerado)

// fallback: true
export async function getStaticPaths() {
  // Gerar apenas os 100 produtos mais populares
  const topProducts = await db.products.findMany({ take: 100 });
  const paths = topProducts.map(p => ({ params: { id: p.id } }));

  return { paths, fallback: true };
}

function ProductPage({ product }: Props) {
  const router = useRouter();

  // Enquanto gera p√°gina sob demanda
  if (router.isFallback) {
    return <Skeleton />;
  }

  return <div>{product.name}</div>;
}
// /products/1-100 ‚úÖ Instant√¢neo (pr√©-gerado)
// /products/101 ‚è≥ Gera sob demanda, depois cachea
// /products/102 ‚è≥ Gera sob demanda, depois cachea

// fallback: 'blocking'
export async function getStaticPaths() {
  const paths = [...];
  return { paths, fallback: 'blocking' };
}
// /products/1-100 ‚úÖ Instant√¢neo
// /products/101 ‚è≥ Aguarda gerar, N√ÉO mostra skeleton
// Usu√°rio v√™ loading no browser, depois p√°gina completa
```

---

## üîÑ ISR (Incremental Static Regeneration)

### Problema

```
SSG Tradicional:
- Build gera 10,000 p√°ginas (lento)
- Conte√∫do fica stale (desatualizado)
- Rebuild toda hora (ineficiente)

ISR Solu√ß√£o:
- Build gera apenas p√°ginas populares
- Gera outras sob demanda
- Regenera p√°ginas stale em background
```

### Implementa√ß√£o

```tsx
export async function getStaticProps() {
  const product = await db.products.findById(id);

  return {
    props: { product },
    // Revalida a cada 60 segundos
    revalidate: 60
  };
}

// Fluxo ISR:
// 1. Build: Gera /products/1.html
// 2. Request (t=0s): Retorna /products/1.html (cache)
// 3. Request (t=30s): Retorna /products/1.html (cache) ‚úÖ
// 4. Request (t=65s):
//    - Retorna /products/1.html (stale cache) ‚úÖ
//    - Trigger regenera√ß√£o em background üîÑ
// 5. Request (t=70s): Retorna NOVO /products/1.html ‚ú®
```

### On-Demand Revalidation

```tsx
// API Route: pages/api/revalidate.ts
export default async function handler(req, res) {
  // Verificar secret
  if (req.query.secret !== process.env.REVALIDATE_SECRET) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  try {
    // Revalidar p√°gina espec√≠fica
    await res.revalidate('/products/123');
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send('Error revalidating');
  }
}

// Webhook (quando produto atualiza no CMS)
POST https://myapp.com/api/revalidate?secret=TOKEN&path=/products/123

// Trigger manual
fetch('/api/revalidate?secret=TOKEN&path=/products/123', {
  method: 'POST'
});
```

---

## üìä SSG vs SSR vs ISR

### Compara√ß√£o

```
M√©trica          | SSG          | ISR          | SSR
-----------------|--------------|--------------|-------------
First Paint      | <50ms ‚ö°‚ö°‚ö°  | <50ms ‚ö°‚ö°‚ö°  | 200-500ms ‚ö°
SEO              | ‚úÖ Perfeito  | ‚úÖ Perfeito  | ‚úÖ Perfeito
Data Freshness   | ‚ùå Stale     | ‚úÖ Fresh     | ‚úÖ Real-time
Build Time       | ‚ùå Lento     | ‚úÖ R√°pido    | ‚úÖ N/A
Server Load      | ‚úÖ Zero      | ‚úÖ M√≠nimo    | ‚ùå Alto
Cost             | $ Barato     | $ Barato     | $$$ Caro
Scalability      | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê    | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê    | ‚≠ê‚≠ê‚≠ê
```

### Quando Usar

```
SSG (Pure Static):
‚úÖ Blogs
‚úÖ Documentation
‚úÖ Marketing sites
‚úÖ Landing pages
‚úÖ Conte√∫do que muda raramente
‚ùå Dados em tempo real
‚ùå User-specific content

ISR (Static + Fresh):
‚úÖ E-commerce (produtos atualizam)
‚úÖ News sites (artigos novos)
‚úÖ Blog com muitos posts
‚úÖ Conte√∫do frequentemente atualizado
‚ùå Dados user-specific
‚ùå Real-time dashboards

SSR (Dynamic):
‚úÖ Dashboards personalizados
‚úÖ Social feeds
‚úÖ Real-time data
‚úÖ User-specific pages
‚ùå Static content (waste de server)
```

---

## üéØ Hybrid Approaches

### Mixing SSG + SSR + CSR

```tsx
// pages/dashboard.tsx (SSR - user-specific)
export async function getServerSideProps(context) {
  const session = await getSession(context);
  const userData = await db.users.findById(session.userId);

  return { props: { userData } };
}

// pages/products/[id].tsx (ISR - frequently updated)
export async function getStaticProps({ params }) {
  const product = await db.products.findById(params.id);
  return {
    props: { product },
    revalidate: 60 // 1 min
  };
}

// pages/about.tsx (SSG - never changes)
export async function getStaticProps() {
  return {
    props: { content: 'About us...' }
  };
}

// Client-Side Fetching (CSR - n√£o precisa SEO)
function UserStats() {
  const { data } = useSWR('/api/stats', fetcher);

  return <div>{data?.views}</div>;
}
```

---

## üöÄ Performance Optimization

### Parallel Data Fetching

```tsx
// ‚ùå Serial (lento)
export async function getStaticProps() {
  const product = await fetchProduct(); // 500ms
  const reviews = await fetchReviews(); // 500ms
  const related = await fetchRelated(); // 500ms
  // Total: 1500ms

  return { props: { product, reviews, related } };
}

// ‚úÖ Parallel (r√°pido)
export async function getStaticProps() {
  const [product, reviews, related] = await Promise.all([
    fetchProduct(),
    fetchReviews(),
    fetchRelated()
  ]);
  // Total: 500ms (maior das 3)

  return { props: { product, reviews, related } };
}
```

### Build Time Optimization

```tsx
// ‚ùå Gera TODAS as 10,000 p√°ginas
export async function getStaticPaths() {
  const allProducts = await db.products.findAll(); // 10,000
  const paths = allProducts.map(p => ({ params: { id: p.id } }));

  return { paths, fallback: false };
}
// Build time: 30 minutos üò±

// ‚úÖ Gera apenas top 100, resto sob demanda
export async function getStaticPaths() {
  const topProducts = await db.products.findMany({
    orderBy: { views: 'desc' },
    take: 100
  });
  const paths = topProducts.map(p => ({ params: { id: p.id } }));

  return { paths, fallback: 'blocking' };
}
// Build time: 30 segundos ‚úÖ
// Top 100: Instant√¢neo
// Resto: Gera sob demanda, depois cachea
```

---

## üöÄ Conclus√£o

SSG Fundamentos incluem:
- **Static Generation**: HTML gerado em build time
- **getStaticProps**: Fetch data em build time
- **getStaticPaths**: Gerar rotas din√¢micas
- **Fallback**: false (404), true (skeleton), blocking (wait)
- **ISR**: Revalidate stale pages (best of both worlds)
- **On-Demand Revalidation**: Trigger rebuild via webhook

**Benefits**:
- ‚ö° Velocidade m√°xima (<50ms)
- üí∞ Custo m√≠nimo (CDN)
- üìà Escalabilidade infinita
- ‚úÖ SEO perfeito

**Tradeoffs**:
- ‚ùå Build time cresce com p√°ginas
- ‚ùå Data pode ficar stale (use ISR!)

SSG + ISR = melhor combina√ß√£o para maioria dos casos (blogs, e-commerce, docs).
