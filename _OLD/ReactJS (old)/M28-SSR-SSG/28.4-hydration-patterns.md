# Hydration Patterns

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**Hydration** Ã© o processo de **"hidratar" HTML estÃ¡tico** (renderizado no servidor) com **JavaScript interativo** no cliente, transformando **markup passivo** em **aplicaÃ§Ã£o React completa** com event listeners, state e interatividade. Conceitualmente, representa **dar vida ao HTML** - servidor gera esqueleto, cliente adiciona mÃºsculos e nervos.

### Contexto HistÃ³rico

```
React 16-17: hydrateRoot()
- Hydrate todo app de uma vez
- Bloqueia thread principal
- Slow time-to-interactive

React 18: Concurrent Features
- Selective Hydration (priorizaÃ§Ã£o)
- Progressive Hydration (incremental)
- Streaming + Hydration (chunks)
```

### Problema que Resolve

**Sem Hydration**:
- HTML estÃ¡tico (sem interatividade)
- BotÃµes nÃ£o clicam
- Forms nÃ£o submetem
- State nÃ£o existe

**Com Hydration**:
- HTML â†’ React completo
- Event listeners attached
- State inicializado
- Totalmente interativo

---

## ğŸ”„ Hydration Flow

### Processo Detalhado

```tsx
// 1. Server renderiza
const html = renderToString(<App initialData={data} />);

// Output HTML:
<div id="root">
  <button class="btn">Click me</button>
</div>
<script>window.__DATA__ = {...}</script>

// 2. Browser recebe HTML
// â†’ UsuÃ¡rio vÃª conteÃºdo instantaneamente âœ¨
// â†’ MAS botÃ£o nÃ£o funciona ainda!

// 3. Browser baixa JS bundle
<script src="/app.js"></script>

// 4. React hydrate
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(
  document.getElementById('root'),
  <App initialData={window.__DATA__} />
);

// 5. React:
// - Renderiza React tree na memÃ³ria
// - Compara com HTML existente
// - Attach event listeners ao HTML
// - Inicializa state

// 6. Agora Ã© interativo! âœ¨
<button class="btn" onClick={handleClick}>Click me</button>
```

---

## âš ï¸ Hydration Mismatch

### Problema

```tsx
// âŒ ERRO - Server e Client diferentes
// Server
function Component() {
  return <div>{Date.now()}</div>;
  // Gera: <div>1234567890</div>
}

// Client (hydration)
function Component() {
  return <div>{Date.now()}</div>;
  // Tenta hidratar com: <div>1234567891</div>
  // âš ï¸ MISMATCH! React warning!
}

// React:
// - Detecta diferenÃ§a
// - Deleta HTML do servidor
// - Re-renderiza no cliente
// - Performance degradada!
```

### Causas Comuns

```tsx
// 1. Timestamp/Random values
// âŒ
<div>{Date.now()}</div>
<div>{Math.random()}</div>

// 2. Browser-only APIs
// âŒ
<div>{window.innerWidth}</div>
<div>{localStorage.getItem('theme')}</div>

// 3. Conditional rendering baseado em client
// âŒ
<div>{navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'}</div>

// 4. useLayoutEffect (roda antes de hydration)
// âŒ
useLayoutEffect(() => {
  setTheme(localStorage.getItem('theme'));
}, []);
```

### SoluÃ§Ãµes

```tsx
// âœ… 1. Passar data do servidor
// Server
const timestamp = Date.now();
const html = renderToString(<Component timestamp={timestamp} />);
// Inject: window.__TIMESTAMP__ = timestamp;

// Client
hydrateRoot(root, <Component timestamp={window.__TIMESTAMP__} />);

// âœ… 2. useEffect (sÃ³ roda no client)
function Component() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <div>Loading...</div>; // SSR
  }

  return <div>{Date.now()}</div>; // Client-only
}

// âœ… 3. Suppressar warning (use com cuidado!)
<div suppressHydrationWarning>
  {Date.now()}
</div>

// âœ… 4. Two-pass rendering
function Component() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <div>
      {isClient ? (
        <ClientOnlyComponent />
      ) : (
        <ServerFallback />
      )}
    </div>
  );
}
```

---

## ğŸ¯ Selective Hydration (React 18+)

### Conceito

```tsx
// Tradicional: Hydrate tudo de uma vez
hydrateRoot(root, <App />);
// âŒ Bloqueia thread principal
// âŒ TTI alto se app grande

// React 18: Hydrate em chunks
function App() {
  return (
    <div>
      <Header />  {/* Chunk 1 - hidrata primeiro */}

      <Suspense fallback={<Skeleton />}>
        <HeavyComponent />  {/* Chunk 2 - hidrata depois */}
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <AnotherHeavy />  {/* Chunk 3 - hidrata por Ãºltimo */}
      </Suspense>
    </div>
  );
}

// Hydration Order (automÃ¡tico):
// 1. Header (no viewport)
// 2. HeavyComponent (lazy)
// 3. AnotherHeavy (lazy)

// Se usuÃ¡rio clicar em HeavyComponent:
// â†’ React PRIORIZA hidrataÃ§Ã£o desse chunk! âš¡
```

### ImplementaÃ§Ã£o

```tsx
import { Suspense } from 'react';
import { hydrateRoot } from 'react-dom/client';

function App() {
  return (
    <Layout>
      {/* Critical - hidrata imediatamente */}
      <Navigation />

      {/* Lazy - hidrata quando necessÃ¡rio */}
      <Suspense fallback={<CommentsSkeleton />}>
        <Comments />
      </Suspense>

      <Suspense fallback={<RecommendationsSkeleton />}>
        <Recommendations />
      </Suspense>
    </Layout>
  );
}

// Client
hydrateRoot(document.getElementById('root'), <App />);

// React automaticamente:
// âœ… Hidrata Navigation primeiro
// âœ… Hidrata Comments quando scroll
// âœ… Hidrata Recommendations lazy
// âœ… Prioriza se usuÃ¡rio interagir
```

---

## ğŸš€ Progressive Hydration

### Conceito

```
Traditional Hydration:
[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] Hydrate 100% â†’ Interactive
Time: 3s

Progressive Hydration:
[â–ˆâ–ˆâ–ˆâ–ˆ            ] 25% â†’ Parcialmente interativo
[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        ] 50% â†’ Mais interativo
[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    ] 75% â†’ Quase completo
[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100% â†’ Totalmente interativo
Time: Interatividade progressiva desde 500ms
```

### Islands Architecture

```tsx
// PÃ¡gina com "ilhas" de interatividade
function Page() {
  return (
    <html>
      <body>
        {/* Static HTML (sem hydration) */}
        <header>
          <h1>My Blog</h1>
          <p>Welcome to my blog</p>
        </header>

        {/* Island 1 - Interactive */}
        <Island>
          <SearchBox />
        </Island>

        {/* Static HTML */}
        <article>
          <h2>Blog Post Title</h2>
          <p>Content goes here...</p>
        </article>

        {/* Island 2 - Interactive */}
        <Island>
          <CommentForm />
        </Island>

        {/* Static HTML */}
        <footer>Copyright 2024</footer>
      </body>
    </html>
  );
}

// Apenas Islands sÃ£o hidratadas!
// Resto Ã© HTML puro (zero JS)
```

### ImplementaÃ§Ã£o (Astro Pattern)

```tsx
// Component.astro
---
// Server-side code
const data = await fetchData();
---

<!-- Static HTML (zero JS) -->
<div>
  <h1>{data.title}</h1>
  <p>{data.description}</p>
</div>

<!-- Interactive Island -->
<InteractiveCounter client:load />

<!-- Static HTML -->
<footer>Footer content</footer>
```

---

## âš¡ Partial Hydration

### Lazy Hydration

```tsx
// Hidrata apenas quando visÃ­vel
function LazyHydrate({ children }) {
  const ref = useRef(null);
  const [shouldHydrate, setShouldHydrate] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setShouldHydrate(true);
          observer.disconnect();
        }
      },
      { rootMargin: '100px' }
    );

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div ref={ref}>
      {shouldHydrate ? children : null}
    </div>
  );
}

// Uso
<LazyHydrate>
  <ExpensiveComponent />
</LazyHydrate>
```

### Idle Hydration

```tsx
// Hidrata quando browser estÃ¡ idle
function IdleHydrate({ children }) {
  const [shouldHydrate, setShouldHydrate] = useState(false);

  useEffect(() => {
    if ('requestIdleCallback' in window) {
      const id = requestIdleCallback(
        () => {
          setShouldHydrate(true);
        },
        { timeout: 500 }
      );

      return () => cancelIdleCallback(id);
    } else {
      // Fallback
      const timeout = setTimeout(() => setShouldHydrate(true), 500);
      return () => clearTimeout(timeout);
    }
  }, []);

  return shouldHydrate ? children : null;
}

// Hidrata quando:
// - Browser estÃ¡ idle (nÃ£o ocupado)
// - OU apÃ³s 500ms (timeout)
```

### On-Interaction Hydration

```tsx
// Hidrata apenas quando usuÃ¡rio interagir
function OnClickHydrate({ children }) {
  const [isHydrated, setIsHydrated] = useState(false);

  if (!isHydrated) {
    return (
      <div
        onMouseEnter={() => setIsHydrated(true)}
        onClick={() => setIsHydrated(true)}
      >
        {/* Render estÃ¡tico */}
        <button>Click me (not interactive yet)</button>
      </div>
    );
  }

  return children;
}

// Uso
<OnClickHydrate>
  <InteractiveButton onClick={handleClick} />
</OnClickHydrate>
```

---

## ğŸ“Š Performance Comparison

```
Full Hydration (Traditional):
â”œâ”€â”€ JS Bundle: 200KB
â”œâ”€â”€ Hydration Time: 1500ms
â”œâ”€â”€ TTI: 2000ms
â””â”€â”€ Interactive: Tudo de uma vez

Selective Hydration (React 18):
â”œâ”€â”€ JS Bundle: 200KB (chunked)
â”œâ”€â”€ Initial Hydration: 300ms
â”œâ”€â”€ TTI: 800ms (partial)
â””â”€â”€ Interactive: Progressivo

Partial Hydration (Islands):
â”œâ”€â”€ JS Bundle: 50KB (apenas islands)
â”œâ”€â”€ Hydration Time: 200ms
â”œâ”€â”€ TTI: 400ms
â””â”€â”€ Interactive: Apenas components necessÃ¡rios
```

---

## ğŸš€ ConclusÃ£o

Hydration Patterns incluem:
- **Full Hydration**: Hydrate todo app (tradicional)
- **Selective Hydration**: Priorizar chunks importantes (React 18)
- **Progressive Hydration**: Hidratar incrementalmente
- **Partial Hydration**: Hidratar apenas necessÃ¡rio (Islands)
- **Lazy Hydration**: Viewport, Idle, Interaction

**Strategies**:
- âœ… Use Suspense boundaries (Selective Hydration)
- âœ… Lazy hydrate offscreen components
- âœ… Prioritize above-the-fold content
- âœ… Minimize hydration mismatch
- âœ… Consider Islands Architecture para static content

**Anti-patterns**:
- âŒ Hydrate tudo de uma vez
- âŒ Hydrate componentes que nÃ£o precisam interatividade
- âŒ Ignorar hydration warnings

Hydration inteligente = performance mÃ¡xima + interatividade otimizada.
