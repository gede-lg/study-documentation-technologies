# Fundamentos de SSR (Server-Side Rendering)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**SSR (Server-Side Rendering)** √© a t√©cnica de **renderizar React no servidor**, gerando **HTML completo** antes de enviar para o cliente, ao inv√©s de enviar JavaScript vazio e renderizar no browser. Conceitualmente, representa **renderiza√ß√£o h√≠brida** - servidor gera HTML inicial (fast first paint), cliente hidrata (interatividade), combinando melhor de ambos os mundos.

### Contexto Hist√≥rico

```
1990s: Server-side (PHP, ASP) ‚Üí HTML completo
2010s: Client-side (React SPA) ‚Üí JavaScript gera tudo
2015+: Universal/Isomorphic ‚Üí H√≠brido (SSR + CSR)
2020+: SSR moderno (Next.js, Remix) ‚Üí Streaming, RSC
```

### Problema que Resolve

**SPA (Client-Side Only)**:
- Blank screen at√© JS carregar
- SEO ruim (bots n√£o executam JS)
- Slow first paint (3-5s)
- Bundle grande inicial

**SSR**:
- HTML instant√¢neo (fast first paint)
- SEO perfeito (HTML completo)
- Fast first paint (<1s)
- Progressive enhancement

---

## üîÑ CSR vs SSR vs SSG

### Compara√ß√£o Visual

```
CSR (Client-Side Rendering):
1. Browser ‚Üí Request ‚Üí Server
2. Server ‚Üí HTML vazio + JS bundle
3. Browser ‚Üí Download JS (2-5s)
4. Browser ‚Üí Execute JS
5. Browser ‚Üí Render (usu√°rio v√™ conte√∫do)
   Total: 3-5s at√© First Contentful Paint

SSR (Server-Side Rendering):
1. Browser ‚Üí Request ‚Üí Server
2. Server ‚Üí Renderiza React
3. Server ‚Üí HTML completo
4. Browser ‚Üí Exibe HTML instantaneamente ‚ú®
5. Browser ‚Üí Download JS (background)
6. Browser ‚Üí Hydrate (interatividade)
   Total: <1s at√© First Contentful Paint

SSG (Static Site Generation):
1. Build time ‚Üí Renderiza todas as p√°ginas
2. Browser ‚Üí Request ‚Üí CDN
3. CDN ‚Üí HTML pr√©-gerado (instant√¢neo) ‚ö°
4. Browser ‚Üí Exibe HTML
5. Browser ‚Üí Download JS (background)
6. Browser ‚Üí Hydrate
   Total: <100ms at√© First Contentful Paint
```

### Quando Usar Cada Um

```
CSR (SPA):
‚úÖ Admin panels (n√£o precisa SEO)
‚úÖ Dashboards privados
‚úÖ Web apps (Gmail, Figma)
‚ùå Marketing sites
‚ùå Blogs
‚ùå E-commerce

SSR:
‚úÖ E-commerce (SEO + dados din√¢micos)
‚úÖ Social media (personalized feeds)
‚úÖ News sites (conte√∫do frequente)
‚ùå Static content (use SSG)
‚ùå N√£o precisa SEO (use CSR)

SSG:
‚úÖ Blogs
‚úÖ Documentation
‚úÖ Marketing sites
‚úÖ Landing pages
‚ùå Dados em tempo real
‚ùå Conte√∫do personalizado
```

---

## üß† Como SSR Funciona

### Fluxo Detalhado

```tsx
// 1. Browser Request
GET /products/123

// 2. Server recebe request
server.get('/products/:id', async (req, res) => {
  // 3. Fetch data
  const product = await db.products.findById(req.params.id);

  // 4. Render React to HTML
  const html = renderToString(
    <App>
      <ProductPage product={product} />
    </App>
  );

  // 5. Inject HTML + data into template
  const fullHtml = `
    <!DOCTYPE html>
    <html>
      <head><title>${product.name}</title></head>
      <body>
        <div id="root">${html}</div>
        <script>
          window.__INITIAL_DATA__ = ${JSON.stringify(product)};
        </script>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `;

  // 6. Send to browser
  res.send(fullHtml);
});

// 7. Browser recebe HTML completo
// ‚Üí Usu√°rio v√™ conte√∫do instantaneamente ‚ú®

// 8. Browser baixa bundle.js
// 9. React hydrate (attach event listeners)
hydrateRoot(
  document.getElementById('root'),
  <App>
    <ProductPage product={window.__INITIAL_DATA__} />
  </App>
);

// 10. Agora √© interativo!
```

---

## üîß Implementa√ß√£o B√°sica (Manual)

### Server Setup (Express + React)

```tsx
// server.tsx
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import App from './App';

const server = express();

server.use(express.static('dist'));

server.get('*', async (req, res) => {
  // Fetch data baseado na rota
  const data = await fetchDataForRoute(req.url);

  // Render React to HTML
  const html = renderToString(
    <App initialData={data} url={req.url} />
  );

  // Send HTML
  res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>My App</title>
        <link rel="stylesheet" href="/styles.css" />
      </head>
      <body>
        <div id="root">${html}</div>
        <script>
          window.__INITIAL_DATA__ = ${JSON.stringify(data)};
        </script>
        <script src="/client.js"></script>
      </body>
    </html>
  `);
});

server.listen(3000);
```

### Client Hydration

```tsx
// client.tsx
import { hydrateRoot } from 'react-dom/client';
import App from './App';

const initialData = window.__INITIAL_DATA__;

hydrateRoot(
  document.getElementById('root')!,
  <App initialData={initialData} url={window.location.pathname} />
);

// Limpar dados globais
delete window.__INITIAL_DATA__;
```

### App Component

```tsx
// App.tsx
function App({ initialData, url }: { initialData: any; url: string }) {
  const [data, setData] = useState(initialData);

  return (
    <Router location={url}>
      <Routes>
        <Route path="/" element={<Home data={data} />} />
        <Route path="/products/:id" element={<Product data={data} />} />
      </Routes>
    </Router>
  );
}
```

---

## ‚ö° Hydration

### O Que √â Hydration?

```tsx
// Server renderiza HTML "seco" (sem interatividade)
<button>Click me</button>

// Client "hidrata" (adiciona event listeners)
<button onClick={handleClick}>Click me</button>
```

### Hydration Mismatch

```tsx
// ‚ùå ERRO - Server e Client diferentes
// Server
function Component() {
  return <div>{Date.now()}</div>;
  // Gera: <div>1234567890</div>
}

// Client (hidrata√ß√£o)
function Component() {
  return <div>{Date.now()}</div>;
  // Tenta hidratar: <div>1234567891</div>
  // ERRO: Mismatch!
}

// ‚úÖ CORRETO - Mesmo conte√∫do
function Component({ timestamp }: { timestamp: number }) {
  return <div>{timestamp}</div>;
}

// Server
const timestamp = Date.now();
renderToString(<Component timestamp={timestamp} />);
// Gera: <div>1234567890</div>

// Client
hydrateRoot(root, <Component timestamp={window.__TIMESTAMP__} />);
// Hidrata: <div>1234567890</div> ‚úÖ
```

### useEffect para C√≥digo Client-Only

```tsx
// ‚úÖ CORRETO - useEffect s√≥ roda no client
function Component() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <div>Loading...</div>; // SSR
  }

  return <div>{Date.now()}</div>; // Client-only
}
```

---

## üéØ Data Fetching em SSR

### getServerSideProps (Next.js Pattern)

```tsx
// pages/products/[id].tsx
export async function getServerSideProps(context) {
  const { id } = context.params;

  // Fetch data no servidor
  const product = await db.products.findById(id);

  if (!product) {
    return { notFound: true };
  }

  return {
    props: {
      product
    }
  };
}

function ProductPage({ product }: { product: Product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}

export default ProductPage;
```

### Fetch em Server Component (React 19+)

```tsx
// Server Component (async)
async function ProductPage({ id }: { id: string }) {
  // Fetch direto no componente
  const product = await db.products.findById(id);

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}
```

---

## üîê Seguran√ßa em SSR

### Prevenir XSS

```tsx
// ‚ùå VULNER√ÅVEL - XSS
function Component({ userInput }: { userInput: string }) {
  return <div dangerouslySetInnerHTML={{ __html: userInput }} />;
}

// Ataque: userInput = '<script>alert(document.cookie)</script>'

// ‚úÖ SEGURO - React escapa automaticamente
function Component({ userInput }: { userInput: string }) {
  return <div>{userInput}</div>;
}
// <script> vira &lt;script&gt;
```

### Serializa√ß√£o Segura

```tsx
// ‚ùå VULNER√ÅVEL - JSON injection
const html = `
  <script>
    window.__DATA__ = ${JSON.stringify(data)};
  </script>
`;
// Ataque: data = { xss: '</script><script>alert(1)</script>' }

// ‚úÖ SEGURO - Escape </script>
import serialize from 'serialize-javascript';

const html = `
  <script>
    window.__DATA__ = ${serialize(data, { isJSON: true })};
  </script>
`;
// Escapa </script> ‚Üí <\/script>
```

---

## üöÄ Conclus√£o

SSR Fundamentos incluem:
- **CSR vs SSR vs SSG**: Client-side vs Server-side vs Static
- **Fluxo SSR**: Request ‚Üí Render ‚Üí HTML ‚Üí Hydrate
- **Hydration**: Attach event listeners ao HTML renderizado
- **Data Fetching**: getServerSideProps, async Server Components
- **Hydration Mismatch**: Server e Client devem gerar mesmo HTML
- **Seguran√ßa**: Escape XSS, serializa√ß√£o segura

**Benefits**:
- ‚úÖ SEO (HTML completo)
- ‚úÖ Fast first paint (<1s)
- ‚úÖ Funciona sem JavaScript (progressive enhancement)

**Tradeoffs**:
- ‚ùå Server load (renderiza por request)
- ‚ùå Complexidade (server + client)
- ‚ùå TTFB pode ser lento (aguarda data fetching)

SSR √© poderoso mas complexo - use frameworks (Next.js, Remix) ao inv√©s de implementar manualmente!
