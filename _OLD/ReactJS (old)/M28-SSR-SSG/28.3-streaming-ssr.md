# Streaming SSR

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Streaming SSR** √© a t√©cnica de **enviar HTML ao browser incrementalmente** durante renderiza√ß√£o do servidor, ao inv√©s de aguardar toda a p√°gina renderizar antes de enviar, permitindo que **usu√°rio veja conte√∫do progressivamente**. Conceitualmente, representa **renderiza√ß√£o progressiva** - stream de HTML chega em chunks, browser renderiza conforme recebe, resultando em perceived performance muito melhor.

### Contexto Hist√≥rico

```
SSR Tradicional (Buffered):
2015-2020: renderToString()
- Aguarda TODA a p√°gina renderizar
- Envia HTML completo de uma vez
- TTFB alto se page complexa

Streaming SSR:
2021+: renderToPipeableStream() (React 18)
- Envia HTML em chunks
- Browser renderiza conforme recebe
- TTFB baixo (primeiro chunk r√°pido)
```

### Problema que Resolve

**SSR Tradicional (Buffered)**:
```
Server: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] Renderiza 100%
        ‚Üì (espera terminar)
Browser: [            ] Aguardando...
        ‚Üì (recebe tudo)
Browser: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] Exibe tudo
TTFB: 2s
```

**Streaming SSR**:
```
Server: [‚ñà‚ñà          ] 20% ‚Üí Send chunk 1
Browser: [‚ñà‚ñà          ] Exibe!
Server: [‚ñà‚ñà‚ñà‚ñà        ] 40% ‚Üí Send chunk 2
Browser: [‚ñà‚ñà‚ñà‚ñà        ] Exibe!
Server: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ] 80% ‚Üí Send chunk 3
Browser: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ] Exibe!
Server: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100% ‚Üí Send chunk 4
Browser: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] Exibe!
TTFB: 200ms (primeiro chunk)
```

---

## üîÑ Como Streaming Funciona

### Fluxo Detalhado

```tsx
// 1. Request
GET /products

// 2. Server inicia streaming
const stream = renderToPipeableStream(
  <App>
    <Suspense fallback={<Skeleton />}>
      <ProductList />
    </Suspense>
  </App>
);

// 3. Send chunk 1 (shell + fallback)
res.write(`
  <!DOCTYPE html>
  <html>
    <body>
      <div id="root">
        <header>Logo</header>
        <div id="product-list">
          <div class="skeleton"></div> ‚Üê Fallback
        </div>
      </div>
    </body>
  </html>
`);
// Browser renderiza header + skeleton instantaneamente! ‚ú®

// 4. Server continua renderizando...
const products = await fetchProducts(); // 1s

// 5. Send chunk 2 (conte√∫do real)
res.write(`
  <script>
    // Substituir skeleton por conte√∫do real
    document.getElementById('product-list').innerHTML = \`
      <div class="product">Product 1</div>
      <div class="product">Product 2</div>
    \`;
  </script>
`);
// Browser atualiza com produtos reais!

// 6. End stream
res.end();
```

---

## üß© Suspense Boundaries

### Conceito

```tsx
// ‚úÖ Streaming com Suspense
function App() {
  return (
    <div>
      <Header />  {/* R√°pido - chunk 1 */}

      <Suspense fallback={<ProductsSkeleton />}>
        <ProductList />  {/* Lento - chunk 2 */}
      </Suspense>

      <Suspense fallback={<ReviewsSkeleton />}>
        <Reviews />  {/* Lento - chunk 3 */}
      </Suspense>

      <Footer />  {/* R√°pido - chunk 1 */}
    </div>
  );
}

// Rendering:
// Chunk 1: Header + Footer + Skeletons (instant√¢neo)
// Chunk 2: ProductList (quando pronto)
// Chunk 3: Reviews (quando pronto)
```

### Implementa√ß√£o

```tsx
// Server
import { renderToPipeableStream } from 'react-dom/server';

app.get('/products', (req, res) => {
  const { pipe } = renderToPipeableStream(
    <App />,
    {
      // Callback quando shell est√° pronto
      onShellReady() {
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/html');
        pipe(res);
      },

      // Callback quando tudo terminou
      onAllReady() {
        console.log('All content sent!');
      },

      // Error handling
      onError(error) {
        console.error(error);
        res.statusCode = 500;
      }
    }
  );
});
```

### Async Component (React 19+)

```tsx
// Server Component ass√≠ncrono
async function ProductList() {
  // Fetch no servidor
  const products = await db.products.findMany();

  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// Uso com Suspense
function Page() {
  return (
    <Suspense fallback={<ProductsSkeleton />}>
      <ProductList />
    </Suspense>
  );
}

// Streaming:
// 1. Send shell + skeleton
// 2. Aguarda ProductList resolver
// 3. Send produtos
```

---

## ‚ö° Selective Hydration

### Problema

```
Hydration Tradicional:
1. HTML completo recebido
2. JS bundle completo baixado
3. React hydrate TODO o app
4. Agora √© interativo

Se bundle grande: 5-10s at√© interatividade! üò±
```

### Solu√ß√£o: Selective Hydration

```tsx
// Prioriza hidrata√ß√£o baseado em intera√ß√£o
function App() {
  return (
    <div>
      <Header />  {/* Hidrata primeiro (vis√≠vel) */}

      <Suspense fallback={<Skeleton />}>
        <HeavyComponent />  {/* Hidrata depois */}
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <AnotherHeavyComponent />  {/* Hidrata por √∫ltimo */}
      </Suspense>
    </div>
  );
}

// Hydration Order:
// 1. Header (vis√≠vel no viewport)
// 2. HeavyComponent (se usu√°rio scrollar)
// 3. AnotherHeavyComponent (lazy)

// Se usu√°rio clicar em HeavyComponent antes de hidratar:
// React prioriza hidrata√ß√£o desse componente!
```

### Implementa√ß√£o

```tsx
import { hydrateRoot } from 'react-dom/client';

// Client
hydrateRoot(document.getElementById('root'), <App />);

// React 18+ automaticamente:
// - Hidrata em chunks
// - Prioriza componentes vis√≠veis
// - Prioriza componentes com intera√ß√£o
// - Continua hidratando em background
```

---

## üìä Performance Comparison

### Metrics

```
Tradicional SSR (buffered):
‚îú‚îÄ‚îÄ TTFB: 2000ms (aguarda renderizar tudo)
‚îú‚îÄ‚îÄ FCP: 2100ms (primeiro conte√∫do)
‚îú‚îÄ‚îÄ LCP: 2100ms (largest content)
‚îî‚îÄ‚îÄ TTI: 5000ms (time to interactive)

Streaming SSR:
‚îú‚îÄ‚îÄ TTFB: 100ms (shell imediato) ‚ö°
‚îú‚îÄ‚îÄ FCP: 200ms (fallbacks) ‚ö°
‚îú‚îÄ‚îÄ LCP: 1500ms (conte√∫do real)
‚îî‚îÄ‚îÄ TTI: 2000ms (selective hydration) ‚ö°
```

### Perceived Performance

```
Tradicional:
User: [Blank screen] (2s) ‚Üí [Full page] ‚ùå Slow

Streaming:
User: [Shell + skeleton] (100ms) ‚Üí [Partial content] (500ms) ‚Üí [Full page] (1.5s) ‚úÖ Fast
```

---

## üéØ Estrat√©gias de Streaming

### 1. Shell-First Strategy

```tsx
// Enviar shell rapidamente
function App() {
  return (
    <html>
      <head>
        <title>My App</title>
        <link rel="stylesheet" href="/styles.css" />
      </head>
      <body>
        <Header />  {/* Shell - r√°pido */}
        <Nav />     {/* Shell - r√°pido */}

        <Suspense fallback={<ContentSkeleton />}>
          <MainContent />  {/* Lazy - lento */}
        </Suspense>

        <Footer />  {/* Shell - r√°pido */}
      </body>
    </html>
  );
}

// Chunk 1 (100ms): Shell completo + skeletons
// Chunk 2 (1s+): MainContent
```

### 2. Critical Content First

```tsx
function ProductPage() {
  return (
    <div>
      {/* Cr√≠tico - chunk 1 */}
      <ProductImage />
      <ProductTitle />
      <ProductPrice />
      <BuyButton />

      {/* N√£o cr√≠tico - chunk 2+ */}
      <Suspense fallback={<Skeleton />}>
        <ProductReviews />
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <RelatedProducts />
      </Suspense>
    </div>
  );
}
```

### 3. Parallel Data Fetching

```tsx
// ‚ùå Serial (lento)
async function Page() {
  const user = await fetchUser();      // 500ms
  const posts = await fetchPosts();    // 500ms
  const comments = await fetchComments(); // 500ms
  // Total: 1500ms
}

// ‚úÖ Parallel (r√°pido) + Streaming
function Page() {
  return (
    <div>
      <Suspense fallback={<UserSkeleton />}>
        <UserInfo />  {/* fetchUser() - 500ms */}
      </Suspense>

      <Suspense fallback={<PostsSkeleton />}>
        <PostsList />  {/* fetchPosts() - 500ms */}
      </Suspense>

      <Suspense fallback={<CommentsSkeleton />}>
        <CommentsList />  {/* fetchComments() - 500ms */}
      </Suspense>
    </div>
  );
}
// Total: 500ms (paralelo)
// Chunks enviados conforme cada fetch resolve
```

---

## üîß Error Handling

### Error Boundary com Streaming

```tsx
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <div>
      <Header />

      <ErrorBoundary
        fallback={<ErrorMessage />}
        onError={(error) => {
          console.error('Stream error:', error);
        }}
      >
        <Suspense fallback={<Skeleton />}>
          <DataComponent />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}

// Se DataComponent falha:
// 1. Shell + skeleton enviado (sucesso)
// 2. DataComponent lan√ßa erro
// 3. ErrorBoundary captura
// 4. Send fallback ao inv√©s do componente
```

---

## üöÄ Conclus√£o

Streaming SSR inclui:
- **Progressive Rendering**: HTML enviado em chunks
- **Suspense Boundaries**: Dividir app em chunks independentes
- **Selective Hydration**: Priorizar componentes importantes
- **TTFB Improvement**: Primeiro chunk <100ms
- **Perceived Performance**: Usu√°rio v√™ conte√∫do instantaneamente

**Benefits**:
- ‚ö° TTFB muito menor (shell r√°pido)
- üëÅÔ∏è Melhor perceived performance (progressivo)
- üéØ Selective hydration (interativo mais r√°pido)
- üîÑ Parallel data fetching (chunks independentes)

**Tradeoffs**:
- ‚öôÔ∏è Complexidade maior (Suspense boundaries)
- üß™ Harder to debug (async rendering)

Streaming SSR + Selective Hydration = futuro do React SSR (React 18+, Next.js 13+).
