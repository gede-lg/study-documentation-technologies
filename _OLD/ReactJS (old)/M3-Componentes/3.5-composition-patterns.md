# Composition Patterns no React: Compondo Componentes de Forma Elegante

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Composition Patterns s√£o **estrat√©gias arquiteturais** para combinar componentes React de forma flex√≠vel, reutiliz√°vel e manuten√≠vel. Representam a aplica√ß√£o do princ√≠pio fundamental "**composi√ß√£o sobre heran√ßa**" do React, onde complexidade emerge da combina√ß√£o de unidades simples ao inv√©s de hierarquias de classes. S√£o padr√µes que definem como componentes **se relacionam, se encaixam e comunicam** para formar interfaces coesas.

Enquanto Component Patterns focam em *estrutura interna* de componentes individuais, Composition Patterns focam em como *m√∫ltiplos componentes trabalham juntos* como um sistema.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o da composi√ß√£o em React:**

**2013-2015: Composi√ß√£o Simples**
React nasceu com filosofia de composi√ß√£o: componentes s√£o fun√ß√µes que retornam elementos, e elementos podem conter outros componentes. Isso era revolucion√°rio comparado a frameworks que usavam heran√ßa de classes ou templates complexos.

**2015-2017: Padr√µes Emergem**
Comunidade identificou padr√µes recorrentes:
- **Props.children**: Padr√£o slot para injetar conte√∫do
- **Props spreading**: Repassar props para componentes internos
- **Componentes de layout**: Separar estrutura de conte√∫do

**2017-2019: Sofistica√ß√£o**
Padr√µes avan√ßados ganham popularidade:
- **Compound Components**: Componentes que trabalham juntos implicitamente via Context
- **Render Props**: Invers√£o de controle total
- **Polymorphic Components**: Componentes que mudam de tipo via prop `as`

**2019-hoje: Hooks e Composi√ß√£o**
Hooks revolucionaram composi√ß√£o de *l√≥gica* (n√£o apenas UI):
- Custom Hooks comp√µem comportamentos
- Padr√µes de composi√ß√£o visual evoluem (Headless Components)
- React Server Components (futuro) trazem novos desafios de composi√ß√£o

**Motiva√ß√£o para padr√µes de composi√ß√£o:**

1. **Flexibilidade sem Complexidade**: Componentes reutiliz√°veis que se adaptam a contextos diferentes
2. **Invers√£o de Controle**: Consumidor decide detalhes, componente prov√™ estrutura
3. **Evitar Prop Drilling**: Componentes comunicam-se implicitamente quando apropriado
4. **Separa√ß√£o de Responsabilidades**: Estrutura (layout) separada de conte√∫do (dados)

### Problema Fundamental que Resolve

**Problemas sem padr√µes de composi√ß√£o:**

1. **Componentes R√≠gidos**: Componente Card aceita `title`, `subtitle`, `image`, `actions`... Cada novo caso requer nova prop. Props proliferam.

2. **Prop Explosion**: Componente com 20+ props opcionais, imposs√≠vel de manter.

3. **Duplica√ß√£o**: Varia√ß√µes de componente (`CardWithImage`, `CardWithVideo`, `CardSimple`) proliferam.

4. **Acoplamento**: Componentes sabem demais sobre internos de outros.

**Composi√ß√£o resolve:**

- **Flexibilidade**: Componente Card gen√©rico comp√µe sub-componentes (`Card.Header`, `Card.Body`, `Card.Footer`)
- **Clareza**: API de composi√ß√£o √© auto-documentada e leg√≠vel
- **Reutiliza√ß√£o**: Componentes focados e pequenos s√£o altamente reutiliz√°veis
- **Manuten√ß√£o**: Mudan√ßas s√£o localizadas, n√£o quebram consumidores

### Import√¢ncia no Ecossistema

Composi√ß√£o √© **filosofia central** do React:

- **Design Systems**: Bibliotecas como Radix UI, Chakra UI, Mantine baseiam-se em composi√ß√£o
- **Acessibilidade**: Componentes compostos podem gerenciar ARIA attributes implicitamente
- **Developer Experience**: APIs compostas s√£o intuitivas e descritivas
- **Escalabilidade**: C√≥digo composto escala melhor que hierarquias r√≠gidas

**Cita√ß√£o cl√°ssica:**
> "Composition is not about reusing code. It's about combining simple things to build more complex things." - Dan Abramov

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Composi√ß√£o sobre Heran√ßa**: Preferir combinar ao inv√©s de estender
2. **Invers√£o de Controle**: Componente prov√™ estrutura, consumidor prov√™ conte√∫do
3. **Props como Interface de Composi√ß√£o**: Props n√£o s√£o apenas dados, s√£o pontos de composi√ß√£o
4. **Comunica√ß√£o Impl√≠cita**: Context permite componentes "conversarem" sem props expl√≠citas
5. **Polimorfismo**: Componentes adaptam-se a diferentes contextos

### Pilares Fundamentais

- **Children**: Prop especial para composi√ß√£o b√°sica
- **Props Spreading**: Repassar props automaticamente
- **Slot Pattern**: M√∫ltiplos pontos de inser√ß√£o de conte√∫do
- **Compound Components**: Componentes que trabalham juntos via Context
- **Polymorphic Components**: Componente muda de elemento via `as` prop

### Vis√£o Geral das Nuances

- **Children √© poderoso e flex√≠vel**: Pode ser elemento, array, fun√ß√£o, string, null
- **React.Children API**: Manipular children de forma segura
- **React.cloneElement**: Injetar props em children (use com cuidado)
- **Trade-off flexibilidade vs complexidade**: Mais composi√ß√£o = API mais complexa
- **TypeScript desafia composi√ß√£o**: Tipar composi√ß√£o corretamente √© avan√ßado

---

## üß† Fundamentos Te√≥ricos

### Filosofia: Composi√ß√£o sobre Heran√ßa

**Heran√ßa (OOP cl√°ssico):**

```javascript
class BaseButton {
  render() { /* base logic */ }
}

class PrimaryButton extends BaseButton {
  render() {
    return <button className="primary">{super.render()}</button>;
  }
}
```

**Problemas:**
- Hierarquias r√≠gidas e fr√°geis
- Mudan√ßas na base afetam todas subclasses
- Dif√≠cil reutilizar partes espec√≠ficas
- "Gorilla/Banana problem": Quer banana, mas vem com gorila segurando banana e floresta inteira

**Composi√ß√£o (React):**

```javascript
function Button({ variant = 'primary', children }) {
  return <button className={variant}>{children}</button>;
}

// Composi√ß√£o ao inv√©s de heran√ßa
function PrimaryButton({ children }) {
  return <Button variant="primary">{children}</Button>;
}

// Ou diretamente
<Button variant="primary">Click</Button>
```

**Vantagens:**
- Flex√≠vel e expl√≠cito
- Mudan√ßas localizadas
- Reutiliza√ß√£o granular
- Combina pe√ßas como LEGO

### Modelo Mental: √Årvore de Composi√ß√£o

Pense em componentes como **√°rvore hier√°rquica** onde cada n√≥ √© um ponto de composi√ß√£o:

```
<Layout>                    ‚Üê Estrutura
  <Header>                  ‚Üê Se√ß√£o
    <Logo />                ‚Üê Conte√∫do
    <Navigation>            ‚Üê Container
      <NavLink />           ‚Üê Item
      <NavLink />
    </Navigation>
  </Header>
  <Main>
    {children}              ‚Üê Ponto de inser√ß√£o
  </Main>
</Layout>
```

Cada n√≠vel adiciona camada de abstra√ß√£o. Folhas s√£o componentes concretos, galhos s√£o composi√ß√µes.

---

## üîç An√°lise Conceitual Profunda

### 3.5.1 Composi√ß√£o vs Heran√ßa

**Exemplo real: Sistema de Cards**

**Abordagem com Heran√ßa (anti-padr√£o em React):**

```javascript
// ‚ùå N√£o fa√ßa isso em React
class BaseCard {
  render() {
    return (
      <div className="card">
        {this.renderHeader()}
        {this.renderBody()}
        {this.renderFooter()}
      </div>
    );
  }

  renderHeader() { return null; }
  renderBody() { return null; }
  renderFooter() { return null; }
}

class ProductCard extends BaseCard {
  renderHeader() {
    return <img src={this.props.image} />;
  }

  renderBody() {
    return <h3>{this.props.title}</h3>;
  }
}

class UserCard extends BaseCard {
  renderHeader() {
    return <Avatar user={this.props.user} />;
  }

  renderBody() {
    return <UserInfo user={this.props.user} />;
  }
}
```

**Problemas:**
- R√≠gido: Todas cards devem ter header/body/footer mesmo se n√£o usam
- Acoplado: Subclasses dependem de implementa√ß√£o da base
- Dif√≠cil testar: Precisa instanciar classe
- Dif√≠cil customizar: E se quiser body antes de header?

**Abordagem com Composi√ß√£o (idiom√°tico React):**

```javascript
// ‚úÖ Padr√£o React
function Card({ children, className }) {
  return <div className={`card ${className}`}>{children}</div>;
}

function CardHeader({ children }) {
  return <div className="card-header">{children}</div>;
}

function CardBody({ children }) {
  return <div className="card-body">{children}</div>;
}

function CardFooter({ children }) {
  return <div className="card-footer">{children}</div>;
}

// Uso - Flexibilidade total
function ProductCard({ product }) {
  return (
    <Card>
      <CardHeader>
        <img src={product.image} alt={product.name} />
      </CardHeader>
      <CardBody>
        <h3>{product.name}</h3>
        <p>{product.price}</p>
      </CardBody>
      <CardFooter>
        <Button>Add to Cart</Button>
      </CardFooter>
    </Card>
  );
}

function UserCard({ user }) {
  return (
    <Card>
      <CardHeader>
        <Avatar user={user} />
      </CardHeader>
      <CardBody>
        <UserInfo user={user} />
      </CardBody>
      {/* Sem footer - n√£o problema! */}
    </Card>
  );
}

// Card customizado - ordem diferente
function InvertedCard() {
  return (
    <Card>
      <CardBody>Conte√∫do primeiro</CardBody>
      <CardHeader>Header depois</CardHeader>
    </Card>
  );
}
```

**Vantagens da composi√ß√£o:**
- Flex√≠vel: Use apenas o que precisa
- Expl√≠cito: Estrutura clara no JSX
- Reutiliz√°vel: CardHeader pode ser usado fora de Card
- Test√°vel: Componentes s√£o fun√ß√µes puras
- Customiz√°vel: Consumidor controla estrutura

---

### 3.5.2 Props Spreading

**Conceito**: Repassar props automaticamente para componentes internos usando spread operator.

**Sintaxe b√°sica:**

```javascript
function CustomInput({ label, error, ...inputProps }) {
  return (
    <div className="input-wrapper">
      {label && <label>{label}</label>}
      {/* Repassa todas as props restantes para input nativo */}
      <input {...inputProps} />
      {error && <span className="error">{error}</span>}
    </div>
  );
}

// Uso - Todas props de input nativo funcionam
<CustomInput
  label="Email"
  type="email"
  placeholder="seu@email.com"
  onChange={handleChange}
  required
  autoComplete="email"
  maxLength={100}
/>
```

**An√°lise conceitual:**

**Como funciona:**
1. Destructuring captura props espec√≠ficas (`label`, `error`)
2. Rest operator (`...inputProps`) captura todas as outras props
3. Spread operator (`{...inputProps}`) expande props no elemento

**Vantagens:**
- **Flexibilidade**: Componente aceita qualquer prop v√°lida do elemento nativo
- **Menos c√≥digo**: N√£o precisa declarar cada prop poss√≠vel
- **Compatibilidade**: Se HTML adicionar nova prop, componente j√° suporta
- **Proxy pattern**: Componente √© wrapper transparente

**Cuidados:**

```javascript
// ‚ùå Problema: Sobrescrever props espalhadas
function Button({ className, ...props }) {
  return (
    <button {...props} className="btn" /> // className de props √© ignorada!
  );
}

// ‚úÖ Solu√ß√£o: Merge manual
function Button({ className, ...props }) {
  return (
    <button {...props} className={`btn ${className || ''}`} />
  );
}

// ‚úÖ Ou spread depois
function Button({ className, ...props }) {
  return (
    <button className="btn" {...props} /> // props.className sobrescreve
  );
}
```

**Padr√£o avan√ßado: Separar props por destino:**

```javascript
function Dialog({ title, footer, children, ...dialogProps }) {
  return (
    <div {...dialogProps} className="dialog"> {/* Props do container */}
      <header>
        <h2>{title}</h2>
      </header>
      <main>{children}</main>
      <footer>{footer}</footer>
    </div>
  );
}
```

---

### 3.5.3 Props.children: Uso e Manipula√ß√£o

#### Children B√°sico

**Conceito**: `children` √© prop especial contendo conte√∫do entre tags de abertura/fechamento.

**Tipos de children:**

```javascript
function Container({ children }) {
  console.log(children); // Pode ser muitas coisas!
  return <div className="container">{children}</div>;
}

// 1. String
<Container>Texto simples</Container>
// children = "Texto simples"

// 2. Elemento √∫nico
<Container><span>Elemento</span></Container>
// children = React Element

// 3. Array de elementos
<Container>
  <p>Par√°grafo 1</p>
  <p>Par√°grafo 2</p>
</Container>
// children = Array [Element, Element]

// 4. Fun√ß√£o (Render Prop)
<Container>
  {() => <div>Conte√∫do din√¢mico</div>}
</Container>
// children = Function

// 5. null/undefined
<Container />
// children = undefined

// 6. Misturado
<Container>
  Texto
  <span>Elemento</span>
  {null}
  Mais texto
</Container>
// children = Array [String, Element, null, String]
```

**Implica√ß√£o**: Children √© tipo polim√≥rfico, precisa tratar diferentes casos.

#### React.Children API

**Problema**: Children pode ser array, elemento √∫nico, null. Manipular diretamente √© perigoso.

**Solu√ß√£o**: `React.Children` API para manipular children de forma segura.

**M√©todos:**

```javascript
import { Children, isValidElement } from 'react';

function List({ children }) {
  // 1. Children.map - Mapeia cada child (funciona com √∫nico ou array)
  const items = Children.map(children, (child, index) => (
    <li key={index}>{child}</li>
  ));

  return <ul>{items}</ul>;
}

// Uso
<List>
  <span>Item 1</span>
  <span>Item 2</span>
</List>
// Renderiza: <ul><li><span>Item 1</span></li><li><span>Item 2</span></li></ul>


// 2. Children.forEach - Itera sem retornar
function Logger({ children }) {
  Children.forEach(children, (child, index) => {
    console.log(`Child ${index}:`, child);
  });

  return <div>{children}</div>;
}


// 3. Children.count - Conta children
function Container({ children }) {
  const count = Children.count(children);
  return (
    <div>
      <p>{count} child(ren)</p>
      {children}
    </div>
  );
}


// 4. Children.only - Garante exatamente um child
function Wrapper({ children }) {
  const onlyChild = Children.only(children); // Lan√ßa erro se !== 1 child
  return <div className="wrapper">{onlyChild}</div>;
}

// ‚úÖ OK
<Wrapper><span>√önico</span></Wrapper>

// ‚ùå Erro
<Wrapper>
  <span>Primeiro</span>
  <span>Segundo</span>
</Wrapper>


// 5. Children.toArray - Converte para array
function ReversedList({ children }) {
  const childrenArray = Children.toArray(children);
  const reversed = childrenArray.reverse();

  return <ul>{reversed.map((child, i) => <li key={i}>{child}</li>)}</ul>;
}
```

**Por que React.Children √© necess√°rio:**

```javascript
// ‚ùå Problem√°tico
function BadList({ children }) {
  // Se children for √∫nico elemento, n√£o √© array!
  return <ul>{children.map(child => <li>{child}</li>)}</ul>; // Erro se √∫nico child
}

// ‚úÖ Seguro
function GoodList({ children }) {
  return <ul>{Children.map(children, child => <li>{child}</li>)}</ul>;
}
```

#### React.cloneElement

**Conceito**: Clonar elemento React e adicionar/sobrescrever props.

**Sintaxe:**

```javascript
React.cloneElement(element, props, ...children)
```

**Casos de uso:**

**1. Injetar props em children:**

```javascript
function Form({ children }) {
  // Clonar cada child e injetar prop disabled
  return (
    <form>
      {Children.map(children, child => {
        if (isValidElement(child)) {
          return React.cloneElement(child, { disabled: true });
        }
        return child;
      })}
    </form>
  );
}

// Uso
<Form>
  <input type="text" />  {/* Receber√° disabled={true} */}
  <button>Submit</button> {/* Receber√° disabled={true} */}
</Form>
```

**2. Adicionar event handlers:**

```javascript
function ClickTracker({ children }) {
  const handleClick = () => console.log('Child clicked!');

  return Children.map(children, child => {
    if (isValidElement(child)) {
      return React.cloneElement(child, {
        onClick: (e) => {
          handleClick();
          // Chama onClick original se existir
          child.props.onClick?.(e);
        }
      });
    }
    return child;
  });
}

<ClickTracker>
  <button>Button 1</button>
  <button onClick={() => console.log('Original')}>Button 2</button>
</ClickTracker>
// Ambos logam "Child clicked!", Button 2 tamb√©m loga "Original"
```

**3. Implementar Tabs (exemplo cl√°ssico):**

```javascript
function Tabs({ children, activeTab }) {
  return (
    <div className="tabs">
      {Children.map(children, (child, index) => {
        if (isValidElement(child) && child.type === Tab) {
          return React.cloneElement(child, {
            isActive: index === activeTab
          });
        }
        return child;
      })}
    </div>
  );
}

function Tab({ label, isActive, children }) {
  return (
    <div className={isActive ? 'tab active' : 'tab'}>
      {children}
    </div>
  );
}

// Uso
<Tabs activeTab={0}>
  <Tab label="First">Conte√∫do 1</Tab>
  <Tab label="Second">Conte√∫do 2</Tab>
</Tabs>
// Tabs injeta isActive em cada Tab
```

**Cuidados com cloneElement:**

- **Use com parcim√¥nia**: Torna fluxo de dados impl√≠cito e dif√≠cil de rastrear
- **Prefira Context API**: Para comunica√ß√£o entre compostos (Compound Components)
- **TypeScript**: Dif√≠cil tipar corretamente
- **Performance**: Clonar √© relativamente caro

**Quando cloneElement √© apropriado:**
- Bibliotecas de componentes (Tabs, Accordion)
- Componentes de layout que precisam injetar props
- Quando alternativa (Context) seria over-engineering

---

### 3.5.4 Padr√£o Slot (Multiple Insertion Points)

**Conceito**: Componente com m√∫ltiplos pontos de inser√ß√£o de conte√∫do, ao inv√©s de apenas `children`.

**Implementa√ß√£o via Props:**

```javascript
function Modal({ header, footer, children }) {
  return (
    <div className="modal">
      <div className="modal-header">{header}</div>
      <div className="modal-body">{children}</div>
      <div className="modal-footer">{footer}</div>
    </div>
  );
}

// Uso
<Modal
  header={<h2>Confirma√ß√£o</h2>}
  footer={
    <>
      <button onClick={onCancel}>Cancelar</button>
      <button onClick={onConfirm}>Confirmar</button>
    </>
  }
>
  <p>Tem certeza que deseja continuar?</p>
</Modal>
```

**Vantagens:**
- **Expl√≠cito**: √ìbvio que header/footer s√£o esperados
- **Flex√≠vel**: Cada slot pode receber qualquer conte√∫do
- **Opcional**: Slots podem ser omitidos

**Padr√£o avan√ßado: Named Slots com Children:**

```javascript
function Layout({ children }) {
  // Identificar children por tipo
  const header = Children.toArray(children).find(
    child => isValidElement(child) && child.type === LayoutHeader
  );

  const sidebar = Children.toArray(children).find(
    child => isValidElement(child) && child.type === LayoutSidebar
  );

  const main = Children.toArray(children).find(
    child => isValidElement(child) && child.type === LayoutMain
  );

  return (
    <div className="layout">
      <header>{header}</header>
      <aside>{sidebar}</aside>
      <main>{main}</main>
    </div>
  );
}

function LayoutHeader({ children }) {
  return children;
}

function LayoutSidebar({ children }) {
  return children;
}

function LayoutMain({ children }) {
  return children;
}

// Uso
<Layout>
  <LayoutHeader>
    <h1>T√≠tulo</h1>
  </LayoutHeader>
  <LayoutSidebar>
    <Navigation />
  </LayoutSidebar>
  <LayoutMain>
    <Content />
  </LayoutMain>
</Layout>
```

**Vantagens deste padr√£o:**
- API declarativa e leg√≠vel
- Ordem dos children n√£o importa (Layout reorganiza)
- Componentes slot podem ter l√≥gica pr√≥pria

---

### 3.5.5 Componentes Estruturais

#### Layout Components

**Conceito**: Componentes que definem estrutura, n√£o conte√∫do.

```javascript
function DashboardLayout({ sidebar, header, children }) {
  return (
    <div className="dashboard-layout">
      <aside className="sidebar">{sidebar}</aside>
      <div className="main-wrapper">
        <header className="header">{header}</header>
        <main className="content">{children}</main>
      </div>
    </div>
  );
}

// Uso
<DashboardLayout
  sidebar={<Sidebar />}
  header={<Header user={user} />}
>
  <Dashboard data={data} />
</DashboardLayout>
```

#### Wrapper Components

**Conceito**: Componentes que envolvem outros adicionando funcionalidade/estilo.

```javascript
function Card({ children, elevated }) {
  const className = elevated ? 'card elevated' : 'card';
  return <div className={className}>{children}</div>;
}

function ScrollableContainer({ children, maxHeight = 400 }) {
  return (
    <div style={{ maxHeight, overflowY: 'auto' }}>
      {children}
    </div>
  );
}
```

#### Provider Components

**Conceito**: Componentes que fornecem contexto/dados via Context API.

```javascript
function ThemeProvider({ children, theme }) {
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
}

// Uso
<ThemeProvider theme={darkTheme}>
  <App />
</ThemeProvider>
```

---

### 3.5.6 Polymorphic Components (Componente `as` prop)

**Conceito**: Componente que pode renderizar como diferentes elementos via prop `as`.

**Implementa√ß√£o b√°sica:**

```javascript
function Text({ as: Component = 'span', children, ...props }) {
  return <Component {...props}>{children}</Component>;
}

// Uso
<Text>Default (span)</Text>
<Text as="p">Par√°grafo</Text>
<Text as="h1">Heading</Text>
<Text as="label">Label</Text>
<Text as={Link} to="/home">Link customizado</Text>
```

**An√°lise:**
- **Flex√≠vel**: Um componente, m√∫ltiplos elementos
- **DRY**: Estilos compartilhados, elementos diferentes
- **Type-safe**: Com TypeScript, pode tipar props condicionalmente

**Exemplo avan√ßado com TypeScript:**

```javascript
function Button({ as = 'button', children, variant, ...props }) {
  const Component = as;
  const className = `btn btn-${variant}`;

  return (
    <Component className={className} {...props}>
      {children}
    </Component>
  );
}

// Uso
<Button variant="primary">Button nativo</Button>
<Button as="a" href="/home" variant="secondary">Link estilizado como bot√£o</Button>
<Button as={RouterLink} to="/dashboard" variant="primary">React Router Link</Button>
```

**Casos de uso:**
- Design systems (Button, Heading, Text com elementos vari√°veis)
- Componentes que precisam ser semanticamente corretos
- Integra√ß√£o com bibliotecas (usar styled-components com Router Link)

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Padr√£o

#### Children Simples
**Use quando**: Slot √∫nico de conte√∫do. Maioria dos casos.

#### Multiple Slots (Props)
**Use quando**: Estrutura fixa com v√°rias se√ß√µes (Modal, Layout).

#### Named Slots (Children por tipo)
**Use quando**: API declarativa √© priorit√°ria, estrutura complexa.

#### Polymorphic Components
**Use quando**: Componente precisa ser semanticamente flex√≠vel (design systems).

#### React.cloneElement
**Use quando**: Precisa injetar props em children (Tabs, Form wrappers). Preferir Context quando poss√≠vel.

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Trade-offs

**Composi√ß√£o aumenta flexibilidade mas:**
- Pode complicar API (muitas props, muitos sub-componentes)
- TypeScript √© desafiador (tipar children, polymorphic components)
- Performance: Mais componentes = mais √°rvore de reconcilia√ß√£o

### Armadilhas

**1. Over-engineering**: Criar componentes compostos para tudo.
**2. Abuso de cloneElement**: Torna fluxo impl√≠cito.
**3. Children validation**: Esquecer de validar tipo de children.

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Compound Components
Composition Patterns s√£o funda√ß√£o de Compound Components (pr√≥ximo t√≥pico).

### Rela√ß√£o com Design Systems
Design systems bem projetados usam composi√ß√£o extensivamente.

### Rela√ß√£o com Acessibilidade
Componentes compostos podem gerenciar ARIA attributes entre partes.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

1. **Children b√°sico** ‚Üí Props spreading ‚Üí Multiple slots
2. **Slots** ‚Üí React.Children API ‚Üí cloneElement
3. **Composi√ß√£o simples** ‚Üí Compound Components (t√≥pico avan√ßado)

### Server Components

React Server Components trazem novos desafios de composi√ß√£o (server vs client components).

---

## üìö Conclus√£o

Composition Patterns s√£o **ess√™ncia do React**. Princ√≠pios fundamentais:

1. **Composi√ß√£o > Heran√ßa**: Combine ao inv√©s de estender
2. **Children √© poderoso**: Use-o extensivamente
3. **Props spreading**: Torna componentes transparentes
4. **Multiple slots**: Para estruturas complexas
5. **Polimorfismo**: Componentes flex√≠veis via `as`

**Recomenda√ß√£o**:
- Comece com children simples
- Adicione slots quando necess√°rio
- Use cloneElement com parcim√¥nia
- Prefira composi√ß√£o expl√≠cita sobre m√°gica impl√≠cita

Composi√ß√£o bem aplicada torna c√≥digo React elegante, flex√≠vel e manuten√≠vel. √â a diferen√ßa entre componentes r√≠gidos e sistemas compon√≠veis.
