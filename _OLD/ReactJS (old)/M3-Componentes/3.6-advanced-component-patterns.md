# Advanced Component Patterns no React: Padr√µes Avan√ßados de Design

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Advanced Component Patterns s√£o **padr√µes arquiteturais sofisticados** que resolvem problemas complexos de design de componentes React, oferecendo APIs flex√≠veis, controle granular e reutiliza√ß√£o avan√ßada. Representam a **fronteira entre componentes simples e sistemas compon√≠veis complexos**, combinando m√∫ltiplos conceitos (composi√ß√£o, invers√£o de controle, state management) para criar componentes poderosos e extens√≠veis.

Estes padr√µes n√£o s√£o para uso cotidiano, mas para **bibliotecas de componentes, design systems e casos de uso complexos** onde flexibilidade m√°xima e experi√™ncia do desenvolvedor s√£o priorit√°rios.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos padr√µes avan√ßados:**

**2015-2017: Identifica√ß√£o de Limita√ß√µes**
Comunidade percebeu que padr√µes b√°sicos (props, children) eram insuficientes para componentes altamente customiz√°veis:
- Bibliotecas como Material-UI, Ant Design precisavam de flexibilidade extrema
- Componentes como Dropdowns, Modals, Tabs requeriam comunica√ß√£o complexa entre partes
- Usu√°rios queriam controlar comportamento sem fork do c√≥digo

**2017-2019: Emerg√™ncia de Padr√µes**
Kent C. Dodds popularizou padr√µes atrav√©s de workshops e artigos:
- **Compound Components**: Componentes que trabalham juntos via Context
- **Control Props**: Permitir componente ser controlled ou uncontrolled
- **State Reducer**: Usu√°rio controla transi√ß√µes de estado
- **Props Getters**: Abstrair complexidade de props de acessibilidade

**2019-hoje: Refinamento com Hooks**
Hooks tornaram implementa√ß√£o mais elegante:
- Custom hooks encapsulam l√≥gica complexa
- Context API simplificou compound components
- Patterns continuam evoluindo (Headless Components ganham popularidade)

**Motiva√ß√£o:**

1. **M√°xima Flexibilidade**: Usu√°rios podem customizar quase tudo sem modificar c√≥digo-fonte
2. **Invers√£o de Controle**: Componente prov√™ primitivas, usu√°rio controla comportamento
3. **Extensibilidade**: Adicionar funcionalidade sem breaking changes
4. **Developer Experience**: APIs intuitivas e poderosas

### Problema Fundamental que Resolve

**Problemas em componentes complexos:**

1. **Rigidez**: Componente Modal com l√≥gica fixa. E se usu√°rio quiser comportamento diferente ao fechar?

2. **Prop Explosion**: Componente com 50+ props para customizar cada aspecto. API confusa.

3. **Falta de Controle**: Dropdown gerencia estado interno. Usu√°rio n√£o consegue controlar programaticamente.

4. **Acessibilidade Complexa**: Tabs requerem ARIA attributes corretos. Usu√°rio esquece ou erra.

5. **Duplica√ß√£o**: Usu√°rios fazem fork de componente para adicionar funcionalidade pequena.

**Padr√µes avan√ßados resolvem:**

- **Compound Components**: Estrutura flex√≠vel, comunica√ß√£o impl√≠cita
- **State Reducer**: Usu√°rio controla l√≥gica de estado
- **Control Props**: Componente pode ser controlled/uncontrolled
- **Props Getters**: Abstrai complexidade, fornece props prontas
- **Headless Components**: Separa√ß√£o total l√≥gica/UI

### Import√¢ncia no Ecossistema

Estes padr√µes s√£o **funda√ß√£o de bibliotecas populares**:

- **Radix UI**: Primitivos acess√≠veis usando compound components e props getters
- **Headless UI**: Componentes headless (l√≥gica sem UI)
- **Downshift**: Autocomplete/dropdown com state reducer e control props
- **React Table**: Hooks compos√°veis com props getters
- **Reach UI**: Componentes acess√≠veis com compound components

**Import√¢ncia:**
- **Bibliotecas**: Padr√£o para design systems profissionais
- **Aprendizado**: Entender torna desenvolvedor avan√ßado
- **Arquitetura**: Refer√™ncia para decis√µes de API design

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Invers√£o de Controle Total**: Usu√°rio controla comportamento, componente prov√™ primitivas
2. **State Management Flex√≠vel**: Estado pode ser interno ou controlado externamente
3. **Separa√ß√£o L√≥gica/UI**: L√≥gica reutiliz√°vel, UI substitu√≠vel
4. **Abstra√ß√£o de Complexidade**: Props getters escondem detalhes de implementa√ß√£o
5. **Composi√ß√£o Avan√ßada**: M√∫ltiplos padr√µes combinados

### Pilares Fundamentais

- **Compound Components**: Sub-componentes comunicam via Context
- **State Reducer Pattern**: Usu√°rio intercepta e modifica transi√ß√µes de estado
- **Control Props Pattern**: Componente funciona controlled/uncontrolled
- **Props Getters Pattern**: Fun√ß√µes que retornam props corretas
- **Headless Components**: L√≥gica sem UI

### Vis√£o Geral das Nuances

- **Complexidade vs Flexibilidade**: Mais poder = API mais complexa
- **TypeScript desafiador**: Tipos complexos para padr√µes avan√ßados
- **Documenta√ß√£o cr√≠tica**: Padr√µes n√£o s√£o √≥bvios, precisam documenta√ß√£o
- **Trade-off performance**: Mais abstra√ß√µes = overhead (geralmente neglig√≠vel)

---

## üß† Fundamentos Te√≥ricos

### Filosofia: Inversion of Control (IoC)

**Princ√≠pio central**: Componente n√£o decide comportamento, **usu√°rio decide**.

**Analogia**: Framework vs Biblioteca
- **Framework**: Voc√™ √© controlado (Rails diz como estruturar app)
- **Biblioteca**: Voc√™ controla (React prov√™ primitivas, voc√™ decide estrutura)

**Aplica√ß√£o a componentes:**

**Baixo controle (componente decide tudo):**

```javascript
function Modal() {
  const [isOpen, setIsOpen] = useState(false);
  // Usu√°rio n√£o pode controlar quando/como modal abre/fecha
  return <div>{/* ... */}</div>;
}
```

**Alto controle (usu√°rio decide tudo):**

```javascript
function Modal({ isOpen, onClose, children }) {
  // Usu√°rio controla estado externamente
  return isOpen ? <div>{children}</div> : null;
}
```

**Padr√µes avan√ßados levam IoC ao extremo**: Usu√°rio pode controlar estado, l√≥gica, rendering, transi√ß√µes.

---

## üîç An√°lise Conceitual Profunda

### 3.6.1 State Initializer Pattern

**Conceito**: Permitir reset de estado para valor inicial.

**Problema**: Componente com estado complexo. Como resetar para estado inicial?

**Solu√ß√£o b√°sica:**

```javascript
function Counter({ initialCount = 0 }) {
  const [count, setCount] = useState(initialCount);

  const reset = () => setCount(initialCount);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

**Problema avan√ßado**: initialCount pode mudar ap√≥s mount. Como sincronizar?

**Solu√ß√£o com ref:**

```javascript
function Counter({ initialCount = 0 }) {
  const initialCountRef = useRef(initialCount);
  const [count, setCount] = useState(initialCount);

  // Atualiza ref se prop mudar
  useEffect(() => {
    initialCountRef.current = initialCount;
  }, [initialCount]);

  const reset = () => setCount(initialCountRef.current);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

**Uso**: Formul√°rios complexos, componentes com m√∫ltiplos estados inter-relacionados.

---

### 3.6.2 State Reducer Pattern

**Conceito**: Usu√°rio fornece reducer customizado para controlar transi√ß√µes de estado.

**Motiva√ß√£o**: Componente tem l√≥gica de estado. Usu√°rio quer customizar transi√ß√µes sem fork.

**Implementa√ß√£o:**

```javascript
// Actions do componente
const actions = {
  INCREMENT: 'INCREMENT',
  DECREMENT: 'DECREMENT',
  RESET: 'RESET'
};

// Reducer padr√£o do componente
function defaultReducer(state, action) {
  switch (action.type) {
    case actions.INCREMENT:
      return { count: state.count + 1 };
    case actions.DECREMENT:
      return { count: state.count - 1 };
    case actions.RESET:
      return { count: 0 };
    default:
      return state;
  }
}

// Componente aceita reducer customizado
function Counter({ initialCount = 0, reducer = defaultReducer }) {
  const [state, dispatch] = useReducer(reducer, { count: initialCount });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: actions.INCREMENT })}>+</button>
      <button onClick={() => dispatch({ type: actions.DECREMENT })}>-</button>
      <button onClick={() => dispatch({ type: actions.RESET })}>Reset</button>
    </div>
  );
}

// Uso padr√£o (sem customiza√ß√£o)
<Counter />

// Uso avan√ßado: limitar count a 10
function customReducer(state, action) {
  const newState = defaultReducer(state, action);

  // L√≥gica customizada: nunca passar de 10
  if (newState.count > 10) {
    return { count: 10 };
  }

  return newState;
}

<Counter reducer={customReducer} />

// Ou: prevenir decrementar abaixo de 0
function noNegativeReducer(state, action) {
  const newState = defaultReducer(state, action);
  return { count: Math.max(0, newState.count) };
}

<Counter reducer={noNegativeReducer} />
```

**An√°lise conceitual:**

**Vantagens:**
- **Flexibilidade m√°xima**: Usu√°rio controla transi√ß√µes
- **Sem fork**: Customizar sem modificar c√≥digo-fonte
- **Composi√ß√£o**: Pode chamar reducer padr√£o e modificar resultado
- **Test√°vel**: Usu√°rio testa seu reducer isoladamente

**Casos de uso reais:**

**Downshift (autocomplete library):**

```javascript
import { useCombobox } from 'downshift';

function Autocomplete({ items }) {
  const stateReducer = (state, actionAndChanges) => {
    const { type, changes } = actionAndChanges;

    // Customizar: n√£o fechar ao selecionar
    if (type === useCombobox.stateChangeTypes.ItemClick) {
      return {
        ...changes,
        isOpen: true, // Manter aberto (padr√£o seria fechar)
      };
    }

    return changes;
  };

  const { getInputProps, getMenuProps, getItemProps } = useCombobox({
    items,
    stateReducer, // Inject reducer customizado
  });

  // Renderizar autocomplete...
}
```

**Quando usar:**
- Bibliotecas de componentes (permitir customiza√ß√£o)
- Componentes com estado complexo
- Quando usu√°rios precisam de l√≥gica customizada

---

### 3.6.3 Control Props Pattern

**Conceito**: Componente funciona como controlled OU uncontrolled, dependendo de props passadas.

**Motiva√ß√£o**: Flexibilidade. Simples por padr√£o (uncontrolled), poderoso quando necess√°rio (controlled).

**Implementa√ß√£o:**

```javascript
function Toggle({
  // Control props (se passadas, componente √© controlled)
  on: controlledOn,
  onChange: controlledOnChange,
  // Prop padr√£o (se control props n√£o passadas)
  defaultOn = false
}) {
  // Estado interno (usado apenas se uncontrolled)
  const [internalOn, setInternalOn] = useState(defaultOn);

  // Determinar se √© controlled
  const isControlled = controlledOn !== undefined;

  // Valor atual (controlled ou internal)
  const on = isControlled ? controlledOn : internalOn;

  // Setter (chama callback se controlled, ou atualiza state interno)
  const setOn = (newValue) => {
    if (isControlled) {
      controlledOnChange?.(newValue);
    } else {
      setInternalOn(newValue);
    }
  };

  const toggle = () => setOn(!on);

  return (
    <button onClick={toggle}>
      {on ? 'ON' : 'OFF'}
    </button>
  );
}

// Uso uncontrolled (estado interno)
<Toggle defaultOn={false} />

// Uso controlled (estado externo)
function App() {
  const [isOn, setIsOn] = useState(false);

  return (
    <>
      <Toggle on={isOn} onChange={setIsOn} />
      <p>Estado externo: {isOn ? 'ON' : 'OFF'}</p>
    </>
  );
}
```

**Pattern mais robusto (warning se misturar controlled/uncontrolled):**

```javascript
function useControlledState(controlledValue, defaultValue, onChange) {
  const [internalValue, setInternalValue] = useState(defaultValue);
  const isControlled = controlledValue !== undefined;

  // Warn se mudar de controlled para uncontrolled
  const wasControlled = useRef(isControlled);
  useEffect(() => {
    if (wasControlled.current !== isControlled) {
      console.warn(
        `Component mudou de ${wasControlled.current ? 'controlled' : 'uncontrolled'} ` +
        `para ${isControlled ? 'controlled' : 'uncontrolled'}. Isso pode causar bugs.`
      );
    }
    wasControlled.current = isControlled;
  }, [isControlled]);

  const value = isControlled ? controlledValue : internalValue;

  const setValue = useCallback((newValue) => {
    if (isControlled) {
      onChange?.(newValue);
    } else {
      setInternalValue(newValue);
    }
  }, [isControlled, onChange]);

  return [value, setValue];
}

// Uso simplificado
function Toggle({ on: controlledOn, onChange, defaultOn = false }) {
  const [on, setOn] = useControlledState(controlledOn, defaultOn, onChange);

  return <button onClick={() => setOn(!on)}>{on ? 'ON' : 'OFF'}</button>;
}
```

**Casos de uso:**
- Componentes de formul√°rio (Input, Select, Checkbox)
- Modals, Dropdowns (pode ser controlado externamente ou auto-gerenciado)
- Tabs, Accordion

**Bibliotecas que usam:**
- React Hook Form (inputs controlled/uncontrolled)
- Radix UI (componentes podem ser controlled)

---

### 3.6.4 Props Collection / Props Getters Pattern

**Conceito**: Fornecer fun√ß√µes que retornam props corretas para aplicar em elementos.

**Problema**: Componente acess√≠vel requer m√∫ltiplas props ARIA + event handlers. Usu√°rio pode esquecer ou errar.

**Solu√ß√£o ruim (exigir props manualmente):**

```javascript
function useToggle() {
  const [on, setOn] = useState(false);

  return {
    on,
    toggle: () => setOn(!on),
    // Usu√°rio precisa aplicar tudo isso manualmente:
    buttonProps: {
      'aria-pressed': on,
      onClick: () => setOn(!on),
    }
  };
}

// Uso - f√°cil esquecer props
function Toggle() {
  const { on, buttonProps } = useToggle();
  // E se usu√°rio esquecer de aplicar buttonProps? ‚ùå
  return <button>Toggle</button>;
}
```

**Solu√ß√£o com Props Getter:**

```javascript
function useToggle() {
  const [on, setOn] = useState(false);

  // Props getter: fun√ß√£o que retorna props
  const getTogglerProps = (props = {}) => ({
    'aria-pressed': on,
    onClick: () => setOn(!on),
    ...props, // Permite override
  });

  return {
    on,
    getTogglerProps,
  };
}

// Uso - √≥bvio que precisa chamar getter
function Toggle() {
  const { on, getTogglerProps } = useToggle();

  return (
    <button {...getTogglerProps()}>
      {on ? 'ON' : 'OFF'}
    </button>
  );
}

// Customiza√ß√£o: adicionar props extras
function CustomToggle() {
  const { on, getTogglerProps } = useToggle();

  return (
    <button {...getTogglerProps({ className: 'custom-toggle' })}>
      {on ? 'ON' : 'OFF'}
    </button>
  );
}
```

**Props Getter avan√ßado (merge event handlers):**

```javascript
function useToggle() {
  const [on, setOn] = useState(false);

  const getTogglerProps = ({ onClick, ...props } = {}) => ({
    'aria-pressed': on,
    onClick: (event) => {
      // Chamar handler do componente
      setOn(!on);
      // Chamar handler customizado se fornecido
      onClick?.(event);
    },
    ...props,
  });

  return { on, getTogglerProps };
}

// Uso com handler customizado
function Toggle() {
  const { on, getTogglerProps } = useToggle();

  return (
    <button {...getTogglerProps({
      onClick: () => console.log('Custom handler!')
    })}>
      {on ? 'ON' : 'OFF'}
    </button>
  );
}
// Ambos handlers s√£o chamados
```

**Caso de uso real: Dropdown acess√≠vel:**

```javascript
function useDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const buttonId = useId();
  const menuId = useId();

  const getButtonProps = (props = {}) => ({
    id: buttonId,
    'aria-haspopup': 'true',
    'aria-expanded': isOpen,
    'aria-controls': menuId,
    onClick: () => setIsOpen(!isOpen),
    ...props,
  });

  const getMenuProps = (props = {}) => ({
    id: menuId,
    role: 'menu',
    'aria-labelledby': buttonId,
    hidden: !isOpen,
    ...props,
  });

  const getItemProps = ({ onClick, ...props } = {}) => ({
    role: 'menuitem',
    onClick: (e) => {
      setIsOpen(false);
      onClick?.(e);
    },
    ...props,
  });

  return {
    isOpen,
    getButtonProps,
    getMenuProps,
    getItemProps,
  };
}

// Uso - acessibilidade autom√°tica
function Dropdown() {
  const { isOpen, getButtonProps, getMenuProps, getItemProps } = useDropdown();

  return (
    <div>
      <button {...getButtonProps()}>Menu</button>
      <ul {...getMenuProps()}>
        <li {...getItemProps({ onClick: () => console.log('Item 1') })}>
          Item 1
        </li>
        <li {...getItemProps({ onClick: () => console.log('Item 2') })}>
          Item 2
        </li>
      </ul>
    </div>
  );
}
```

**Vantagens:**
- **Acessibilidade**: Props ARIA corretas automaticamente
- **DX**: API clara e dif√≠cil de usar incorretamente
- **Flexibilidade**: Usu√°rio pode adicionar props customizadas
- **Manuten√ß√£o**: Mudar implementa√ß√£o interna n√£o quebra uso

**Bibliotecas que usam:**
- **Downshift**: getInputProps, getMenuProps, getItemProps
- **React Table**: getTableProps, getTableBodyProps, getRowProps
- **Reach UI**: M√∫ltiplos getters para componentes acess√≠veis

---

### 3.6.5 Compound Components Pattern

**Conceito**: Componentes que trabalham juntos implicitamente via Context.

**Problema**: Tabs requer coordena√ß√£o entre TabList, Tab, TabPanel. Como comunicar sem prop drilling?

**Solu√ß√£o sem Compound Components (ruim):**

```javascript
<Tabs activeTab={0}>
  <TabList tabs={['Tab 1', 'Tab 2']} onTabChange={handleChange} />
  <TabPanel index={0}>Content 1</TabPanel>
  <TabPanel index={1}>Content 2</TabPanel>
</Tabs>
// TabPanel precisa saber index, TabList recebe dados... prop drilling
```

**Solu√ß√£o com Compound Components:**

```javascript
// Context para compartilhar estado
const TabsContext = createContext();

function Tabs({ children, defaultActiveTab = 0 }) {
  const [activeTab, setActiveTab] = useState(defaultActiveTab);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list" role="tablist">{children}</div>;
}

function Tab({ index, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === index;

  return (
    <button
      role="tab"
      aria-selected={isActive}
      onClick={() => setActiveTab(index)}
      className={isActive ? 'tab active' : 'tab'}
    >
      {children}
    </button>
  );
}

function TabPanel({ index, children }) {
  const { activeTab } = useContext(TabsContext);

  if (activeTab !== index) return null;

  return (
    <div role="tabpanel" className="tab-panel">
      {children}
    </div>
  );
}

// API p√∫blica
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Uso - limpo e declarativo
<Tabs defaultActiveTab={0}>
  <Tabs.List>
    <Tabs.Tab index={0}>Tab 1</Tabs.Tab>
    <Tabs.Tab index={1}>Tab 2</Tabs.Tab>
    <Tabs.Tab index={2}>Tab 3</Tabs.Tab>
  </Tabs.List>

  <Tabs.Panel index={0}>
    <h2>Content 1</h2>
    <p>Primeiro painel</p>
  </Tabs.Panel>

  <Tabs.Panel index={1}>
    <h2>Content 2</h2>
    <p>Segundo painel</p>
  </Tabs.Panel>

  <Tabs.Panel index={2}>
    <h2>Content 3</h2>
    <p>Terceiro painel</p>
  </Tabs.Panel>
</Tabs>
```

**Vantagens:**
- **API declarativa**: Estrutura clara
- **Sem prop drilling**: Context comunica implicitamente
- **Flexibilidade**: Ordem, aninhamento flex√≠vel
- **Composi√ß√£o**: Adicionar sub-componentes sem quebrar API

**Pattern avan√ßado: Valida√ß√£o de estrutura:**

```javascript
function Tabs({ children }) {
  // Validar que children s√£o componentes v√°lidos
  Children.forEach(children, child => {
    if (isValidElement(child)) {
      const validTypes = [TabList, TabPanel];
      if (!validTypes.includes(child.type)) {
        console.warn('Tabs s√≥ aceita TabList e TabPanel como filhos');
      }
    }
  });

  // ...resto da implementa√ß√£o
}
```

**Bibliotecas que usam:**
- **Radix UI**: Todos componentes s√£o compound components
- **Reach UI**: Tabs, Accordion, Menu
- **Chakra UI**: Muitos componentes compostos

---

### 3.6.6 Headless Components Pattern

**Conceito**: Separa√ß√£o total entre l√≥gica (hooks) e UI (renderiza√ß√£o).

**Motiva√ß√£o**: L√≥gica √© reutiliz√°vel mas UI varia (design systems diferentes).

**Implementa√ß√£o:**

```javascript
// Hook headless: apenas l√≥gica
function useToggle({ initialOn = false } = {}) {
  const [on, setOn] = useState(initialOn);

  const toggle = () => setOn(prev => !prev);
  const setOnState = () => setOn(true);
  const setOffState = () => setOn(false);

  return {
    on,
    toggle,
    setOn: setOnState,
    setOff: setOffState,
  };
}

// UI 1: Switch
function ToggleSwitch() {
  const { on, toggle } = useToggle();

  return (
    <button
      onClick={toggle}
      className={on ? 'switch on' : 'switch off'}
      role="switch"
      aria-checked={on}
    >
      <span className="switch-thumb" />
    </button>
  );
}

// UI 2: Checkbox
function ToggleCheckbox() {
  const { on, toggle } = useToggle();

  return (
    <label>
      <input type="checkbox" checked={on} onChange={toggle} />
      Toggle
    </label>
  );
}

// UI 3: Texto
function ToggleText() {
  const { on, toggle } = useToggle();

  return (
    <button onClick={toggle}>
      {on ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode'}
    </button>
  );
}
```

**Caso real: Autocomplete headless:**

```javascript
// Hook headless para autocomplete
function useAutocomplete({ items, onSelect }) {
  const [inputValue, setInputValue] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(0);

  const filteredItems = items.filter(item =>
    item.toLowerCase().includes(inputValue.toLowerCase())
  );

  const selectItem = (item) => {
    setInputValue(item);
    setIsOpen(false);
    onSelect?.(item);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowDown') {
      setHighlightedIndex(i => Math.min(i + 1, filteredItems.length - 1));
    } else if (e.key === 'ArrowUp') {
      setHighlightedIndex(i => Math.max(i - 1, 0));
    } else if (e.key === 'Enter') {
      selectItem(filteredItems[highlightedIndex]);
    } else if (e.key === 'Escape') {
      setIsOpen(false);
    }
  };

  return {
    inputValue,
    setInputValue,
    isOpen,
    setIsOpen,
    filteredItems,
    highlightedIndex,
    selectItem,
    handleKeyDown,
  };
}

// UI customizada 1: Simples
function SimpleAutocomplete({ items, onSelect }) {
  const {
    inputValue,
    setInputValue,
    isOpen,
    setIsOpen,
    filteredItems,
    selectItem,
    handleKeyDown,
  } = useAutocomplete({ items, onSelect });

  return (
    <div>
      <input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onFocus={() => setIsOpen(true)}
        onKeyDown={handleKeyDown}
      />
      {isOpen && (
        <ul>
          {filteredItems.map(item => (
            <li key={item} onClick={() => selectItem(item)}>
              {item}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

// UI customizada 2: Com √≠cones e estilo diferente
function FancyAutocomplete({ items, onSelect }) {
  const { inputValue, setInputValue, isOpen, filteredItems, selectItem } =
    useAutocomplete({ items, onSelect });

  return (
    <div className="fancy-autocomplete">
      <div className="input-wrapper">
        <SearchIcon />
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Buscar..."
        />
      </div>
      {isOpen && (
        <div className="dropdown">
          {filteredItems.map(item => (
            <div className="item" onClick={() => selectItem(item)}>
              <ItemIcon />
              <span>{item}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

**Vantagens:**
- **Reutiliza√ß√£o m√°xima**: L√≥gica compartilhada, UI independente
- **Flexibilidade total**: Zero opini√µes sobre UI
- **F√°cil customizar**: Usu√°rio controla 100% da renderiza√ß√£o
- **F√°cil testar**: L√≥gica test√°vel sem renderizar UI

**Bibliotecas headless:**
- **Headless UI**: Componentes sem estilo (Tailwind Labs)
- **Downshift**: Autocomplete/dropdown headless
- **React Table**: Tabelas headless
- **React Hook Form**: Forms headless

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Padr√£o

#### State Reducer
**Use quando**: Usu√°rios precisam customizar l√≥gica de transi√ß√£o de estado (bibliotecas).

#### Control Props
**Use quando**: Componente pode ser simples (uncontrolled) ou controlado externamente (forms, modals).

#### Props Getters
**Use quando**: Componente requer props complexas (ARIA, event handlers) que usu√°rio pode esquecer.

#### Compound Components
**Use quando**: M√∫ltiplos sub-componentes precisam coordenar (Tabs, Accordion, Menu).

#### Headless Components
**Use quando**: L√≥gica √© reutiliz√°vel mas UI varia (design systems, bibliotecas).

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Trade-offs

**Complexidade:**
- Padr√µes avan√ßados tornam c√≥digo mais complexo
- Requer documenta√ß√£o extensa
- Curva de aprendizado alta

**Performance:**
- Context pode causar re-renders (otimize com useMemo)
- Props getters t√™m overhead (geralmente neglig√≠vel)

**TypeScript:**
- Tipos complexos para padr√µes avan√ßados
- Props getters dif√≠ceis de tipar corretamente

### Quando N√ÉO Usar

- Componentes simples (Button, Input b√°sico)
- Projetos pequenos (overhead > benef√≠cio)
- Equipe j√∫nior (preferir padr√µes simples)

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Hooks
Padr√µes avan√ßados dependem fortemente de hooks customizados.

### Rela√ß√£o com Context API
Compound Components usam Context extensivamente.

### Rela√ß√£o com Acessibilidade
Props Getters abstraem complexidade de ARIA.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Tend√™ncias Futuras

**React Server Components:**
Novos desafios para padr√µes (l√≥gica server vs client).

**React Compiler:**
Otimiza√ß√µes autom√°ticas podem tornar alguns padr√µes desnecess√°rios.

**Headless dominando:**
Design systems modernos favorecem headless components.

---

## üìö Conclus√£o

Advanced Component Patterns s√£o **ferramentas poderosas** para criar componentes flex√≠veis e reutiliz√°veis. Principais li√ß√µes:

1. **State Reducer**: Usu√°rio controla transi√ß√µes
2. **Control Props**: Componente controlled/uncontrolled
3. **Props Getters**: Abstrai complexidade de props
4. **Compound Components**: Coordena√ß√£o via Context
5. **Headless**: Separa√ß√£o total l√≥gica/UI

**Recomenda√ß√£o:**
- Use apenas quando necess√°rio
- Preferir simplicidade quando poss√≠vel
- Documentar extensivamente
- Reservar para bibliotecas e design systems

Estes padr√µes separam bibliotecas amadoras de profissionais. N√£o s√£o para todo c√≥digo, mas quando apropriados, transformam componentes r√≠gidos em sistemas poderosos e extens√≠veis.

**Estudo recomendado:**
- Kent C. Dodds: "Advanced React Component Patterns"
- Radix UI: Source code (refer√™ncia de implementa√ß√£o)
- Downshift: Exemplo real de todos padr√µes combinados

Dominar padr√µes avan√ßados √© marca de desenvolvedor React s√™nior.
