# Component Patterns no React: Padr√µes de Design para Componentes

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Component Patterns s√£o **solu√ß√µes arquiteturais recorrentes** para problemas comuns de design de componentes React. S√£o abstra√ß√µes conceituais que definem como componentes devem ser estruturados, como se comunicam, onde vive o estado, e como l√≥gica √© distribu√≠da e reutilizada. Representam o **vocabul√°rio de design** que a comunidade React desenvolveu para expressar inten√ß√µes arquiteturais de forma clara e padronizada.

Esses padr√µes n√£o s√£o c√≥digo espec√≠fico, mas **princ√≠pios e estruturas** que podem ser implementados de diversas formas. S√£o o equivalente em React dos Design Patterns cl√°ssicos (Gang of Four) da engenharia de software, adaptados para programa√ß√£o declarativa e composicional.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos padr√µes:**

**2013-2015:** React era novo, padr√µes ainda emergindo. Componentes eram principalmente apresentacionais ou de classe com estado.

**2015-2017:** Comunidade identificou problemas recorrentes:
- Como separar l√≥gica de apresenta√ß√£o?
- Como reutilizar comportamento sem heran√ßa?
- Como evitar prop drilling?

Surgiram padr√µes cl√°ssicos:
- **Container/Presentational** (Dan Abramov, 2015)
- **Higher-Order Components (HOCs)** (inspirado em Higher-Order Functions)
- **Render Props** (Michael Jackson, 2017)

**2018-hoje:** Hooks revolucionaram padr√µes:
- Custom Hooks substitu√≠ram HOCs/Render Props para reutiliza√ß√£o
- Controlled/Uncontrolled permanecem relevantes para forms
- Novos padr√µes emergiram: Compound Components, Headless Components

**Motiva√ß√£o para padr√µes:**
1. **Comunica√ß√£o:** Nome ao inv√©s de explicar estrutura ("use um HOC" vs "crie fun√ß√£o que retorna componente que...")
2. **Reutiliza√ß√£o:** Evitar reinventar a roda
3. **Manutenibilidade:** C√≥digo estruturado segundo padr√µes conhecidos √© mais f√°cil de entender
4. **Onboarding:** Novos devs aprendem padr√µes uma vez, aplicam em m√∫ltiplos contextos

### Problema Fundamental que Resolve

Sem padr√µes, cada desenvolvedor inventa solu√ß√µes ad-hoc para problemas comuns:
- **Inconsist√™ncia:** C√≥digo de diferentes pessoas n√£o se parece
- **Complexidade:** Solu√ß√µes reinventadas s√£o frequentemente sub√≥timas
- **Falta de Nomenclatura:** Dif√≠cil discutir arquitetura sem vocabul√°rio comum

**Padr√µes resolvem:**
- **Consist√™ncia:** Solu√ß√£o padr√£o para problema padr√£o
- **Comunica√ß√£o:** "Use render prop aqui" √© claro e conciso
- **Qualidade:** Padr√µes testados pela comunidade s√£o melhores que inven√ß√µes individuais
- **Velocidade:** N√£o perder tempo decidindo estrutura, aplicar padr√£o conhecido

### Import√¢ncia no Ecossistema

Padr√µes s√£o **linguagem compartilhada** do ecossistema React:

- **Code Reviews:** "Este componente deveria ser presentational" √© feedback acion√°vel
- **Arquitetura:** Decis√µes de design expressas em termos de padr√µes
- **Bibliotecas:** React Hook Form, Headless UI, Radix implementam padr√µes espec√≠ficos
- **Entrevistas:** Conhecer padr√µes √© expectativa para posi√ß√µes React s√™nior
- **Evolu√ß√£o:** Comunidade discute trade-offs de padr√µes, refinando-os continuamente

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Separa√ß√£o de Responsabilidades:** Container vs Presentational separa l√≥gica de UI
2. **Controle de Estado:** Controlled vs Uncontrolled define quem gerencia estado
3. **Reutiliza√ß√£o de L√≥gica:** HOCs, Render Props, Custom Hooks compartilham comportamento
4. **Invers√£o de Controle:** Componentes flex√≠veis delegam decis√µes ao consumidor
5. **Composi√ß√£o:** Combinar padr√µes para solu√ß√µes complexas

### Pilares Fundamentais

- **Container/Presentational:** Divis√£o entre l√≥gica (containers) e UI (presentational)
- **Controlled Components:** React controla estado do formul√°rio via props
- **Uncontrolled Components:** DOM controla estado, React l√™ via refs
- **Higher-Order Components:** Fun√ß√£o que recebe componente e retorna componente melhorado
- **Render Props:** Componente recebe fun√ß√£o como prop para renderizar conte√∫do

### Vis√£o Geral das Nuances

- **Hooks tornaram HOCs menos necess√°rios:** Custom hooks s√£o mais simples
- **Controlled √© preferido:** Uncontrolled para casos espec√≠ficos (performance, integra√ß√£o)
- **Padr√µes se comp√µem:** Container pode usar HOC que usa Render Prop
- **Trade-offs:** Cada padr√£o tem custos (complexidade, performance, verbosidade)

---

## üß† Fundamentos Te√≥ricos

### Filosofia de Design de Componentes

#### Princ√≠pio 1: Separation of Concerns (SoC)

Componentes devem ter **responsabilidade √∫nica**. Padr√µes ajudam a separar:

- **O qu√™ renderizar** (Presentational)
- **Como obter dados** (Container)
- **Quando algo acontece** (L√≥gica de neg√≥cio)

**Exemplo sem separa√ß√£o:**

```javascript
// ‚ùå Tudo em um componente (Deus componente)
function UserDashboard() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser().then(setUser);
    fetchPosts().then(setPosts);
    setLoading(false);
  }, []);

  if (loading) return <Spinner />;

  return (
    <div className="dashboard">
      <h1>{user.name}</h1>
      <Avatar src={user.avatar} />
      <Bio text={user.bio} />
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <h3>{post.title}</h3>
            <p>{post.content}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Com separa√ß√£o (Container/Presentational):**

```javascript
// Container: L√≥gica e dados
function UserDashboardContainer() {
  const { user, posts, loading } = useUserDashboard(); // Custom hook

  if (loading) return <Spinner />;

  return <UserDashboard user={user} posts={posts} />;
}

// Presentational: Apenas UI
function UserDashboard({ user, posts }) {
  return (
    <div className="dashboard">
      <UserProfile user={user} />
      <PostsList posts={posts} />
    </div>
  );
}
```

#### Princ√≠pio 2: Composi√ß√£o sobre Heran√ßa

React favorece **composi√ß√£o** (combinar componentes) ao inv√©s de **heran√ßa** (classes estendendo classes).

**Heran√ßa (evitado em React):**

```javascript
class BaseButton extends Component { /* ... */ }
class PrimaryButton extends BaseButton { /* ... */ }
class SecondaryButton extends BaseButton { /* ... */ }
```

**Composi√ß√£o (idiom√°tico em React):**

```javascript
function Button({ variant, children }) {
  const className = `btn btn-${variant}`;
  return <button className={className}>{children}</button>;
}

// Uso
<Button variant="primary">Click</Button>
<Button variant="secondary">Cancel</Button>
```

Padr√µes como Compound Components e Children levam composi√ß√£o ao extremo.

---

## üîç An√°lise Conceitual Profunda

### 3.4.1 Container/Presentational (Smart/Dumb)

**Conceito:** Separar componentes em duas categorias:
- **Containers (Smart):** Lidam com l√≥gica, estado, side effects
- **Presentational (Dumb):** Apenas renderizam UI com base em props

#### Containers (Smart Components)

**Responsabilidades:**
- Buscar dados (fetch, subscriptions)
- Gerenciar estado local/global
- L√≥gica de neg√≥cio
- Passar dados para componentes presentational

**Caracter√≠sticas:**
- Pouco ou nenhum JSX pr√≥prio
- Comp√µem outros componentes
- Usam hooks (useState, useEffect, useContext)

**Exemplo:**

```javascript
// UserListContainer.jsx
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('');

  useEffect(() => {
    fetchUsers()
      .then(data => {
        setUsers(data);
        setLoading(false);
      });
  }, []);

  const filteredUsers = users.filter(u =>
    u.name.toLowerCase().includes(filter.toLowerCase())
  );

  function handleDelete(userId) {
    deleteUser(userId).then(() => {
      setUsers(prev => prev.filter(u => u.id !== userId));
    });
  }

  if (loading) return <Spinner />;

  return (
    <UserList
      users={filteredUsers}
      onDelete={handleDelete}
      filter={filter}
      onFilterChange={setFilter}
    />
  );
}
```

#### Presentational (Dumb Components)

**Responsabilidades:**
- Renderizar UI
- Receber dados via props
- Chamar callbacks de props para eventos

**Caracter√≠sticas:**
- N√£o usam hooks de estado/efeito (podem usar useMemo, useCallback)
- Fun√ß√£o pura de props ‚Üí JSX
- Altamente reutiliz√°veis
- F√°ceis de testar (sem side effects)

**Exemplo:**

```javascript
// UserList.jsx (presentational)
function UserList({ users, onDelete, filter, onFilterChange }) {
  return (
    <div className="user-list">
      <input
        type="text"
        value={filter}
        onChange={(e) => onFilterChange(e.target.value)}
        placeholder="Filtrar usu√°rios..."
      />

      <ul>
        {users.map(user => (
          <UserCard
            key={user.id}
            user={user}
            onDelete={() => onDelete(user.id)}
          />
        ))}
      </ul>
    </div>
  );
}

function UserCard({ user, onDelete }) {
  return (
    <li className="user-card">
      <img src={user.avatar} alt={user.name} />
      <div>
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
      <button onClick={onDelete}>Deletar</button>
    </li>
  );
}
```

**An√°lise conceitual:**

**Vantagens:**
- **Testabilidade:** Presentational s√£o fun√ß√µes puras, f√°ceis de testar
- **Reutiliza√ß√£o:** UserList pode receber dados de qualquer fonte
- **Design:** Designers podem trabalhar em presentational sem entender l√≥gica
- **Performance:** Presentational podem ser memoizados (React.memo)

**Desvantagens:**
- **Verbosidade:** Mais arquivos, mais boilerplate
- **Prop Drilling:** Containers passam muitas props para presentational
- **Overhead:** Para componentes simples, separa√ß√£o pode ser over-engineering

**Quando usar:**
- Componentes complexos com muita l√≥gica
- Componentes altamente reutiliz√°veis (design systems)
- Quando equipe tem designers trabalhando em UI

**Quando evitar:**
- Componentes pequenos e simples
- L√≥gica √© trivial (um useState)

**Evolu√ß√£o com Hooks:**

Antes dos hooks, containers eram classes e presentational eram fun√ß√µes. Com hooks, **ambos podem ser fun√ß√µes**. Custom hooks podem extrair l√≥gica do container:

```javascript
// Custom hook (l√≥gica reutiliz√°vel)
function useUserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUsers().then(data => {
      setUsers(data);
      setLoading(false);
    });
  }, []);

  const deleteUser = (userId) => {
    return deleteUserApi(userId).then(() => {
      setUsers(prev => prev.filter(u => u.id !== userId));
    });
  };

  return { users, loading, deleteUser };
}

// Container simplificado (usa hook)
function UserListContainer() {
  const { users, loading, deleteUser } = useUserList();

  if (loading) return <Spinner />;

  return <UserList users={users} onDelete={deleteUser} />;
}
```

Isso torna padr√£o ainda mais poderoso: l√≥gica em hook, container fino, presentational puro.

---

### 3.4.2 Controlled vs Uncontrolled Components

Padr√£o espec√≠fico para **formul√°rios e inputs**, define **quem controla o estado**.

#### Controlled Components

**Conceito:** React controla valor do input via **state** e **props**.

**Sintaxe b√°sica:**

```javascript
function ControlledForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log({ name, email });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={name}  // Valor controlado por React
        onChange={(e) => setName(e.target.value)}  // React atualiza state
      />
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Fluxo conceitual:**

1. Estado `name` √© a **fonte da verdade**
2. Input renderiza com `value={name}`
3. Usu√°rio digita ‚Üí evento onChange
4. onChange atualiza state via `setName`
5. Componente re-renderiza, input mostra novo valor

**Caracter√≠sticas:**
- **Single source of truth:** Estado React √© fonte da verdade
- **Valida√ß√£o em tempo real:** Pode validar a cada keystroke
- **Controle total:** Pode transformar input (uppercase, mascarar, limitar caracteres)
- **Sincroniza√ß√£o:** F√°cil sincronizar m√∫ltiplos inputs

**Exemplo com valida√ß√£o e transforma√ß√£o:**

```javascript
function ControlledInput() {
  const [value, setValue] = useState('');
  const [error, setError] = useState('');

  const handleChange = (e) => {
    const newValue = e.target.value;

    // Transforma√ß√£o: apenas letras
    const sanitized = newValue.replace(/[^a-zA-Z]/g, '');

    setValue(sanitized);

    // Valida√ß√£o em tempo real
    if (sanitized.length < 3) {
      setError('M√≠nimo 3 caracteres');
    } else {
      setError('');
    }
  };

  return (
    <div>
      <input value={value} onChange={handleChange} />
      {error && <span className="error">{error}</span>}
    </div>
  );
}
```

**Handler √∫nico para m√∫ltiplos inputs:**

```javascript
function MultipleInputs() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: ''
  });

  // Handler gen√©rico (computed property name)
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value  // Atualiza campo espec√≠fico
    }));
  };

  return (
    <form>
      <input name="name" value={formData.name} onChange={handleChange} />
      <input name="email" value={formData.email} onChange={handleChange} />
      <input name="age" value={formData.age} onChange={handleChange} />
    </form>
  );
}
```

#### Uncontrolled Components

**Conceito:** DOM controla valor, React l√™ via **ref** quando necess√°rio.

**Sintaxe b√°sica:**

```javascript
function UncontrolledForm() {
  const nameRef = useRef();
  const emailRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();

    // L√™ valores do DOM quando necess√°rio
    const name = nameRef.current.value;
    const email = emailRef.current.value;

    console.log({ name, email });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={nameRef}
        defaultValue=""  // Valor inicial (n√£o value)
      />
      <input
        type="email"
        ref={emailRef}
        defaultValue=""
      />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

**Fluxo conceitual:**

1. Input renderiza com `defaultValue`
2. DOM gerencia estado interno do input
3. Usu√°rio digita ‚Üí DOM atualiza automaticamente
4. React n√£o re-renderiza a cada keystroke
5. Quando necess√°rio (submit), React l√™ via `ref.current.value`

**Caracter√≠sticas:**
- **DOM como fonte da verdade:** Estado vive no DOM, n√£o em React
- **Menos re-renders:** React n√£o re-renderiza a cada mudan√ßa
- **Simples para casos b√°sicos:** Menos c√≥digo para forms simples
- **Integra√ß√£o com n√£o-React:** √ötil para integrar bibliotecas externas

**Quando usar Uncontrolled:**

```javascript
// 1. File inputs (sempre uncontrolled)
function FileUpload() {
  const fileRef = useRef();

  const handleUpload = () => {
    const file = fileRef.current.files[0];
    // Upload file...
  };

  return <input type="file" ref={fileRef} />;
}

// 2. Performance cr√≠tica (evitar re-renders)
function SearchWithDebounce() {
  const searchRef = useRef();

  const handleSearch = () => {
    const query = searchRef.current.value;
    performSearch(query);
  };

  // Debounce n√£o causa re-render
  useEffect(() => {
    const timer = setTimeout(handleSearch, 500);
    return () => clearTimeout(timer);
  }, []);

  return <input ref={searchRef} onChange={() => {}} />;
}

// 3. Integra√ß√£o com bibliotecas de formul√°rio
// (React Hook Form usa uncontrolled internamente)
```

#### Controlled vs Uncontrolled: Compara√ß√£o

| Aspecto | Controlled | Uncontrolled |
|---------|-----------|--------------|
| **Fonte da verdade** | React state | DOM |
| **Valida√ß√£o em tempo real** | F√°cil (onChange) | Dif√≠cil |
| **Transforma√ß√£o de input** | F√°cil | Imposs√≠vel |
| **Performance** | Re-render a cada mudan√ßa | Sem re-renders |
| **Sincroniza√ß√£o** | F√°cil (m√∫ltiplos inputs) | Dif√≠cil |
| **Complexidade** | Mais c√≥digo (state, handlers) | Menos c√≥digo (apenas ref) |
| **Testabilidade** | F√°cil (state √© acess√≠vel) | M√©dio (precisa acessar DOM) |
| **File inputs** | N√£o suportado | √önica op√ß√£o |
| **Casos de uso** | Maioria dos formul√°rios | Forms simples, file upload, performance cr√≠tica |

**Recomenda√ß√£o geral:** Prefira **Controlled** (padr√£o React). Use Uncontrolled apenas quando:
- File inputs
- Performance √© problema demonstrado
- Integra√ß√£o com biblioteca externa que assume controle do DOM

---

### 3.4.3 Higher-Order Components (HOC)

**Conceito:** Fun√ß√£o que recebe um componente e retorna novo componente com funcionalidade adicional.

**Padr√£o funcional:** Inspirado em Higher-Order Functions (map, filter).

**Sintaxe b√°sica:**

```javascript
// HOC: fun√ß√£o que retorna componente
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <Spinner />;
    }
    return <Component {...props} />;
  };
}

// Uso
function UserList({ users }) {
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}

const UserListWithLoading = withLoading(UserList);

// Renderizar
<UserListWithLoading isLoading={loading} users={users} />
```

**An√°lise conceitual:**

**Como funciona:**
1. `withLoading` √© fun√ß√£o que recebe `Component`
2. Retorna novo componente que envolve `Component`
3. Novo componente adiciona l√≥gica (verificar `isLoading`)
4. Repassa props restantes com spread (`{...props}`)

**Casos de uso cl√°ssicos:**

**1. Adicionar l√≥gica de autentica√ß√£o:**

```javascript
function withAuth(Component) {
  return function AuthenticatedComponent(props) {
    const { user, loading } = useAuth();

    if (loading) return <Spinner />;
    if (!user) return <Redirect to="/login" />;

    return <Component {...props} user={user} />;
  };
}

// Proteger componente
const DashboardPage = () => <div>Dashboard</div>;
export default withAuth(DashboardPage);
```

**2. Adicionar props de contexto:**

```javascript
function withTheme(Component) {
  return function ThemedComponent(props) {
    const theme = useContext(ThemeContext);
    return <Component {...props} theme={theme} />;
  };
}

// Componente recebe theme automaticamente
const Button = ({ theme, children }) => (
  <button style={{ backgroundColor: theme.primaryColor }}>
    {children}
  </button>
);

export default withTheme(Button);
```

**3. Logging/Analytics:**

```javascript
function withAnalytics(Component, eventName) {
  return function AnalyticsComponent(props) {
    useEffect(() => {
      trackEvent(eventName, { component: Component.name });
    }, []);

    return <Component {...props} />;
  };
}

const ProductPage = () => <div>Product</div>;
export default withAnalytics(ProductPage, 'product_page_view');
```

**Composi√ß√£o de HOCs:**

```javascript
// M√∫ltiplos HOCs
const EnhancedComponent = withAuth(withTheme(withAnalytics(MyComponent)));

// Melhor legibilidade com compose
import { compose } from 'redux'; // ou criar pr√≥prio

const enhance = compose(
  withAuth,
  withTheme,
  withAnalytics
);

export default enhance(MyComponent);
```

**Problemas de HOCs:**

**1. Wrapper Hell:** Muitos HOCs criam hierarquia profunda

```javascript
<WithAuth>
  <WithTheme>
    <WithAnalytics>
      <WithData>
        <MyComponent />
      </WithData>
    </WithAnalytics>
  </WithTheme>
</WithAuth>
```

**2. Naming Conflicts:** Props de HOCs podem colidir

```javascript
withData(withUser(Component))
// Se ambos injetam prop 'data', uma sobrescreve a outra
```

**3. Dificulta Refatora√ß√£o:** Componentes fortemente acoplados a HOCs

**4. Menos Claros:** Dif√≠cil saber de onde props v√™m (DevTools ajudam)

**Evolu√ß√£o com Hooks:**

Hooks substitu√≠ram maioria dos HOCs:

```javascript
// Antes (HOC)
function withAuth(Component) {
  return function AuthComponent(props) {
    const user = useAuth();
    return <Component {...props} user={user} />;
  };
}

const Dashboard = withAuth(DashboardComponent);

// Depois (Custom Hook)
function Dashboard() {
  const user = useAuth(); // Hook direto
  return <DashboardComponent user={user} />;
}
```

**Quando ainda usar HOCs:**
- Modificar renderiza√ß√£o (wrapping com Provider)
- Bibliotecas legadas (Redux `connect`, React Router `withRouter`)
- Quando precisar de l√≥gica que envolve m√∫ltiplos componentes

**Quando usar Hooks:**
- Reutilizar l√≥gica (quase sempre)

---

### 3.4.4 Render Props (Function as Children)

**Conceito:** Componente recebe fun√ß√£o como prop (geralmente `children`) e a chama para renderizar conte√∫do.

**Sintaxe b√°sica:**

```javascript
// Componente com render prop
function DataProvider({ render }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData().then(result => {
      setData(result);
      setLoading(false);
    });
  }, []);

  // Chama fun√ß√£o passada, fornecendo dados
  return render({ data, loading });
}

// Uso
<DataProvider
  render={({ data, loading }) => (
    loading ? <Spinner /> : <UserList users={data} />
  )}
/>
```

**Varia√ß√£o: Function as Children:**

```javascript
// Componente aceita children como fun√ß√£o
function DataProvider({ children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData().then(result => {
      setData(result);
      setLoading(false);
    });
  }, []);

  // Children √© fun√ß√£o, chamamos com dados
  return children({ data, loading });
}

// Uso (mais idiom√°tico em React)
<DataProvider>
  {({ data, loading }) => (
    loading ? <Spinner /> : <UserList users={data} />
  )}
</DataProvider>
```

**An√°lise conceitual:**

**Como funciona:**
1. Componente gerencia l√≥gica (fetch, state)
2. Ao inv√©s de renderizar UI fixa, chama fun√ß√£o passada
3. Passa dados/fun√ß√µes para a fun√ß√£o
4. Fun√ß√£o retorna JSX customizado

**Invers√£o de Controle:**
- Componente DataProvider controla **quando** renderizar
- Consumidor controla **o que** renderizar

**Casos de uso:**

**1. Compartilhar l√≥gica com controle total de UI:**

```javascript
function MouseTracker({ children }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  return children(position);
}

// Diferentes UIs com mesma l√≥gica
<MouseTracker>
  {({ x, y }) => (
    <p>Mouse est√° em ({x}, {y})</p>
  )}
</MouseTracker>

<MouseTracker>
  {({ x, y }) => (
    <div style={{ position: 'absolute', left: x, top: y }}>
      üê≠
    </div>
  )}
</MouseTracker>
```

**2. Dados ass√≠ncronos com estados de loading/error:**

```javascript
function AsyncData({ url, children }) {
  const [state, setState] = useState({ loading: true, data: null, error: null });

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => setState({ loading: false, data, error: null }))
      .catch(error => setState({ loading: false, data: null, error }));
  }, [url]);

  return children(state);
}

// Uso
<AsyncData url="/api/users">
  {({ loading, data, error }) => {
    if (loading) return <Spinner />;
    if (error) return <Error message={error.message} />;
    return <UserList users={data} />;
  }}
</AsyncData>
```

**Vantagens:**
- **Flexibilidade m√°xima:** Consumidor decide renderiza√ß√£o
- **Reutiliza√ß√£o:** Mesma l√≥gica, m√∫ltiplas UIs
- **Expl√≠cito:** √ìbvio que children √© fun√ß√£o

**Desvantagens:**
- **Verbosidade:** Mais c√≥digo que componentes simples
- **Aninhamento:** M√∫ltiplos render props criam pyramid of doom
- **Performance:** Nova fun√ß√£o cada render (pode memoizar)

**Pyramid of Doom:**

```javascript
<AsyncData url="/users">
  {({ data: users }) => (
    <AsyncData url="/posts">
      {({ data: posts }) => (
        <AsyncData url="/comments">
          {({ data: comments }) => (
            <Dashboard users={users} posts={posts} comments={comments} />
          )}
        </AsyncData>
      )}
    </AsyncData>
  )}
</AsyncData>
```

**Evolu√ß√£o com Hooks:**

Render props tamb√©m foram largamente substitu√≠dos por hooks:

```javascript
// Antes (Render Prop)
<MouseTracker>
  {({ x, y }) => <p>Mouse: ({x}, {y})</p>}
</MouseTracker>

// Depois (Custom Hook)
function Component() {
  const { x, y } = useMousePosition(); // Hook customizado
  return <p>Mouse: ({x}, {y})</p>;
}
```

**Quando ainda usar Render Props:**
- Componentes de bibliotecas (React Router `<Route render={...} />`)
- Quando precisar de controle fino sobre renderiza√ß√£o
- Compound components (padr√£o avan√ßado)

**Quando usar Hooks:**
- Reutilizar l√≥gica sem controle de renderiza√ß√£o (maioria dos casos)

---

## üéØ Aplicabilidade e Contextos

### Escolhendo Padr√£o Adequado

#### Para Separa√ß√£o L√≥gica/UI

**Use:** Container/Presentational

**Quando:**
- Componente grande com muita l√≥gica
- UI reutiliz√°vel em m√∫ltiplos contextos
- Equipe tem designers trabalhando separadamente

#### Para Formul√°rios

**Use:** Controlled Components

**Quando:**
- Valida√ß√£o em tempo real
- Sincronizar m√∫ltiplos inputs
- Transformar input (m√°scaras, uppercase)

**Use:** Uncontrolled Components

**Quando:**
- File inputs
- Forms muito simples
- Performance √© problema

#### Para Reutilizar L√≥gica

**Use:** Custom Hooks (moderno, preferido)

**Quando:**
- L√≥gica sem UI
- M√∫ltiplos componentes precisam da mesma l√≥gica
- Quer composi√ß√£o simples

**Use:** HOCs (legado)

**Quando:**
- Precisa envolver componente (Provider)
- Biblioteca requer (Redux connect)

**Use:** Render Props (raro hoje)

**Quando:**
- Controle total de renderiza√ß√£o necess√°rio
- Biblioteca usa esse padr√£o

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Trade-offs de Padr√µes

**Container/Presentational:**
- ‚úÖ Testabilidade, reutiliza√ß√£o
- ‚ùå Prop drilling, verbosidade

**Controlled:**
- ‚úÖ Controle total, valida√ß√£o
- ‚ùå Re-renders frequentes

**Uncontrolled:**
- ‚úÖ Performance, simplicidade
- ‚ùå Menos controle

**HOCs:**
- ‚úÖ Reutiliza√ß√£o, composi√ß√£o
- ‚ùå Wrapper hell, naming conflicts

**Render Props:**
- ‚úÖ Flexibilidade m√°xima
- ‚ùå Pyramid of doom, verbosidade

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Hooks

Hooks substitu√≠ram HOCs e Render Props para reutiliza√ß√£o de l√≥gica. Custom Hooks s√£o padr√£o moderno preferido.

### Rela√ß√£o com State Management

Containers geralmente conectam-se a estado global (Redux, Context).

### Rela√ß√£o com Testing

Presentational components s√£o mais f√°ceis de testar (fun√ß√µes puras).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### De Padr√µes Cl√°ssicos para Hooks

**Progress√£o:**
1. HOCs/Render Props (2015-2018)
2. Hooks (2018-hoje)
3. Server Components (futuro) - novos padr√µes emergindo

### Padr√µes Avan√ßados

- **Compound Components:** Componentes que trabalham juntos
- **State Reducer:** Consumidor controla l√≥gica de estado
- **Controlled Props:** Componente pode ser controlled ou uncontrolled

---

## üìö Conclus√£o

Component Patterns s√£o **vocabul√°rio essencial** para desenvolvedores React. Principais li√ß√µes:

1. **Container/Presentational:** Separa l√≥gica de UI
2. **Controlled:** Padr√£o para forms (React controla estado)
3. **Uncontrolled:** Casos espec√≠ficos (file inputs, performance)
4. **HOCs/Render Props:** Legado, substitu√≠dos por hooks
5. **Custom Hooks:** Padr√£o moderno para reutiliza√ß√£o

**Recomenda√ß√£o:**
- Aprenda todos os padr√µes para entender c√≥digo existente
- Use Custom Hooks para novo c√≥digo
- Aplique Container/Presentational quando separa√ß√£o justificar overhead
- Prefira Controlled para formul√°rios

Padr√µes n√£o s√£o dogma - s√£o ferramentas. Use quando resolvem problema real, n√£o por obriga√ß√£o.
