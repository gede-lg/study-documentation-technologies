# useReducer no React: Gerenciamento de Estado Complexo

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useReducer` √© o hook para gerenciar **estado complexo** atrav√©s de um padr√£o **reducer** - uma fun√ß√£o pura que recebe estado atual e a√ß√£o, retornando novo estado. Conceitualmente, √© uma alternativa a useState quando l√≥gica de atualiza√ß√£o √© complexa, envolve m√∫ltiplos sub-valores, ou pr√≥ximo estado depende do anterior de forma n√£o-trivial.

O pattern reducer vem da programa√ß√£o funcional (popularizado por Redux): ao inv√©s de **imperativo** "fa√ßa isso, depois aquilo", √© **declarativo** "dado estado X e a√ß√£o Y, novo estado √© Z". Centraliza l√≥gica de transi√ß√µes de estado em um lugar, tornando atualiza√ß√µes previs√≠veis, test√°veis e rastre√°veis.

**Met√°fora:** Se useState √© "interruptor simples" (liga/desliga), useReducer √© "painel de controle" com m√∫ltiplos bot√µes e l√≥gica complexa - cada bot√£o (a√ß√£o) aciona comportamento espec√≠fico, mas tudo passa pelo reducer (centro de controle).

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o do gerenciamento de estado:**

**2015 - Redux (Biblioteca Externa)**
Redux popularizou pattern reducer para React:
```javascript
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    default:
      return state;
  }
}
```

**Vantagens:** Previsibilidade, testabilidade, DevTools (time travel).

**Problema:** Boilerplate excessivo para apps pequenos, curva de aprendizado.

**2018 - useReducer (React 16.8)**
React incorporou pattern reducer nativamente:
- Mesma API de Redux (reducer + dispatch)
- Sem boilerplate (sem actions creators, middleware)
- Integra√ß√£o natural com Hooks
- Leve (built-in, sem lib externa)

**Filosofia:** useState para estado simples, useReducer para estado complexo. N√£o √© "useState vs useReducer", mas "ferramenta certa para cada caso".

### Problema Fundamental que Resolve

**Sem useReducer (useState complexo):**

**Problema 1 - M√∫ltiplas atualiza√ß√µes relacionadas:**
```javascript
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [submitting, setSubmitting] = useState(false);

  // L√≥gica espalhada, dif√≠cil rastrear transi√ß√µes
  const handleSubmit = () => {
    setSubmitting(true);
    setErrors({});
    // ... valida√ß√£o ...
    if (valid) {
      // reset
      setName('');
      setEmail('');
      setTouched({});
    }
    setSubmitting(false);
  };

  // Muitos setters, dif√≠cil coordenar
}
```

**Problema 2 - Estado com l√≥gica complexa:**
```javascript
function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(c => c + 1);
  };

  const decrement = () => {
    setCount(c => c > 0 ? c - 1 : 0); // L√≥gica inline
  };

  const reset = () => {
    setCount(0);
  };

  const incrementBy = (amount) => {
    setCount(c => c + amount);
  };

  // L√≥gica espalhada em m√∫ltiplas fun√ß√µes
}
```

**Com useReducer:**

```javascript
// Reducer: centraliza TODA l√≥gica de estado
function formReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD':
      return {
        ...state,
        [action.field]: action.value
      };

    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.errors
      };

    case 'SUBMIT':
      return {
        ...state,
        submitting: true,
        errors: {}
      };

    case 'SUBMIT_SUCCESS':
      return {
        name: '',
        email: '',
        errors: {},
        touched: {},
        submitting: false
      };

    case 'SUBMIT_ERROR':
      return {
        ...state,
        submitting: false,
        errors: action.errors
      };

    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(formReducer, {
    name: '',
    email: '',
    errors: {},
    touched: {},
    submitting: false
  });

  const handleSubmit = () => {
    dispatch({ type: 'SUBMIT' });
    // ... valida√ß√£o ...
    if (valid) {
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } else {
      dispatch({ type: 'SUBMIT_ERROR', errors });
    }
  };

  // L√≥gica centralizada, transi√ß√µes claras
}
```

**Vantagens:**
- L√≥gica de estado em um lugar
- Transi√ß√µes expl√≠citas (actions)
- F√°cil testar reducer (fun√ß√£o pura)
- Rastrear mudan√ßas (log de actions)

### Import√¢ncia no Ecossistema

useReducer √© **crucial** para:

- **Formul√°rios complexos**: M√∫ltiplos campos, valida√ß√£o
- **Estado com sub-objetos**: Objetos aninhados
- **L√≥gica n√£o-trivial**: Transi√ß√µes condicionais
- **M√°quinas de estado**: Estados discretos (loading, success, error)
- **Mini-Redux**: Alternativa leve para apps m√©dios

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Reducer**: Fun√ß√£o pura (state, action) => newState
2. **Action**: Objeto descrevendo "o que aconteceu"
3. **Dispatch**: Fun√ß√£o para enviar actions
4. **Estado inicial**: Valor inicial ou lazy initializer
5. **Previsibilidade**: Mesma action + state ‚Üí sempre mesmo resultado

### Pilares Fundamentais

- **Reducer function**: Centraliza l√≥gica de transi√ß√µes
- **Action objects**: `{ type, payload }` descrevem mudan√ßas
- **dispatch**: Dispara actions
- **Imutabilidade**: Reducer retorna novo estado (n√£o muta)
- **Pure function**: Sem side effects no reducer

### Vis√£o Geral das Nuances

- **useState vs useReducer**: Quando usar cada um
- **Action types**: Conven√ß√£o (strings uppercase)
- **Payload**: Dados adicionais na action
- **Lazy initialization**: Computar estado inicial de forma lazy
- **Combine com Context**: Pattern Redux-like

---

## üß† Fundamentos Te√≥ricos

### Anatomia do useReducer

**API:**
```javascript
const [state, dispatch] = useReducer(reducer, initialState, init);
```

**Par√¢metros:**
1. **reducer**: Fun√ß√£o `(state, action) => newState`
2. **initialState**: Estado inicial
3. **init** (opcional): Fun√ß√£o lazy para calcular estado inicial

**Retorno:**
1. **state**: Estado atual
2. **dispatch**: Fun√ß√£o para enviar actions `dispatch(action)`

### Reducer Function

**Assinatura:**
```javascript
function reducer(state, action) {
  // L√≥gica baseada em action.type
  // Retorna NOVO estado (n√£o muta state)
  return newState;
}
```

**Regras:**
1. **Fun√ß√£o pura**: Sem side effects, sem randomness
2. **Imut√°vel**: Retorna novo objeto/array, n√£o muta state
3. **Switch statement**: Conven√ß√£o (mas pode usar if/else)
4. **Default case**: Retorna state inalterado

**Exemplo:**
```javascript
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };

    case 'DECREMENT':
      return { count: state.count - 1 };

    case 'RESET':
      return { count: 0 };

    default:
      return state; // Importante!
  }
}
```

### Actions

**Conven√ß√£o:**
```javascript
{
  type: 'ACTION_NAME', // String descrevendo a√ß√£o
  payload: data        // Dados opcionais (qualquer tipo)
}
```

**Exemplos:**
```javascript
// Action sem payload
{ type: 'RESET' }

// Action com payload simples
{ type: 'INCREMENT_BY', payload: 5 }

// Action com payload objeto
{
  type: 'UPDATE_USER',
  payload: { name: 'Ana', email: 'ana@example.com' }
}

// Action com m√∫ltiplos campos (menos comum)
{
  type: 'SET_ERROR',
  field: 'email',
  message: 'Email inv√°lido'
}
```

**Conven√ß√µes de nomes:**
- UPPERCASE com underscores: `INCREMENT`, `FETCH_SUCCESS`
- Verbos imperativos: `ADD_TODO`, `DELETE_USER`, `UPDATE_SETTINGS`

### dispatch Function

**Uso:**
```javascript
const [state, dispatch] = useReducer(reducer, initialState);

// Enviar action
dispatch({ type: 'INCREMENT' });
dispatch({ type: 'ADD_TODO', payload: { text: 'Nova tarefa' } });
```

**Caracter√≠sticas:**
- **S√≠ncrono**: Reducer executa imediatamente
- **Batching**: React agrupa m√∫ltiplos dispatches (re-render √∫nico)
- **Est√°vel**: dispatch nunca muda (pode omitir de deps)

### Estado Inicial

**Forma 1: Valor direto**
```javascript
const initialState = { count: 0 };
const [state, dispatch] = useReducer(reducer, initialState);
```

**Forma 2: Lazy initialization**
```javascript
function init(initialValue) {
  // C√°lculo custoso ou leitura de localStorage
  return { count: initialValue };
}

const [state, dispatch] = useReducer(reducer, 0, init);
// init(0) executa apenas uma vez (no mount)
```

---

## üîç An√°lise Conceitual Profunda

### 7.2.1 Caso B√°sico: Contador

```javascript
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };

    case 'DECREMENT':
      return { count: state.count - 1 };

    case 'RESET':
      return { count: 0 };

    case 'SET':
      return { count: action.payload };

    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'SET', payload: 10 })}>Set 10</button>
    </div>
  );
}
```

### 7.2.2 Caso Intermedi√°rio: Formul√°rio

```javascript
function formReducer(state, action) {
  switch (action.type) {
    case 'CHANGE':
      return {
        ...state,
        [action.field]: action.value
      };

    case 'TOUCH':
      return {
        ...state,
        touched: {
          ...state.touched,
          [action.field]: true
        }
      };

    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.message
        }
      };

    case 'CLEAR_ERROR':
      const { [action.field]: removed, ...rest } = state.errors;
      return {
        ...state,
        errors: rest
      };

    case 'SUBMIT':
      return {
        ...state,
        submitting: true
      };

    case 'SUBMIT_SUCCESS':
      return {
        name: '',
        email: '',
        errors: {},
        touched: {},
        submitting: false
      };

    case 'SUBMIT_ERROR':
      return {
        ...state,
        submitting: false,
        errors: action.errors
      };

    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(formReducer, {
    name: '',
    email: '',
    errors: {},
    touched: {},
    submitting: false
  });

  const handleChange = (field, value) => {
    dispatch({ type: 'CHANGE', field, value });

    // Valida√ß√£o
    if (!value) {
      dispatch({ type: 'SET_ERROR', field, message: 'Campo obrigat√≥rio' });
    } else {
      dispatch({ type: 'CLEAR_ERROR', field });
    }
  };

  const handleBlur = (field) => {
    dispatch({ type: 'TOUCH', field });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    dispatch({ type: 'SUBMIT' });

    try {
      await api.submitForm(state);
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (error) {
      dispatch({ type: 'SUBMIT_ERROR', errors: error.errors });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={state.name}
        onChange={(e) => handleChange('name', e.target.value)}
        onBlur={() => handleBlur('name')}
      />
      {state.touched.name && state.errors.name && (
        <span>{state.errors.name}</span>
      )}

      <input
        value={state.email}
        onChange={(e) => handleChange('email', e.target.value)}
        onBlur={() => handleBlur('email')}
      />
      {state.touched.email && state.errors.email && (
        <span>{state.errors.email}</span>
      )}

      <button type="submit" disabled={state.submitting}>
        {state.submitting ? 'Enviando...' : 'Enviar'}
      </button>
    </form>
  );
}
```

### 7.2.3 Caso Avan√ßado: Todo List

```javascript
function todosReducer(state, action) {
  switch (action.type) {
    case 'ADD':
      return [
        ...state,
        {
          id: Date.now(),
          text: action.payload,
          completed: false
        }
      ];

    case 'TOGGLE':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );

    case 'DELETE':
      return state.filter(todo => todo.id !== action.payload);

    case 'EDIT':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, text: action.payload.text }
          : todo
      );

    case 'CLEAR_COMPLETED':
      return state.filter(todo => !todo.completed);

    default:
      return state;
  }
}

function TodoList() {
  const [todos, dispatch] = useReducer(todosReducer, []);
  const [input, setInput] = useState('');

  const handleAdd = () => {
    if (input.trim()) {
      dispatch({ type: 'ADD', payload: input });
      setInput('');
    }
  };

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && handleAdd()}
      />
      <button onClick={handleAdd}>Adicionar</button>

      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch({ type: 'TOGGLE', payload: todo.id })}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => dispatch({ type: 'DELETE', payload: todo.id })}>
              Deletar
            </button>
          </li>
        ))}
      </ul>

      <button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}>
        Limpar Conclu√≠dos
      </button>
    </div>
  );
}
```

### 7.2.4 Pattern: Lazy Initialization

**Quando:** Estado inicial custoso de computar.

```javascript
function init(initialCount) {
  // C√°lculo custoso ou leitura de storage
  const stored = localStorage.getItem('count');
  return {
    count: stored ? parseInt(stored, 10) : initialCount
  };
}

function Counter({ initialCount }) {
  // init executa APENAS no mount (n√£o toda render)
  const [state, dispatch] = useReducer(reducer, initialCount, init);

  // Salvar no localStorage quando mudar
  useEffect(() => {
    localStorage.setItem('count', state.count);
  }, [state.count]);

  return <div>Count: {state.count}</div>;
}
```

### 7.2.5 Pattern: useReducer + useContext

**Mini-Redux:** Combinar para state management global.

```javascript
// TodoContext.js
import { createContext, useContext, useReducer } from 'react';

const TodosContext = createContext();
const TodosDispatchContext = createContext();

function todosReducer(state, action) {
  // ... reducer logic ...
}

export function TodosProvider({ children }) {
  const [todos, dispatch] = useReducer(todosReducer, []);

  return (
    <TodosContext.Provider value={todos}>
      <TodosDispatchContext.Provider value={dispatch}>
        {children}
      </TodosDispatchContext.Provider>
    </TodosContext.Provider>
  );
}

export function useTodos() {
  const context = useContext(TodosContext);
  if (!context) throw new Error('useTodos fora de TodosProvider');
  return context;
}

export function useTodosDispatch() {
  const context = useContext(TodosDispatchContext);
  if (!context) throw new Error('useTodosDispatch fora de TodosProvider');
  return context;
}
```

**Uso:**
```javascript
// App.js
function App() {
  return (
    <TodosProvider>
      <TodoList />
      <TodoStats />
    </TodosProvider>
  );
}

// TodoList.js
function TodoList() {
  const todos = useTodos();
  const dispatch = useTodosDispatch();

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
          <button onClick={() => dispatch({ type: 'TOGGLE', payload: todo.id })}>
            Toggle
          </button>
        </li>
      ))}
    </ul>
  );
}

// TodoStats.js
function TodoStats() {
  const todos = useTodos();

  const completed = todos.filter(t => t.completed).length;
  const total = todos.length;

  return <div>{completed} / {total} conclu√≠dos</div>;
}
```

### 7.2.6 Pattern: Estado como M√°quina de Estados

**Conceito:** Estados discretos (idle, loading, success, error).

```javascript
function fetchReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return {
        status: 'loading',
        data: null,
        error: null
      };

    case 'FETCH_SUCCESS':
      return {
        status: 'success',
        data: action.payload,
        error: null
      };

    case 'FETCH_ERROR':
      return {
        status: 'error',
        data: null,
        error: action.payload
      };

    case 'RESET':
      return {
        status: 'idle',
        data: null,
        error: null
      };

    default:
      return state;
  }
}

function DataFetcher({ url }) {
  const [state, dispatch] = useReducer(fetchReducer, {
    status: 'idle',
    data: null,
    error: null
  });

  useEffect(() => {
    dispatch({ type: 'FETCH_START' });

    fetch(url)
      .then(res => res.json())
      .then(data => {
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      })
      .catch(error => {
        dispatch({ type: 'FETCH_ERROR', payload: error.message });
      });
  }, [url]);

  switch (state.status) {
    case 'idle':
      return <div>Clique para carregar</div>;

    case 'loading':
      return <div>Carregando...</div>;

    case 'success':
      return <div>Dados: {JSON.stringify(state.data)}</div>;

    case 'error':
      return <div>Erro: {state.error}</div>;

    default:
      return null;
  }
}
```

### 7.2.7 Testing Reducers

**Vantagem:** Reducers s√£o fun√ß√µes puras, f√°ceis de testar.

```javascript
// todosReducer.test.js
import { todosReducer } from './todosReducer';

describe('todosReducer', () => {
  test('ADD adiciona novo todo', () => {
    const initialState = [];
    const action = { type: 'ADD', payload: 'Nova tarefa' };
    const newState = todosReducer(initialState, action);

    expect(newState.length).toBe(1);
    expect(newState[0].text).toBe('Nova tarefa');
    expect(newState[0].completed).toBe(false);
  });

  test('TOGGLE alterna completed', () => {
    const initialState = [
      { id: 1, text: 'Tarefa', completed: false }
    ];
    const action = { type: 'TOGGLE', payload: 1 };
    const newState = todosReducer(initialState, action);

    expect(newState[0].completed).toBe(true);
  });

  test('DELETE remove todo', () => {
    const initialState = [
      { id: 1, text: 'Tarefa 1', completed: false },
      { id: 2, text: 'Tarefa 2', completed: false }
    ];
    const action = { type: 'DELETE', payload: 1 };
    const newState = todosReducer(initialState, action);

    expect(newState.length).toBe(1);
    expect(newState[0].id).toBe(2);
  });
});
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar useReducer

‚úÖ **Use useReducer quando:**
- Estado tem m√∫ltiplos sub-valores relacionados
- L√≥gica de atualiza√ß√£o √© complexa
- Pr√≥ximo estado depende do anterior de forma n√£o-trivial
- Muitas transi√ß√µes de estado diferentes
- Quer centralizar l√≥gica de estado em um lugar
- Precisa rastrear/logar mudan√ßas (actions)

‚úÖ **Use useState quando:**
- Estado √© primitivo simples (boolean, string, number)
- Poucas transi√ß√µes (toggle, increment)
- N√£o h√° l√≥gica complexa

### Compara√ß√£o: useState vs useReducer

```javascript
// useState - simples
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

// useReducer - complexo
function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0, history: [] });
  return <button onClick={() => dispatch({ type: 'INCREMENT' })}>{state.count}</button>;
}
```

**Regra geral:** Comece com useState. Migre para useReducer quando complexidade aumentar.

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Reducer Deve Ser Puro

**‚ùå Side effects no reducer:**
```javascript
function reducer(state, action) {
  // ‚ùå ERRADO - side effects
  console.log('Action:', action);
  localStorage.setItem('state', JSON.stringify(state));
  fetch('/api/log', { body: action });

  return newState;
}
```

**‚úÖ Side effects em useEffect:**
```javascript
function Component() {
  const [state, dispatch] = useReducer(reducer, initialState);

  useEffect(() => {
    // ‚úÖ Side effects aqui
    console.log('State mudou:', state);
    localStorage.setItem('state', JSON.stringify(state));
  }, [state]);
}
```

### Imutabilidade

**‚ùå Mutar estado:**
```javascript
function reducer(state, action) {
  // ‚ùå Muta√ß√£o direta
  state.count++;
  return state; // Mesmo objeto, React n√£o detecta mudan√ßa
}
```

**‚úÖ Retornar novo objeto:**
```javascript
function reducer(state, action) {
  // ‚úÖ Novo objeto
  return { ...state, count: state.count + 1 };
}
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useState

useReducer √© "useState mais poderoso" para estado complexo.

### Rela√ß√£o com useContext

useReducer + useContext = pattern Redux-like.

### Rela√ß√£o com Redux

useReducer √© inspirado em Redux, mas mais simples (sem middleware, sem DevTools nativos).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
useState (simples)
    ‚Üì
useReducer (complexo local)
    ‚Üì
useReducer + useContext (global)
    ‚Üì
Redux/Zustand (apps grandes)
```

---

## üìö Conclus√£o

useReducer √© hook **essencial** para estado complexo. Princ√≠pios:

1. **Reducer**: Fun√ß√£o pura (state, action) => newState
2. **Actions**: Objetos descrevendo mudan√ßas
3. **dispatch**: Envia actions ao reducer
4. **Centraliza√ß√£o**: Toda l√≥gica de estado em um lugar
5. **Testabilidade**: Reducers s√£o f√°ceis de testar

**Recomenda√ß√µes:**
- Use para estado com m√∫ltiplos sub-valores
- Conven√ß√£o: actions com `type` (uppercase) e `payload`
- Combine com useContext para state management global
- N√£o fa√ßa side effects no reducer
- Sempre retorne novo estado (imutabilidade)

**Dominar useReducer = gerenciar estado complexo de forma previs√≠vel e escal√°vel.**
