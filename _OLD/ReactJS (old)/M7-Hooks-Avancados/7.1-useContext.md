# useContext no React: Compartilhamento de Estado Global

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useContext` √© o hook para **consumir Context API** - o sistema nativo do React para compartilhar dados globalmente na √°rvore de componentes sem passar props manualmente em cada n√≠vel. Conceitualmente, permite **"teleportar" dados** de um componente provedor (Provider) para qualquer consumidor (Consumer) em qualquer profundidade, eliminando "props drilling" (passar props por m√∫ltiplos n√≠veis intermedi√°rios que n√£o as usam).

Context resolve o problema de **dados transversais** - informa√ß√µes que muitos componentes precisam (tema, idioma, autentica√ß√£o, configura√ß√µes) mas que n√£o fazem sentido passar explicitamente por toda hierarquia. √â como criar um "estado global" acess√≠vel a qualquer componente que o solicite, sem quebrar unidirecionalidade de dados.

**Met√°fora:** Se props s√£o "passar mensagem m√£o-a-m√£o" (cada pessoa repassa), Context √© "r√°dio" - voc√™ transmite uma vez (Provider) e qualquer um sintonizado (useContext) recebe diretamente, sem intermedi√°rios.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o do compartilhamento de estado:**

**2013-2016: Props Drilling**
√önico jeito de compartilhar dados era via props:
```javascript
<App user={user}>
  <Layout user={user}>
    <Sidebar user={user}>
      <Profile user={user} /> {/* Finalmente usa! */}
    </Sidebar>
  </Layout>
</App>
```

**Problema:** Layout e Sidebar n√£o usam `user`, apenas repassam. Dif√≠cil manter, fr√°gil.

**2016 - Context API (React 16.3):**
Introduzida para resolver props drilling:
```javascript
const UserContext = React.createContext();

<UserContext.Provider value={user}>
  <Layout>
    <Sidebar>
      <Profile /> {/* Acessa user diretamente via Context */}
    </Sidebar>
  </Layout>
</UserContext.Provider>
```

**API antiga:** Usava `<Context.Consumer>` (render prop):
```javascript
<UserContext.Consumer>
  {user => <div>{user.name}</div>}
</UserContext.Consumer>
```

**2018 - useContext Hook (React 16.8):**
Hooks simplificaram consumo:
```javascript
const user = useContext(UserContext); // Muito mais limpo!
```

**Filosofia:** Context √© para **dados transversais raros** (tema, auth), n√£o para tudo. State local + props ainda s√£o prefer√≠veis quando poss√≠vel (melhor performance, mais expl√≠cito).

### Problema Fundamental que Resolve

**Sem Context:**

**Problema: Props Drilling**
```javascript
function App() {
  const [theme, setTheme] = useState('light');

  return <Dashboard theme={theme} setTheme={setTheme} />;
}

function Dashboard({ theme, setTheme }) {
  // Dashboard n√£o usa theme, apenas repassa
  return <Sidebar theme={theme} setTheme={setTheme} />;
}

function Sidebar({ theme, setTheme }) {
  // Sidebar n√£o usa theme, apenas repassa
  return <Settings theme={theme} setTheme={setTheme} />;
}

function Settings({ theme, setTheme }) {
  // Finalmente usa!
  return (
    <div>
      <p>Tema: {theme}</p>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Alternar
      </button>
    </div>
  );
}
```

**Problemas:**
1. Dashboard e Sidebar s√£o "props tunnels" (n√£o usam, s√≥ repassam)
2. Fr√°gil - se remover intermedi√°rio, quebra
3. Dif√≠cil refatorar - precisa mudar v√°rios componentes
4. Polui props de componentes

**Com Context:**

```javascript
// 1. Criar Context
const ThemeContext = createContext();

// 2. Prover valor
function App() {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Dashboard />
    </ThemeContext.Provider>
  );
}

// 3. Intermedi√°rios N√ÉO precisam props
function Dashboard() {
  return <Sidebar />;
}

function Sidebar() {
  return <Settings />;
}

// 4. Consumir onde necess√°rio
function Settings() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <div>
      <p>Tema: {theme}</p>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Alternar
      </button>
    </div>
  );
}
```

**Vantagens:**
- Intermedi√°rios limpos (sem props desnecess√°rias)
- Refatora√ß√£o f√°cil (adicionar/remover n√≠veis n√£o quebra)
- C√≥digo mais leg√≠vel
- Componentes desacoplados

### Import√¢ncia no Ecossistema

useContext √© **fundamental** para:

- **Temas**: Dark/light mode
- **Internacionaliza√ß√£o (i18n)**: Idioma da aplica√ß√£o
- **Autentica√ß√£o**: Usu√°rio logado, permiss√µes
- **Configura√ß√µes globais**: Feature flags, API URLs
- **State management leve**: Alternativa a Redux para apps pequenos

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Context**: Container de dados compartilhados
2. **Provider**: Componente que fornece valor
3. **Consumer**: Componente que consome (useContext)
4. **Valor global**: Acess√≠vel em qualquer profundidade
5. **Re-render autom√°tico**: Consumidores re-renderizam quando valor muda

### Pilares Fundamentais

- **createContext**: Criar Context
- **Provider**: Prover valor na √°rvore
- **useContext**: Hook para consumir
- **Valor do contexto**: Qualquer tipo (primitivo, objeto, fun√ß√£o)
- **M√∫ltiplos contextos**: Aninhar m√∫ltiplos Providers

### Vis√£o Geral das Nuances

- **Performance**: Todos os consumidores re-renderizam quando valor muda
- **Valor default**: Usado apenas se n√£o houver Provider acima
- **Composi√ß√£o**: M√∫ltiplos contextos s√£o prefer√≠veis a um grande
- **Otimiza√ß√£o**: Memoizar valor do Provider para evitar re-renders
- **Not for everything**: Preferir props quando poss√≠vel

---

## üß† Fundamentos Te√≥ricos

### Anatomia do Context

**Tr√™s partes:**

```javascript
// 1. Criar Context (fora dos componentes)
const MyContext = createContext(defaultValue);

// 2. Prover valor
function App() {
  return (
    <MyContext.Provider value={someValue}>
      <ComponentTree />
    </MyContext.Provider>
  );
}

// 3. Consumir valor
function SomeComponent() {
  const value = useContext(MyContext);
  return <div>{value}</div>;
}
```

### createContext: Cria√ß√£o

**API:**
```javascript
const MyContext = createContext(defaultValue);
```

**defaultValue:**
- Usado apenas se componente **n√£o** tiver Provider acima
- √ötil para testes ou componentes standalone
- Em apps reais, geralmente h√° Provider no root

**Exemplo:**
```javascript
const ThemeContext = createContext('light'); // Default: 'light'

// Sem Provider
function Component() {
  const theme = useContext(ThemeContext); // 'light' (default)
  return <div>{theme}</div>;
}

// Com Provider
<ThemeContext.Provider value="dark">
  <Component /> {/* 'dark' (do Provider) */}
</ThemeContext.Provider>
```

### Provider: Fornecimento de Valor

**Conceito:** Componente que "embrulha" parte da √°rvore, fornecendo valor do Context.

```javascript
<MyContext.Provider value={someValue}>
  {/* Todos os filhos podem acessar someValue via useContext */}
</MyContext.Provider>
```

**Caracter√≠sticas:**

**1. M√∫ltiplos Providers:**
```javascript
<ThemeContext.Provider value="dark">
  <UserContext.Provider value={user}>
    <LanguageContext.Provider value="pt-BR">
      <App />
    </LanguageContext.Provider>
  </UserContext.Provider>
</ThemeContext.Provider>
```

**2. Providers aninhados (mesmo Context):**
```javascript
<ThemeContext.Provider value="dark">
  <OuterComponent />
  <ThemeContext.Provider value="light">
    <InnerComponent /> {/* Usa 'light', mais pr√≥ximo */}
  </ThemeContext.Provider>
</ThemeContext.Provider>
```

Componente usa Provider **mais pr√≥ximo** acima dele.

**3. Valor pode ser qualquer tipo:**
```javascript
// Primitivo
<ThemeContext.Provider value="dark">

// Objeto
<UserContext.Provider value={{ name: 'Ana', age: 30 }}>

// Array
<ItemsContext.Provider value={[1, 2, 3]}>

// Fun√ß√£o
<UpdateContext.Provider value={updateFunction}>

// M√∫ltiplos valores (objeto)
<AppContext.Provider value={{ theme, user, setTheme, setUser }}>
```

### useContext: Consumo de Valor

**API:**
```javascript
const value = useContext(MyContext);
```

**Regras:**
1. Deve ser chamado **dentro** de componente funcional (ou custom hook)
2. Retorna `value` do Provider mais pr√≥ximo acima
3. Se n√£o houver Provider, retorna `defaultValue` do `createContext`
4. Quando `value` muda, componente **re-renderiza**

**Exemplo:**
```javascript
function Component() {
  const theme = useContext(ThemeContext);
  const user = useContext(UserContext);
  const lang = useContext(LanguageContext);

  return (
    <div className={theme}>
      {lang === 'pt-BR' ? 'Ol√°' : 'Hello'}, {user.name}
    </div>
  );
}
```

### Re-render Behavior

**Regra fundamental:** Quando `value` do Provider muda, **todos** os consumidores re-renderizam.

```javascript
function App() {
  const [count, setCount] = useState(0);

  return (
    <CountContext.Provider value={count}>
      <ComponentA /> {/* Re-renderiza quando count muda */}
      <ComponentB /> {/* Re-renderiza quando count muda */}
    </CountContext.Provider>
  );
}

function ComponentA() {
  const count = useContext(CountContext);
  return <div>A: {count}</div>;
}

function ComponentB() {
  const count = useContext(CountContext);
  return <div>B: {count}</div>;
}
```

**Importante:** Re-render acontece mesmo se componente n√£o usar parte do valor que mudou (veremos otimiza√ß√£o adiante).

---

## üîç An√°lise Conceitual Profunda

### 7.1.1 Pattern B√°sico: Tema (Theme)

#### Implementa√ß√£o Simples

```javascript
// ThemeContext.js
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook para facilitar uso
export function useTheme() {
  const context = useContext(ThemeContext);

  if (!context) {
    throw new Error('useTheme deve ser usado dentro de ThemeProvider');
  }

  return context;
}
```

**Uso:**

```javascript
// App.js
import { ThemeProvider } from './ThemeContext';

function App() {
  return (
    <ThemeProvider>
      <Header />
      <MainContent />
    </ThemeProvider>
  );
}

// Header.js
import { useTheme } from './ThemeContext';

function Header() {
  const { theme, toggleTheme } = useTheme();

  return (
    <header className={theme}>
      <h1>Meu App</h1>
      <button onClick={toggleTheme}>
        Alternar para {theme === 'light' ? 'dark' : 'light'}
      </button>
    </header>
  );
}

// MainContent.js
function MainContent() {
  const { theme } = useTheme();

  return (
    <main className={theme}>
      <p>Conte√∫do no tema {theme}</p>
    </main>
  );
}
```

### 7.1.2 Pattern: Autentica√ß√£o

```javascript
// AuthContext.js
import { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Verificar se usu√°rio est√° logado (ao montar)
  useEffect(() => {
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
      setUser(JSON.parse(storedUser));
    }
    setLoading(false);
  }, []);

  const login = (userData) => {
    setUser(userData);
    localStorage.setItem('user', JSON.stringify(userData));
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
  };

  const value = {
    user,
    login,
    logout,
    isAuthenticated: !!user
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);

  if (!context) {
    throw new Error('useAuth deve ser usado dentro de AuthProvider');
  }

  return context;
}
```

**Uso:**

```javascript
// App.js
function App() {
  return (
    <AuthProvider>
      <Router>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route path="/dashboard" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
        </Routes>
      </Router>
    </AuthProvider>
  );
}

// ProtectedRoute.js
function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }

  return children;
}

// Dashboard.js
function Dashboard() {
  const { user, logout } = useAuth();

  return (
    <div>
      <h1>Bem-vindo, {user.name}</h1>
      <button onClick={logout}>Sair</button>
    </div>
  );
}

// Login.js
function Login() {
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleLogin = () => {
    // Simular login
    login({ name: 'Ana', email: 'ana@example.com' });
    navigate('/dashboard');
  };

  return <button onClick={handleLogin}>Entrar</button>;
}
```

### 7.1.3 Pattern: M√∫ltiplos Contextos Compostos

**Problema:** Um Context grande causa re-renders desnecess√°rios.

```javascript
// ‚ùå Um Context com tudo
const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [language, setLanguage] = useState('pt-BR');

  // Se user mudar, TODOS os consumidores re-renderizam
  // (mesmo se s√≥ usam theme ou language)
  return (
    <AppContext.Provider value={{ user, theme, language, setUser, setTheme, setLanguage }}>
      {children}
    </AppContext.Provider>
  );
}
```

**Solu√ß√£o:** Separar em m√∫ltiplos Contexts.

```javascript
// ‚úÖ Contextos separados
function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <AppContent />
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

// Componente que s√≥ usa theme n√£o re-renderiza quando user muda
function ThemedButton() {
  const { theme } = useTheme(); // Apenas ThemeContext
  return <button className={theme}>Clique</button>;
}
```

### 7.1.4 Otimiza√ß√£o: Memoizar Valor do Provider

**Problema:** Criar novo objeto toda render causa re-renders desnecess√°rios.

```javascript
// ‚ùå PROBLEMA
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // Novo objeto toda render!
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Mesmo que theme n√£o mude, consumidores re-renderizam
// porque { theme, setTheme } √© novo objeto toda vez
```

**Solu√ß√£o:** Memoizar com `useMemo`.

```javascript
// ‚úÖ Memoizado
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const value = useMemo(() => ({ theme, setTheme }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// Agora, se theme n√£o mudar, value √© o mesmo objeto
// Consumidores n√£o re-renderizam desnecessariamente
```

**Alternativa:** Se fun√ß√µes n√£o dependem de props/state, podem ficar fora:

```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // toggleTheme √© est√°vel (n√£o recriada)
  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  }, []);

  const value = useMemo(() => ({ theme, toggleTheme }), [theme, toggleTheme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### 7.1.5 Pattern: Separar State e Dispatch

**Otimiza√ß√£o avan√ßada:** Separar dados de fun√ß√µes em Contexts diferentes.

```javascript
// Dois Contexts: um para state, outro para dispatch
const ThemeStateContext = createContext();
const ThemeDispatchContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeStateContext.Provider value={theme}>
      <ThemeDispatchContext.Provider value={setTheme}>
        {children}
      </ThemeDispatchContext.Provider>
    </ThemeStateContext.Provider>
  );
}

// Hooks separados
function useThemeState() {
  const context = useContext(ThemeStateContext);
  if (!context) throw new Error('useThemeState fora de Provider');
  return context;
}

function useThemeDispatch() {
  const context = useContext(ThemeDispatchContext);
  if (!context) throw new Error('useThemeDispatch fora de Provider');
  return context;
}
```

**Vantagem:**

```javascript
// Componente que s√≥ l√™ theme
function Display() {
  const theme = useThemeState(); // N√£o re-renderiza quando setTheme muda
  return <div>{theme}</div>;
}

// Componente que s√≥ altera theme
function Toggle() {
  const setTheme = useThemeDispatch(); // N√£o re-renderiza quando theme muda
  return <button onClick={() => setTheme('dark')}>Dark</button>;
}
```

### 7.1.6 Pattern: useReducer + useContext

**Para state complexo:** Combinar useReducer com Context.

```javascript
// CartContext.js
import { createContext, useContext, useReducer } from 'react';

const CartContext = createContext();
const CartDispatchContext = createContext();

function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      return [...state, action.payload];

    case 'REMOVE_ITEM':
      return state.filter(item => item.id !== action.payload);

    case 'CLEAR':
      return [];

    default:
      return state;
  }
}

export function CartProvider({ children }) {
  const [cart, dispatch] = useReducer(cartReducer, []);

  return (
    <CartContext.Provider value={cart}>
      <CartDispatchContext.Provider value={dispatch}>
        {children}
      </CartDispatchContext.Provider>
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) throw new Error('useCart fora de CartProvider');
  return context;
}

export function useCartDispatch() {
  const context = useContext(CartDispatchContext);
  if (!context) throw new Error('useCartDispatch fora de CartProvider');
  return context;
}
```

**Uso:**

```javascript
function ProductList() {
  const dispatch = useCartDispatch();

  const addToCart = (product) => {
    dispatch({ type: 'ADD_ITEM', payload: product });
  };

  return (
    <div>
      <button onClick={() => addToCart({ id: 1, name: 'Produto' })}>
        Adicionar ao Carrinho
      </button>
    </div>
  );
}

function Cart() {
  const cart = useCart();
  const dispatch = useCartDispatch();

  return (
    <div>
      <h2>Carrinho ({cart.length})</h2>
      {cart.map(item => (
        <div key={item.id}>
          {item.name}
          <button onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: item.id })}>
            Remover
          </button>
        </div>
      ))}
      <button onClick={() => dispatch({ type: 'CLEAR' })}>
        Limpar Carrinho
      </button>
    </div>
  );
}
```

### 7.1.7 Pattern: Error Handling em Context

**Validar se Context est√° dispon√≠vel:**

```javascript
// Criar Context
const MyContext = createContext();

// Custom hook com valida√ß√£o
export function useMyContext() {
  const context = useContext(MyContext);

  if (context === undefined) {
    throw new Error(
      'useMyContext deve ser usado dentro de MyContextProvider. ' +
      'Certifique-se de que o componente est√° envolto pelo Provider.'
    );
  }

  return context;
}

// Provider
export function MyContextProvider({ children }) {
  const [value, setValue] = useState(null);

  return (
    <MyContext.Provider value={{ value, setValue }}>
      {children}
    </MyContext.Provider>
  );
}
```

**Benef√≠cio:** Erro claro e imediato se esquecer Provider.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Context

‚úÖ **Use Context para:**
- Tema (dark/light mode)
- Internacionaliza√ß√£o (idioma)
- Autentica√ß√£o (usu√°rio, permiss√µes)
- Configura√ß√µes globais
- Feature flags
- Dados que muitos componentes precisam

‚ùå **N√ÉO use Context para:**
- Props que passam apenas 1-2 n√≠veis (use props normais)
- Dados que mudam muito frequentemente (performance)
- Substituir todas as props (torna c√≥digo impl√≠cito, dif√≠cil rastrear)
- State management complexo em apps grandes (considere Redux/Zustand)

### Quando Context vs State Management Library

**Context suficiente:**
- App pequeno/m√©dio
- Poucos estados globais
- Estados mudam raramente

**Redux/Zustand prefer√≠vel:**
- App grande
- Muitos estados globais interconectados
- L√≥gica complexa de atualiza√ß√£o
- Necessidade de DevTools/time travel
- Performance cr√≠tica (muitas atualiza√ß√µes)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Problema de Performance

**Todos os consumidores re-renderizam quando valor muda:**

```javascript
function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  return (
    <AppContext.Provider value={{ user, theme, setUser, setTheme }}>
      {children}
    </AppContext.Provider>
  );
}

// Se user mudar, ComponentA re-renderiza (mesmo usando s√≥ theme!)
function ComponentA() {
  const { theme } = useContext(AppContext);
  return <div className={theme}>Content</div>;
}
```

**Solu√ß√µes:**
1. Separar Contexts (um para user, outro para theme)
2. Memoizar componentes consumidores com React.memo
3. Usar bibliotecas de state management com seletores (Redux, Zustand)

### Context N√£o √â Para Tudo

**Anti-pattern:** Usar Context para evitar passar props.

```javascript
// ‚ùå RUIM - Context para dados locais
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <CountContext.Provider value={count}>
      <Child />
    </CountContext.Provider>
  );
}

// ‚úÖ BOM - Props diretas
function Parent() {
  const [count, setCount] = useState(0);
  return <Child count={count} />;
}
```

**Regra:** Se prop passa 1-2 n√≠veis, use props. Context √© para dados **transversais** (muitos componentes, v√°rias profundidades).

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useReducer

Context + useReducer = pattern "Redux-like" para apps m√©dios.

### Rela√ß√£o com useMemo

Memoizar valor do Provider evita re-renders desnecess√°rios.

### Rela√ß√£o com Custom Hooks

Encapsular Context em custom hook (`useTheme`, `useAuth`) melhora DX.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Props simples
    ‚Üì
Props drilling (problema)
    ‚Üì
Context b√°sico (solu√ß√£o)
    ‚Üì
Context + useReducer (state complexo)
    ‚Üì
Redux/Zustand (apps grandes)
```

---

## üìö Conclus√£o

useContext √© hook **essencial** para compartilhar dados globalmente. Princ√≠pios:

1. **Props drilling**: Context resolve passar props por muitos n√≠veis
2. **API tripla**: createContext, Provider, useContext
3. **Re-render autom√°tico**: Consumidores re-renderizam quando valor muda
4. **Otimiza√ß√£o**: Memoizar valor, separar Contexts
5. **Use com modera√ß√£o**: N√£o substitui props em todos os casos

**Recomenda√ß√µes:**
- Use para dados transversais (tema, auth)
- Crie custom hooks para cada Context
- Memoize valor do Provider
- Separe state e dispatch em Contexts diferentes (performance)
- Prefira props locais quando poss√≠vel

**Dominar useContext = eliminar props drilling e criar arquitetura de estado limpa.**
