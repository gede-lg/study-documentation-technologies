# Outros Hooks Nativos do React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Al√©m dos hooks fundamentais (useState, useEffect, useContext, useReducer, useMemo, useCallback), React oferece **hooks especializados** para casos de uso espec√≠ficos: `useId` para IDs √∫nicos e est√°veis, hooks de **concorr√™ncia** (useTransition, useDeferredValue) para priorizar atualiza√ß√µes, e hooks do **React 19** (useOptimistic, useFormStatus, useFormState) para experi√™ncias de usu√°rio otimistas e formul√°rios avan√ßados.

Esses hooks representam **padr√µes consolidados** que antes requeriam c√≥digo boilerplate ou bibliotecas externas. S√£o solu√ß√µes idiom√°ticas para problemas recorrentes: acessibilidade (IDs √∫nicos), performance (transi√ß√µes n√£o-bloqueantes), e UX moderna (atualiza√ß√µes otimistas).

**Filosofia:** Hooks especializados existem para simplificar casos comuns. Voc√™ n√£o precisa todos, mas quando problema espec√≠fico aparece, h√° hook nativo que resolve elegantemente.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos hooks especializados:**

**React 18 (2022):**
- **useId**: IDs √∫nicos para acessibilidade
- **useTransition**: Transi√ß√µes de estado n√£o-urgente
- **useDeferredValue**: Atrasar re-render de partes n√£o-cr√≠ticas

**Motiva√ß√£o:** Habilitar **Concurrent Rendering** (renderiza√ß√£o interrupt√≠vel) e melhorar acessibilidade.

**React 19 (2024):**
- **useOptimistic**: Atualiza√ß√µes otimistas (UI assume sucesso antes de confirmar)
- **useFormStatus**: Estado de formul√°rios em submission
- **useFormState**: Gerenciar estado de forms com Server Actions

**Motiva√ß√£o:** Melhorar **UX de formul√°rios** e integrar com Server Components/Actions.

### Import√¢ncia no Ecossistema

Esses hooks s√£o **opcionais mas poderosos**:

- **useId**: Essencial para componentes acess√≠veis reutiliz√°veis
- **useTransition/useDeferredValue**: Apps grandes com muitas atualiza√ß√µes
- **Hooks React 19**: Modernizar formul√°rios e integra√ß√µes servidor

---

## üìã Sum√°rio Conceitual

### Hooks Cobertos

1. **useId**: Gera√ß√£o de IDs √∫nicos (acessibilidade)
2. **useTransition**: Marcar atualiza√ß√µes como n√£o-urgentes
3. **useDeferredValue**: Atrasar re-render de valores
4. **useOptimistic** (React 19): Atualiza√ß√µes otimistas
5. **useFormStatus** (React 19): Estado de formul√°rio
6. **useFormState** (React 19): Estado gerenciado de forms

### Aspectos Te√≥ricos Centrais

- **useId**: Garantia de IDs √∫nicos (SSR-safe)
- **Concurrent Hooks**: Priorizar atualiza√ß√µes (urgente vs n√£o-urgente)
- **Form Hooks**: Integra√ß√£o moderna com formul√°rios
- **Otimiza√ß√£o**: Performance e UX

---

## üß† Fundamentos Te√≥ricos

### 7.5.1 useId: IDs √önicos e Est√°veis

#### Conceito

`useId` gera ID √∫nico e est√°vel entre servidor e cliente (SSR-safe).

**Problema que resolve:**

```javascript
// ‚ùå ID n√£o √© √∫nico (m√∫ltiplas inst√¢ncias do componente)
function Input({ label }) {
  return (
    <div>
      <label htmlFor="input">label</label>
      <input id="input" />
    </div>
  );
}

// Render dois inputs:
<Input label="Nome" />
<Input label="Email" />

// Problema: ambos t√™m id="input" (inv√°lido, label n√£o funciona)
```

**Solu√ß√£o com useId:**

```javascript
import { useId } from 'react';

function Input({ label }) {
  const id = useId(); // ID √∫nico: ":r1:", ":r2:", etc.

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} />
    </div>
  );
}

// Cada Input tem ID √∫nico automaticamente ‚úì
```

#### Caracter√≠sticas

- **√önico**: Cada chamada retorna ID diferente
- **Est√°vel**: Mesmo ID entre server e client (SSR)
- **N√£o contador**: Formato `:rN:` (implementa√ß√£o interna)
- **N√£o para keys**: Apenas para acessibilidade (aria-*, htmlFor, id)

#### Casos de Uso

**1. Acessibilidade (label + input):**

```javascript
function FormField({ label, type = 'text' }) {
  const id = useId();

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} type={type} />
    </div>
  );
}
```

**2. M√∫ltiplos IDs relacionados:**

```javascript
function Field({ label, errorMessage }) {
  const id = useId();

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input
        id={id}
        aria-describedby={`${id}-error`}
        aria-invalid={!!errorMessage}
      />
      {errorMessage && (
        <span id={`${id}-error`} role="alert">
          {errorMessage}
        </span>
      )}
    </div>
  );
}
```

**3. Lista de componentes (n√£o para key!):**

```javascript
function RadioGroup({ options, name }) {
  const groupId = useId();

  return (
    <fieldset>
      {options.map((option, index) => {
        const id = `${groupId}-${index}`;
        return (
          <div key={option.value}> {/* key separada! */}
            <input type="radio" id={id} name={name} value={option.value} />
            <label htmlFor={id}>{option.label}</label>
          </div>
        );
      })}
    </fieldset>
  );
}
```

#### ‚ùå N√£o Use useId Para

```javascript
// ‚ùå Keys de lista
const id = useId();
return items.map(item => <div key={id}>...</div>); // Todos t√™m mesmo ID!

// ‚úÖ Use dados √∫nicos do item
return items.map(item => <div key={item.id}>...</div>);
```

---

## üîç An√°lise Conceitual Profunda

### 7.5.2 useTransition: Atualiza√ß√µes N√£o-Urgentes

#### Conceito

`useTransition` marca atualiza√ß√µes de estado como **n√£o-urgentes**, permitindo que React priorize atualiza√ß√µes urgentes (ex: input do usu√°rio).

**API:**
```javascript
const [isPending, startTransition] = useTransition();

// isPending: boolean - true durante transi√ß√£o
// startTransition: fun√ß√£o - marca updates como n√£o-urgentes
```

#### Problema que Resolve

**Sem useTransition:**

```javascript
function SearchResults({ items }) {
  const [query, setQuery] = useState('');

  // Filtro pesado
  const filtered = items.filter(item =>
    item.name.toLowerCase().includes(query.toLowerCase())
  );

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)} // Input trava!
      />
      <List items={filtered} /> {/* Re-render pesado */}
    </div>
  );
}

// Problema: Digitar trava porque filtro bloqueia input
```

**Com useTransition:**

```javascript
import { useState, useTransition } from 'react';

function SearchResults({ items }) {
  const [query, setQuery] = useState('');
  const [deferredQuery, setDeferredQuery] = useState('');
  const [isPending, startTransition] = useTransition();

  // Filtro usa deferredQuery (atrasado)
  const filtered = items.filter(item =>
    item.name.toLowerCase().includes(deferredQuery.toLowerCase())
  );

  return (
    <div>
      <input
        value={query}
        onChange={(e) => {
          setQuery(e.target.value); // Urgente (input responde imediatamente)
          startTransition(() => {
            setDeferredQuery(e.target.value); // N√£o-urgente (pode esperar)
          });
        }}
      />
      {isPending && <p>Carregando...</p>}
      <List items={filtered} /> {/* Atualiza quando poss√≠vel */}
    </div>
  );
}

// Input responsivo, lista atualiza quando React tem tempo ‚úì
```

#### Casos de Uso

**1. Navega√ß√£o entre tabs:**

```javascript
function Tabs() {
  const [tab, setTab] = useState('home');
  const [isPending, startTransition] = useTransition();

  const selectTab = (nextTab) => {
    startTransition(() => {
      setTab(nextTab); // Transi√ß√£o pode ser interrompida
    });
  };

  return (
    <div>
      <button onClick={() => selectTab('home')}>Home</button>
      <button onClick={() => selectTab('posts')}>Posts</button>
      <button onClick={() => selectTab('contact')}>Contato</button>

      {isPending && <Spinner />}
      {tab === 'home' && <HomeTab />}
      {tab === 'posts' && <PostsTab />} {/* Render pesado */}
      {tab === 'contact' && <ContactTab />}
    </div>
  );
}
```

**2. Busca com resultados pesados:**

```javascript
function Search() {
  const [input, setInput] = useState('');
  const [search, setSearch] = useState('');
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    setInput(e.target.value);
    startTransition(() => {
      setSearch(e.target.value); // Atualizar resultados (n√£o-urgente)
    });
  };

  return (
    <div>
      <input value={input} onChange={handleChange} />
      {isPending ? <Spinner /> : <Results query={search} />}
    </div>
  );
}
```

### 7.5.3 useDeferredValue: Atrasar Valor

#### Conceito

`useDeferredValue` retorna vers√£o **atrasada** de um valor, permitindo que React priorize atualiza√ß√µes mais urgentes.

**API:**
```javascript
const deferredValue = useDeferredValue(value);
```

#### Diferen√ßa: useTransition vs useDeferredValue

- **useTransition**: Voc√™ controla quando marcar update como n√£o-urgente (wrap setState)
- **useDeferredValue**: React automaticamente atrasa valor (mais simples)

**Exemplo:**

```javascript
import { useState, useDeferredValue } from 'react';

function SearchResults({ items }) {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query); // Valor atrasado

  // Filtro usa deferredQuery (atualiza quando poss√≠vel)
  const filtered = items.filter(item =>
    item.name.toLowerCase().includes(deferredQuery.toLowerCase())
  );

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)} // Urgente
      />
      <List items={filtered} /> {/* Usa valor atrasado */}
    </div>
  );
}

// Input responsivo, lista atualiza com delay ‚úì
```

#### Casos de Uso

**1. Debounce visual:**

```javascript
function Graph({ data }) {
  const deferredData = useDeferredValue(data);

  return <ExpensiveGraph data={deferredData} />;
}

// Se data mudar rapidamente, gr√°fico n√£o re-renderiza toda vez
```

**2. Lista pesada:**

```javascript
function HeavyList({ items }) {
  const deferredItems = useDeferredValue(items);

  return (
    <ul>
      {deferredItems.map(item => (
        <ExpensiveItem key={item.id} item={item} />
      ))}
    </ul>
  );
}
```

### 7.5.4 useOptimistic (React 19): Atualiza√ß√µes Otimistas

#### Conceito

`useOptimistic` permite mostrar estado **otimista** (assumir sucesso) enquanto opera√ß√£o ass√≠ncrona est√° em andamento.

**API:**
```javascript
const [optimisticState, addOptimistic] = useOptimistic(
  currentState,
  updateFn
);
```

#### Caso de Uso

**Exemplo: Adicionar like otimista**

```javascript
import { useOptimistic } from 'react';

function Post({ post }) {
  const [optimisticLikes, addOptimisticLike] = useOptimistic(
    post.likes,
    (currentLikes, amount) => currentLikes + amount
  );

  const handleLike = async () => {
    // Atualizar UI imediatamente (otimista)
    addOptimisticLike(1);

    // Enviar para servidor
    try {
      await fetch(`/api/posts/${post.id}/like`, { method: 'POST' });
      // Se sucesso, servidor retorna novo valor (re-fetch ou state update)
    } catch (error) {
      // Se erro, optimisticLikes volta ao valor real
      console.error('Erro ao dar like');
    }
  };

  return (
    <div>
      <p>{post.content}</p>
      <button onClick={handleLike}>
        üëç {optimisticLikes} {/* Mostra valor otimista imediatamente */}
      </button>
    </div>
  );
}
```

### 7.5.5 useFormStatus (React 19): Estado de Formul√°rio

#### Conceito

`useFormStatus` retorna informa√ß√µes sobre **estado do formul√°rio pai** (submitting, dados, etc).

**API:**
```javascript
const { pending, data, method, action } = useFormStatus();
```

#### Caso de Uso

**Bot√£o de submit com loading:**

```javascript
import { useFormStatus } from 'react-dom';

function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Enviando...' : 'Enviar'}
    </button>
  );
}

function Form() {
  const handleSubmit = async (formData) => {
    // Server Action ou API call
    await fetch('/api/submit', {
      method: 'POST',
      body: formData
    });
  };

  return (
    <form action={handleSubmit}>
      <input name="email" />
      <SubmitButton /> {/* Acessa estado do form pai */}
    </form>
  );
}
```

### 7.5.6 useFormState (React 19): Estado Gerenciado de Forms

#### Conceito

`useFormState` gerencia estado de formul√°rio integrado com Server Actions.

**API:**
```javascript
const [state, formAction] = useFormState(serverAction, initialState);
```

#### Caso de Uso

```javascript
import { useFormState } from 'react-dom';

async function submitForm(prevState, formData) {
  // Server Action
  const email = formData.get('email');

  if (!email.includes('@')) {
    return { error: 'Email inv√°lido' };
  }

  // Salvar no servidor
  await saveEmail(email);

  return { success: true };
}

function Newsletter() {
  const [state, formAction] = useFormState(submitForm, { error: null });

  return (
    <form action={formAction}>
      <input name="email" />
      <button type="submit">Inscrever</button>

      {state.error && <p style={{ color: 'red' }}>{state.error}</p>}
      {state.success && <p style={{ color: 'green' }}>Inscrito!</p>}
    </form>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Hook

**useId:**
- Componentes reutiliz√°veis com inputs/labels
- IDs para acessibilidade (aria-*, htmlFor)

**useTransition:**
- Navega√ß√£o entre tabs/rotas
- Atualiza√ß√µes que podem ser interrompidas
- Controle fino sobre o que √© urgente

**useDeferredValue:**
- Listas/gr√°ficos pesados
- Alternativa simples a useTransition
- "Debounce visual" autom√°tico

**useOptimistic (React 19):**
- Likes, favoritos, carrinho
- Qualquer update que pode falhar mas quer UI responsiva

**useFormStatus (React 19):**
- Bot√µes de submit com loading
- Indicadores de progresso em forms

**useFormState (React 19):**
- Formul√°rios com Server Actions
- Valida√ß√£o e feedback de erros

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### useTransition/useDeferredValue

- **N√£o √© garantia**: React pode n√£o atrasar se tiver recursos
- **Custo**: Overhead de gerenciar prioridades
- **Use quando medido**: N√£o otimize prematuramente

### Hooks React 19

- **Novos**: Ainda estabilizando, API pode mudar
- **Server Components**: useFormState/useFormStatus integram com RSC
- **Compatibilidade**: Requerem React 19+

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Concurrent React

useTransition e useDeferredValue s√£o base do **Concurrent Rendering** (React 18+).

### Rela√ß√£o com Acessibilidade

useId facilita **WCAG compliance** (associa√ß√£o label/input).

### Rela√ß√£o com Server Components

Hooks React 19 integram com **Server Actions** (Next.js App Router).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Hooks b√°sicos (useState, useEffect)
    ‚Üì
Hooks avan√ßados (useContext, useReducer)
    ‚Üì
Hooks especializados (useId, useTransition)
    ‚Üì
Hooks React 19 (useOptimistic, useFormState)
```

---

## üìö Conclus√£o

Hooks nativos especializados resolvem **casos espec√≠ficos** de forma idiom√°tica:

1. **useId**: IDs √∫nicos para acessibilidade
2. **useTransition**: Priorizar atualiza√ß√µes urgentes
3. **useDeferredValue**: Atrasar re-renders autom√°ticos
4. **useOptimistic**: UX otimista (assumir sucesso)
5. **useFormStatus**: Estado de forms em submission
6. **useFormState**: Gerenciar state de forms

**Recomenda√ß√µes:**
- Use useId para componentes acess√≠veis reutiliz√°veis
- useTransition/useDeferredValue para apps com muitas atualiza√ß√µes
- Hooks React 19 para formul√°rios modernos
- N√£o use "por via das d√∫vidas" - apenas quando problema espec√≠fico aparecer

**Dominar hooks especializados = ter ferramentas certas para problemas espec√≠ficos.**
