# useCallback no React: Memoiza√ß√£o de Fun√ß√µes

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useCallback` √© o hook para **memoizar fun√ß√µes** - cachear refer√™ncia de fun√ß√£o para evitar recri√°-la em toda render. Conceitualmente, √© **useMemo especializado para fun√ß√µes**: ao inv√©s de memoizar valor computado, memoiza a pr√≥pria fun√ß√£o. Garante que fun√ß√£o mant√©m **mesma identidade referencial** entre renders, essencial para otimizar componentes que dependem de igualdade de props (React.memo) ou evitar re-execu√ß√µes de useEffect.

A cada render, fun√ß√µes declaradas no corpo do componente s√£o **recriadas** (nova refer√™ncia), mesmo com c√≥digo id√™ntico. useCallback "congela" a fun√ß√£o - retorna mesma refer√™ncia enquanto depend√™ncias n√£o mudarem. √â otimiza√ß√£o de **igualdade referencial**, n√£o de execu√ß√£o (fun√ß√£o ainda executa normalmente quando chamada).

**Met√°fora:** Se fun√ß√£o normal √© "novo livro impresso toda vez", useCallback √© "emprestar mesmo livro da biblioteca" - conte√∫do igual, mas √© fisicamente o mesmo objeto enquanto deps n√£o mudam.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o da otimiza√ß√£o de fun√ß√µes:**

**2013-2017: Classes**
Em classes, m√©todos s√£o propriedades da inst√¢ncia:
```javascript
class Component extends React.Component {
  handleClick = () => {
    // Mesma fun√ß√£o toda render (bind autom√°tico)
  }
}
```

**Problema com Hooks:** Fun√ß√µes no corpo s√£o recriadas toda render.

```javascript
function Component() {
  // Nova fun√ß√£o toda render!
  const handleClick = () => console.log('click');

  return <Child onClick={handleClick} />; // Prop sempre diferente
}
```

**2018 - useCallback (React 16.8)**
Solu√ß√£o para estabilizar refer√™ncias:
```javascript
const handleClick = useCallback(() => {
  console.log('click');
}, []); // Mesma fun√ß√£o toda render
```

**Filosofia:** useCallback √© **otimiza√ß√£o de igualdade**, n√£o performance da fun√ß√£o. Use quando igualdade referencial importa (React.memo, deps de useEffect).

### Problema Fundamental que Resolve

**Sem useCallback:**

**Problema 1 - React.memo n√£o funciona:**
```javascript
function Parent() {
  const [count, setCount] = useState(0);

  // ‚ùå Nova fun√ß√£o toda render
  const handleClick = () => {
    console.log('Clicked');
  };

  return (
    <div>
      <Child onClick={handleClick} />
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child renderizou'); // Loga toda vez!
  return <button onClick={onClick}>Clique</button>;
});

// Problema: handleClick √© nova toda render
// ‚Üí onClick prop sempre diferente
// ‚Üí React.memo n√£o previne re-render
```

**Problema 2 - useEffect re-executa desnecessariamente:**
```javascript
function Component({ id }) {
  const [data, setData] = useState(null);

  // ‚ùå Nova fun√ß√£o toda render
  const fetchData = () => {
    fetch(`/api/${id}`).then(res => res.json()).then(setData);
  };

  useEffect(() => {
    fetchData(); // Re-executa toda render (fetchData sempre diferente)
  }, [fetchData]); // ESLint requer fetchData nas deps

  return <div>{data?.name}</div>;
}
```

**Com useCallback:**

```javascript
// ‚úÖ Problema 1: React.memo funciona
function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []); // Mesma fun√ß√£o toda render

  return (
    <div>
      <Child onClick={handleClick} />
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child renderizou'); // Loga apenas 1x ‚úì
  return <button onClick={onClick}>Clique</button>;
});

// ‚úÖ Problema 2: useEffect n√£o re-executa
function Component({ id }) {
  const [data, setData] = useState(null);

  const fetchData = useCallback(() => {
    fetch(`/api/${id}`).then(res => res.json()).then(setData);
  }, [id]); // Recria apenas quando id muda

  useEffect(() => {
    fetchData(); // Re-executa apenas quando id muda ‚úì
  }, [fetchData]);

  return <div>{data?.name}</div>;
}
```

### Import√¢ncia no Ecossistema

useCallback √© **essencial** para:

- **Otimizar React.memo**: Evitar re-renders de filhos
- **Estabilizar deps de useEffect**: Prevenir re-execu√ß√µes
- **Callbacks para bibliotecas**: Fun√ß√µes passadas a libs externas
- **Performance em listas**: Callbacks para itens individuais

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Identidade referencial**: Mesma refer√™ncia entre renders
2. **Memoiza√ß√£o de fun√ß√£o**: Cache da fun√ß√£o, n√£o do resultado
3. **Depend√™ncias**: Array determina quando recriar
4. **Otimiza√ß√£o**: Para igualdade, n√£o execu√ß√£o
5. **Equival√™ncia**: `useCallback(fn, deps)` = `useMemo(() => fn, deps)`

### Pilares Fundamentais

- **Function reference**: Retorna fun√ß√£o memoizada
- **Dependencies array**: Quando recriar fun√ß√£o
- **Closure**: Fun√ß√£o captura valores das deps
- **Stable identity**: Previne re-renders de filhos
- **useEffect deps**: Evita re-execu√ß√µes

### Vis√£o Geral das Nuances

- **N√£o otimiza execu√ß√£o**: Fun√ß√£o ainda roda normalmente
- **Custo existe**: Comparar deps tem overhead
- **Use com React.memo**: Combina√ß√£o frequente
- **Stale closures**: Cuidado com deps faltando
- **ESLint exhaustive-deps**: Valida deps

---

## üß† Fundamentos Te√≥ricos

### Anatomia do useCallback

**API:**
```javascript
const memoizedFn = useCallback(fn, dependencies);
```

**Par√¢metros:**
1. **fn**: Fun√ß√£o a ser memoizada
2. **dependencies**: Array de deps - quando recriar

**Retorno:**
- Fun√ß√£o memoizada (mesma refer√™ncia se deps n√£o mudaram)

### Equival√™ncia com useMemo

**useCallback √© a√ß√∫car sint√°tico:**

```javascript
// useCallback
const handleClick = useCallback(() => {
  console.log('click');
}, []);

// √â exatamente igual a:
const handleClick = useMemo(() => {
  return () => console.log('click');
}, []);
```

**Diferen√ßa:** useCallback √© mais leg√≠vel para fun√ß√µes.

### Como Funciona

**Primeira render:**
```javascript
const fn = useCallback(() => doSomething(a, b), [a, b]);

// 1. React armazena fun√ß√£o no cache
// 2. Retorna a fun√ß√£o
```

**Renders subsequentes:**
```javascript
// 1. React compara deps atuais com anteriores (Object.is)
// 2a. Se deps iguais: retorna fun√ß√£o do cache (mesma refer√™ncia)
// 2b. Se deps diferentes: cria nova fun√ß√£o, atualiza cache
```

**Visualiza√ß√£o:**
```
useCallback(() => fn, [a, b])
        ‚Üì
   Deps mudaram?
      ‚ÜôÔ∏è      ‚ÜòÔ∏è
    Sim       N√£o
     ‚Üì         ‚Üì
  Nova fn   Fn do cache
     ‚Üì         ‚Üì
 Nova ref   Mesma ref
```

---

## üîç An√°lise Conceitual Profunda

### 7.4.1 Caso B√°sico: Otimizar React.memo

```javascript
function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // ‚úÖ Fun√ß√£o est√°vel (deps vazio)
  const handleClick = useCallback(() => {
    setText('Clicou!');
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Incrementar</button>

      <ExpensiveChild onClick={handleClick} />
    </div>
  );
}

const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild renderizou');

  // Simula√ß√£o de componente custoso
  const expensiveResult = Array.from({ length: 10000 }).map((_, i) => i).reduce((a, b) => a + b);

  return <button onClick={onClick}>Clique aqui</button>;
});

// Clicar "Incrementar" ‚Üí count muda ‚Üí Parent re-renderiza
// ‚Üí handleClick √© mesma refer√™ncia (useCallback)
// ‚Üí ExpensiveChild N√ÉO re-renderiza (React.memo + prop igual) ‚úì
```

### 7.4.2 Caso: Callback com Deps

```javascript
function SearchBox({ onSearch }) {
  const [query, setQuery] = useState('');
  const [minLength, setMinLength] = useState(3);

  // Callback depende de query e minLength
  const handleSearch = useCallback(() => {
    if (query.length >= minLength) {
      onSearch(query);
    }
  }, [query, minLength, onSearch]); // Recria quando deps mudam

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={handleSearch}>Buscar</button>
      <input
        type="number"
        value={minLength}
        onChange={(e) => setMinLength(Number(e.target.value))}
      />
    </div>
  );
}
```

**Fluxo:**
- `query` ou `minLength` muda ‚Üí `handleSearch` recriada (nova closure com novos valores)
- `query` e `minLength` n√£o mudam ‚Üí `handleSearch` mant√©m mesma refer√™ncia

### 7.4.3 Caso: useEffect com Callback

```javascript
function Component({ userId }) {
  const [user, setUser] = useState(null);

  // Callback est√°vel (depende apenas de userId)
  const fetchUser = useCallback(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]); // Recria apenas quando userId muda

  useEffect(() => {
    fetchUser(); // Re-executa apenas quando fetchUser muda
  }, [fetchUser]); // fetchUser pode estar nas deps (√© est√°vel)

  return <div>{user?.name}</div>;
}

// Alternativa sem useCallback (inline):
function Component({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]); // userId diretamente nas deps

  return <div>{user?.name}</div>;
}
```

**Nota:** Se fun√ß√£o √© usada apenas no useEffect, inline √© mais simples (sem useCallback).

### 7.4.4 Caso: Callbacks em Listas

**Problema:** Callback diferente para cada item causa re-renders.

```javascript
// ‚ùå Sem otimiza√ß√£o
function TodoList({ todos }) {
  const handleToggle = (id) => {
    // Toggle todo
  };

  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={() => handleToggle(todo.id)} // Nova fun√ß√£o para cada item!
        />
      ))}
    </ul>
  );
}

const TodoItem = React.memo(({ todo, onToggle }) => {
  console.log('TodoItem renderizou:', todo.id);
  return (
    <li>
      <input type="checkbox" checked={todo.completed} onChange={onToggle} />
      {todo.text}
    </li>
  );
});

// Problema: Qualquer re-render do parent recria TODAS as fun√ß√µes
// ‚Üí Todos os TodoItems re-renderizam
```

**Solu√ß√£o 1:** useCallback no parent.

```javascript
// ‚úÖ useCallback est√°vel
function TodoList({ todos }) {
  const handleToggle = useCallback((id) => {
    // Toggle todo
  }, []); // Deps vazio (fun√ß√£o n√£o depende de nada do component)

  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={() => handleToggle(todo.id)} // Ainda cria nova fn!
        />
      ))}
    </ul>
  );
}
```

**Problema:** `() => handleToggle(todo.id)` ainda √© nova fun√ß√£o.

**Solu√ß√£o 2:** Passar ID separado.

```javascript
// ‚úÖ Melhor: passar callback + ID separado
function TodoList({ todos }) {
  const handleToggle = useCallback((id) => {
    // Toggle todo
  }, []);

  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle} // Mesma fun√ß√£o para todos
          todoId={todo.id}
        />
      ))}
    </ul>
  );
}

const TodoItem = React.memo(({ todo, onToggle, todoId }) => {
  return (
    <li>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todoId)} // Inline aqui OK (dentro do item)
      />
      {todo.text}
    </li>
  );
});
```

### 7.4.5 Anti-pattern: useCallback Desnecess√°rio

**‚ùå Callback n√£o passado a filho ou useEffect:**

```javascript
function Component() {
  // ‚ùå useCallback desnecess√°rio
  const handleClick = useCallback(() => {
    console.log('click');
  }, []);

  // Fun√ß√£o usada apenas localmente, n√£o passa para filho nem useEffect
  return <button onClick={handleClick}>Clique</button>;
}

// ‚úÖ Melhor: sem useCallback
function Component() {
  const handleClick = () => {
    console.log('click');
  };

  return <button onClick={handleClick}>Clique</button>;
}
```

**Regra:** S√≥ use useCallback se fun√ß√£o √©:
1. Passada para `React.memo` child
2. Dep de `useEffect`/`useMemo`/`useCallback`
3. Passada para biblioteca externa

### 7.4.6 Stale Closures com useCallback

**Problema:** Callback captura valores antigos.

```javascript
function Component() {
  const [count, setCount] = useState(0);

  // ‚ùå handleClick captura count inicial (0)
  const handleClick = useCallback(() => {
    console.log('Count:', count); // Sempre loga 0!
  }, []); // Deps vazio = nunca recria

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Incrementar</button>
      <button onClick={handleClick}>Log Count</button>
    </div>
  );
}
```

**Solu√ß√µes:**

**1. Incluir count nas deps:**
```javascript
const handleClick = useCallback(() => {
  console.log('Count:', count); // Loga valor atual
}, [count]); // Recria quando count muda
```

**2. Usar forma funcional de setState:**
```javascript
const handleClick = useCallback(() => {
  setCount(prev => {
    console.log('Count:', prev); // Sempre tem valor atual
    return prev + 1;
  });
}, []); // N√£o precisa de count nas deps
```

**3. Usar useRef:**
```javascript
const countRef = useRef(count);

useEffect(() => {
  countRef.current = count; // Mant√©m ref atualizada
}, [count]);

const handleClick = useCallback(() => {
  console.log('Count:', countRef.current); // Sempre atual
}, []); // N√£o precisa de count nas deps
```

### 7.4.7 Pattern: Event Handlers Compostos

```javascript
function Form({ onSubmit }) {
  const [values, setValues] = useState({ name: '', email: '' });
  const [errors, setErrors] = useState({});

  // Validar (est√°vel)
  const validate = useCallback((values) => {
    const errors = {};
    if (!values.name) errors.name = 'Nome obrigat√≥rio';
    if (!values.email) errors.email = 'Email obrigat√≥rio';
    return errors;
  }, []);

  // Submit (depende de values e validate)
  const handleSubmit = useCallback((e) => {
    e.preventDefault();

    const validationErrors = validate(values);
    setErrors(validationErrors);

    if (Object.keys(validationErrors).length === 0) {
      onSubmit(values);
    }
  }, [values, validate, onSubmit]);

  return (
    <form onSubmit={handleSubmit}>
      {/* form fields */}
    </form>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar useCallback

‚úÖ **Use useCallback quando:**
- Passar callback para `React.memo` child
- Callback √© dep de `useEffect` ou outro hook
- Passar fun√ß√£o para biblioteca externa (event listener, etc)
- Fun√ß√£o √© referenciada em m√∫ltiplos places

‚ùå **N√ÉO use useCallback se:**
- Callback usado apenas inline (ex: `onClick` sem filho memoizado)
- Fun√ß√£o n√£o √© passada como prop ou dep
- "Por via das d√∫vidas" (otimiza√ß√£o prematura)

### Compara√ß√£o: useCallback vs useMemo

```javascript
// useCallback para fun√ß√µes
const fn = useCallback(() => doSomething(), []);

// useMemo para valores
const value = useMemo(() => computeValue(), []);

// Equival√™ncia
const fn = useMemo(() => () => doSomething(), []); // Igual a useCallback
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### useCallback N√£o Otimiza Execu√ß√£o

**Importante:** useCallback memoiza **refer√™ncia**, n√£o execu√ß√£o.

```javascript
const handleClick = useCallback(() => {
  // C√≥digo aqui executa NORMALMENTE toda vez que fun√ß√£o √© chamada
  expensiveCalculation();
}, []);

// useCallback n√£o previne expensiveCalculation() de rodar
// Apenas garante que 'handleClick' √© mesma refer√™ncia
```

Se quer cachear **resultado**, use `useMemo`:
```javascript
const result = useMemo(() => expensiveCalculation(), []);
```

### Custo de useCallback

**Memoiza√ß√£o tem custo:**
1. Comparar deps (Object.is)
2. Gerenciar closure/cache

**Para callbacks simples, custo pode n√£o valer:**

```javascript
// ‚ùå Overhead desnecess√°rio
const handleClick = useCallback(() => {
  console.log('click');
}, []);

// Se n√£o passa para React.memo ou useEffect, melhor sem:
const handleClick = () => console.log('click');
```

### Deps Faltando (Stale Closures)

**Problema comum:** Esquecer deps causa bugs sutis.

```javascript
function Component({ userId }) {
  const [data, setData] = useState(null);

  // ‚ùå Faltou userId nas deps
  const fetchData = useCallback(() => {
    fetch(`/api/user/${userId}`) // Usa userId
      .then(res => res.json())
      .then(setData);
  }, []); // userId deveria estar aqui!

  // Se userId mudar, fetchData continua usando userId antigo (stale)
}
```

**Solu√ß√£o:** ESLint exhaustive-deps pega isso.

```javascript
const fetchData = useCallback(() => {
  fetch(`/api/user/${userId}`)
    .then(res => res.json())
    .then(setData);
}, [userId]); // ‚úì
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useMemo

useCallback √© useMemo especializado para fun√ß√µes.

### Rela√ß√£o com React.memo

useCallback estabiliza props (callbacks) para React.memo funcionar.

### Rela√ß√£o com useEffect

useCallback permite callbacks serem deps de useEffect sem causar re-execu√ß√µes.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Fun√ß√µes normais (recriam toda render)
    ‚Üì
Problema: React.memo n√£o funciona
    ‚Üì
useCallback (estabilizar refer√™ncia)
    ‚Üì
Otimiza√ß√£o completa (memo + callback)
```

---

## üìö Conclus√£o

useCallback √© hook de **otimiza√ß√£o de igualdade** para fun√ß√µes. Princ√≠pios:

1. **Identidade referencial**: Mesma fun√ß√£o entre renders
2. **Depend√™ncias**: Recria quando deps mudam
3. **N√£o otimiza execu√ß√£o**: Apenas refer√™ncia
4. **Use com React.memo**: Combina√ß√£o frequente
5. **Evita stale closures**: Deps corretas s√£o cr√≠ticas

**Recomenda√ß√µes:**
- Use quando passar callback para React.memo child
- Use quando callback √© dep de useEffect
- ESLint exhaustive-deps para validar deps
- N√£o use para todos os callbacks (custo overhead)
- Combine com React.memo para otimizar filhos

**Dominar useCallback = prevenir re-renders desnecess√°rios via igualdade referencial.**
