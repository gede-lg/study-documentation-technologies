# useMemo no React: Memoiza√ß√£o de Valores

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useMemo` √© o hook para **memoizar valores computados** - cachear resultado de c√°lculos custosos para evitar recalcular em toda render. Conceitualmente, √© uma **otimiza√ß√£o de performance**: voc√™ diz "calcule isso uma vez, reutilize enquanto depend√™ncias n√£o mudarem". √â trade-off consciente - mem√≥ria (cache) por CPU (n√£o recalcular).

O hook retorna valor memoizado que s√≥ √© recalculado quando depend√™ncias mudam. Entre re-renders, se deps n√£o mudaram, retorna valor cacheado imediatamente. √â aplica√ß√£o do conceito de **memoiza√ß√£o** (programa√ß√£o funcional): lembrar resultados de computa√ß√µes para evitar duplica√ß√£o de trabalho.

**Met√°fora:** Se fun√ß√£o normal √© "sempre cozinhar do zero", useMemo √© "guardar na geladeira e reaquecer" - voc√™ s√≥ cozinha de novo (recalcula) quando ingredientes (deps) mudam. Se mesmos ingredientes, retorna prato pronto (cache).

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o da otimiza√ß√£o em React:**

**2013-2017: Classes + Lifecycle**
Otimiza√ß√£o em classes era manual:
```javascript
class Component extends React.Component {
  computedValue() {
    // Recalcula toda render (ineficiente)
    return expensiveCalculation(this.props.data);
  }
}
```

**Solu√ß√£o:** Memoiza√ß√£o manual via instance variables.

**2018 - useMemo (React 16.8)**
Hooks introduziram memoiza√ß√£o declarativa:
```javascript
const value = useMemo(() => expensiveCalculation(data), [data]);
// Recalcula apenas quando 'data' muda
```

**Filosofia:** "Otimiza√ß√£o prematura √© a raiz de todo mal" (Donald Knuth). useMemo √© para casos **medidos** onde performance √© problema, n√£o padr√£o default.

### Problema Fundamental que Resolve

**Sem useMemo:**

**Problema 1 - C√°lculo custoso toda render:**
```javascript
function Component({ items }) {
  // üê¢ Filtro roda TODA render (mesmo se items n√£o mudou)
  const filtered = items.filter(item => {
    // Opera√ß√£o custosa (ex: regex complexa)
    return expensiveFilter(item);
  });

  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Filtrados: {filtered.length}</p>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    </div>
  );
}

// Clicar bot√£o ‚Üí re-render ‚Üí expensiveFilter roda de novo
// (mesmo que items n√£o mudou!)
```

**Problema 2 - Novo objeto/array toda render causa re-render filho:**
```javascript
function Parent() {
  const [count, setCount] = useState(0);

  // ‚ùå Novo array toda render
  const config = [1, 2, 3];

  return <Child config={config} />;
}

const Child = React.memo(({ config }) => {
  // Re-renderiza toda vez (config sempre diferente)
  console.log('Child renderizou');
  return <div>{config.length}</div>;
});
```

**Com useMemo:**

```javascript
// ‚úÖ Problema 1: Cache de c√°lculo
function Component({ items }) {
  const filtered = useMemo(() => {
    return items.filter(item => expensiveFilter(item));
  }, [items]); // Recalcula apenas quando items muda

  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Filtrados: {filtered.length}</p>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    </div>
  );
}
// Clicar bot√£o ‚Üí re-render ‚Üí filtered vem do cache ‚ö°

// ‚úÖ Problema 2: Estabilidade referencial
function Parent() {
  const [count, setCount] = useState(0);

  const config = useMemo(() => [1, 2, 3], []); // Sempre mesmo array

  return <Child config={config} />;
}

const Child = React.memo(({ config }) => {
  // N√ÉO re-renderiza (config √© sempre mesma refer√™ncia)
  console.log('Child renderizou');
  return <div>{config.length}</div>;
});
```

**Vantagens:**
- Evita trabalho duplicado (performance)
- Estabiliza refer√™ncias (previne re-renders)
- Declarativo (deps expl√≠citas)

### Import√¢ncia no Ecossistema

useMemo √© **crucial** para:

- **C√°lculos custosos**: Filtros, sorts, transforma√ß√µes pesadas
- **Estabilidade referencial**: Objetos/arrays passados a React.memo
- **Performance cr√≠tica**: Listas grandes, dashboards complexos
- **Evitar cascata de re-renders**: Quebrar cadeia de atualiza√ß√µes

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Memoiza√ß√£o**: Cache de valores computados
2. **Depend√™ncias**: Array determina quando recalcular
3. **Trade-off**: Mem√≥ria (cache) vs CPU (recalcular)
4. **Otimiza√ß√£o**: Use apenas quando necess√°rio (medido)
5. **Identidade referencial**: Mesmo objeto entre renders

### Pilares Fundamentais

- **Factory function**: Fun√ß√£o que retorna valor
- **Dependencies array**: Quando recalcular
- **Cached value**: Valor retornado entre re-renders
- **Lazy evaluation**: S√≥ executa quando necess√°rio
- **Compara√ß√£o**: Object.is() nas deps

### Vis√£o Geral das Nuances

- **N√£o √© garantia**: React pode descartar cache
- **Custo existe**: Memoiza√ß√£o tem overhead (comparar deps)
- **Preferir simplicidade**: N√£o memoize tudo
- **Combine com React.memo**: Para otimizar filhos
- **ESLint exhaustive-deps**: Valida deps

---

## üß† Fundamentos Te√≥ricos

### Anatomia do useMemo

**API:**
```javascript
const memoizedValue = useMemo(() => computeValue(a, b), [a, b]);
```

**Par√¢metros:**
1. **Factory function**: `() => value` - fun√ß√£o que calcula/retorna valor
2. **Dependencies**: Array de deps - quando recalcular

**Retorno:**
- Valor memoizado (do cache ou recalculado)

### Como Funciona

**Primeira render:**
```javascript
const value = useMemo(() => heavyCalculation(data), [data]);

// 1. React executa heavyCalculation(data)
// 2. Armazena resultado no cache
// 3. Retorna resultado
```

**Renders subsequentes:**
```javascript
// 1. React compara deps atuais com deps anteriores (Object.is)
// 2a. Se deps iguais: retorna valor do cache (‚ö° r√°pido)
// 2b. Se deps diferentes: re-executa heavyCalculation, atualiza cache
```

**Fluxo:**
```
useMemo(() => calc(a, b), [a, b])
     ‚Üì
Deps mudaram? (Object.is)
     ‚ÜôÔ∏è        ‚ÜòÔ∏è
   Sim         N√£o
    ‚Üì           ‚Üì
Recalcular   Retornar cache
    ‚Üì           ‚Üì
Atualizar    Valor antigo
  cache
    ‚Üì
Retornar novo valor
```

### Compara√ß√£o de Depend√™ncias

**React usa Object.is() (similar a ===):**

```javascript
// Primitivos: compara√ß√£o por valor
const num = useMemo(() => calc(count), [count]);
// count = 5 ‚Üí 5 ‚Üí Re-render: count = 5 ‚Üí deps iguais ‚Üí cache

// Objetos: compara√ß√£o por refer√™ncia
const obj = useMemo(() => transform(user), [user]);
// user = {id: 1} ‚Üí {id: 1} ‚Üí Re-render: user = {id: 1} (novo objeto)
// ‚Üí deps diferentes ‚Üí recalcula
```

**Importante:** Objetos/arrays novos sempre s√£o diferentes (mesmo conte√∫do).

---

## üîç An√°lise Conceitual Profunda

### 7.3.1 Caso B√°sico: C√°lculo Custoso

```javascript
function SearchResults({ query, items }) {
  // Filtro + sort custoso
  const filtered = useMemo(() => {
    console.log('Calculando filtered...');

    return items
      .filter(item => item.name.toLowerCase().includes(query.toLowerCase()))
      .sort((a, b) => a.name.localeCompare(b.name));
  }, [query, items]); // Recalcula apenas quando query ou items muda

  const [highlight, setHighlight] = useState(false);

  return (
    <div>
      <button onClick={() => setHighlight(!highlight)}>
        Toggle Highlight
      </button>
      {/* Clicar bot√£o n√£o recalcula filtered (vem do cache) */}
      <ul>
        {filtered.map(item => (
          <li key={item.id} style={{ background: highlight ? 'yellow' : 'white' }}>
            {item.name}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Benef√≠cio:** `filtered` s√≥ recalcula quando `query` ou `items` muda. Estado local (`highlight`) n√£o causa rec√°lculo.

### 7.3.2 Caso: Estabilidade Referencial

**Problema:** React.memo n√£o funciona se props sempre novas.

```javascript
// ‚ùå Sem useMemo
function Parent() {
  const [count, setCount] = useState(0);

  const options = { theme: 'dark', fontSize: 14 }; // Novo objeto toda render

  return (
    <div>
      <Child options={options} />
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
    </div>
  );
}

const Child = React.memo(({ options }) => {
  console.log('Child renderizou'); // Loga toda vez (options sempre diferente)
  return <div>Theme: {options.theme}</div>;
});
```

**Solu√ß√£o:** Memoize objeto.

```javascript
// ‚úÖ Com useMemo
function Parent() {
  const [count, setCount] = useState(0);

  const options = useMemo(() => ({ theme: 'dark', fontSize: 14 }), []);
  // Mesmo objeto toda render

  return (
    <div>
      <Child options={options} />
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
    </div>
  );
}

const Child = React.memo(({ options }) => {
  console.log('Child renderizou'); // Loga apenas 1x (options sempre igual)
  return <div>Theme: {options.theme}</div>;
});
```

### 7.3.3 Caso: useMemo em Dependency Array

**useMemo pode ser dep de outro useMemo/useEffect:**

```javascript
function Component({ items, filter }) {
  // Primeiro: filtrar
  const filtered = useMemo(() => {
    return items.filter(item => item.category === filter);
  }, [items, filter]);

  // Segundo: ordenar (depende de filtered)
  const sorted = useMemo(() => {
    return filtered.sort((a, b) => a.price - b.price);
  }, [filtered]); // 'filtered' vem do useMemo acima

  // Efeito (depende de sorted)
  useEffect(() => {
    console.log('Sorted mudou:', sorted.length);
  }, [sorted]);

  return <List items={sorted} />;
}
```

### 7.3.4 Caso: Array de Objetos

```javascript
function UserList({ users, searchTerm }) {
  const filteredUsers = useMemo(() => {
    console.log('Filtrando usu√°rios...');

    return users.filter(user =>
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [users, searchTerm]);

  const sortedUsers = useMemo(() => {
    console.log('Ordenando usu√°rios...');

    return [...filteredUsers].sort((a, b) =>
      a.name.localeCompare(b.name)
    );
  }, [filteredUsers]);

  return (
    <ul>
      {sortedUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 7.3.5 Anti-pattern: Memoizar Tudo

**‚ùå Memoiza√ß√£o desnecess√°ria:**

```javascript
function Component({ name }) {
  // ‚ùå Custo de memoiza√ß√£o > custo de recalcular
  const uppercased = useMemo(() => name.toUpperCase(), [name]);

  // ‚ùå Primitivo, sem custo de recalcular
  const doubled = useMemo(() => 2 * 2, []);

  // ‚ùå Opera√ß√£o trivial
  const greeting = useMemo(() => `Hello, ${name}`, [name]);

  return <div>{greeting}</div>;
}
```

**‚úÖ Sem memoiza√ß√£o (melhor):**

```javascript
function Component({ name }) {
  // Opera√ß√µes triviais: deixe acontecer toda render
  const uppercased = name.toUpperCase();
  const doubled = 2 * 2;
  const greeting = `Hello, ${name}`;

  return <div>{greeting}</div>;
}
```

**Regra:** S√≥ memoize se:
1. C√°lculo √© **medido como lento** (> ~10ms)
2. Valor √© objeto/array passado para React.memo
3. Valor √© dep de useEffect custoso

### 7.3.6 Pattern: Computa√ß√£o Derivada

```javascript
function Dashboard({ transactions }) {
  const stats = useMemo(() => {
    console.log('Calculando estat√≠sticas...');

    const total = transactions.reduce((sum, t) => sum + t.amount, 0);
    const avg = total / transactions.length;
    const max = Math.max(...transactions.map(t => t.amount));
    const min = Math.min(...transactions.map(t => t.amount));

    return { total, avg, max, min };
  }, [transactions]);

  const chartData = useMemo(() => {
    console.log('Preparando dados do gr√°fico...');

    return transactions.map(t => ({
      x: t.date,
      y: t.amount
    }));
  }, [transactions]);

  return (
    <div>
      <Stats data={stats} />
      <Chart data={chartData} />
    </div>
  );
}
```

### 7.3.7 Pattern: useMemo com Context

```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // Memoizar valor do Context (evita re-renders)
  const value = useMemo(() => ({
    theme,
    setTheme,
    isDark: theme === 'dark'
  }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### 7.3.8 Debugging: Verificar Rec√°lculos

```javascript
function Component({ data }) {
  const processed = useMemo(() => {
    console.log('useMemo executou'); // Log para ver quando recalcula
    return expensiveProcess(data);
  }, [data]);

  console.log('Componente renderizou'); // Log toda render

  return <div>{processed}</div>;
}

// Se ver "useMemo executou" toda render:
// ‚Üí Deps est√£o mudando (investigar por qu√™)
// Se ver apenas "Componente renderizou":
// ‚Üí useMemo funcionando (retornando cache) ‚úì
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar useMemo

‚úÖ **Use useMemo quando:**
- C√°lculo √© **comprovadamente lento** (perfil com DevTools)
- Processar arrays/listas grandes (filter, map, sort)
- Computa√ß√µes complexas (recurs√£o, algoritmos pesados)
- Estabilizar refer√™ncia de objeto/array passado a React.memo
- Evitar re-execu√ß√£o de useEffect custoso

‚ùå **N√ÉO use useMemo se:**
- C√°lculo √© trivial (< 1ms)
- Valor √© primitivo simples
- N√£o h√° problema de performance medido
- "Por via das d√∫vidas" (otimiza√ß√£o prematura)

### Checklist de Decis√£o

```
Preciso otimizar?
    ‚Üì
Perfil mostra problema?
    ‚ÜôÔ∏è        ‚ÜòÔ∏è
  N√£o         Sim
   ‚Üì           ‚Üì
N√£o use    √â c√°lculo ou refer√™ncia?
             ‚ÜôÔ∏è              ‚ÜòÔ∏è
          C√°lculo        Refer√™ncia
             ‚Üì               ‚Üì
          useMemo         useMemo
      (cache resultado) (estabilizar obj/array)
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### useMemo N√£o √â Garantia

**React pode descartar cache:**

```javascript
const value = useMemo(() => calc(data), [data]);

// React PODE descartar cache (ex: press√£o de mem√≥ria)
// e recalcular mesmo que deps n√£o mudaram
// ‚Üí N√£o confie para "garantia sem√¢ntica", apenas performance
```

**Regra:** C√≥digo deve funcionar **sem** useMemo. useMemo √© apenas otimiza√ß√£o.

### Custo de Memoiza√ß√£o

**Memoiza√ß√£o tem overhead:**

1. Alocar mem√≥ria para cache
2. Comparar depend√™ncias (Object.is)
3. Gerenciar ciclo de vida do cache

**Para c√°lculos triviais, custo > benef√≠cio:**

```javascript
// ‚ùå Custo de useMemo > custo de recalcular
const doubled = useMemo(() => count * 2, [count]);

// ‚úÖ Melhor sem useMemo
const doubled = count * 2;
```

### Deps Incorretas

**‚ùå Deps faltando:**
```javascript
const filtered = useMemo(() => {
  return items.filter(item => item.category === category); // Usa 'category'
}, [items]); // Faltou 'category' nas deps!

// Se category mudar, filtered n√£o atualiza (bug)
```

**‚úÖ ESLint exhaustive-deps:**
```javascript
// ESLint avisa: "category" deve estar nas deps
const filtered = useMemo(() => {
  return items.filter(item => item.category === category);
}, [items, category]); // ‚úì
```

### Objeto/Array nas Deps

**Problema:** Objeto novo toda render causa rec√°lculo.

```javascript
function Parent() {
  const config = { theme: 'dark' }; // Novo objeto toda render

  return <Child config={config} />;
}

function Child({ config }) {
  const processed = useMemo(() => {
    // Recalcula TODA render (config sempre diferente)
    return process(config);
  }, [config]);
}
```

**Solu√ß√£o:** Memoize o objeto tamb√©m.

```javascript
function Parent() {
  const config = useMemo(() => ({ theme: 'dark' }), []); // Est√°vel
  return <Child config={config} />;
}
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useCallback

useCallback √© useMemo para fun√ß√µes: `useCallback(fn, deps)` = `useMemo(() => fn, deps)`.

### Rela√ß√£o com React.memo

useMemo estabiliza props (objetos/arrays) para React.memo funcionar.

### Rela√ß√£o com useEffect

useMemo pode ser dep de useEffect (evita re-execu√ß√£o desnecess√°ria).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Componente simples (sem otimiza√ß√£o)
    ‚Üì
Perfil identifica lentid√£o
    ‚Üì
useMemo para c√°lculos custosos
    ‚Üì
useCallback para fun√ß√µes
    ‚Üì
React.memo para componentes
```

---

## üìö Conclus√£o

useMemo √© hook de **otimiza√ß√£o** para memoizar valores. Princ√≠pios:

1. **Memoiza√ß√£o**: Cache de valores computados
2. **Depend√™ncias**: Recalcula quando deps mudam
3. **Trade-off**: Mem√≥ria vs CPU
4. **Use com modera√ß√£o**: Apenas quando necess√°rio
5. **Medi√ß√£o**: Profile antes de otimizar

**Recomenda√ß√µes:**
- S√≥ use se tiver problema de performance **medido**
- Combine com React.memo para evitar re-renders
- ESLint exhaustive-deps para validar deps
- N√£o memoize c√°lculos triviais
- C√≥digo deve funcionar sem useMemo (√© apenas otimiza√ß√£o)

**Dominar useMemo = otimizar performance de forma cir√∫rgica, n√£o prematura.**
