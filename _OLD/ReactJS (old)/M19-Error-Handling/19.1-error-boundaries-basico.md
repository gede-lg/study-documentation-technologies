# Error Boundaries B√°sico no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Error Boundaries** s√£o componentes React especiais que **capturam erros JavaScript** que ocorrem em qualquer lugar na **√°rvore de componentes filhos** durante renderiza√ß√£o, ciclo de vida, ou construtores, e exibem uma **UI de fallback** ao inv√©s de deixar toda aplica√ß√£o quebrar. Conceitualmente, funcionam como um **try/catch declarativo para componentes React** - criando "zonas de seguran√ßa" que isolam erros e previnem crash total da aplica√ß√£o.

Na ess√™ncia, Error Boundaries transformam **falhas catastr√≥ficas** (tela branca, aplica√ß√£o travada) em **degrada√ß√£o graciosa** (UI alternativa informativa, resto da aplica√ß√£o continua funcionando).

### Contexto Hist√≥rico e Motiva√ß√£o

Antes do React 16 (2017), um erro JavaScript em qualquer componente **quebrava toda aplica√ß√£o** - usu√°rio via tela branca sem feedback. N√£o havia forma nativa de capturar e recuperar de erros em componentes.

**Problemas pr√©-Error Boundaries**:

1. **Crash Total**: Erro em um bot√£o quebrava toda aplica√ß√£o
2. **Debugging Dif√≠cil**: Stack trace confuso, hard de identificar origem
3. **Experi√™ncia Ruim**: Usu√°rio via tela branca sem explica√ß√£o
4. **Sem Recupera√ß√£o**: Aplica√ß√£o ficava inutiliz√°vel at√© reload

**A solu√ß√£o React 16**: Error Boundaries - componentes que capturam erros e mostram fallback, isolando problemas.

### Problema Fundamental que Resolve

**1. Preven√ß√£o de Crash Total**:

```jsx
// ‚ùå Sem Error Boundary - erro quebra toda app
function App() {
  return (
    <div>
      <Header />
      <BuggyComponent /> {/* Erro aqui ‚Üí tela branca total */}
      <Footer />
    </div>
  );
}

// ‚úÖ Com Error Boundary - erro isolado
function App() {
  return (
    <div>
      <Header /> {/* Continua funcionando */}
      <ErrorBoundary fallback={<p>Algo deu errado aqui</p>}>
        <BuggyComponent /> {/* Erro isolado nesta se√ß√£o */}
      </ErrorBoundary>
      <Footer /> {/* Continua funcionando */}
    </div>
  );
}
```

**2. Feedback ao Usu√°rio**:

```jsx
// Sem Error Boundary: tela branca silenciosa
// Com Error Boundary: mensagem √∫til

<ErrorBoundary
  fallback={
    <div>
      <h2>Oops! Algo deu errado.</h2>
      <p>Estamos trabalhando para resolver o problema.</p>
      <button onClick={() => window.location.reload()}>
        Recarregar P√°gina
      </button>
    </div>
  }
>
  <MyComponent />
</ErrorBoundary>
```

**3. Error Reporting (Logging)**:

```jsx
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // Enviar erro para servi√ßo de monitoramento
    logErrorToService(error, errorInfo);
    // Sentry, LogRocket, etc.
  }

  render() {
    if (this.state.hasError) {
      return <FallbackUI />;
    }
    return this.props.children;
  }
}
```

### Import√¢ncia no Ecossistema

Error Boundaries s√£o **essenciais** para:

- **Aplica√ß√µes Production**: Prevenir tela branca em produ√ß√£o
- **UX Resiliente**: Degrada√ß√£o graciosa ao inv√©s de crash
- **Monitoramento**: Capturar e reportar erros para ferramentas (Sentry)
- **Debugging**: Stack traces estruturados, contexto de onde erro ocorreu
- **Confiabilidade**: Isolar bugs de terceiros (libs, APIs) do resto da app

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Componente de Classe Obrigat√≥rio**: Error Boundaries **devem** ser classes (n√£o podem ser funcionais)
2. **M√©todos Lifecycle Especiais**: `getDerivedStateFromError` e `componentDidCatch`
3. **Escopo de Captura**: Capturam erros de **componentes filhos** (n√£o de si mesmo)
4. **Fallback UI**: Renderizam UI alternativa quando erro √© capturado
5. **Granularidade**: Podem ter m√∫ltiplos boundaries em diferentes n√≠veis

### Pilares Fundamentais

- **getDerivedStateFromError(error)**: Atualiza estado para renderizar fallback (render phase)
- **componentDidCatch(error, errorInfo)**: Log de erros, side effects (commit phase)
- **Wrapping**: Envolver componentes que podem falhar
- **Fallback**: UI alternativa exibida em caso de erro
- **Isolamento**: Erro n√£o propaga al√©m do boundary

---

## üß† Fundamentos Te√≥ricos

### Como Error Boundaries Funcionam Internamente

**Processo interno**:

1. **Erro Ocorre**: Componente filho lan√ßa erro durante render/lifecycle
2. **Captura**: React propaga erro at√© encontrar Error Boundary mais pr√≥ximo
3. **getDerivedStateFromError**: Atualizado estado (hasError: true)
4. **Re-render**: Error Boundary re-renderiza com fallback UI
5. **componentDidCatch**: Chamado ap√≥s commit - log de erro

**Visualiza√ß√£o**:

```
√Årvore de componentes:

<App>
  <ErrorBoundary>       ‚Üê Captura erros aqui
    <ComponentA>
      <ComponentB>
        <BuggyComponent /> ‚Üê Erro lan√ßado aqui
      </ComponentB>
    </ComponentA>
  </ErrorBoundary>
</App>

Fluxo de erro:
1. BuggyComponent lan√ßa erro
2. Erro propaga: BuggyComponent ‚Üí ComponentB ‚Üí ComponentA
3. ErrorBoundary captura erro
4. getDerivedStateFromError ‚Üí hasError: true
5. Re-render com fallback
6. componentDidCatch ‚Üí log erro
```

### Por Que Componentes de Classe?

Error Boundaries **n√£o podem ser funcionais** porque:

1. **Lifecycle Methods**: `getDerivedStateFromError` e `componentDidCatch` s√£o exclusivos de classes
2. **Timing Preciso**: Necess√°rio controle sobre render phase (getDerivedStateFromError) e commit phase (componentDidCatch)
3. **Proposta de Hook**: N√£o h√° `useErrorBoundary` oficial (em discuss√£o para futuras vers√µes)

**Workaround**: Usar classe Error Boundary + componentes funcionais normalmente.

---

## üîç An√°lise Conceitual Profunda

### Sintaxe B√°sica

#### Error Boundary M√≠nimo

```jsx
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Atualiza estado para renderizar fallback
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log do erro
    console.error('Erro capturado:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Fallback UI
      return <h1>Algo deu errado.</h1>;
    }

    // Renderiza filhos normalmente
    return this.props.children;
  }
}
```

**An√°lise**:
- `getDerivedStateFromError`: M√©todo est√°tico que recebe erro e retorna novo estado
- `componentDidCatch`: Recebe erro e informa√ß√µes adicionais (componentStack)
- `hasError`: Flag de estado para controlar renderiza√ß√£o
- `this.props.children`: Componentes filhos wrappados

#### Uso B√°sico

```jsx
function App() {
  return (
    <div>
      <h1>Minha Aplica√ß√£o</h1>

      <ErrorBoundary>
        <MyWidget />
      </ErrorBoundary>

      <Footer />
    </div>
  );
}
```

**Conceito**: `MyWidget` e descendentes s√£o protegidos. Erro neles mostra fallback. `Footer` continua funcionando.

### getDerivedStateFromError vs componentDidCatch

#### getDerivedStateFromError

```jsx
static getDerivedStateFromError(error) {
  // Chamado durante render phase
  // APENAS atualizar estado - sem side effects!
  return { hasError: true, error };
}
```

**Caracter√≠sticas**:
- **Quando**: Durante render phase (antes de commit)
- **Prop√≥sito**: Atualizar estado para renderizar fallback
- **Restri√ß√µes**: N√£o fazer side effects (log, API calls)
- **Retorno**: Objeto para atualizar estado (ou null)

#### componentDidCatch

```jsx
componentDidCatch(error, errorInfo) {
  // Chamado durante commit phase
  // Side effects permitidos
  console.error('Erro:', error);
  console.error('Component Stack:', errorInfo.componentStack);

  // Enviar para servi√ßo de monitoramento
  logErrorToMyService(error, errorInfo);
}
```

**Caracter√≠sticas**:
- **Quando**: Ap√≥s commit phase (depois de DOM atualizado)
- **Prop√≥sito**: Side effects (log, analytics, reportar erro)
- **Par√¢metros**:
  - `error`: Erro lan√ßado
  - `errorInfo`: Objeto com `componentStack` (stack trace de componentes)

**Diferen√ßa Temporal**:

```
Erro lan√ßado
  ‚Üì
getDerivedStateFromError() ‚Üê Render phase (atualiza estado)
  ‚Üì
Re-render com fallback
  ‚Üì
Commit to DOM
  ‚Üì
componentDidCatch() ‚Üê Commit phase (side effects)
```

### Fallback UI Customiz√°vel

#### Fallback via Props

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // Renderiza fallback passado via prop
      return this.props.fallback || <h1>Erro</h1>;
    }

    return this.props.children;
  }
}

// Uso
<ErrorBoundary fallback={<CustomErrorUI />}>
  <MyComponent />
</ErrorBoundary>
```

#### Fallback com Informa√ß√µes do Erro

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h2>Oops! Algo deu errado</h2>
          <details>
            <summary>Detalhes do erro</summary>
            <pre>{this.state.error.toString()}</pre>
          </details>
          <button onClick={() => this.setState({ hasError: false })}>
            Tentar Novamente
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Error Reporting (Integra√ß√£o com Sentry)

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Integra√ß√£o com Sentry
    if (typeof Sentry !== 'undefined') {
      Sentry.withScope((scope) => {
        scope.setExtras(errorInfo);
        Sentry.captureException(error);
      });
    }

    // Ou integra√ß√£o customizada
    fetch('/api/log-error', {
      method: 'POST',
      body: JSON.stringify({
        error: error.toString(),
        componentStack: errorInfo.componentStack,
        timestamp: new Date().toISOString()
      })
    });
  }

  render() {
    if (this.state.hasError) {
      return <h1>Erro reportado. Estamos investigando.</h1>;
    }

    return this.props.children;
  }
}
```

### M√∫ltiplos Error Boundaries (Granularidade)

```jsx
function App() {
  return (
    <div>
      <Header />

      {/* Boundary para sidebar */}
      <ErrorBoundary fallback={<p>Sidebar indispon√≠vel</p>}>
        <Sidebar />
      </ErrorBoundary>

      {/* Boundary para conte√∫do principal */}
      <ErrorBoundary fallback={<p>Conte√∫do indispon√≠vel</p>}>
        <MainContent />
      </ErrorBoundary>

      {/* Boundary para coment√°rios */}
      <ErrorBoundary fallback={<p>Coment√°rios indispon√≠veis</p>}>
        <Comments />
      </ErrorBoundary>

      <Footer />
    </div>
  );
}
```

**Conceito**: Erro em `Sidebar` n√£o afeta `MainContent` ou `Comments`. Cada se√ß√£o protegida independentemente.

#### Boundary Aninhados

```jsx
<ErrorBoundary fallback={<p>App crash</p>}>
  <App>
    <ErrorBoundary fallback={<p>Se√ß√£o crash</p>}>
      <Section>
        <BuggyComponent />
      </Section>
    </ErrorBoundary>
  </App>
</ErrorBoundary>
```

**Comportamento**: Erro capturado pelo boundary **mais pr√≥ximo**. Se `Section` boundary capturar, boundary externo n√£o √© ativado.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Error Boundaries

#### 1. Prote√ß√£o de Se√ß√µes Cr√≠ticas

```jsx
function Dashboard() {
  return (
    <div>
      {/* Widgets podem falhar independentemente */}
      <ErrorBoundary fallback={<WidgetError />}>
        <SalesWidget />
      </ErrorBoundary>

      <ErrorBoundary fallback={<WidgetError />}>
        <AnalyticsWidget />
      </ErrorBoundary>

      <ErrorBoundary fallback={<WidgetError />}>
        <NotificationsWidget />
      </ErrorBoundary>
    </div>
  );
}
```

#### 2. Integra√ß√µes com Libs Terceiras

```jsx
// Biblioteca externa pode ter bugs
<ErrorBoundary fallback={<p>Mapa indispon√≠vel</p>}>
  <ThirdPartyMap apiKey={key} />
</ErrorBoundary>
```

#### 3. Rotas (com React Router)

```jsx
function App() {
  return (
    <Router>
      <Routes>
        <Route
          path="/"
          element={
            <ErrorBoundary fallback={<ErrorPage />}>
              <Home />
            </ErrorBoundary>
          }
        />
        <Route
          path="/dashboard"
          element={
            <ErrorBoundary fallback={<ErrorPage />}>
              <Dashboard />
            </ErrorBoundary>
          }
        />
      </Routes>
    </Router>
  );
}
```

### Quando N√ÉO Usar

Error Boundaries **n√£o capturam**:

1. **Event Handlers**: Erros em `onClick`, `onChange`, etc.
2. **C√≥digo Ass√≠ncrono**: `setTimeout`, `fetch`, Promises
3. **Server-Side Rendering**: Erros no servidor
4. **Pr√≥prio Error Boundary**: Erros no pr√≥prio componente boundary

**Exemplo do que N√ÉO √© capturado**:

```jsx
function Component() {
  const handleClick = () => {
    throw new Error('Click error'); // ‚ùå N√£o capturado!
  };

  useEffect(() => {
    setTimeout(() => {
      throw new Error('Timeout error'); // ‚ùå N√£o capturado!
    }, 1000);
  }, []);

  return <button onClick={handleClick}>Click</button>;
}
```

**Solu√ß√£o**: try/catch manual em event handlers e c√≥digo ass√≠ncrono.

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes dos Error Boundaries

#### 1. N√£o Captura Event Handlers

```jsx
// ‚ùå Erro em event handler n√£o √© capturado
function MyComponent() {
  const handleClick = () => {
    throw new Error('Boom!'); // N√£o capturado por Error Boundary
  };

  return <button onClick={handleClick}>Click</button>;
}

// ‚úÖ Solu√ß√£o: try/catch manual
function MyComponent() {
  const handleClick = () => {
    try {
      throw new Error('Boom!');
    } catch (error) {
      console.error('Erro capturado:', error);
      // Lidar com erro manualmente
    }
  };

  return <button onClick={handleClick}>Click</button>;
}
```

#### 2. N√£o Captura C√≥digo Ass√≠ncrono

```jsx
// ‚ùå N√£o capturado
useEffect(() => {
  fetch('/api/data')
    .then(res => res.json())
    .catch(error => {
      throw error; // N√£o capturado!
    });
}, []);

// ‚úÖ Solu√ß√£o: tratamento manual
useEffect(() => {
  fetch('/api/data')
    .then(res => res.json())
    .catch(error => {
      setError(error); // Guardar em estado
      console.error(error);
    });
}, []);
```

#### 3. Deve Ser Componente de Classe

```jsx
// ‚ùå N√£o funciona - componente funcional
function ErrorBoundary({ children }) {
  // N√£o h√° hook nativo para error boundaries
  return children;
}

// ‚úÖ Deve ser classe
class ErrorBoundary extends React.Component {
  // ...
}
```

**Workaround**: Usar biblioteca `react-error-boundary` (wrapper funcional sobre classe).

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Outros Conceitos

#### Error Boundaries + Suspense

```jsx
// Suspense para loading, Error Boundary para erros
<ErrorBoundary fallback={<ErrorUI />}>
  <Suspense fallback={<LoadingUI />}>
    <LazyComponent />
  </Suspense>
</ErrorBoundary>
```

**Conceito**: Suspense trata loading, Error Boundary trata erros - complementares.

#### Error Boundaries + React Router

```jsx
import { useRouteError } from 'react-router-dom';

// React Router v6.4+ tem error handling nativo
<Route
  path="/dashboard"
  element={<Dashboard />}
  errorElement={<ErrorPage />}
/>

// Componente de erro
function ErrorPage() {
  const error = useRouteError();
  return (
    <div>
      <h1>Erro!</h1>
      <p>{error.statusText || error.message}</p>
    </div>
  );
}
```

#### Error Boundaries + State Management

```jsx
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // Despachar a√ß√£o para store global
    store.dispatch({
      type: 'ERROR_OCCURRED',
      payload: { error, errorInfo }
    });
  }

  render() { /* ... */ }
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Error Boundaries B√°sico preparam para:

1. **Error Boundaries Avan√ßado** (19.2):
   - Estrat√©gias de granularidade
   - Reset mechanisms
   - Error recovery patterns

2. **Testing** (M√≥dulo 24):
   - Testar error boundaries
   - Simular erros em testes

3. **Monitoring** (M√≥dulo 31):
   - Integra√ß√£o com Sentry, LogRocket
   - Error tracking em produ√ß√£o

4. **Concurrent Features** (M√≥dulo 20):
   - Error boundaries com Suspense
   - Error handling em Server Components

### Padr√µes de Constru√ß√£o

Error Boundaries s√£o **base** para:
- Aplica√ß√µes resilientes (production-ready)
- Debugging estruturado (error reporting)
- UX graciosa (degrada√ß√£o controlada)
- Isolamento de falhas (microservices no frontend)

---

## üéØ Conclus√£o

Error Boundaries s√£o **essenciais para aplica√ß√µes production**:

**Conceito Central**: Try/catch declarativo para √°rvore de componentes React.

**Principais Benef√≠cios**:
- Previne crash total (tela branca)
- Fallback UI informativo
- Error reporting estruturado
- Isolamento de erros

**Limita√ß√µes**: N√£o capturam event handlers, c√≥digo ass√≠ncrono, ou erros no pr√≥prio boundary.

**Quando Usar**: Sempre em aplica√ß√µes production - no m√≠nimo um boundary global, idealmente m√∫ltiplos em se√ß√µes cr√≠ticas.

Error Boundaries transformam **falhas catastr√≥ficas em degrada√ß√£o graciosa** - essenciais para construir aplica√ß√µes React confi√°veis e resilientes que oferecem boa UX mesmo quando algo d√° errado.
