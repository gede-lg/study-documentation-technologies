# Error Boundaries Avan√ßado no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Error Boundaries Avan√ßado** refere-se a t√©cnicas sofisticadas de tratamento de erros que v√£o al√©m da captura b√°sica, incluindo **estrat√©gias de granularidade** (onde colocar boundaries), **mecanismos de reset/retry** (permitir usu√°rio recuperar de erros), **error recovery patterns** (re-tentativas autom√°ticas, fallbacks progressivos), e **tratamento de casos especiais** (erros em hooks, eventos, c√≥digo ass√≠ncrono que boundaries n√£o capturam). Conceitualmente, representa **arquitetura completa de resili√™ncia** - n√£o apenas capturar erros, mas orquestrar recupera√ß√£o inteligente e experi√™ncia de usu√°rio robusta mesmo em cen√°rios de falha complexos.

Na ess√™ncia, Error Boundaries Avan√ßado trata de transformar error handling de **reativo (apenas exibir fallback)** para **proativo e recuper√°vel** (permitir retry, degrada√ß√£o progressiva, isolamento cir√∫rgico de falhas).

### Contexto Hist√≥rico e Motiva√ß√£o

Error Boundaries b√°sicos (React 16) resolveram crash total, mas aplica√ß√µes production precisam de **mais**:

**Desafios que Error Boundaries Avan√ßado resolve**:

1. **Granularidade**: Onde colocar boundaries? Global? Por rota? Por componente?
2. **Recupera√ß√£o**: Como permitir usu√°rio re-tentar ap√≥s erro sem reload completo?
3. **Erros N√£o Capturados**: Event handlers, promises, hooks - boundaries n√£o capturam
4. **Estado Corrupto**: Erro pode deixar estado inconsistente - como resetar?
5. **UX Durante Erro**: Como comunicar erro de forma √∫til e permitir a√ß√£o?

**A evolu√ß√£o**: De captura passiva para **gerenciamento ativo de erros** - retry, reset, logging estrat√©gico, degrada√ß√£o progressiva.

### Problema Fundamental que Resolve

**1. Reset Mechanism (Recupera√ß√£o sem Reload)**:

```jsx
// ‚ùå B√°sico - sem forma de recuperar
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return <h1>Erro!</h1>; // Usu√°rio preso nesta tela
    }
    return this.props.children;
  }
}

// ‚úÖ Avan√ßado - retry/reset
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  resetError = () => {
    this.setState({ hasError: false }); // Reset!
  };

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Erro!</h1>
          <button onClick={this.resetError}>Tentar Novamente</button>
        </div>
      );
    }
    return this.props.children;
  }
}
```

**2. Granularidade Estrat√©gica**:

```jsx
// ‚ùå Boundary global - erro em widget quebra tudo
<ErrorBoundary>
  <Dashboard>
    <Widget1 /> {/* Erro aqui quebra dashboard inteiro */}
    <Widget2 />
    <Widget3 />
  </Dashboard>
</ErrorBoundary>

// ‚úÖ Boundaries granulares - isolamento
<Dashboard>
  <ErrorBoundary fallback={<WidgetError />}>
    <Widget1 /> {/* Erro isolado aqui */}
  </ErrorBoundary>

  <ErrorBoundary fallback={<WidgetError />}>
    <Widget2 /> {/* Outros widgets continuam funcionando */}
  </ErrorBoundary>

  <ErrorBoundary fallback={<WidgetError />}>
    <Widget3 />
  </ErrorBoundary>
</Dashboard>
```

**3. Tratamento de Erros N√£o Capturados (Hooks, Events)**:

```jsx
// Error Boundaries n√£o capturam event handlers
function Component() {
  const [error, setError] = useState(null);

  const handleClick = () => {
    try {
      throw new Error('Event error');
    } catch (err) {
      setError(err); // Captura manual
    }
  };

  if (error) {
    return <ErrorUI error={error} onReset={() => setError(null)} />;
  }

  return <button onClick={handleClick}>Click</button>;
}
```

### Import√¢ncia no Ecossistema

Error Boundaries Avan√ßado s√£o **cr√≠ticos** para:

- **Aplica√ß√µes Enterprise**: Requisitos de alta disponibilidade, UX robusta
- **Micro-frontends**: Isolamento de falhas entre times/m√≥dulos
- **Monitoramento Inteligente**: Reportar erros com contexto rico (user actions, estado)
- **Progressive Enhancement**: Degrada√ß√£o graciosa com funcionalidade reduzida
- **Developer Experience**: Debugging estruturado com stack traces completos

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Estrat√©gias de Granularidade**: Global, por rota, por feature, por componente
2. **Reset Mechanisms**: Reset state, reset key, retry logic
3. **Error Recovery**: Automatic retry, fallback progressivo, cache
4. **Limita√ß√µes e Workarounds**: Capturar erros que boundaries n√£o pegam
5. **Error Context**: Propagar informa√ß√µes de erro atrav√©s da √°rvore

### Pilares Fundamentais

- **Granularidade**: Quanto isolar (coarse-grained vs fine-grained)
- **Reset**: `resetErrorBoundary()`, `resetKeys` prop
- **Retry**: Re-tentativas autom√°ticas com backoff
- **Fallback Progressivo**: V√°rios n√≠veis de degrada√ß√£o
- **Error Metadata**: Contexto, user actions, timestamp

---

## üß† Fundamentos Te√≥ricos

### Estrat√©gias de Granularidade

**N√≠veis de prote√ß√£o**:

```
1. Global (App-level)
   ‚Üì
2. Rota-level (por p√°gina)
   ‚Üì
3. Feature-level (por se√ß√£o)
   ‚Üì
4. Component-level (por widget)
```

**Trade-offs**:

- **Coarse-grained (Global)**:
  - Menos boundaries, c√≥digo simples
  - Erro pequeno quebra muito

- **Fine-grained (Component-level)**:
  - Isolamento m√°ximo, UX resiliente
  - Mais c√≥digo, complexidade maior

**Decis√£o**: Balancear baseado em criticidade e independ√™ncia de componentes.

### Reset Mechanisms

**Conceito**: Permitir que usu√°rio/sistema recupere de erro sem reload completo.

**M√©todos**:

1. **Manual Reset**: Bot√£o "Tentar Novamente"
2. **Automatic Reset**: Resetar quando props/state mudam
3. **Key-based Reset**: Mudar `key` for√ßa remount
4. **Time-based Reset**: Reset ap√≥s X segundos

---

## üîç An√°lise Conceitual Profunda

### Granularidade Estrat√©gica

#### Padr√£o Global + Por Rota

```jsx
function App() {
  return (
    // Global - captura erros cr√≠ticos n√£o capturados
    <ErrorBoundary fallback={<CriticalErrorPage />}>
      <Router>
        <Routes>
          {/* Por rota - isolamento de p√°ginas */}
          <Route
            path="/"
            element={
              <ErrorBoundary fallback={<PageError />}>
                <Home />
              </ErrorBoundary>
            }
          />
          <Route
            path="/dashboard"
            element={
              <ErrorBoundary fallback={<PageError />}>
                <Dashboard />
              </ErrorBoundary>
            }
          />
        </Routes>
      </Router>
    </ErrorBoundary>
  );
}
```

**Conceito**: Dois n√≠veis - global para catch-all, por rota para isolamento de p√°ginas.

#### Padr√£o Granular (Feature-level)

```jsx
function Dashboard() {
  return (
    <div className="dashboard">
      <Header /> {/* Sem boundary - cr√≠tico */}

      {/* Boundaries independentes por feature */}
      <ErrorBoundary fallback={<WidgetError name="Analytics" />}>
        <AnalyticsWidget />
      </ErrorBoundary>

      <ErrorBoundary fallback={<WidgetError name="Sales" />}>
        <SalesWidget />
      </ErrorBoundary>

      <ErrorBoundary fallback={<WidgetError name="Notifications" />}>
        <NotificationsWidget />
      </ErrorBoundary>

      <Footer /> {/* Sem boundary - cr√≠tico */}
    </div>
  );
}
```

**Vantagem**: Erro em `AnalyticsWidget` n√£o afeta `SalesWidget` ou `NotificationsWidget`.

### Reset Mechanisms

#### Reset Manual com Bot√£o

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error:', error, errorInfo);
  }

  resetErrorBoundary = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h2>Algo deu errado</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={this.resetErrorBoundary}>
            Tentar Novamente
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**Conceito**: Usu√°rio clica "Tentar Novamente", boundary reseta estado e re-renderiza filhos.

#### Reset Autom√°tico com resetKeys

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidUpdate(prevProps) {
    // Reset quando resetKeys mudam
    if (
      this.state.hasError &&
      prevProps.resetKeys !== this.props.resetKeys
    ) {
      this.setState({ hasError: false });
    }
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }
}

// Uso
function Parent() {
  const [userId, setUserId] = useState(1);

  return (
    <ErrorBoundary
      resetKeys={[userId]} // Reset quando userId muda
      fallback={<ErrorUI />}
    >
      <UserProfile userId={userId} />
    </ErrorBoundary>
  );
}
```

**Conceito**: Boundary reseta automaticamente quando depend√™ncias (`resetKeys`) mudam.

#### Reset com Key Prop (Remount For√ßado)

```jsx
function Parent() {
  const [resetKey, setResetKey] = useState(0);

  const handleReset = () => {
    setResetKey(prev => prev + 1); // Mudar key for√ßa remount
  };

  return (
    <>
      <button onClick={handleReset}>Reset</button>

      <ErrorBoundary fallback={<ErrorUI onReset={handleReset} />}>
        <BuggyComponent key={resetKey} />
        {/* Key muda ‚Üí componente desmonta e monta novamente */}
      </ErrorBoundary>
    </>
  );
}
```

**Conceito**: Mudar `key` for√ßa React a desmontar e remontar componente - estado resetado.

### Error Recovery Patterns

#### Retry com Contador

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, errorCount: 0 };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidUpdate(prevProps, prevState) {
    // Se erro foi resetado, incrementar contador
    if (prevState.hasError && !this.state.hasError) {
      this.setState(state => ({ errorCount: state.errorCount + 1 }));
    }
  }

  resetErrorBoundary = () => {
    if (this.state.errorCount < 3) {
      // M√°ximo 3 tentativas
      this.setState({ hasError: false });
    }
  };

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>Erro (Tentativa {this.state.errorCount + 1}/3)</h2>
          {this.state.errorCount < 3 ? (
            <button onClick={this.resetErrorBoundary}>Retry</button>
          ) : (
            <p>M√°ximo de tentativas atingido. Recarregue a p√°gina.</p>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
```

**Conceito**: Limitar re-tentativas para evitar loop infinito de erros.

#### Fallback Progressivo

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false, errorCount: 0 };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.hasError && !this.state.hasError) {
      this.setState(s => ({ errorCount: s.errorCount + 1 }));
    }
  }

  resetErrorBoundary = () => {
    this.setState({ hasError: false });
  };

  render() {
    if (this.state.hasError) {
      const { errorCount } = this.state;

      // Fallbacks progressivos
      if (errorCount === 0) {
        return <MinimalFallback onRetry={this.resetErrorBoundary} />;
      } else if (errorCount === 1) {
        return <CachedDataFallback onRetry={this.resetErrorBoundary} />;
      } else {
        return <OfflineFallback />; // √öltima tentativa - modo offline
      }
    }

    return this.props.children;
  }
}
```

**Conceito**: Degrada√ß√£o progressiva - tentar vers√µes mais simples antes de desistir.

### Tratamento de Erros N√£o Capturados

#### Erros em Event Handlers

```jsx
function useErrorHandler() {
  const [error, setError] = useState(null);

  const handleError = useCallback((error) => {
    setError(error);
  }, []);

  const resetError = useCallback(() => {
    setError(null);
  }, []);

  return { error, handleError, resetError };
}

// Uso
function Component() {
  const { error, handleError, resetError } = useErrorHandler();

  const handleClick = () => {
    try {
      throw new Error('Click error');
    } catch (err) {
      handleError(err); // Captura manual
    }
  };

  if (error) {
    return (
      <div>
        <h2>Erro: {error.message}</h2>
        <button onClick={resetError}>Tentar Novamente</button>
      </div>
    );
  }

  return <button onClick={handleClick}>Click</button>;
}
```

#### Erros em Promises/Async

```jsx
function Component() {
  const [error, setError] = useState(null);
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('/api/data')
      .then(res => {
        if (!res.ok) throw new Error('Fetch failed');
        return res.json();
      })
      .then(setData)
      .catch(setError); // Captura erro ass√≠ncrono
  }, []);

  if (error) {
    return (
      <div>
        <h2>Erro ao carregar dados</h2>
        <button onClick={() => window.location.reload()}>
          Recarregar
        </button>
      </div>
    );
  }

  if (!data) return <Loading />;

  return <DataDisplay data={data} />;
}
```

#### Global Error Handler (Uncaught Errors)

```jsx
// Em index.js ou App.js
useEffect(() => {
  const handleError = (event) => {
    console.error('Uncaught error:', event.error);
    // Enviar para servi√ßo de monitoramento
    logErrorToService(event.error);
  };

  const handleRejection = (event) => {
    console.error('Unhandled rejection:', event.reason);
    logErrorToService(event.reason);
  };

  window.addEventListener('error', handleError);
  window.addEventListener('unhandledrejection', handleRejection);

  return () => {
    window.removeEventListener('error', handleError);
    window.removeEventListener('unhandledrejection', handleRejection);
  };
}, []);
```

### React-Error-Boundary (Biblioteca)

```jsx
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <p>Algo deu errado:</p>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Tentar novamente</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        // Reset app state
      }}
      resetKeys={[/* dependencies */]}
    >
      <MyApp />
    </ErrorBoundary>
  );
}
```

**Vantagens**:
- API funcional (n√£o precisa classe)
- Reset autom√°tico com `resetKeys`
- `onReset` callback para limpar estado
- `useErrorHandler` hook para erros manuais

#### useErrorHandler Hook

```jsx
import { useErrorHandler } from 'react-error-boundary';

function Component() {
  const handleError = useErrorHandler();

  const handleClick = async () => {
    try {
      await fetchData();
    } catch (error) {
      handleError(error); // Propaga para Error Boundary mais pr√≥ximo
    }
  };

  return <button onClick={handleClick}>Fetch</button>;
}
```

---

## üéØ Aplicabilidade e Contextos

### Estrat√©gias de Deployment

#### Aplica√ß√£o Pequena/M√©dia

```jsx
// 1 boundary global + boundaries por rota
<ErrorBoundary fallback={<CriticalError />}>
  <Router>
    <Routes>
      {routes.map(route => (
        <Route
          key={route.path}
          path={route.path}
          element={
            <ErrorBoundary fallback={<PageError />}>
              {route.element}
            </ErrorBoundary>
          }
        />
      ))}
    </Routes>
  </Router>
</ErrorBoundary>
```

#### Aplica√ß√£o Enterprise (Micro-frontends)

```jsx
// Boundaries em m√∫ltiplos n√≠veis
<ErrorBoundary name="global" fallback={<AppCrash />}>
  <App>
    <ErrorBoundary name="navigation" fallback={<NavError />}>
      <Navigation />
    </ErrorBoundary>

    <ErrorBoundary name="content" fallback={<ContentError />}>
      <Routes>
        <Route path="/sales" element={
          <ErrorBoundary name="sales-module" fallback={<ModuleError />}>
            <SalesModule /> {/* Time Sales */}
          </ErrorBoundary>
        } />
        <Route path="/analytics" element={
          <ErrorBoundary name="analytics-module" fallback={<ModuleError />}>
            <AnalyticsModule /> {/* Time Analytics */}
          </ErrorBoundary>
        } />
      </Routes>
    </ErrorBoundary>

    <ErrorBoundary name="sidebar" fallback={<SidebarError />}>
      <Sidebar />
    </ErrorBoundary>
  </App>
</ErrorBoundary>
```

**Conceito**: Cada m√≥dulo/time isolado - bug n√£o afeta outros times.

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Armadilhas Avan√ßadas

#### 1. Loop Infinito de Erros

```jsx
// ‚ùå Perigo - loop infinito se componente sempre falha
class ErrorBoundary extends React.Component {
  resetErrorBoundary = () => {
    this.setState({ hasError: false });
    // Se filho sempre lan√ßa erro ‚Üí loop infinito!
  };

  // ...
}

// ‚úÖ Solu√ß√£o - limitar tentativas
state = { hasError: false, retryCount: 0 };

resetErrorBoundary = () => {
  if (this.state.retryCount < 3) {
    this.setState(s => ({
      hasError: false,
      retryCount: s.retryCount + 1
    }));
  }
};
```

#### 2. Estado Corrupto ap√≥s Erro

```jsx
// Problema: erro pode deixar estado inconsistente
function BuggyComponent() {
  const [step, setStep] = useState(1);

  const proceed = () => {
    setStep(2);
    throw new Error('Boom!'); // Erro ap√≥s setStep
    // step = 2, mas processo n√£o completou
  };

  // Estado corrupto!
}

// Solu√ß√£o: resetar estado ao resetar boundary
<ErrorBoundary
  resetKeys={[key]}
  onReset={() => {
    // Resetar estado global/contexto
    resetAppState();
  }}
>
  <BuggyComponent key={key} /> {/* Key for√ßa remount */}
</ErrorBoundary>
```

#### 3. Erro em getDerivedStateFromError

```jsx
// ‚ùå Erro no pr√≥prio boundary n√£o √© capturado
static getDerivedStateFromError(error) {
  throw new Error('Erro no boundary!'); // N√£o capturado!
  return { hasError: true };
}

// Solu√ß√£o: boundary externo
<ErrorBoundary> {/* Captura erro do boundary interno */}
  <ErrorBoundary>
    <Component />
  </ErrorBoundary>
</ErrorBoundary>
```

---

## üîó Interconex√µes Conceituais

### Error Boundaries + Context API

```jsx
const ErrorContext = createContext();

function ErrorProvider({ children }) {
  const [errors, setErrors] = useState([]);

  const addError = (error) => {
    setErrors(prev => [...prev, { id: Date.now(), error }]);
  };

  return (
    <ErrorContext.Provider value={{ errors, addError }}>
      {children}
    </ErrorContext.Provider>
  );
}

// Boundary reporta erros ao contexto
class ErrorBoundary extends React.Component {
  componentDidCatch(error) {
    this.props.onError?.(error); // Callback para provider
  }

  // ...
}

// Uso
<ErrorProvider>
  <ErrorBoundary onError={addError}>
    <App />
  </ErrorBoundary>
  <ErrorToast /> {/* Mostra erros do contexto */}
</ErrorProvider>
```

### Error Boundaries + Suspense

```jsx
<ErrorBoundary fallback={<ErrorUI />}>
  <Suspense fallback={<Loading />}>
    <LazyComponent />
    {/* Erro ao carregar ‚Üí ErrorBoundary */}
    {/* Carregando ‚Üí Suspense */}
  </Suspense>
</ErrorBoundary>
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Error Boundaries Avan√ßado preparam para:

1. **Testing** (M√≥dulo 24):
   - Testar error boundaries
   - Simular erros, verificar fallback, testar reset

2. **Monitoring** (M√≥dulo 31):
   - Sentry integration avan√ßada
   - Error tracking com contexto
   - Performance monitoring

3. **Concurrent Features** (M√≥dulo 20):
   - Error handling com Suspense
   - Error boundaries em Server Components

4. **Architecture** (M√≥dulo 26):
   - Error handling architecture
   - Micro-frontends error isolation

---

## üéØ Conclus√£o

Error Boundaries Avan√ßado transformam error handling em **sistema robusto de resili√™ncia**:

**Conceitos Centrais**:
- Granularidade estrat√©gica (global ‚Üí component-level)
- Reset mechanisms (manual, autom√°tico, key-based)
- Error recovery (retry, fallback progressivo)
- Tratamento de limita√ß√µes (hooks, events, async)

**Principais Padr√µes**:
- M√∫ltiplos n√≠veis de boundaries
- Reset com limita√ß√£o de tentativas
- Degrada√ß√£o progressiva
- Global error handlers para uncaught errors

**Quando Usar**:
- Sempre em production (m√≠nimo global + por rota)
- Granular em features cr√≠ticas/independentes
- Reset em componentes recuper√°veis

**Benef√≠cios**:
- UX resiliente mesmo com erros
- Isolamento de falhas
- Debugging estruturado
- Monitoramento inteligente

Error Boundaries Avan√ßado elevam aplica√ß√µes React de **fr√°geis** para **resilientes** - essenciais para construir software production-ready que oferece experi√™ncia confi√°vel mesmo quando coisas d√£o errado.
