# Props B√°sico no React: Fundamentos de Comunica√ß√£o entre Componentes

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Props (abrevia√ß√£o de "properties") s√£o o **mecanismo fundamental de comunica√ß√£o** entre componentes React. Conceitualmente, props s√£o **argumentos passados para componentes**, an√°logos a par√¢metros de fun√ß√µes em JavaScript tradicional. Representam dados imut√°veis que fluem **unidirecionalmente** de componentes pais para componentes filhos, implementando o princ√≠pio de "one-way data binding".

Props s√£o a **interface p√∫blica** de um componente - definem que dados o componente aceita, como se comporta com diferentes inputs, e como pode ser customizado. S√£o objetos JavaScript que o React passa automaticamente como primeiro argumento para componentes funcionais ou ficam dispon√≠veis em `this.props` em componentes de classe.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o do conceito de Props:**

**2013 - Nascimento:** Quando React foi criado no Facebook, props foram inspirados em **atributos HTML** mas com superpoderes: podiam ser qualquer tipo JavaScript (n√£o apenas strings), incluindo fun√ß√µes, objetos, arrays, at√© outros componentes.

**Motiva√ß√£o original:**
React foi criado para resolver problemas de **sincroniza√ß√£o de estado** em interfaces complexas (Feed do Facebook). Props implementaram solu√ß√£o elegante:
- **Fluxo de dados previs√≠vel**: Dados fluem em uma dire√ß√£o (pai ‚Üí filho)
- **Componentes reativos**: Quando props mudam, componente re-renderiza automaticamente
- **Imutabilidade**: Props n√£o podem ser modificados pelo componente receptor, garantindo previsibilidade

**2015-2017: Refinamento**
Comunidade desenvolveu padr√µes:
- **PropTypes**: Valida√ß√£o de tipos (runtime)
- **defaultProps**: Valores padr√£o para props opcionais
- **Destructuring**: Sintaxe ES6 para extrair props elegantemente

**2018-hoje: Era Hooks e TypeScript**
- **TypeScript**: Valida√ß√£o de tipos em tempo de compila√ß√£o substituiu PropTypes
- **Hooks**: Mudaram como props s√£o usadas internamente, mas conceito permanece central
- **React.memo**: Otimiza√ß√£o baseada em compara√ß√£o de props

### Problema Fundamental que Resolve

**Sem props, componentes seriam ilhas isoladas:**

**Problema 1 - Reutiliza√ß√£o:**
Componente Button hardcoded com texto "Clique". Como criar bot√µes com textos diferentes? Duplicar componente? P√©ssimo.

**Problema 2 - Comunica√ß√£o:**
Componente Dashboard precisa passar dados para UserProfile. Como? Vari√°veis globais? State global sempre? Acoplamento inaceit√°vel.

**Problema 3 - Configura√ß√£o:**
Componente Card com estilos fixos. Como criar varia√ß√µes? Classes condicionais hardcoded? N√£o escala.

**Props resolve tudo isso:**

```javascript
// Reutiliza√ß√£o: Mesmo componente, textos diferentes
<Button text="Salvar" />
<Button text="Cancelar" />

// Comunica√ß√£o: Pai passa dados para filho
<Dashboard>
  <UserProfile user={userData} />
</Dashboard>

// Configura√ß√£o: Componente flex√≠vel
<Card variant="elevated" size="large" />
<Card variant="outlined" size="small" />
```

**Props implementa:**
1. **Parametriza√ß√£o**: Componentes como fun√ß√µes configur√°veis
2. **Composi√ß√£o**: Combinar componentes passando dados
3. **Encapsulamento**: Componente n√£o sabe de onde props v√™m
4. **Unidirecionalidade**: Fluxo de dados previs√≠vel

### Import√¢ncia no Ecossistema

Props s√£o **absolutamente fundamentais** no React:

- **Base da Arquitetura**: Todo React √© constru√≠do sobre props (e state)
- **Padr√£o Universal**: Toda biblioteca, framework, tutorial usa props
- **Composi√ß√£o**: Props permitem component composition, filosofia central do React
- **Performance**: React otimiza re-renders comparando props
- **Developer Experience**: API intuitiva (similar a HTML attributes)

**Cita√ß√£o relevante:**
> "Props are to React what parameters are to functions - they're how you customize behavior." - React Core Team

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Imutabilidade**: Props s√£o read-only no componente receptor
2. **Unidirecionalidade**: Dados fluem de pai para filho, nunca o contr√°rio
3. **Reatividade**: Mudan√ßas em props disparam re-render autom√°tico
4. **Tipagem**: Props podem ser qualquer tipo JavaScript
5. **Interface**: Props definem contrato p√∫blico do componente

### Pilares Fundamentais

- **Passagem**: Pai passa props como atributos JSX
- **Recep√ß√£o**: Filho recebe props como primeiro argumento (fun√ß√£o) ou `this.props` (classe)
- **Acesso**: Props s√£o objeto JavaScript com propriedades
- **Valida√ß√£o**: PropTypes ou TypeScript garantem tipos corretos
- **Defaults**: defaultProps define valores padr√£o

### Vis√£o Geral das Nuances

- **Props vs State**: Props s√£o externos (recebidos), state √© interno (gerenciado)
- **Destructuring**: Extrair props no par√¢metro vs no corpo da fun√ß√£o
- **Rest/Spread**: Capturar props restantes e repassar
- **Children**: Prop especial para conte√∫do entre tags
- **Callback Props**: Passar fun√ß√µes para comunica√ß√£o filho ‚Üí pai

---

## üß† Fundamentos Te√≥ricos

### Como Props Funcionam Internamente

#### Fluxo de Dados: Pai ‚Üí Filho

**Modelo mental:**

```
ComponentePai
    ‚Üì props (objeto)
ComponenteFilho
```

Quando voc√™ escreve JSX:

```javascript
<Button text="Salvar" variant="primary" />
```

React transforma isso em:

```javascript
React.createElement(Button, {
  text: "Salvar",
  variant: "primary"
})
```

O segundo argumento (objeto) √© o **props** que React passa para o componente.

#### Componente Funcional Recebe Props

```javascript
function Button(props) {
  // props = { text: "Salvar", variant: "primary" }
  console.log(props.text); // "Salvar"
  console.log(props.variant); // "primary"

  return <button>{props.text}</button>;
}
```

**Conceito crucial:** Props √© **objeto passado automaticamente pelo React**. Voc√™ n√£o chama `Button({ text: "Salvar" })` manualmente - React faz isso.

#### Imutabilidade de Props

Props s√£o **read-only**. Tentar modific√°-los viola princ√≠pio fundamental do React:

```javascript
function Button(props) {
  // ‚ùå NUNCA fa√ßa isso
  props.text = "Novo texto"; // TypeError em strict mode

  // ‚úÖ Props s√£o imut√°veis
  // Se precisa de valor derivado, use vari√°vel local
  const uppercaseText = props.text.toUpperCase();

  return <button>{uppercaseText}</button>;
}
```

**Por qu√™ imutabilidade?**

1. **Previsibilidade**: Componente n√£o pode afetar outros mudando props
2. **Otimiza√ß√£o**: React compara props para decidir se precisa re-renderizar
3. **Debugging**: Fluxo de dados unidirecional √© mais f√°cil de rastrear
4. **Funcional**: Componente como fun√ß√£o pura (mesmo input ‚Üí mesmo output)

#### Props e Re-rendering

Quando props mudam, React **automaticamente re-renderiza** o componente:

```javascript
// Pai
function App() {
  const [count, setCount] = useState(0);

  return <Counter value={count} />; // Quando count muda, Counter re-renderiza
}

// Filho
function Counter({ value }) {
  console.log('Counter renderizou com value:', value);
  return <div>{value}</div>;
}
```

**Fluxo:**
1. State `count` muda em `App`
2. `App` re-renderiza
3. JSX `<Counter value={count} />` √© executado com novo `count`
4. React v√™ que prop `value` mudou
5. `Counter` re-renderiza com novo `value`

### Princ√≠pios e Conceitos Subjacentes

#### 1. One-Way Data Flow (Fluxo Unidirecional)

**Conceito:** Dados fluem em uma dire√ß√£o: de componentes ancestrais para descendentes.

```
     App (state: user)
        ‚Üì props
    Dashboard (props: { user })
        ‚Üì props
    UserProfile (props: { user })
```

**Benef√≠cios:**
- **Previsibilidade**: F√°cil rastrear de onde dados v√™m
- **Debugging**: Seguir fluxo √© linear
- **Escalabilidade**: Adicionar componentes n√£o cria depend√™ncias circulares

**Contraste com Two-Way Binding (Angular 1.x):**
Em frameworks com two-way binding, mudan√ßas no filho afetam pai automaticamente. Parece conveniente mas cria "action at distance" - mudan√ßas em um lugar afetam outros implicitamente.

#### 2. Props como Interface de Componente

**Analogia:** Props s√£o como API de fun√ß√£o:

```javascript
// Fun√ß√£o
function soma(a, b) { // a, b s√£o "props"
  return a + b;
}

// Componente
function Button({ text, onClick }) { // text, onClick s√£o props
  return <button onClick={onClick}>{text}</button>;
}
```

**Implica√ß√µes:**
- **Contrato**: Props definem o que componente precisa
- **Documenta√ß√£o**: Props s√£o auto-documenta√ß√£o
- **Tipagem**: TypeScript/PropTypes formalizam contrato
- **Mudan√ßas**: Alterar props √© breaking change (como mudar assinatura de fun√ß√£o)

#### 3. Composi√ß√£o sobre Configura√ß√£o

**Filosofia React:** Preferir passar componentes como props ao inv√©s de configura√ß√µes complexas.

```javascript
// ‚ùå Configura√ß√£o (limitado)
<Button icon="save" iconPosition="left" />

// ‚úÖ Composi√ß√£o (flex√≠vel)
<Button icon={<SaveIcon />}>
  Salvar
</Button>
```

Props permitem passar **qualquer coisa** - n√£o apenas primitivos, mas componentes, elementos, fun√ß√µes.

---

## üîç An√°lise Conceitual Profunda

### 4.1.1 Conceito e Passagem de Props

#### Sintaxe de Passagem

Props s√£o passadas como **atributos no JSX**:

```javascript
// Tipos diferentes de props
<Component
  stringProp="texto simples"
  numberProp={42}
  booleanProp={true}
  arrayProp={[1, 2, 3]}
  objectProp={{ key: 'value' }}
  functionProp={() => console.log('clicked')}
  componentProp={<OtherComponent />}
  undefinedProp={undefined}
  nullProp={null}
/>
```

**Regras de sintaxe:**

1. **Strings**: Podem ser passadas sem chaves
```javascript
<Button text="Salvar" />        // ‚úÖ String literal
<Button text={'Salvar'} />      // ‚úÖ Tamb√©m funciona, mas desnecess√°rio
```

2. **Outros tipos**: Requerem chaves `{}`
```javascript
<Counter value={10} />           // ‚úÖ Number
<Toggle enabled={true} />        // ‚úÖ Boolean
<List items={[1, 2, 3]} />       // ‚úÖ Array
```

3. **Boolean shorthand**: Prop presente sem valor = `true`
```javascript
<Input required />               // Equivalente a required={true}
<Button disabled />              // Equivalente a disabled={true}
```

4. **Express√µes JavaScript**: Qualquer express√£o v√°lida
```javascript
<Component
  sum={10 + 5}                   // Express√£o aritm√©tica
  message={user ? user.name : 'Guest'}  // Tern√°rio
  items={data.filter(x => x.active)}    // Array method
  onClick={() => handleClick()}         // Arrow function
/>
```

#### Props em Componentes Aninhados

Props fluem atrav√©s de hierarquia de componentes:

```javascript
// N√≠vel 1
function App() {
  const user = { name: 'Maria', age: 25 };

  return <Dashboard user={user} />;
}

// N√≠vel 2
function Dashboard({ user }) {
  return (
    <div>
      <Header userName={user.name} />
      <Profile user={user} />
    </div>
  );
}

// N√≠vel 3
function Profile({ user }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.age} anos</p>
    </div>
  );
}
```

**An√°lise do fluxo:**
- `App` passa `user` completo para `Dashboard`
- `Dashboard` passa apenas `user.name` para `Header` (extrai o necess√°rio)
- `Dashboard` passa `user` completo para `Profile`
- Cada componente recebe apenas o que precisa

#### Props Impl√≠citas vs Expl√≠citas

```javascript
// Expl√≠cito (preferido - √≥bvio)
function Parent() {
  const data = fetchData();
  return <Child data={data} />;
}

function Child({ data }) {
  return <div>{data}</div>;
}

// Impl√≠cito (usar com cuidado)
function Parent() {
  return (
    <DataProvider>
      <Child />
    </DataProvider>
  );
}

function Child() {
  const data = useContext(DataContext); // Props "impl√≠citas" via Context
  return <div>{data}</div>;
}
```

**Trade-off:**
- **Expl√≠cito**: Mais verboso mas claro (props drilling vis√≠vel)
- **Impl√≠cito (Context)**: Menos verboso mas m√°gico (de onde vem o dado?)

---

### 4.1.2 Desestrutura√ß√£o de Props

#### Destructuring no Par√¢metro (Preferido)

**Sintaxe moderna e idiom√°tica:**

```javascript
// ‚úÖ Destructuring direto no par√¢metro
function UserCard({ name, age, email, avatar }) {
  return (
    <div className="user-card">
      <img src={avatar} alt={name} />
      <h2>{name}</h2>
      <p>{age} anos</p>
      <p>{email}</p>
    </div>
  );
}
```

**Vantagens:**
1. **Legibilidade**: Props usadas s√£o √≥bvias
2. **Menos digita√ß√£o**: `name` ao inv√©s de `props.name`
3. **Auto-documenta√ß√£o**: Lista de props esperadas √© clara
4. **IDE Support**: Autocomplete funciona melhor

#### Destructuring no Corpo

```javascript
// ‚ùå Menos idiom√°tico, mas funciona
function UserCard(props) {
  const { name, age, email, avatar } = props;

  return (
    <div className="user-card">
      <img src={avatar} alt={name} />
      <h2>{name}</h2>
      <p>{age} anos</p>
      <p>{email}</p>
    </div>
  );
}
```

**Quando usar:** Se precisa acessar `props` como objeto (raro).

#### Valores Padr√£o no Destructuring

**Sintaxe ES6 para defaults:**

```javascript
function Button({
  text = 'Clique',
  variant = 'primary',
  size = 'medium',
  disabled = false
}) {
  return (
    <button
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
    >
      {text}
    </button>
  );
}

// Uso
<Button />  // Usa todos os defaults
<Button text="Salvar" />  // text customizado, resto usa defaults
<Button text="Deletar" variant="danger" />  // M√∫ltiplos customizados
```

**Como funciona:**
- Se prop n√£o for passada (ou for `undefined`), usa valor padr√£o
- Se prop for `null`, `0`, `""`, `false`, **n√£o usa default** (s√£o valores v√°lidos)

```javascript
<Button text="" />  // text ser√° "" (string vazia), n√£o "Clique"
<Button disabled={false} />  // disabled ser√° false, n√£o true
```

#### Destructuring Aninhado

Props podem conter objetos aninhados:

```javascript
function UserCard({ user: { name, email }, isActive }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
      <span>{isActive ? 'Ativo' : 'Inativo'}</span>
    </div>
  );
}

// Uso
const user = { name: 'Jo√£o', email: 'joao@example.com' };
<UserCard user={user} isActive={true} />
```

**Cuidado:** Destructuring aninhado pode ser confuso. Alternativa:

```javascript
// Mais leg√≠vel
function UserCard({ user, isActive }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <span>{isActive ? 'Ativo' : 'Inativo'}</span>
    </div>
  );
}
```

#### Renomear Props no Destructuring

```javascript
function Component({ className: customClassName }) {
  // 'className' renomeado para 'customClassName'
  return <div className={customClassName}>Content</div>;
}
```

**Uso:** Evitar conflitos de nomes ou tornar mais descritivo.

---

### 4.1.3 Rest/Spread Operators com Props

#### Rest Operator: Capturar Props Restantes

**Sintaxe:** `...nomeVariavel` captura todas props n√£o explicitamente destructured.

```javascript
function CustomInput({ label, error, ...inputProps }) {
  // inputProps cont√©m todas as outras props
  return (
    <div className="input-wrapper">
      <label>{label}</label>
      <input {...inputProps} />  {/* Spread para repassar */}
      {error && <span className="error">{error}</span>}
    </div>
  );
}

// Uso
<CustomInput
  label="Email"
  error="Email inv√°lido"
  type="email"            // ‚Üê vai para inputProps
  placeholder="seu@email.com"  // ‚Üê vai para inputProps
  required                // ‚Üê vai para inputProps
  onChange={handleChange} // ‚Üê vai para inputProps
/>
```

**An√°lise:**
- `label` e `error` s√£o extra√≠dos explicitamente
- Tudo mais (`type`, `placeholder`, `required`, `onChange`) √© capturado em `inputProps`
- `{...inputProps}` expande esses props no `<input>`

**Resultado efetivo:**
```javascript
<input
  type="email"
  placeholder="seu@email.com"
  required={true}
  onChange={handleChange}
/>
```

#### Spread Operator: Repassar Props

**Conceito:** Expandir objeto de props em atributos individuais.

```javascript
const buttonProps = {
  type: 'submit',
  disabled: true,
  onClick: handleClick
};

// Sem spread (tedioso)
<button
  type={buttonProps.type}
  disabled={buttonProps.disabled}
  onClick={buttonProps.onClick}
>
  Submit
</button>

// Com spread (elegante)
<button {...buttonProps}>
  Submit
</button>
```

#### Combinar Rest e Spread (Padr√£o Proxy)

**Padr√£o:** Capturar props restantes e repassar para componente interno.

```javascript
function FancyButton({ icon, children, ...restProps }) {
  return (
    <button className="fancy-button" {...restProps}>
      {icon && <span className="icon">{icon}</span>}
      {children}
    </button>
  );
}

// Uso - todas props de button nativo funcionam
<FancyButton
  icon={<SaveIcon />}
  onClick={handleSave}
  disabled={isSaving}
  type="submit"
  aria-label="Salvar documento"
>
  Salvar
</FancyButton>
```

**Vantagens:**
- **Transpar√™ncia**: Componente wrapper n√£o precisa conhecer todas props poss√≠veis
- **Extensibilidade**: Se HTML adicionar novo atributo, componente j√° suporta
- **Menos c√≥digo**: N√£o precisa listar cada prop explicitamente

#### Ordem Importa: Override de Props

Quando usar spread, ordem determina preced√™ncia:

```javascript
function Button({ className, ...props }) {
  // Props ANTES de spread - podem ser sobrescritos
  return (
    <button className="btn" {...props}>
      Click
    </button>
  );
}

<Button className="custom" />
// Resultado: className="custom" (props.className sobrescreve "btn")

// Props DEPOIS de spread - sobrescrevem props vindas
function Button({ className, ...props }) {
  return (
    <button {...props} className="btn">
      Click
    </button>
  );
}

<Button className="custom" />
// Resultado: className="btn" ("btn" sobrescreve props.className)
```

**Merge manual (ambos presentes):**

```javascript
function Button({ className, ...props }) {
  return (
    <button {...props} className={`btn ${className || ''}`}>
      Click
    </button>
  );
}

<Button className="custom" />
// Resultado: className="btn custom" (ambos aplicados)
```

#### Props Spreading: Cuidados

**Problema: Passar props n√£o relacionadas**

```javascript
function Parent() {
  return <Child internalState={state} data={data} />;
}

function Child({ data, ...rest }) {
  // rest cont√©m internalState, que vaza para DOM
  return <div {...rest}>{data}</div>;
}

// HTML resultante:
<div internalstate="[object Object]">...</div>
// ‚ö†Ô∏è internalstate n√£o √© atributo HTML v√°lido
```

**Solu√ß√£o:** Seja expl√≠cito sobre quais props repassar, ou filtre:

```javascript
function Child({ data, internalState, ...domProps }) {
  // internalState usado internamente, n√£o repassado
  return <div {...domProps}>{data}</div>;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada T√©cnica

#### Props Simples (Acesso Direto)

**Use quando:** Componente pequeno, poucas props, clareza m√°xima.

```javascript
function Label(props) {
  return <label htmlFor={props.htmlFor}>{props.children}</label>;
}
```

#### Destructuring

**Use quando:** Componente usa m√∫ltiplas props, legibilidade importa (maioria dos casos).

```javascript
function UserProfile({ name, email, avatar, bio }) {
  // ...
}
```

#### Rest/Spread

**Use quando:** Componente wrapper que repassa props para elemento/componente interno.

```javascript
function CustomInput({ label, ...inputProps }) {
  return (
    <>
      <label>{label}</label>
      <input {...inputProps} />
    </>
  );
}
```

#### Valores Padr√£o

**Use quando:** Props opcionais t√™m valores sensatos padr√£o.

```javascript
function Button({ variant = 'primary', size = 'medium', children }) {
  // ...
}
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes Conceituais

#### 1. Props S√£o Imut√°veis

**Limita√ß√£o:** Componente n√£o pode modificar props recebidas.

```javascript
function Counter({ count }) {
  // ‚ùå Erro
  count = count + 1;

  // ‚úÖ Se precisa de valor derivado, use state
  const [internalCount, setInternalCount] = useState(count);
}
```

**Por qu√™:** Garantir fluxo unidirecional e previsibilidade.

#### 2. Props Drilling

**Problema:** Passar props por m√∫ltiplos n√≠veis intermedi√°rios que n√£o usam as props.

```javascript
function App() {
  const user = { name: 'Maria' };
  return <Page user={user} />;
}

function Page({ user }) {
  // Page n√£o usa user, apenas repassa
  return <Layout user={user} />;
}

function Layout({ user }) {
  // Layout n√£o usa user, apenas repassa
  return <Sidebar user={user} />;
}

function Sidebar({ user }) {
  // Finalmente usa
  return <div>{user.name}</div>;
}
```

**Solu√ß√µes:**
- **Context API**: Para dados globais ou muito profundos
- **Component Composition**: Passar componente ao inv√©s de dado
- **State Management**: Redux, Zustand para estado compartilhado

#### 3. Performance com Props Complexas

**Problema:** Passar objetos/arrays grandes ou criar fun√ß√µes inline.

```javascript
// ‚ùå Nova fun√ß√£o toda render
<Button onClick={() => handleClick(id)} />

// ‚ùå Novo objeto toda render
<Component style={{ color: 'red' }} />
```

**Solu√ß√£o:** Memoiza√ß√£o (useCallback, useMemo).

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com State

**Props vs State:**

| Aspecto | Props | State |
|---------|-------|-------|
| Origem | Externa (pai) | Interna (componente) |
| Mutabilidade | Imut√°vel | Mut√°vel (via setState) |
| Controle | Pai controla | Componente controla |
| Uso | Configurar componente | Guardar dados mut√°veis |

**Intera√ß√£o:** Props inicializam state, callbacks em props atualizam state do pai.

### Rela√ß√£o com Componentes

Props s√£o o mecanismo que permite **component composition** - combinar componentes pequenos em interfaces complexas.

### Rela√ß√£o com Virtual DOM

React compara props (shallow comparison) para decidir se componente precisa re-renderizar (reconciliation).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural de Aprendizado

```
Props B√°sico
    ‚Üì
Props Avan√ßado (children, callbacks)
    ‚Üì
PropTypes / TypeScript
    ‚Üì
Props Otimiza√ß√£o (React.memo, useCallback)
    ‚Üì
Padr√µes Avan√ßados (Render Props, HOCs)
```

### Props em Contextos Avan√ßados

- **Controlled Components**: Props controlam estado do filho
- **Render Props**: Passar fun√ß√£o como prop
- **Higher-Order Components**: Injetar props automaticamente
- **TypeScript**: Tipar props para seguran√ßa

---

## üìö Conclus√£o

Props s√£o **funda√ß√£o absoluta** do React. Princ√≠pios essenciais:

1. **Imutabilidade**: Props s√£o read-only
2. **Unidirecionalidade**: Fluxo pai ‚Üí filho
3. **Interface**: Props definem API do componente
4. **Reatividade**: Mudan√ßas em props ‚Üí re-render
5. **Flexibilidade**: Props podem ser qualquer tipo

**Recomenda√ß√µes:**
- Use destructuring para legibilidade
- Defina defaults para props opcionais
- Use rest/spread para componentes wrapper
- Documente props com TypeScript ou PropTypes
- Lembre: props s√£o argumentos, componentes s√£o fun√ß√µes

**Dominar props √© dominar comunica√ß√£o no React.** Todo padr√£o avan√ßado constr√≥i sobre esse fundamento. Props simples, mas poderosos - ess√™ncia da composi√ß√£o React.
