# Props Avan√ßado no React: Padr√µes e T√©cnicas Sofisticadas

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Props Avan√ßado refere-se a **padr√µes, t√©cnicas e conceitos sofisticados** no uso de props React que v√£o al√©m da passagem simples de dados. Engloba `props.children` como mecanismo de composi√ß√£o, uso de fun√ß√µes como props para comunica√ß√£o bidirecional (callbacks), valida√ß√£o robusta com PropTypes e TypeScript, e resolu√ß√£o do problema de "props drilling" atrav√©s de padr√µes arquiteturais. Representa o **dom√≠nio profundo** de como props podem ser usadas para criar APIs de componentes flex√≠veis, type-safe e manuten√≠vel.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos padr√µes avan√ßados de props:**

**2013-2015: Descoberta**
Comunidade React descobriu que `children` n√£o era apenas uma prop comum - era mecanismo poderoso de composi√ß√£o. Padr√£o "render props" emergiu como solu√ß√£o para reutiliza√ß√£o de l√≥gica.

**2015-2017: Formaliza√ß√£o**
- **PropTypes** (biblioteca externa, depois integrada ao React) trouxe valida√ß√£o runtime
- **defaultProps** tornou-se padr√£o oficial
- Padr√µes como "Function as Child" ganharam popularidade

**2017-2019: Maturidade e Desafios**
- **Props drilling** identificado como problema arquitetural
- Context API melhorada (React 16.3) como solu√ß√£o
- TypeScript ganhou tra√ß√£o, oferecendo valida√ß√£o compile-time superior

**2019-hoje: Era Moderna**
- **TypeScript dominante**: PropTypes considerados legados
- **Hooks**: Custom hooks substitu√≠ram render props em muitos casos
- **Props drilling**: Resolvido com Context, Zustand, Jotai
- **Patterns refinados**: Props getters, compound components

### Problema Fundamental que Resolve

**Problemas que props b√°sico n√£o resolve:**

**1. Composi√ß√£o Flex√≠vel:**
Como criar componente Card que aceita conte√∫do arbitr√°rio? Props espec√≠ficas (title, content, footer) limitam flexibilidade.

**2. Comunica√ß√£o Filho ‚Üí Pai:**
Props fluem pai ‚Üí filho. Como filho notifica pai sobre eventos? State lifting √© verboso.

**3. Props Incorretas:**
Usu√°rio passa `age="vinte"` (string) quando esperamos `age={20}` (number). Runtime error.

**4. Props Drilling:**
Passar prop por 5 n√≠veis de componentes que n√£o usam a prop. Verboso e fr√°gil.

**Props Avan√ßado resolve:**

- **Children**: Composi√ß√£o infinitamente flex√≠vel
- **Callbacks**: Comunica√ß√£o bidirecional elegante
- **PropTypes/TypeScript**: Valida√ß√£o e autocomplete
- **Context API**: Eliminar props drilling

### Import√¢ncia no Ecossistema

T√©cnicas avan√ßadas de props s√£o **distintivo de c√≥digo React profissional**:

- **Bibliotecas**: Todas usam children, callbacks, valida√ß√£o
- **Type Safety**: TypeScript com props √© padr√£o em empresas
- **Arquitetura**: Props drilling vs Context √© decis√£o arquitetural cr√≠tica
- **DX**: APIs bem projetadas (com children, defaults, valida√ß√£o) definem UX do desenvolvedor

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Children como Composi√ß√£o**: Prop especial para conte√∫do arbitr√°rio
2. **Callbacks para Comunica√ß√£o**: Fun√ß√µes como props permitem filho ‚Üí pai
3. **Valida√ß√£o de Contrato**: PropTypes/TypeScript garantem corre√ß√£o
4. **Props Drilling Problem**: Limita√ß√£o arquitetural de props
5. **Solu√ß√µes Alternativas**: Context, composition, state management

### Pilares Fundamentais

- **props.children**: Conte√∫do entre tags de abertura/fechamento
- **Callback Props**: Fun√ß√µes passadas para notificar eventos
- **defaultProps**: Valores padr√£o para props opcionais
- **PropTypes**: Valida√ß√£o runtime de tipos
- **TypeScript**: Valida√ß√£o compile-time, autocomplete, refatora√ß√£o

### Vis√£o Geral das Nuances

- **Children pode ser qualquer coisa**: String, elemento, array, fun√ß√£o, null
- **Callbacks devem ser est√°veis**: useCallback para evitar re-renders
- **PropTypes em desuso**: TypeScript √© preferido
- **Props drilling tem solu√ß√µes**: Context, composition, state management
- **Trade-offs**: Flexibilidade vs complexidade

---

## üß† Fundamentos Te√≥ricos

### Props.Children: Mecanismo de Composi√ß√£o

#### Conceito Fundamental

`children` √© **prop especial** automaticamente preenchida pelo React com conte√∫do entre tags JSX:

```javascript
<Card>
  <h1>T√≠tulo</h1>
  <p>Conte√∫do</p>
</Card>

// Card recebe:
// props.children = [<h1>T√≠tulo</h1>, <p>Conte√∫do</p>]
```

**Por que especial?**
- N√£o precisa ser explicitamente passada: `<Card children={...}>`
- Sintaxe natural (similar a HTML)
- Tipo polim√≥rfico (pode ser qualquer coisa)

#### Children e Composi√ß√£o

**Filosofia:** Componentes como "containers" que aceitam conte√∫do arbitr√°rio.

```javascript
// Container gen√©rico
function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

// Uso - flexibilidade infinita
<Card>
  <img src="photo.jpg" />
</Card>

<Card>
  <h2>T√≠tulo</h2>
  <p>Descri√ß√£o</p>
  <button>A√ß√£o</button>
</Card>

<Card>
  <ComplexComponent data={data} />
</Card>
```

**Contraste com props espec√≠ficas:**

```javascript
// ‚ùå R√≠gido
function Card({ title, description, actionButton }) {
  return (
    <div className="card">
      <h2>{title}</h2>
      <p>{description}</p>
      {actionButton}
    </div>
  );
}
// Limitado: E se quiser imagem? Lista? M√∫ltiplos bot√µes?

// ‚úÖ Flex√≠vel
function Card({ children }) {
  return <div className="card">{children}</div>;
}
// Aceita qualquer coisa
```

### Callbacks: Comunica√ß√£o Bidirecional

#### Conceito: Fun√ß√µes como Props

**Problema:** Props fluem pai ‚Üí filho. Como filho notifica pai?

**Solu√ß√£o:** Passar fun√ß√µes como props. Filho chama fun√ß√£o, pai recebe notifica√ß√£o.

```javascript
// Pai
function TodoApp() {
  const [todos, setTodos] = useState([]);

  // Fun√ß√£o que ser√° passada como prop
  const handleAddTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text }]);
  };

  return <TodoForm onSubmit={handleAddTodo} />;
}

// Filho
function TodoForm({ onSubmit }) {
  const [input, setInput] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(input); // Chama fun√ß√£o do pai
    setInput('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button>Add</button>
    </form>
  );
}
```

**Fluxo:**
1. Pai define fun√ß√£o `handleAddTodo`
2. Pai passa fun√ß√£o como prop `onSubmit`
3. Filho recebe `onSubmit`
4. Quando evento ocorre, filho chama `onSubmit(data)`
5. Fun√ß√£o do pai executa, atualizando state
6. Pai re-renderiza, passando novos dados para filho

**Conceito chave:** Dados descem (props), eventos sobem (callbacks).

---

## üîç An√°lise Conceitual Profunda

### 4.2.1 Props.children: Uso B√°sico e Avan√ßado

#### Tipos de Children

Children pode ser **qualquer tipo v√°lido React**:

```javascript
function Display({ children }) {
  console.log(children);
  return <div>{children}</div>;
}

// 1. String
<Display>Texto simples</Display>
// children = "Texto simples"

// 2. Number
<Display>{42}</Display>
// children = 42

// 3. Elemento React
<Display><span>Elemento</span></Display>
// children = React Element

// 4. Array de elementos
<Display>
  <p>Primeiro</p>
  <p>Segundo</p>
</Display>
// children = [Element, Element]

// 5. Null/Undefined (n√£o renderiza)
<Display>{null}</Display>
<Display>{undefined}</Display>
// children = null/undefined (React n√£o renderiza)

// 6. Boolean (n√£o renderiza)
<Display>{true}</Display>
<Display>{false}</Display>
// children = true/false (React n√£o renderiza)

// 7. Fun√ß√£o (Render Prop Pattern)
<Display>
  {() => <span>Conte√∫do din√¢mico</span>}
</Display>
// children = Function

// 8. Express√µes
<Display>
  {items.map(item => <li key={item.id}>{item.name}</li>)}
</Display>
// children = Array de elementos
```

#### Padr√£o: Layout Components

**Uso cl√°ssico:** Componentes que definem estrutura mas n√£o conte√∫do.

```javascript
function Page({ children }) {
  return (
    <div className="page">
      <Header />
      <main className="content">
        {children}
      </main>
      <Footer />
    </div>
  );
}

// Uso - conte√∫do varia, estrutura n√£o
<Page>
  <h1>Home</h1>
  <p>Bem-vindo</p>
</Page>

<Page>
  <DashboardContent />
</Page>
```

#### Children como Fun√ß√£o (Render Props)

**Padr√£o avan√ßado:** Children √© fun√ß√£o que recebe dados e retorna elementos.

```javascript
function DataProvider({ children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData().then(result => {
      setData(result);
      setLoading(false);
    });
  }, []);

  // Chama children como fun√ß√£o, passando dados
  return children({ data, loading });
}

// Uso - controle total sobre renderiza√ß√£o
<DataProvider>
  {({ data, loading }) => (
    loading ? <Spinner /> : <UserList users={data} />
  )}
</DataProvider>

// Diferentes UIs com mesma l√≥gica
<DataProvider>
  {({ data, loading }) => (
    loading ? (
      <p>Carregando...</p>
    ) : (
      <table>
        <tbody>
          {data.map(user => (
            <tr key={user.id}>
              <td>{user.name}</td>
            </tr>
          ))}
        </tbody>
      </table>
    )
  )}
</DataProvider>
```

**An√°lise:**
- **Invers√£o de controle**: Provider controla l√≥gica, consumidor controla UI
- **Flexibilidade**: Mesma l√≥gica, m√∫ltiplas UIs
- **Expl√≠cito**: √ìbvio que children recebe dados

**Trade-off:** Verbosidade vs flexibilidade.

#### Manipula√ß√£o de Children

**Problema:** Como iterar, modificar ou filtrar children?

**Solu√ß√£o:** `React.Children` API (coberto em m√≥dulo anterior, recapitulando):

```javascript
import { Children, isValidElement, cloneElement } from 'react';

function List({ children }) {
  // Mapear children com seguran√ßa
  const items = Children.map(children, (child, index) => (
    <li key={index} className="list-item">
      {child}
    </li>
  ));

  return <ul>{items}</ul>;
}

function DisabledForm({ children }) {
  // Clonar children injetando prop disabled
  const disabledChildren = Children.map(children, child => {
    if (isValidElement(child)) {
      return cloneElement(child, { disabled: true });
    }
    return child;
  });

  return <form>{disabledChildren}</form>;
}

// Uso
<DisabledForm>
  <input type="text" />
  <button>Submit</button>
</DisabledForm>
// Ambos renderizam com disabled={true}
```

---

### 4.2.2 Props como Callbacks

#### Nomenclatura de Callbacks

**Conven√ß√£o:** Callbacks come√ßam com `on` (eventos) ou `handle` (handlers internos).

```javascript
// Props (callbacks passados para filho) ‚Üí on*
<Button onClick={handleClick} />
<Form onSubmit={handleSubmit} />
<Input onChange={handleChange} />

// Handlers (fun√ß√µes internas) ‚Üí handle*
function Component() {
  const handleClick = () => { /* ... */ };
  const handleSubmit = (e) => { /* ... */ };

  return <button onClick={handleClick}>Click</button>;
}
```

**Raz√£o:** Clareza sobre dire√ß√£o do fluxo.

#### Passando Dados via Callbacks

**Padr√£o:** Callback recebe dados do filho.

```javascript
// Pai
function TodoApp() {
  const [todos, setTodos] = useState([]);

  const handleAddTodo = (todoText) => {
    const newTodo = { id: Date.now(), text: todoText };
    setTodos([...todos, newTodo]);
  };

  const handleDeleteTodo = (todoId) => {
    setTodos(todos.filter(t => t.id !== todoId));
  };

  return (
    <div>
      <TodoForm onAdd={handleAddTodo} />
      <TodoList todos={todos} onDelete={handleDeleteTodo} />
    </div>
  );
}

// Filho - Form
function TodoForm({ onAdd }) {
  const [input, setInput] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    onAdd(input); // Passa texto para pai
    setInput('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button>Add</button>
    </form>
  );
}

// Filho - Item
function TodoItem({ todo, onDelete }) {
  return (
    <li>
      {todo.text}
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </li>
  );
}
```

**An√°lise do fluxo:**
1. `TodoForm` chama `onAdd(input)` ‚Üí passa texto
2. `handleAddTodo` no pai recebe texto, cria todo, atualiza state
3. Pai re-renderiza com novos todos
4. `TodoList` renderiza com lista atualizada

#### Callbacks com Argumentos Extras

**Problema:** Handler precisa de argumento, mas evento sint√©tico tamb√©m.

```javascript
// ‚ùå N√£o funciona (event n√£o passado)
<button onClick={handleClick(itemId)}>Delete</button>
// handleClick √© chamado imediatamente durante render!

// ‚úÖ Solu√ß√£o 1: Arrow function inline
<button onClick={(e) => handleClick(itemId, e)}>Delete</button>

// ‚úÖ Solu√ß√£o 2: Currying
const handleClick = (id) => (event) => {
  console.log('Clicked item:', id);
  console.log('Event:', event);
};

<button onClick={handleClick(itemId)}>Delete</button>

// ‚úÖ Solu√ß√£o 3: Data attributes (se apenas ID)
<button data-id={itemId} onClick={handleClick}>Delete</button>

function handleClick(e) {
  const id = e.currentTarget.dataset.id;
  console.log('Clicked item:', id);
}
```

**Trade-offs:**
- **Arrow inline**: Simples mas cria nova fun√ß√£o cada render (performance)
- **Currying**: Elegante mas menos √≥bvio
- **Data attributes**: Perform√°tico mas limitado a strings

#### Callbacks e Performance

**Problema:** Passar callback inline cria nova fun√ß√£o cada render.

```javascript
// ‚ùå Nova fun√ß√£o toda render
<TodoItem onDelete={() => handleDelete(todo.id)} />

// TodoItem re-renderiza mesmo que todo n√£o mude
// (props.onDelete √© nova fun√ß√£o toda vez)
```

**Solu√ß√£o:** `useCallback` para estabilizar identidade.

```javascript
function TodoList({ todos }) {
  const handleDelete = useCallback((id) => {
    // L√≥gica de delete
  }, []); // Depend√™ncias

  return todos.map(todo => (
    <TodoItem
      key={todo.id}
      todo={todo}
      onDelete={() => handleDelete(todo.id)} // Ainda cria nova fun√ß√£o
    />
  ));
}

// Melhor: Passar ID via prop, callback est√°vel
function TodoList({ todos }) {
  const handleDelete = useCallback((id) => {
    // L√≥gica
  }, []);

  return todos.map(todo => (
    <TodoItem
      key={todo.id}
      todo={todo}
      todoId={todo.id}
      onDelete={handleDelete} // Mesma fun√ß√£o toda render
    />
  ));
}

function TodoItem({ todo, todoId, onDelete }) {
  return (
    <li>
      {todo.text}
      <button onClick={() => onDelete(todoId)}>Delete</button>
    </li>
  );
}
```

**Regra geral:** Se componente filho √© memoizado (`React.memo`), callbacks devem ser est√°veis.

---

### 4.2.3 Valida√ß√£o: DefaultProps e PropTypes

#### defaultProps: Valores Padr√£o

**Conceito:** Definir valores padr√£o para props opcionais.

**Sintaxe (React <18):**

```javascript
function Button({ text, variant, size }) {
  return (
    <button className={`btn btn-${variant} btn-${size}`}>
      {text}
    </button>
  );
}

Button.defaultProps = {
  text: 'Click',
  variant: 'primary',
  size: 'medium'
};

// Uso
<Button />  // Usa todos os defaults
<Button text="Save" />  // text custom, resto defaults
```

**Sintaxe moderna (preferida):**

```javascript
function Button({
  text = 'Click',
  variant = 'primary',
  size = 'medium'
}) {
  return (
    <button className={`btn btn-${variant} btn-${size}`}>
      {text}
    </button>
  );
}
```

**Vantagens de default parameters:**
- Mais moderno (ES6)
- Menos c√≥digo
- Funciona com TypeScript nativamente
- Performance ligeiramente melhor

**Quando defaultProps ainda √© √∫til:**
- Componentes de classe (default parameters n√£o funcionam em `this.props`)
- Bibliotecas que precisam introspe√ß√£o (ler defaults externamente)

#### PropTypes: Valida√ß√£o Runtime

**Conceito:** Validar tipos de props em desenvolvimento.

**Instala√ß√£o:**
```bash
npm install prop-types
```

**Uso b√°sico:**

```javascript
import PropTypes from 'prop-types';

function UserCard({ name, age, email, isActive }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{age} anos</p>
      <p>{email}</p>
      <span>{isActive ? 'Ativo' : 'Inativo'}</span>
    </div>
  );
}

UserCard.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number.isRequired,
  email: PropTypes.string,
  isActive: PropTypes.bool
};

UserCard.defaultProps = {
  isActive: false
};

// Uso incorreto (warnings no console em dev)
<UserCard name="Jo√£o" age="25" />  // ‚ö†Ô∏è age deveria ser number
<UserCard age={25} />  // ‚ö†Ô∏è name √© required
```

**Tipos dispon√≠veis:**

```javascript
import PropTypes from 'prop-types';

Component.propTypes = {
  // Tipos primitivos
  stringProp: PropTypes.string,
  numberProp: PropTypes.number,
  boolProp: PropTypes.bool,
  functionProp: PropTypes.func,
  arrayProp: PropTypes.array,
  objectProp: PropTypes.object,
  symbolProp: PropTypes.symbol,

  // Elemento React
  elementProp: PropTypes.element,

  // Inst√¢ncia de classe
  instanceProp: PropTypes.instanceOf(Date),

  // Enum
  enumProp: PropTypes.oneOf(['News', 'Photos']),

  // Union type
  unionProp: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number
  ]),

  // Array de tipo espec√≠fico
  arrayOfNumbersProp: PropTypes.arrayOf(PropTypes.number),

  // Objeto com shape espec√≠fica
  userProp: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
    email: PropTypes.string
  }),

  // Objeto com valores de tipo espec√≠fico
  dictionaryProp: PropTypes.objectOf(PropTypes.number),

  // Requerido
  requiredProp: PropTypes.string.isRequired,

  // Custom validator
  customProp: function(props, propName, componentName) {
    if (!/matchme/.test(props[propName])) {
      return new Error(
        `Invalid prop ${propName} in ${componentName}. Validation failed.`
      );
    }
  }
};
```

**An√°lise:**
- **Desenvolvimento**: Warnings √∫teis para catch erros
- **Produ√ß√£o**: PropTypes s√£o removidos (n√£o afetam bundle)
- **Performance**: Overhead neglig√≠vel em dev, zero em prod

**Limita√ß√µes de PropTypes:**
- **Runtime only**: Erros s√≥ aparecem quando c√≥digo executa
- **Sem autocomplete**: IDE n√£o sabe tipos
- **Sem refatora√ß√£o**: Renomear prop n√£o atualiza PropTypes automaticamente

**Status atual (2024):** PropTypes considerados **legados**. TypeScript √© preferido.

---

### 4.2.4 Comunica√ß√£o: Props como Callbacks (Aprofundamento)

#### Lifting State Up

**Conceito:** Quando m√∫ltiplos componentes precisam compartilhar estado, "eleve" estado para ancestral comum.

```javascript
// ‚ùå Problema: Estados duplicados e desincronizados
function TemperatureCelsius() {
  const [temp, setTemp] = useState(0);
  return <input value={temp} onChange={(e) => setTemp(e.target.value)} />;
}

function TemperatureFahrenheit() {
  const [temp, setTemp] = useState(32);
  return <input value={temp} onChange={(e) => setTemp(e.target.value)} />;
}

function App() {
  return (
    <>
      <TemperatureCelsius />
      <TemperatureFahrenheit />
    </>
  );
}
// Celsius e Fahrenheit n√£o sincronizam!

// ‚úÖ Solu√ß√£o: Lift state up
function TemperatureInput({ temperature, scale, onTemperatureChange }) {
  return (
    <fieldset>
      <legend>Temperatura em {scale}:</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
}

function App() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('c');

  const handleCelsiusChange = (temp) => {
    setTemperature(temp);
    setScale('c');
  };

  const handleFahrenheitChange = (temp) => {
    setTemperature(temp);
    setScale('f');
  };

  const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

  return (
    <div>
      <TemperatureInput
        scale="Celsius"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="Fahrenheit"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict celsius={parseFloat(celsius)} />
    </div>
  );
}
```

**Fluxo:**
1. Estado vive no `App` (ancestral comum)
2. Cada input recebe `temperature` (dados descendo) e `onTemperatureChange` (eventos subindo)
3. Quando input muda, chama callback ‚Üí atualiza estado no pai
4. Pai re-renderiza ambos inputs com valores sincronizados

---

### 4.2.5 Props Drilling

#### O Problema

**Conceito:** Passar props por m√∫ltiplos n√≠veis intermedi√°rios que n√£o usam as props.

```javascript
// N√≠vel 0
function App() {
  const user = { name: 'Maria', avatar: 'avatar.jpg' };
  return <Dashboard user={user} />;
}

// N√≠vel 1 (n√£o usa user, apenas repassa)
function Dashboard({ user }) {
  return (
    <div>
      <Sidebar user={user} />
    </div>
  );
}

// N√≠vel 2 (n√£o usa user, apenas repassa)
function Sidebar({ user }) {
  return <Navigation user={user} />;
}

// N√≠vel 3 (n√£o usa user, apenas repassa)
function Navigation({ user }) {
  return <UserMenu user={user} />;
}

// N√≠vel 4 (finalmente usa!)
function UserMenu({ user }) {
  return (
    <div>
      <img src={user.avatar} alt={user.name} />
      <span>{user.name}</span>
    </div>
  );
}
```

**Problemas:**
1. **Verbosidade**: Cada n√≠vel precisa aceitar e repassar prop
2. **Fragilidade**: Renomear `user` requer mudan√ßa em 5 lugares
3. **Acoplamento**: Componentes intermedi√°rios sabem sobre `user` mesmo sem usar
4. **Manuten√ß√£o**: Adicionar prop a UserMenu requer tocar 4 arquivos

#### Solu√ß√µes para Props Drilling

**Solu√ß√£o 1: Context API**

```javascript
import { createContext, useContext } from 'react';

// Criar contexto
const UserContext = createContext();

// N√≠vel 0
function App() {
  const user = { name: 'Maria', avatar: 'avatar.jpg' };

  return (
    <UserContext.Provider value={user}>
      <Dashboard />
    </UserContext.Provider>
  );
}

// N√≠veis intermedi√°rios (n√£o precisam saber de user)
function Dashboard() {
  return <Sidebar />;
}

function Sidebar() {
  return <Navigation />;
}

function Navigation() {
  return <UserMenu />;
}

// N√≠vel final (consome contexto diretamente)
function UserMenu() {
  const user = useContext(UserContext);

  return (
    <div>
      <img src={user.avatar} alt={user.name} />
      <span>{user.name}</span>
    </div>
  );
}
```

**Vantagens:**
- Componentes intermedi√°rios n√£o precisam saber de `user`
- Adicionar/remover props n√£o afeta intermedi√°rios
- M√∫ltiplos componentes podem consumir mesmo contexto

**Quando usar Context:**
- Dados globais (user, theme, language)
- Props atravessam >3 n√≠veis
- M√∫ltiplos componentes precisam dos mesmos dados

**Solu√ß√£o 2: Component Composition**

```javascript
// Ao inv√©s de passar dados, passar componentes
function App() {
  const user = { name: 'Maria', avatar: 'avatar.jpg' };

  return (
    <Dashboard
      sidebar={<Sidebar navigation={<Navigation userMenu={<UserMenu user={user} />} />} />}
    />
  );
}

// Componentes intermedi√°rios n√£o veem user
function Dashboard({ sidebar }) {
  return <div>{sidebar}</div>;
}

function Sidebar({ navigation }) {
  return <aside>{navigation}</aside>;
}

function Navigation({ userMenu }) {
  return <nav>{userMenu}</nav>;
}

function UserMenu({ user }) {
  return (
    <div>
      <img src={user.avatar} alt={user.name} />
      <span>{user.name}</span>
    </div>
  );
}
```

**Vantagens:**
- Invers√£o de controle
- Intermedi√°rios s√£o mais gen√©ricos

**Desvantagens:**
- JSX aninhado pode ser confuso
- N√£o funciona bem para dados din√¢micos

**Solu√ß√£o 3: State Management (Redux, Zustand)**

Para apps grandes, biblioteca de state management:

```javascript
// Store global
const useUserStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user })
}));

// Qualquer componente acessa diretamente
function UserMenu() {
  const user = useUserStore(state => state.user);
  return <div>{user.name}</div>;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada T√©cnica

#### Children
**Use quando:** Componente √© container gen√©rico (Card, Modal, Layout).

#### Callbacks
**Use quando:** Filho precisa notificar pai (eventos, formul√°rios).

#### PropTypes
**Use quando:** Projeto legado sem TypeScript, valida√ß√£o runtime necess√°ria.

#### TypeScript
**Use quando:** Projeto moderno, type safety √© priorit√°rio (maioria dos casos).

#### Context API
**Use quando:** Props drilling >3 n√≠veis, dados globais/compartilhados.

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Trade-offs

**Children:**
- ‚úÖ Flexibilidade m√°xima
- ‚ùå Tipo dif√≠cil de validar

**Callbacks:**
- ‚úÖ Comunica√ß√£o bidirecional
- ‚ùå Performance (se n√£o memoizados)

**PropTypes:**
- ‚úÖ Valida√ß√£o runtime
- ‚ùå Sem autocomplete, legado

**Context:**
- ‚úÖ Elimina props drilling
- ‚ùå Re-renders podem ser problem√°ticos

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Hooks
Custom hooks podem encapsular l√≥gica de callbacks e context.

### Rela√ß√£o com TypeScript
TypeScript substituiu PropTypes para valida√ß√£o.

### Rela√ß√£o com Performance
Callbacks e context impactam re-renders, requerem otimiza√ß√£o.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Props B√°sico
    ‚Üì
Props Avan√ßado (children, callbacks)
    ‚Üì
Context API (eliminar drilling)
    ‚Üì
State Management (Redux, Zustand)
```

### Tend√™ncias Futuras

- **TypeScript dominante**: PropTypes obsoletos
- **Server Components**: Props serializ√°veis apenas
- **Signals**: Alternativas reativas a props/state

---

## üìö Conclus√£o

Props Avan√ßado expande fundamentos para criar **APIs de componentes poderosas**. Li√ß√µes essenciais:

1. **Children**: Composi√ß√£o infinitamente flex√≠vel
2. **Callbacks**: Comunica√ß√£o elegante filho ‚Üí pai
3. **Valida√ß√£o**: TypeScript > PropTypes
4. **Props Drilling**: Solucion√°vel com Context/composition
5. **Trade-offs**: Flexibilidade vs complexidade

**Recomenda√ß√µes:**
- Use children extensivamente para composi√ß√£o
- Callbacks para eventos, memoize quando necess√°rio
- TypeScript para valida√ß√£o moderna
- Context para dados globais, n√£o abuse
- Prefira composi√ß√£o a props drilling

**Dominar props avan√ßado eleva c√≥digo React de funcional para profissional.** √â distin√ß√£o entre desenvolvedores juniores e seniores.
