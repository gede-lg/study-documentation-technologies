# Custom Hooks: Data & State

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Custom Hooks de Data & State** s√£o hooks especializados em **gerenciar dados** e **estado persistente** - buscar dados de APIs (useFetch, useApi), sincronizar com storage (useLocalStorage, useSessionStorage), rastrear valores anteriores (usePrevious), e controlar toggles (useToggle). Representam padr√µes consolidados de **gerenciamento de dados** que aparecem repetidamente em aplica√ß√µes React.

Esses hooks abstraem complexidades comuns: loading/error states em fetches, serializa√ß√£o JSON em storage, compara√ß√£o de valores anteriores, l√≥gica booleana. Transformam c√≥digo imperativo verbose em **API declarativa** - ao inv√©s de 20 linhas de useEffect + useState para fetch, voc√™ escreve `const { data, loading } = useFetch(url)`.

**Filosofia:** Cada hook resolve **um problema bem definido** de dados/estado. N√£o s√£o "mega-hooks" que fazem tudo, mas pe√ßas focadas que podem ser compostas.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos patterns de data/state:**

**2016-2018: Redux/MobX Everywhere**
At√© Redux/MobX para estado local simples:
```javascript
// Overkill para toggle
const mapStateToProps = state => ({ isOpen: state.modal.isOpen });
const mapDispatchToProps = { toggleModal };
connect(mapStateToProps, mapDispatchToProps)(Modal);
```

**2018-2019: Hooks + Pattern Discovery**
Comunidade descobriu patterns recorrentes:
- Data fetching sempre igual (loading/error/data)
- LocalStorage sempre precisa JSON.parse/stringify
- Toggle sempre tem mesma l√≥gica

**2019-2020: Bibliotecas de Hooks**
- **react-use**: 100+ hooks utilit√°rios
- **usehooks-ts**: Hooks TypeScript-first
- **ahooks**: Hooks empresariais

**2020-presente: Hooks Especializados**
- React Query/SWR: Data fetching profissional
- Custom hooks para casos espec√≠ficos da aplica√ß√£o

**Motiva√ß√£o:** Evitar reinventar roda. Patterns de data/state s√£o **commodities** - c√≥digo boilerplate que deve ser abstra√≠do.

### Problema Fundamental que Resolve

**Sem custom hooks de data/state:**

```javascript
// Fetch manual (verbose, repetitivo)
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const controller = new AbortController();
    setLoading(true);

    fetch(`/api/users/${userId}`, { signal: controller.signal })
      .then(res => {
        if (!res.ok) throw new Error('Fetch failed');
        return res.json();
      })
      .then(setUser)
      .catch(err => {
        if (err.name !== 'AbortError') setError(err);
      })
      .finally(() => setLoading(false));

    return () => controller.abort();
  }, [userId]);

  // LocalStorage manual
  const [theme, setTheme] = useState(() => {
    const stored = localStorage.getItem('theme');
    return stored ? JSON.parse(stored) : 'light';
  });

  useEffect(() => {
    localStorage.setItem('theme', JSON.stringify(theme));
  }, [theme]);

  // Toggle manual
  const [isOpen, setIsOpen] = useState(false);
  const toggle = () => setIsOpen(v => !v);
  const open = () => setIsOpen(true);
  const close = () => setIsOpen(false);

  // 50+ linhas s√≥ de boilerplate de data/state!
}
```

**Com custom hooks:**

```javascript
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [isOpen, toggle, open, close] = useToggle(false);

  // 3 linhas! L√≥gica encapsulada, c√≥digo limpo
}
```

### Import√¢ncia no Ecossistema

Hooks de data/state s√£o **essenciais** para:

- **Produtividade**: Evitar c√≥digo boilerplate
- **Consist√™ncia**: Mesma l√≥gica em toda app
- **Manutenibilidade**: Bug fix em um lugar
- **Testabilidade**: Testar hooks isoladamente

---

## üìã Sum√°rio Conceitual

### Hooks Cobertos

1. **useFetch / useApi**: Data fetching de APIs
2. **useLocalStorage**: Persistir estado em localStorage
3. **usePrevious**: Rastrear valor anterior
4. **useToggle**: Gerenciar estado booleano

### Aspectos Te√≥ricos Centrais

- **Abstra√ß√£o de patterns**: Encapsular l√≥gica repetitiva
- **API consistente**: Retornos previs√≠veis
- **Error handling**: Gerenciar falhas graciosamente
- **Performance**: Evitar re-fetches/re-computa√ß√µes
- **Type safety**: TypeScript para robustez

---

## üß† Fundamentos Te√≥ricos

### Pattern: Data Fetching

**Elementos comuns:**
- Estados: `data`, `loading`, `error`
- Cancelamento: AbortController
- Refetch: Fun√ß√£o manual
- Dependencies: URL muda ‚Üí re-fetch

**API t√≠pica:**
```javascript
const { data, loading, error, refetch } = useFetch(url, options);
```

### Pattern: Persistent State

**Elementos comuns:**
- Inicializa√ß√£o: Ler de storage
- Sincroniza√ß√£o: Escrever quando muda
- Serializa√ß√£o: JSON.parse/stringify
- SSR-safe: Checar `typeof window`

**API t√≠pica:**
```javascript
const [value, setValue] = useLocalStorage(key, initialValue);
```

### Pattern: State Tracking

**Elementos comuns:**
- Ref para valor anterior
- useEffect para atualizar ref
- Return valor anterior

**API t√≠pica:**
```javascript
const previousValue = usePrevious(currentValue);
```

---

## üîç An√°lise Conceitual Profunda

### 8.2.1 useFetch: Data Fetching Completo

```javascript
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // useRef para rastrear se fetch est√° mounted
  const isMountedRef = useRef(true);

  const fetchData = useCallback(async () => {
    // N√£o fetch se URL null/undefined
    if (!url) return;

    const controller = new AbortController();
    const { signal } = controller;

    setLoading(true);
    setError(null);

    try {
      const response = await fetch(url, { ...options, signal });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const json = await response.json();

      // Apenas atualizar state se mounted
      if (isMountedRef.current) {
        setData(json);
      }
    } catch (err) {
      if (err.name !== 'AbortError' && isMountedRef.current) {
        setError(err.message);
      }
    } finally {
      if (isMountedRef.current) {
        setLoading(false);
      }
    }

    return () => controller.abort();
  }, [url, options]);

  useEffect(() => {
    fetchData();

    return () => {
      isMountedRef.current = false;
    };
  }, [fetchData]);

  // Refetch manual
  const refetch = useCallback(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch };
}

// Uso
function UserList() {
  const { data, loading, error, refetch } = useFetch('/api/users');

  if (loading) return <Spinner />;
  if (error) return <Error message={error} onRetry={refetch} />;

  return (
    <div>
      <button onClick={refetch}>Atualizar</button>
      <ul>
        {data?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### Varia√ß√£o: useApi com M√©todos HTTP

```javascript
function useApi(baseUrl) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const request = useCallback(async (endpoint, options = {}) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`${baseUrl}${endpoint}`, options);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const json = await response.json();
      setData(json);
      return json;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [baseUrl]);

  const get = useCallback((endpoint) => {
    return request(endpoint, { method: 'GET' });
  }, [request]);

  const post = useCallback((endpoint, body) => {
    return request(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
  }, [request]);

  const put = useCallback((endpoint, body) => {
    return request(endpoint, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
  }, [request]);

  const del = useCallback((endpoint) => {
    return request(endpoint, { method: 'DELETE' });
  }, [request]);

  return { data, loading, error, get, post, put, delete: del };
}

// Uso
function UserManager() {
  const api = useApi('https://api.example.com');

  const handleCreate = async () => {
    try {
      await api.post('/users', { name: 'Ana', email: 'ana@example.com' });
      alert('Usu√°rio criado!');
    } catch (error) {
      alert('Erro ao criar usu√°rio');
    }
  };

  return <button onClick={handleCreate}>Criar Usu√°rio</button>;
}
```

### 8.2.2 useLocalStorage: Persist√™ncia Local

```javascript
function useLocalStorage(key, initialValue) {
  // State com lazy initialization (l√™ localStorage apenas no mount)
  const [storedValue, setStoredValue] = useState(() => {
    // SSR-safe: checar se window existe
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Erro ao ler localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Fun√ß√£o para atualizar state e localStorage
  const setValue = useCallback((value) => {
    try {
      // Permitir value ser fun√ß√£o (como setState)
      const valueToStore = value instanceof Function ? value(storedValue) : value;

      setStoredValue(valueToStore);

      // Salvar em localStorage
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Erro ao salvar localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  // Remover item do localStorage
  const removeValue = useCallback(() => {
    try {
      if (typeof window !== 'undefined') {
        window.localStorage.removeItem(key);
      }
      setStoredValue(initialValue);
    } catch (error) {
      console.error(`Erro ao remover localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  // Sincronizar entre tabs (storage event)
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleStorageChange = (e) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue));
        } catch (error) {
          console.error('Erro ao parsear storage event:', error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [key]);

  return [storedValue, setValue, removeValue];
}

// Uso: Theme preference
function ThemeToggle() {
  const [theme, setTheme, removeTheme] = useLocalStorage('theme', 'light');

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  const resetTheme = () => {
    removeTheme();
  };

  return (
    <div className={theme}>
      <p>Tema atual: {theme}</p>
      <button onClick={toggleTheme}>Alternar Tema</button>
      <button onClick={resetTheme}>Resetar Tema</button>
    </div>
  );
}

// Uso: Shopping Cart
function ShoppingCart() {
  const [cart, setCart] = useLocalStorage('cart', []);

  const addItem = (item) => {
    setCart(prevCart => [...prevCart, item]);
  };

  const removeItem = (itemId) => {
    setCart(prevCart => prevCart.filter(item => item.id !== itemId));
  };

  const clearCart = () => {
    setCart([]);
  };

  return (
    <div>
      <p>Itens no carrinho: {cart.length}</p>
      <button onClick={() => addItem({ id: Date.now(), name: 'Produto' })}>
        Adicionar Item
      </button>
      <button onClick={clearCart}>Limpar Carrinho</button>
    </div>
  );
}
```

#### Varia√ß√£o: useSessionStorage

```javascript
function useSessionStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.sessionStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Erro ao ler sessionStorage:', error);
      return initialValue;
    }
  });

  const setValue = useCallback((value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.sessionStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error('Erro ao salvar sessionStorage:', error);
    }
  }, [key, storedValue]);

  return [storedValue, setValue];
}

// Uso: Form tempor√°rio (perdido ao fechar tab)
function TemporaryForm() {
  const [formData, setFormData] = useSessionStorage('tempForm', {
    name: '',
    email: ''
  });

  return (
    <form>
      <input
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      <input
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
      />
    </form>
  );
}
```

### 8.2.3 usePrevious: Rastrear Valor Anterior

```javascript
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// Uso: Comparar valor atual com anterior
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Atual: {count}</p>
      <p>Anterior: {prevCount}</p>
      <p>
        {prevCount !== undefined && (
          count > prevCount ? 'Aumentou' : count < prevCount ? 'Diminuiu' : 'Igual'
        )}
      </p>
      <button onClick={() => setCount(count + 1)}>Incrementar</button>
      <button onClick={() => setCount(count - 1)}>Decrementar</button>
    </div>
  );
}

// Uso: Detectar mudan√ßa de prop
function UserProfile({ userId }) {
  const prevUserId = usePrevious(userId);

  useEffect(() => {
    if (userId !== prevUserId && prevUserId !== undefined) {
      console.log(`User mudou de ${prevUserId} para ${userId}`);
      // Fazer algo quando userId muda
    }
  }, [userId, prevUserId]);

  return <div>User ID: {userId}</div>;
}

// Uso: Anima√ß√£o baseada em mudan√ßa
function AnimatedValue({ value }) {
  const prevValue = usePrevious(value);
  const [animating, setAnimating] = useState(false);

  useEffect(() => {
    if (value !== prevValue && prevValue !== undefined) {
      setAnimating(true);
      const timer = setTimeout(() => setAnimating(false), 500);
      return () => clearTimeout(timer);
    }
  }, [value, prevValue]);

  return (
    <div className={animating ? 'animating' : ''}>
      {value}
    </div>
  );
}
```

### 8.2.4 useToggle: Estado Booleano

```javascript
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);

  const setTrue = useCallback(() => {
    setValue(true);
  }, []);

  const setFalse = useCallback(() => {
    setValue(false);
  }, []);

  return [value, toggle, setTrue, setFalse];
}

// Uso: Modal
function ModalExample() {
  const [isOpen, toggle, open, close] = useToggle(false);

  return (
    <div>
      <button onClick={open}>Abrir Modal</button>

      {isOpen && (
        <div className="modal">
          <div className="modal-content">
            <h2>Modal</h2>
            <p>Conte√∫do do modal</p>
            <button onClick={close}>Fechar</button>
          </div>
          <div className="modal-overlay" onClick={close} />
        </div>
      )}
    </div>
  );
}

// Uso: Sidebar
function Sidebar() {
  const [isExpanded, toggleExpanded] = useToggle(true);

  return (
    <aside className={isExpanded ? 'expanded' : 'collapsed'}>
      <button onClick={toggleExpanded}>
        {isExpanded ? '‚Üê' : '‚Üí'}
      </button>
      {isExpanded && (
        <nav>
          <a href="/home">Home</a>
          <a href="/about">Sobre</a>
        </nav>
      )}
    </aside>
  );
}

// Uso: Accordion
function AccordionItem({ title, children }) {
  const [isOpen, toggle] = useToggle(false);

  return (
    <div className="accordion-item">
      <button onClick={toggle} className="accordion-header">
        {title}
        <span>{isOpen ? '‚àí' : '+'}</span>
      </button>
      {isOpen && (
        <div className="accordion-content">
          {children}
        </div>
      )}
    </div>
  );
}
```

#### Varia√ß√£o: useBoolean (API alternativa)

```javascript
function useBoolean(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const actions = useMemo(() => ({
    toggle: () => setValue(v => !v),
    on: () => setValue(true),
    off: () => setValue(false),
    set: (newValue) => setValue(newValue)
  }), []);

  return [value, actions];
}

// Uso
function Example() {
  const [isLoading, loading] = useBoolean(false);

  const handleSubmit = async () => {
    loading.on();
    try {
      await api.submit();
    } finally {
      loading.off();
    }
  };

  return (
    <button onClick={handleSubmit} disabled={isLoading}>
      {isLoading ? 'Enviando...' : 'Enviar'}
    </button>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Hook

**useFetch/useApi:**
- Data fetching simples (n√£o cache/revalidation complexo)
- Prot√≥tipos r√°pidos
- Apps pequenas sem React Query/SWR

**useLocalStorage:**
- Prefer√™ncias do usu√°rio (tema, idioma)
- Carrinho de compras
- Formul√°rios parcialmente preenchidos
- Qualquer estado que deve persistir entre sess√µes

**usePrevious:**
- Comparar mudan√ßas de props/state
- Anima√ß√µes baseadas em transi√ß√µes
- Logs/debugging de mudan√ßas
- Detectar primeira render vs atualiza√ß√µes

**useToggle:**
- Modais, drawers, dropdowns (abrir/fechar)
- Toggles de feature flags
- Estados booleanos com m√∫ltiplas opera√ß√µes

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### useFetch vs React Query

**useFetch b√°sico:**
- ‚úÖ Simples, sem deps externas
- ‚ùå Sem cache, deduplica√ß√£o, revalidation
- ‚ùå Sem background refetch, stale-while-revalidate

**React Query:**
- ‚úÖ Cache autom√°tico, deduplica√ß√£o
- ‚úÖ Background refetch, mutations
- ‚ùå Biblioteca externa, curva aprendizado

**Regra:** useFetch para casos simples. React Query para apps complexas.

### localStorage Limitations

**Problemas:**
- Limite de ~5-10MB (varia por browser)
- S√≠ncrono (pode bloquear UI se objeto grande)
- Apenas strings (precisa JSON.stringify)
- Sem expira√ß√£o autom√°tica

**Alternativas:**
- IndexedDB: Grandes volumes, ass√≠ncrono
- SessionStorage: Tempor√°rio (limpa ao fechar tab)
- Cookies: Pequenos dados, enviados ao servidor

### usePrevious Edge Cases

**Primeira render:**
```javascript
const prevValue = usePrevious(value);
// prevValue √© undefined na primeira render
```

**Solu√ß√£o:**
```javascript
if (prevValue !== undefined) {
  // Apenas comparar ap√≥s primeira render
}
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com State Management

Custom hooks s√£o alternativa leve a Redux/MobX para estado local/persistente.

### Rela√ß√£o com React Query

useFetch √© vers√£o simplificada. React Query adiciona cache, mutations, etc.

### Rela√ß√£o com Refs

usePrevious usa useRef internamente (armazenar valor sem causar re-render).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Estado local (useState)
    ‚Üì
Persistir estado (useLocalStorage)
    ‚Üì
Data fetching (useFetch)
    ‚Üì
Cache profissional (React Query)
```

---

## üìö Conclus√£o

Custom Hooks de Data & State s√£o **ferramentas essenciais** para gerenciar dados. Princ√≠pios:

1. **useFetch**: Data fetching com loading/error
2. **useLocalStorage**: Persistir estado localmente
3. **usePrevious**: Rastrear valores anteriores
4. **useToggle**: Gerenciar booleanos

**Recomenda√ß√µes:**
- Use useFetch para data fetching simples (React Query para complexo)
- useLocalStorage para prefer√™ncias e carrinho
- usePrevious para compara√ß√µes e anima√ß√µes
- useToggle para estados booleanos com m√∫ltiplas opera√ß√µes
- Sempre handle errors graciosamente
- SSR-safe (checar typeof window)

**Dominar hooks de data/state = c√≥digo limpo, reutiliz√°vel e robusto.**
