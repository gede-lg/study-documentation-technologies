# Cria√ß√£o de Custom Hooks no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Custom Hooks** s√£o fun√ß√µes JavaScript que encapsulam **l√≥gica reutiliz√°vel com state** usando hooks nativos do React. Conceitualmente, s√£o "receitas" de comportamento que podem ser compartilhadas entre componentes - extrair padr√µes recorrentes (data fetching, subscriptions, form logic) em fun√ß√µes compostas de hooks primitivos (useState, useEffect, etc.), promovendo **DRY** (Don't Repeat Yourself) e separa√ß√£o de concerns.

Diferente de componentes (retornam JSX), custom hooks retornam **dados e fun√ß√µes** - state, callbacks, valores computados. S√£o a forma React de **composi√ß√£o de l√≥gica**: ao inv√©s de heran√ßa ou HOCs (Higher-Order Components), voc√™ comp√µe comportamento chamando m√∫ltiplos hooks. Transformam c√≥digo imperativo espalhado em API declarativa reutiliz√°vel.

**Met√°fora:** Se hooks nativos s√£o "ingredientes" (useState, useEffect), custom hooks s√£o "receitas prontas" - voc√™ combina ingredientes base em pratos espec√≠ficos (useFetch, useLocalStorage) que podem ser servidos em qualquer "restaurante" (componente).

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o da reutiliza√ß√£o de l√≥gica:**

**2013-2016: Mixins (Classes - Legado)**
```javascript
const TimerMixin = {
  componentDidMount() { /* timer logic */ }
};

const Component = React.createClass({
  mixins: [TimerMixin]
});
```

**Problema:** Conflito de nomes, depend√™ncias impl√≠citas, dif√≠cil rastrear origem.

**2016-2018: Higher-Order Components (HOCs)**
```javascript
const withTimer = (Component) => {
  return class extends React.Component {
    // timer logic
    render() { return <Component {...this.props} {...state} />; }
  };
};
```

**Problema:** "Wrapper hell", props naming conflicts, dificulta refatora√ß√£o.

**2018-2019: Render Props**
```javascript
<Timer render={(time) => <Display time={time} />} />
```

**Problema:** Aninhamento excessivo, menos leg√≠vel.

**2019-presente: Custom Hooks (Solu√ß√£o Definitiva)**
```javascript
function Component() {
  const time = useTimer(); // Simples, claro, compon√≠vel
  return <Display time={time} />;
}
```

**Vantagens:**
- Sem wrapper hell (sem HOCs aninhados)
- Sem conflitos de props
- Composi√ß√£o clara (m√∫ltiplos hooks em sequ√™ncia)
- Test√°vel isoladamente
- TypeScript-friendly

**Filosofia:** "Hooks are about reusing stateful logic, not state itself" - cada componente que usa hook tem **state independente**.

### Problema Fundamental que Resolve

**Sem Custom Hooks:**

**Problema 1 - Duplica√ß√£o de l√≥gica:**
```javascript
// ComponentA.js
function ComponentA() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/users')
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  return <div>...</div>;
}

// ComponentB.js
function ComponentB() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/posts')
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  return <div>...</div>;
}

// Problema: L√≥gica duplicada (fetch + loading/error states)
```

**Problema 2 - Componente "gordo":**
```javascript
function Dashboard() {
  // 50 linhas de fetch logic
  // 30 linhas de form logic
  // 40 linhas de subscription logic
  // 20 linhas de animation logic
  // Total: 140 linhas, dif√≠cil manter
}
```

**Com Custom Hooks:**

```javascript
// useFetch.js
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);

  return { data, loading, error };
}

// ComponentA.js
function ComponentA() {
  const { data, loading, error } = useFetch('/api/users');
  if (loading) return <Spinner />;
  if (error) return <Error />;
  return <div>{data.map(...)}</div>;
}

// ComponentB.js
function ComponentB() {
  const { data, loading, error } = useFetch('/api/posts');
  if (loading) return <Spinner />;
  if (error) return <Error />;
  return <div>{data.map(...)}</div>;
}

// Vantagens:
// ‚úì L√≥gica centralizada (DRY)
// ‚úì Componentes limpos (apenas UI)
// ‚úì Test√°vel isoladamente
// ‚úì F√°cil adicionar features (retry, cache)
```

### Import√¢ncia no Ecossistema

Custom Hooks s√£o **fundamentais** para:

- **Reutiliza√ß√£o**: Compartilhar l√≥gica entre componentes
- **Separa√ß√£o de concerns**: UI (componente) vs l√≥gica (hook)
- **Testabilidade**: Testar l√≥gica sem renderizar componente
- **Manutenibilidade**: Centralizar comportamento
- **Ecossistema**: Bibliotecas populares (react-use, usehooks-ts)

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Encapsula√ß√£o**: Agrupar l√≥gica relacionada
2. **Composi√ß√£o**: Combinar hooks primitivos
3. **Reutiliza√ß√£o**: Compartilhar entre componentes
4. **Abstra√ß√£o**: Esconder complexidade
5. **Conven√ß√£o**: Nome come√ßa com `use`

### Pilares Fundamentais

- **Naming convention**: `use` prefix (obrigat√≥rio)
- **Composi√ß√£o de hooks**: Usa hooks nativos internamente
- **Return values**: Retorna dados/fun√ß√µes (n√£o JSX)
- **Regras dos Hooks**: Seguem mesmas regras
- **State independente**: Cada chamada tem state pr√≥prio

### Vis√£o Geral das Nuances

- **N√£o s√£o componentes**: N√£o retornam JSX
- **State isolado**: Cada uso tem instance separada
- **Testabilidade**: `@testing-library/react-hooks`
- **TypeScript**: Tipagem de retorno
- **Performance**: Mesmas considera√ß√µes de hooks nativos

---

## üß† Fundamentos Te√≥ricos

### Regras dos Custom Hooks

**1. Nome deve come√ßar com `use`:**
```javascript
// ‚úÖ Correto
function useFetch() { }
function useLocalStorage() { }
function useDebounce() { }

// ‚ùå Errado (ESLint avisa)
function fetchData() { } // N√£o come√ßa com 'use'
function getData() { }
```

**Por qu√™?** React/ESLint identifica hooks pelo prefixo `use` para enfor√ßar regras.

**2. S√≥ pode chamar hooks no top-level:**
```javascript
function useCustom() {
  // ‚úÖ Top-level
  const [state, setState] = useState(0);

  // ‚ùå Condicional
  if (condition) {
    const [other, setOther] = useState(0); // ERRO!
  }

  // ‚úÖ useEffect OK (√© hook)
  useEffect(() => {
    // ‚ùå Hook dentro de callback
    const [x, setX] = useState(0); // ERRO!
  }, []);
}
```

**3. S√≥ pode chamar de componentes ou custom hooks:**
```javascript
// ‚úÖ De componente
function Component() {
  const value = useCustom();
}

// ‚úÖ De outro custom hook
function useOther() {
  const value = useCustom();
}

// ‚ùå De fun√ß√£o regular
function regularFunction() {
  const value = useCustom(); // ERRO!
}
```

### Anatomia de um Custom Hook

**Estrutura b√°sica:**
```javascript
function useCustomHook(initialValue) {
  // 1. State (se necess√°rio)
  const [state, setState] = useState(initialValue);

  // 2. Efeitos colaterais (se necess√°rio)
  useEffect(() => {
    // logic
  }, [dependencies]);

  // 3. Fun√ß√µes auxiliares
  const helper = () => {
    // logic
  };

  // 4. Retornar API p√∫blica
  return { state, helper };
}
```

### Return Patterns

**1. Objeto (mais comum):**
```javascript
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  return { data, loading }; // Desestrutura√ß√£o nomeada
}

// Uso
const { data, loading } = useFetch('/api');
```

**2. Array (quando ordem importa):**
```javascript
function useToggle(initial = false) {
  const [value, setValue] = useState(initial);
  const toggle = () => setValue(v => !v);

  return [value, toggle]; // Array (como useState)
}

// Uso
const [isOpen, toggleOpen] = useToggle(false);
```

**3. Valor √∫nico:**
```javascript
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width; // Apenas o valor
}

// Uso
const width = useWindowWidth();
```

**4. Fun√ß√£o:**
```javascript
function useDebounce() {
  const timeoutRef = useRef(null);

  return useCallback((fn, delay) => {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(fn, delay);
  }, []);
}

// Uso
const debounce = useDebounce();
debounce(() => console.log('hi'), 500);
```

---

## üîç An√°lise Conceitual Profunda

### 8.1.1 Custom Hook B√°sico: useToggle

```javascript
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);

  const setTrue = useCallback(() => {
    setValue(true);
  }, []);

  const setFalse = useCallback(() => {
    setValue(false);
  }, []);

  return [value, toggle, setTrue, setFalse];
}

// Uso
function Modal() {
  const [isOpen, toggle, open, close] = useToggle(false);

  return (
    <>
      <button onClick={open}>Abrir Modal</button>
      {isOpen && (
        <div className="modal">
          <p>Conte√∫do</p>
          <button onClick={close}>Fechar</button>
        </div>
      )}
    </>
  );
}
```

### 8.1.2 Custom Hook Intermedi√°rio: useFetch

```javascript
function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    // AbortController para cancelamento
    const controller = new AbortController();
    const signal = controller.signal;

    const fetchData = async () => {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(url, { ...options, signal });

        if (!response.ok) {
          throw new Error(`HTTP error: ${response.status}`);
        }

        const json = await response.json();
        setData(json);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchData();

    // Cleanup: cancelar fetch
    return () => controller.abort();
  }, [url]); // Re-fetch quando URL muda

  // Fun√ß√£o para refetch manual
  const refetch = useCallback(() => {
    setData(null);
    setError(null);
  }, []);

  return { data, loading, error, refetch };
}

// Uso
function UserProfile({ userId }) {
  const { data, loading, error, refetch } = useFetch(`/api/users/${userId}`);

  if (loading) return <Spinner />;
  if (error) return <Error message={error} onRetry={refetch} />;
  if (!data) return null;

  return <div>{data.name}</div>;
}
```

### 8.1.3 Custom Hook Avan√ßado: useLocalStorage

```javascript
function useLocalStorage(key, initialValue) {
  // State para armazenar valor
  // Lazy initialization: apenas ler localStorage no mount
  const [storedValue, setStoredValue] = useState(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Erro ao ler localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Fun√ß√£o para atualizar state e localStorage
  const setValue = useCallback((value) => {
    try {
      // Permitir value ser fun√ß√£o (como useState)
      const valueToStore = value instanceof Function ? value(storedValue) : value;

      setStoredValue(valueToStore);

      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Erro ao salvar localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  // Sincronizar entre tabs (storage event)
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === key && e.newValue) {
        setStoredValue(JSON.parse(e.newValue));
      }
    };

    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [key]);

  return [storedValue, setValue];
}

// Uso
function ThemeToggle() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return (
    <button onClick={toggleTheme}>
      Tema atual: {theme}
    </button>
  );
}
```

### 8.1.4 Composi√ß√£o de Custom Hooks

**Custom hook usando outros custom hooks:**

```javascript
// Hook base: useDebounce
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// Hook composto: useSearchUsers (usa useDebounce + useFetch)
function useSearchUsers(query) {
  const debouncedQuery = useDebounce(query, 500); // Usa hook customizado

  const { data, loading, error } = useFetch(
    debouncedQuery ? `/api/users/search?q=${debouncedQuery}` : null
  );

  return { users: data, loading, error };
}

// Uso no componente
function UserSearch() {
  const [query, setQuery] = useState('');
  const { users, loading } = useSearchUsers(query);

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      {loading && <Spinner />}
      <ul>
        {users?.map(user => <li key={user.id}>{user.name}</li>)}
      </ul>
    </div>
  );
}
```

### 8.1.5 Custom Hook com Callback Parameter

```javascript
function useEventListener(eventName, handler, element = window) {
  // Ref para armazenar handler (evitar remover/adicionar listener toda vez)
  const savedHandler = useRef(handler);

  // Atualizar ref quando handler muda
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    // Handler wrapper que chama vers√£o atual
    const eventListener = (event) => savedHandler.current(event);

    element.addEventListener(eventName, eventListener);

    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// Uso
function Component() {
  const handleKeyPress = (e) => {
    if (e.key === 'Escape') {
      console.log('ESC pressionado');
    }
  };

  useEventListener('keydown', handleKeyPress);

  return <div>Pressione ESC</div>;
}
```

### 8.1.6 Custom Hook com Cleanup Complexo

```javascript
function useWebSocket(url) {
  const [data, setData] = useState(null);
  const [status, setStatus] = useState('disconnected'); // disconnected | connecting | connected
  const wsRef = useRef(null);

  useEffect(() => {
    setStatus('connecting');

    // Criar WebSocket
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => {
      setStatus('connected');
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setData(message);
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      setStatus('disconnected');
    };

    ws.onclose = () => {
      setStatus('disconnected');
    };

    // Cleanup: fechar WebSocket
    return () => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
    };
  }, [url]);

  // Fun√ß√£o para enviar mensagens
  const sendMessage = useCallback((message) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    }
  }, []);

  return { data, status, sendMessage };
}

// Uso
function Chat() {
  const { data, status, sendMessage } = useWebSocket('wss://chat.example.com');

  const handleSend = () => {
    sendMessage({ text: 'Hello!' });
  };

  return (
    <div>
      <p>Status: {status}</p>
      <p>Mensagem: {data?.text}</p>
      <button onClick={handleSend} disabled={status !== 'connected'}>
        Enviar
      </button>
    </div>
  );
}
```

### 8.1.7 Testing Custom Hooks

**Com @testing-library/react-hooks (ou renderHook do RTL):**

```javascript
// useCounter.js
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  const decrement = useCallback(() => {
    setCount(c => c - 1);
  }, []);

  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);

  return { count, increment, decrement, reset };
}

// useCounter.test.js
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  test('deve inicializar com valor padr√£o', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  test('deve inicializar com valor customizado', () => {
    const { result } = renderHook(() => useCounter(10));
    expect(result.current.count).toBe(10);
  });

  test('deve incrementar', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  test('deve decrementar', () => {
    const { result } = renderHook(() => useCounter(5));

    act(() => {
      result.current.decrement();
    });

    expect(result.current.count).toBe(4);
  });

  test('deve resetar', () => {
    const { result } = renderHook(() => useCounter(10));

    act(() => {
      result.current.increment();
      result.current.increment();
    });

    expect(result.current.count).toBe(12);

    act(() => {
      result.current.reset();
    });

    expect(result.current.count).toBe(10);
  });
});
```

---

## üéØ Aplicabilidade e Contextos

### Quando Criar Custom Hook

‚úÖ **Crie custom hook quando:**
- L√≥gica √© reutilizada em 2+ componentes
- Componente fica muito complexo (extrair l√≥gica)
- Quer testar l√≥gica isoladamente
- Padr√£o comum (fetch, localStorage, subscription)

‚ùå **N√ÉO crie custom hook se:**
- Usado apenas uma vez (YAGNI - You Ain't Gonna Need It)
- L√≥gica √© trivial (ex: useState simples)
- Abstra√ß√£o prematura

### Naming Conventions

```javascript
// ‚úÖ Bom: descritivo, come√ßa com 'use'
useFetch
useLocalStorage
useWindowSize
useDebounce
useAuth

// ‚ùå Ruim: gen√©rico demais
useData
useValue
useStuff
```

### Organiza√ß√£o de Arquivos

```
src/
  hooks/
    useAuth.js
    useFetch.js
    useLocalStorage.js
    useDebounce.js
    index.js  // Barrel export
```

**Barrel export (index.js):**
```javascript
export { useAuth } from './useAuth';
export { useFetch } from './useFetch';
export { useLocalStorage } from './useLocalStorage';
export { useDebounce } from './useDebounce';
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### State √â Independente

**Cada chamada do hook tem state pr√≥prio:**

```javascript
function Component() {
  const counter1 = useCounter(0); // State independente
  const counter2 = useCounter(0); // Outro state independente

  // counter1 e counter2 N√ÉO compartilham estado
  counter1.increment(); // Afeta apenas counter1
}
```

Se precisa compartilhar state: use Context ou state lifting.

### Performance

**Custom hooks seguem mesmas regras de performance:**

```javascript
// ‚ùå Recria objeto toda render
function useData() {
  return { value: 1, label: 'One' }; // Novo objeto
}

// ‚úÖ Memoize se necess√°rio
function useData() {
  return useMemo(() => ({ value: 1, label: 'One' }), []);
}
```

### TypeScript

**Tipagem de custom hooks:**

```javascript
// TypeScript
function useFetch<T>(url: string): {
  data: T | null;
  loading: boolean;
  error: string | null;
} {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // ... logic

  return { data, loading, error };
}

// Uso com tipo
interface User {
  id: number;
  name: string;
}

const { data } = useFetch<User>('/api/user');
// data √© User | null
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Hooks Nativos

Custom hooks comp√µem hooks nativos (useState, useEffect, etc).

### Rela√ß√£o com Componentes

Componentes usam custom hooks para l√≥gica, retornam JSX para UI.

### Rela√ß√£o com HOCs/Render Props

Custom hooks substituem HOCs e Render Props (mais simples, sem wrapper hell).

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Hooks nativos (useState, useEffect)
    ‚Üì
Extrair l√≥gica duplicada
    ‚Üì
Criar custom hook simples
    ‚Üì
Compor m√∫ltiplos custom hooks
    ‚Üì
Biblioteca de hooks (ecossistema)
```

---

## üìö Conclus√£o

Custom Hooks s√£o **ferramenta essencial** para reutiliza√ß√£o de l√≥gica. Princ√≠pios:

1. **Conven√ß√£o**: Nome come√ßa com `use`
2. **Composi√ß√£o**: Combina hooks nativos
3. **Reutiliza√ß√£o**: Compartilha entre componentes
4. **Separa√ß√£o**: L√≥gica (hook) vs UI (componente)
5. **Testabilidade**: Teste isolado de l√≥gica

**Recomenda√ß√µes:**
- Extraia l√≥gica duplicada em custom hooks
- Nome descritivo (use + a√ß√£o)
- Retorne objeto ou array consistente
- Teste hooks isoladamente
- Documente par√¢metros e retorno

**Dominar custom hooks = escrever c√≥digo React limpo, reutiliz√°vel e test√°vel.**
