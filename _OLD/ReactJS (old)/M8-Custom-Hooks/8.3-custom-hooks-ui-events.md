# Custom Hooks: UI & Events

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Custom Hooks de UI & Events** s√£o hooks especializados em **intera√ß√µes do usu√°rio** e **responsividade da interface** - debouncing de inputs (useDebounce), detec√ß√£o de cliques fora (useClickOutside), event listeners gen√©ricos (useEventListener), media queries responsivas (useMediaQuery), e observa√ß√£o de visibilidade (useIntersectionObserver). Representam padr√µes de **UX e interatividade** que aparecem em aplica√ß√µes modernas.

Esses hooks encapsulam complexidades de eventos DOM, throttling/debouncing, queries de m√≠dia, e APIs de observa√ß√£o. Transformam c√≥digo imperativo de addEventListener/removeEventListener em **APIs declarativas** - ao inv√©s de gerenciar listeners manualmente, voc√™ escreve `useEventListener('keydown', handler)`.

**Filosofia:** UI & Events s√£o **ponte entre React e browser** - hooks que fazem React "conversar" com APIs nativas (DOM Events, Media Queries, Intersection Observer) de forma idiom√°tica.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos patterns de UI/Events:**

**2013-2016: jQuery Era**
```javascript
$(window).on('resize', debounce(handleResize, 300));
$(document).on('click', '.outside', handleClickOutside);
```

**2016-2018: React Classes + Lifecycle**
```javascript
class Component extends React.Component {
  componentDidMount() {
    window.addEventListener('resize', this.handleResize);
    document.addEventListener('click', this.handleClickOutside);
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
    document.removeEventListener('click', this.handleClickOutside);
  }
}
```

**Problema:** L√≥gica de eventos espalhada (mount/unmount), dif√≠cil reutilizar.

**2018-presente: Hooks**
```javascript
function Component() {
  useEventListener('resize', handleResize);
  useClickOutside(ref, handleClickOutside);
  // Cleanup autom√°tico, reutiliz√°vel
}
```

**Motiva√ß√£o:** Encapsular patterns comuns de eventos/UI que antes requeriam classes ou libs externas (jQuery, lodash debounce).

### Problema Fundamental que Resolve

**Sem custom hooks de UI/Events:**

```javascript
function SearchInput() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  const dropdownRef = useRef(null);

  // Debounce manual
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);

    return () => clearTimeout(timer);
  }, [query]);

  // Click outside manual
  useEffect(() => {
    const handleClick = (e) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        // Close dropdown
      }
    };

    document.addEventListener('click', handleClick);
    return () => document.removeEventListener('click', handleClick);
  }, []);

  // Media query manual
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const query = window.matchMedia('(max-width: 768px)');
    setIsMobile(query.matches);

    const handleChange = (e) => setIsMobile(e.matches);
    query.addListener(handleChange);

    return () => query.removeListener(handleChange);
  }, []);

  // Intersection Observer manual
  const [isVisible, setIsVisible] = useState(false);
  const targetRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      setIsVisible(entry.isIntersecting);
    });

    if (targetRef.current) {
      observer.observe(targetRef.current);
    }

    return () => observer.disconnect();
  }, []);

  // 80+ linhas de boilerplate!
}
```

**Com custom hooks:**

```javascript
function SearchInput() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);
  const dropdownRef = useClickOutside(() => {/* close dropdown */});
  const isMobile = useMediaQuery('(max-width: 768px)');
  const [targetRef, isVisible] = useIntersectionObserver();

  // 5 linhas! Limpo, leg√≠vel
}
```

### Import√¢ncia no Ecossistema

Hooks de UI/Events s√£o **essenciais** para:

- **UX moderna**: Debounce, click outside, responsive
- **Performance**: Evitar renderiza√ß√µes excessivas
- **Acessibilidade**: Keyboard events, focus management
- **Lazy loading**: Intersection Observer para imagens/conte√∫do

---

## üìã Sum√°rio Conceitual

### Hooks Cobertos

1. **useDebounce**: Atrasar atualiza√ß√µes de valores
2. **useClickOutside**: Detectar cliques fora de elemento
3. **useEventListener**: Event listeners gen√©ricos
4. **useMediaQuery**: Media queries responsivas
5. **useIntersectionObserver**: Observar visibilidade de elementos

### Aspectos Te√≥ricos Centrais

- **Cleanup**: Remover listeners automaticamente
- **Performance**: Throttle/debounce para otimizar
- **Browser APIs**: Integrar nativamente (DOM, Media Queries, IO)
- **Responsiveness**: Adaptar UI a diferentes contextos
- **Type safety**: TypeScript para eventos

---

## üß† Fundamentos Te√≥ricos

### Pattern: Debouncing

**Conceito:** Atrasar execu√ß√£o at√© input "estabilizar".

```
Input r√°pido:
a ‚Üí ab ‚Üí abc ‚Üí abcd
‚Üì    ‚Üì    ‚Üì     ‚Üì
Timer reset cada vez
           ‚Üì (500ms depois)
       Executa "abcd"
```

**Quando usar:** Search inputs, resize handlers, scroll handlers.

### Pattern: Click Outside

**Conceito:** Detectar cliques fora de elemento espec√≠fico.

**Uso comum:** Fechar dropdowns, modais, tooltips.

### Pattern: Event Listener

**Conceito:** Abstrair addEventListener + removeEventListener.

**Vantagens:** Cleanup autom√°tico, handler sempre atualizado.

### Pattern: Media Query

**Conceito:** Reagir a mudan√ßas de viewport/m√≠dia.

**Uso comum:** Layouts responsivos, detec√ß√£o de dispositivo.

### Pattern: Intersection Observer

**Conceito:** Observar quando elemento entra/sai do viewport.

**Uso comum:** Lazy loading, infinite scroll, anima√ß√µes on-view.

---

## üîç An√°lise Conceitual Profunda

### 8.3.1 useDebounce: Atrasar Valores

```javascript
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // Criar timer para atualizar valor ap√≥s delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup: cancelar timer se value mudar antes de delay
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Uso: Search com debounce
function SearchBox() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);

  // Buscar apenas quando debouncedQuery muda
  const { data, loading } = useFetch(
    debouncedQuery ? `/api/search?q=${debouncedQuery}` : null
  );

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Buscar..."
      />
      {loading && <Spinner />}
      <ul>
        {data?.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

// Uso: Auto-save de formul√°rio
function AutoSaveForm() {
  const [formData, setFormData] = useState({ title: '', content: '' });
  const debouncedFormData = useDebounce(formData, 1000);

  useEffect(() => {
    // Auto-save ap√≥s 1s de inatividade
    if (debouncedFormData.title || debouncedFormData.content) {
      fetch('/api/drafts', {
        method: 'POST',
        body: JSON.stringify(debouncedFormData)
      });
    }
  }, [debouncedFormData]);

  return (
    <form>
      <input
        value={formData.title}
        onChange={(e) => setFormData({ ...formData, title: e.target.value })}
      />
      <textarea
        value={formData.content}
        onChange={(e) => setFormData({ ...formData, content: e.target.value })}
      />
      <small>Salvando automaticamente...</small>
    </form>
  );
}
```

#### Varia√ß√£o: useDebouncedCallback

```javascript
function useDebouncedCallback(callback, delay) {
  const timeoutRef = useRef(null);
  const callbackRef = useRef(callback);

  // Atualizar callback ref
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const debouncedCallback = useCallback((...args) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(() => {
      callbackRef.current(...args);
    }, delay);
  }, [delay]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return debouncedCallback;
}

// Uso
function Component() {
  const handleSearch = useDebouncedCallback((query) => {
    console.log('Searching for:', query);
  }, 500);

  return <input onChange={(e) => handleSearch(e.target.value)} />;
}
```

### 8.3.2 useClickOutside: Detectar Cliques Externos

```javascript
function useClickOutside(callback) {
  const ref = useRef(null);
  const callbackRef = useRef(callback);

  // Atualizar callback ref
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    const handleClick = (event) => {
      // Se clique foi fora do elemento
      if (ref.current && !ref.current.contains(event.target)) {
        callbackRef.current(event);
      }
    };

    // Listener em document (captura todos cliques)
    document.addEventListener('mousedown', handleClick);

    return () => {
      document.removeEventListener('mousedown', handleClick);
    };
  }, []);

  return ref;
}

// Uso: Dropdown
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useClickOutside(() => setIsOpen(false));

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>
        Toggle Dropdown
      </button>
      {isOpen && (
        <ul className="dropdown-menu">
          <li>Option 1</li>
          <li>Option 2</li>
          <li>Option 3</li>
        </ul>
      )}
    </div>
  );
}

// Uso: Modal
function Modal({ isOpen, onClose, children }) {
  const modalRef = useClickOutside(onClose);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div ref={modalRef} className="modal-content">
        {children}
      </div>
    </div>
  );
}

// Uso: Tooltip
function Tooltip({ text, children }) {
  const [isVisible, setIsVisible] = useState(false);
  const tooltipRef = useClickOutside(() => setIsVisible(false));

  return (
    <div ref={tooltipRef} className="tooltip-container">
      <div onClick={() => setIsVisible(!isVisible)}>
        {children}
      </div>
      {isVisible && (
        <div className="tooltip">
          {text}
        </div>
      )}
    </div>
  );
}
```

### 8.3.3 useEventListener: Event Listeners Gen√©ricos

```javascript
function useEventListener(eventName, handler, element = window) {
  const savedHandler = useRef(handler);

  // Atualizar ref quando handler muda
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    // Garantir que elemento suporta addEventListener
    const isSupported = element && element.addEventListener;
    if (!isSupported) return;

    // Wrapper que chama handler atual
    const eventListener = (event) => savedHandler.current(event);

    element.addEventListener(eventName, eventListener);

    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// Uso: Keyboard shortcuts
function KeyboardShortcuts() {
  const [lastKey, setLastKey] = useState('');

  useEventListener('keydown', (e) => {
    setLastKey(e.key);

    // Shortcuts espec√≠ficas
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault();
      console.log('Save shortcut!');
    }

    if (e.key === 'Escape') {
      console.log('Close modal');
    }
  });

  return <div>√öltima tecla: {lastKey}</div>;
}

// Uso: Window resize
function WindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEventListener('resize', () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  });

  return (
    <div>
      Window: {windowSize.width} x {windowSize.height}
    </div>
  );
}

// Uso: Scroll position
function ScrollIndicator() {
  const [scrollPosition, setScrollPosition] = useState(0);

  useEventListener('scroll', () => {
    const height = document.documentElement.scrollHeight - window.innerHeight;
    const scrolled = window.scrollY;
    const percentage = (scrolled / height) * 100;
    setScrollPosition(percentage);
  });

  return (
    <div className="scroll-indicator">
      <div
        className="scroll-progress"
        style={{ width: `${scrollPosition}%` }}
      />
    </div>
  );
}

// Uso: Custom element (ref)
function CustomElementListener() {
  const divRef = useRef(null);

  useEventListener('click', (e) => {
    console.log('Div clicada!', e);
  }, divRef.current);

  return <div ref={divRef}>Clique aqui</div>;
}
```

### 8.3.4 useMediaQuery: Responsive Queries

```javascript
function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => {
    if (typeof window !== 'undefined') {
      return window.matchMedia(query).matches;
    }
    return false;
  });

  useEffect(() => {
    if (typeof window === 'undefined') return;

    const mediaQuery = window.matchMedia(query);
    setMatches(mediaQuery.matches);

    // Listener para mudan√ßas
    const handleChange = (e) => {
      setMatches(e.matches);
    };

    // API moderna vs legada
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener('change', handleChange);
      return () => mediaQuery.removeEventListener('change', handleChange);
    } else {
      // Fallback para browsers antigos
      mediaQuery.addListener(handleChange);
      return () => mediaQuery.removeListener(handleChange);
    }
  }, [query]);

  return matches;
}

// Uso: Responsive layout
function ResponsiveLayout() {
  const isMobile = useMediaQuery('(max-width: 768px)');
  const isTablet = useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
  const isDesktop = useMediaQuery('(min-width: 1025px)');

  return (
    <div>
      {isMobile && <MobileNav />}
      {isTablet && <TabletNav />}
      {isDesktop && <DesktopNav />}
    </div>
  );
}

// Uso: Dark mode preference
function ThemeDetector() {
  const prefersDark = useMediaQuery('(prefers-color-scheme: dark)');
  const [theme, setTheme] = useState(prefersDark ? 'dark' : 'light');

  useEffect(() => {
    setTheme(prefersDark ? 'dark' : 'light');
  }, [prefersDark]);

  return (
    <div className={theme}>
      <p>Tema: {theme}</p>
      <p>Sistema prefere: {prefersDark ? 'escuro' : 'claro'}</p>
    </div>
  );
}

// Uso: Orientation
function OrientationDetector() {
  const isPortrait = useMediaQuery('(orientation: portrait)');

  return (
    <div>
      Orienta√ß√£o: {isPortrait ? 'Retrato' : 'Paisagem'}
    </div>
  );
}

// Uso: Print
function PrintStyles() {
  const isPrinting = useMediaQuery('print');

  return (
    <div>
      {isPrinting ? (
        <div>Vers√£o para impress√£o</div>
      ) : (
        <div>Vers√£o para tela</div>
      )}
    </div>
  );
}
```

### 8.3.5 useIntersectionObserver: Visibilidade de Elementos

```javascript
function useIntersectionObserver(options = {}) {
  const [entry, setEntry] = useState(null);
  const [isIntersecting, setIsIntersecting] = useState(false);
  const elementRef = useRef(null);

  const {
    threshold = 0,
    root = null,
    rootMargin = '0px'
  } = options;

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        setEntry(entry);
        setIsIntersecting(entry.isIntersecting);
      },
      { threshold, root, rootMargin }
    );

    observer.observe(element);

    return () => {
      observer.disconnect();
    };
  }, [threshold, root, rootMargin]);

  return [elementRef, isIntersecting, entry];
}

// Uso: Lazy load de imagem
function LazyImage({ src, alt, placeholder }) {
  const [imgRef, isVisible] = useIntersectionObserver({
    threshold: 0.1
  });

  return (
    <img
      ref={imgRef}
      src={isVisible ? src : placeholder}
      alt={alt}
      loading="lazy"
    />
  );
}

// Uso: Infinite scroll
function InfiniteList({ items, loadMore, hasMore }) {
  const [loaderRef, isVisible] = useIntersectionObserver({
    threshold: 1.0
  });

  useEffect(() => {
    if (isVisible && hasMore) {
      loadMore();
    }
  }, [isVisible, hasMore, loadMore]);

  return (
    <div>
      {items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
      {hasMore && (
        <div ref={loaderRef}>
          Carregando mais...
        </div>
      )}
    </div>
  );
}

// Uso: Anima√ß√£o on-view
function FadeInSection({ children }) {
  const [ref, isVisible] = useIntersectionObserver({
    threshold: 0.5
  });

  return (
    <div
      ref={ref}
      className={`fade-in-section ${isVisible ? 'is-visible' : ''}`}
    >
      {children}
    </div>
  );
}

// Uso: Analytics (track views)
function AnalyticsSection({ sectionId, children }) {
  const [ref, isVisible] = useIntersectionObserver({
    threshold: 0.8
  });

  useEffect(() => {
    if (isVisible) {
      // Track view
      analytics.track('Section Viewed', { sectionId });
    }
  }, [isVisible, sectionId]);

  return <section ref={ref}>{children}</section>;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Hook

**useDebounce:**
- Search inputs (evitar requests a cada tecla)
- Auto-save de formul√°rios
- Resize/scroll handlers (evitar execu√ß√µes excessivas)

**useClickOutside:**
- Dropdowns, modals, tooltips
- Context menus
- Qualquer UI que fecha ao clicar fora

**useEventListener:**
- Keyboard shortcuts globais
- Window events (resize, scroll)
- Custom events em elementos espec√≠ficos

**useMediaQuery:**
- Layouts responsivos
- Detec√ß√£o de dark mode
- Adaptar UI para print/mobile/tablet

**useIntersectionObserver:**
- Lazy loading de imagens/componentes
- Infinite scroll
- Anima√ß√µes on-view
- Analytics (tracking de views)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Performance: Debounce vs Throttle

**Debounce:** Aguarda pausa na entrada.
**Throttle:** Limita taxa de execu√ß√£o.

```javascript
// Debounce: busca ap√≥s parar de digitar
const debouncedSearch = useDebounce(query, 500);

// Throttle: atualiza m√°ximo 1x por segundo (scroll)
// (useThrottle seria implementa√ß√£o separada)
```

### Browser Support

**IntersectionObserver:** IE n√£o suporta (precisa polyfill).

**matchMedia:** Suportado amplamente, mas API mudou (addEventListener vs addListener).

**Solu√ß√£o:** Feature detection + fallbacks.

### Memory Leaks

**Sempre remove listeners:**
```javascript
useEffect(() => {
  element.addEventListener('event', handler);
  return () => element.removeEventListener('event', handler); // Crucial!
}, []);
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Performance

Debounce/throttle reduzem re-renders e requests desnecess√°rios.

### Rela√ß√£o com Acessibilidade

Keyboard events, focus management melhoram a11y.

### Rela√ß√£o com Responsive Design

Media queries permitem adaptar UI a diferentes contextos.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Event listeners manuais
    ‚Üì
useEventListener (abstra√ß√£o)
    ‚Üì
Hooks especializados (useClickOutside, etc)
    ‚Üì
Composi√ß√£o (m√∫ltiplos hooks juntos)
```

---

## üìö Conclus√£o

Custom Hooks de UI & Events s√£o **essenciais** para interatividade. Princ√≠pios:

1. **useDebounce**: Atrasar atualiza√ß√µes (performance)
2. **useClickOutside**: Detectar cliques externos (UX)
3. **useEventListener**: Abstrair addEventListener (DRY)
4. **useMediaQuery**: Responsive design (adaptabilidade)
5. **useIntersectionObserver**: Lazy loading (performance)

**Recomenda√ß√µes:**
- Sempre cleanup listeners (evitar memory leaks)
- Debounce inputs para performance
- Use media queries para responsive design
- IntersectionObserver para lazy loading
- Trate edge cases (SSR, browser support)

**Dominar hooks de UI/Events = interfaces responsivas, perform√°ticas e acess√≠veis.**
