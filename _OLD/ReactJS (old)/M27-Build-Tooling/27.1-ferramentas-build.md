# Ferramentas de Build no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Ferramentas de Build** s√£o **sistemas que transformam c√≥digo-fonte** (JSX, TypeScript, modern JavaScript) em **c√≥digo otimizado** que browsers entendem, incluindo **bundling, transpiling, minification e tree-shaking**. Conceitualmente, representam **compilador do frontend** - ponte entre c√≥digo moderno (ESM, TS, JSX) e realidade dos browsers.

### Problema que Resolve

**Sem Build Tools**:
- Browsers n√£o entendem JSX/TypeScript
- Centenas de arquivos HTTP requests
- C√≥digo n√£o otimizado
- Sem tree-shaking (c√≥digo n√£o usado)
- Desenvolvimento lento

**Com Build Tools**:
- Transpila JSX/TS para JS
- Bundle √∫nico otimizado
- C√≥digo minificado
- Tree-shaking remove c√≥digo morto
- Hot Module Replacement (HMR)

---

## ‚ö° Vite (Recomendado 2024)

### Por Que Vite?

```
Webpack (tradicional):
Start dev server: 10-30s
HMR update: 1-3s

Vite (moderno):
Start dev server: <1s ‚ú®
HMR update: <100ms ‚ö°
```

### Setup B√°sico

```bash
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
npm run dev
```

### Configura√ß√£o

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],

  // Path aliases
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/components': path.resolve(__dirname, './src/components')
    }
  },

  // Dev server
  server: {
    port: 3000,
    open: true, // Abre browser automaticamente
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true
      }
    }
  },

  // Build optimization
  build: {
    outDir: 'dist',
    sourcemap: true,

    rollupOptions: {
      output: {
        manualChunks: {
          // Vendor splitting
          react: ['react', 'react-dom'],
          router: ['react-router-dom'],
          query: ['@tanstack/react-query']
        }
      }
    },

    // Chunk size warning
    chunkSizeWarningLimit: 1000 // KB
  },

  // Environment variables
  envPrefix: 'VITE_'
});
```

### Environment Variables

```bash
# .env
VITE_API_URL=http://localhost:5000/api
VITE_APP_TITLE=My App

# .env.production
VITE_API_URL=https://api.example.com
```

```tsx
// Uso
const apiUrl = import.meta.env.VITE_API_URL;
const isDev = import.meta.env.DEV;
const isProd = import.meta.env.PROD;

console.log(apiUrl); // http://localhost:5000/api
```

### Plugins √öteis

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import svgr from 'vite-plugin-svgr';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),

    // SVG como componentes React
    svgr(),

    // Visualizar bundle size
    visualizer({
      open: true,
      filename: 'dist/stats.html'
    })
  ]
});
```

---

## üì¶ Webpack (Legado mas Comum)

### Quando Usar Webpack

- Projeto legado (j√° usa Webpack)
- Necessita plugins espec√≠ficos Webpack
- Module Federation (micro-frontends)

### Configura√ß√£o B√°sica

```javascript
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  mode: process.env.NODE_ENV === 'production' ? 'production' : 'development',

  entry: './src/index.tsx',

  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    clean: true
  },

  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.jsx'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },

  module: {
    rules: [
      // TypeScript/JSX
      {
        test: /\.(ts|tsx)$/,
        use: 'ts-loader',
        exclude: /node_modules/
      },

      // CSS
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader']
      },

      // CSS Modules
      {
        test: /\.module\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          }
        ]
      },

      // Images
      {
        test: /\.(png|jpg|jpeg|gif|svg)$/,
        type: 'asset/resource'
      }
    ]
  },

  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html'
    }),

    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css'
    })
  ],

  devServer: {
    port: 3000,
    hot: true,
    open: true,
    historyApiFallback: true
  },

  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        }
      }
    }
  }
};
```

---

## üî® Outras Ferramentas

### Parcel (Zero Config)

```bash
npm install --save-dev parcel
```

```json
// package.json
{
  "scripts": {
    "start": "parcel src/index.html",
    "build": "parcel build src/index.html"
  }
}
```

**Pros**: Zero config, muito simples
**Cons**: Menos controle, comunidade menor

### Turbopack (Futuro - Next.js 13+)

```javascript
// next.config.js
module.exports = {
  experimental: {
    turbopack: true
  }
};
```

**Status**: Experimental (2024)
**Performance**: 10x mais r√°pido que Webpack

---

## üéØ Build Optimization

### Code Splitting

```tsx
// ‚úÖ Route-based splitting
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./pages/Dashboard'));
const Products = lazy(() => import('./pages/Products'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/products" element={<Products />} />
      </Routes>
    </Suspense>
  );
}
```

### Manual Chunks (Vite)

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          if (id.includes('node_modules')) {
            if (id.includes('react')) return 'react-vendor';
            if (id.includes('lodash')) return 'lodash';
            return 'vendor';
          }
        }
      }
    }
  }
});
```

### Tree-Shaking

```tsx
// ‚ùå Import tudo (bundle cresce)
import _ from 'lodash';
_.debounce(fn, 300);

// ‚úÖ Import apenas o necess√°rio
import debounce from 'lodash/debounce';
debounce(fn, 300);

// ‚úÖ Named imports (tree-shakeable)
import { debounce } from 'lodash-es';
```

---

## üìä Bundle Analysis

### Vite

```bash
npm install --save-dev rollup-plugin-visualizer
```

```typescript
// vite.config.ts
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    visualizer({
      open: true,
      filename: 'dist/stats.html',
      gzipSize: true
    })
  ]
});
```

### Webpack

```bash
npm install --save-dev webpack-bundle-analyzer
```

```javascript
// webpack.config.js
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false,
      reportFilename: 'bundle-report.html'
    })
  ]
};
```

---

## ‚öôÔ∏è Build Scripts

### package.json Padr√£o

```json
{
  "scripts": {
    // Development
    "dev": "vite",
    "dev:host": "vite --host",

    // Build
    "build": "tsc && vite build",
    "build:analyze": "vite build --mode analyze",

    // Preview production build
    "preview": "vite preview",

    // Type check
    "type-check": "tsc --noEmit",

    // Lint
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",

    // Test
    "test": "vitest",
    "test:coverage": "vitest --coverage",

    // Clean
    "clean": "rm -rf dist node_modules"
  }
}
```

---

## üöÄ Conclus√£o

Ferramentas de Build incluem:
- **Vite** (2024): Dev server instant√¢neo, HMR <100ms
- **Webpack**: Legado mas poderoso, module federation
- **Parcel**: Zero config
- **Turbopack**: Futuro (experimental)

**Recomenda√ß√£o**: Use **Vite** para novos projetos - faster, simpler, melhor DX. Webpack apenas para legado ou necessidades espec√≠ficas (Module Federation).

Build optimization: Code splitting, tree-shaking, bundle analysis.
