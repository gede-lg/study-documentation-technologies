# CSS Animations no React: Uma An√°lise Conceitual Profunda

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

CSS Animations no React referem-se ao uso de **tecnologias de anima√ß√£o nativas do CSS** - `transitions` (transi√ß√µes entre estados) e `animations` (sequ√™ncias de keyframes) - aplicadas em componentes React para criar movimento, feedback visual e melhorar a experi√™ncia do usu√°rio. Conceitualmente, trata-se de aproveitar o **motor de anima√ß√£o otimizado do navegador** enquanto React gerencia quando e como essas anima√ß√µes s√£o disparadas, criando uma sinergia entre a declaratividade do React e a performance nativa do CSS.

Na ess√™ncia, CSS Animations no React significa usar propriedades CSS (`transition`, `animation`, `@keyframes`) controladas por mudan√ßas de estado React (classes condicionais, estilos inline din√¢micos) para criar interfaces fluidas e responsivas sem JavaScript de anima√ß√£o pesado.

### Contexto Hist√≥rico e Motiva√ß√£o

**CSS Transitions** foram introduzidas no CSS3 por volta de 2009, permitindo interpolar valores de propriedades CSS ao longo do tempo. **CSS Animations** (`@keyframes`) chegaram logo depois, oferecendo controle mais complexo sobre sequ√™ncias de anima√ß√£o.

**Antes das CSS Animations**: Anima√ß√µes web requeriam:
- **JavaScript manual** (setInterval/setTimeout mudando valores) - performance ruim, jank
- **jQuery animate** - overhead de biblioteca, n√£o otimizado para GPU
- **Flash** - plugin externo, seguran√ßa problem√°tica

**Problemas que motivaram CSS Animations**:

1. **Performance**: JavaScript manipulando estilos em cada frame √© lento. Navegadores n√£o conseguem otimizar.

2. **Bateria**: Anima√ß√µes JS desperdi√ßam energia em dispositivos m√≥veis.

3. **Complexidade**: Escrever anima√ß√µes suaves em JS puro √© trabalhoso (easing, timing, etc.).

**A revolu√ß√£o CSS**: Navegadores podem **otimizar anima√ß√µes CSS em hardware** (GPU), permitindo 60fps consistentes com uso m√≠nimo de CPU.

**No contexto React**: Quando React surgiu (2013), CSS Animations j√° eram padr√£o estabelecido. React adicionou camada de **controle declarativo**:
- Estado React dispara anima√ß√µes
- Classes CSS definem comportamento
- Navegador executa anima√ß√£o de forma otimizada

**Motiva√ß√£o**: Combinar melhor dos dois mundos - **l√≥gica declarativa do React + performance nativa de CSS**.

### Problema Fundamental que Resolve

CSS Animations no React resolvem problemas espec√≠ficos:

**1. Feedback Visual de Mudan√ßas de Estado**:
```jsx
const [isOpen, setIsOpen] = useState(false);

// Sem anima√ß√£o: mudan√ßa abrupta
<div className={isOpen ? 'menu-open' : 'menu-closed'}>

// Com anima√ß√£o: transi√ß√£o suave
<div className={clsx('menu', isOpen && 'menu-open')}>
```

**2. Performance de Anima√ß√µes**:
CSS animations usam **compositing thread** - executam em GPU, n√£o bloqueiam main thread (onde React roda).

**3. Indica√ß√£o de Carregamento/Estado**:
Spinners, skeleton screens, progress bars - anima√ß√µes CSS comunicam "algo est√° acontecendo".

**4. Melhoria de UX**:
- **Entrada/sa√≠da de elementos**: Fade in/out suaviza aparecimento
- **Aten√ß√£o do usu√°rio**: Pulsar bot√£o importante
- **Fluidez**: Hover states animados parecem mais responsivos

**5. Acessibilidade Respeitosa**:
CSS permite respeitar `prefers-reduced-motion` nativamente:
```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}
```

### Import√¢ncia no Ecossistema

CSS Animations s√£o **fundamentais** para UX moderna em React:

**Expectativa de Usu√°rio**:
- Apps sem anima√ß√µes parecem "quebrados" ou lentos
- Feedback visual √© esperado (bot√µes respondem a hover/click)

**Performance**:
- CSS animations s√£o **mais r√°pidas** que qualquer solu√ß√£o JavaScript
- 60fps consistentes em hardware moderno
- Battery-friendly em mobile

**Simplicidade**:
- N√£o requer bibliotecas extras (anima√ß√µes j√° no navegador)
- Controle via classes CSS - familiar para desenvolvedores

**Base para Bibliotecas**:
- React Transition Group, Framer Motion, etc. **usam CSS animations** por baixo
- Entender CSS √© fundamento para bibliotecas avan√ßadas

**Padr√£o Universal**:
- Funciona em todos navegadores modernos
- N√£o depende de React - transfer√≠vel para outros frameworks

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Transitions**: Interpola√ß√£o autom√°tica entre dois estados
2. **Animations**: Sequ√™ncias de keyframes com controle total
3. **Triggers**: Mudan√ßas de classe/propriedade disparam anima√ß√µes
4. **Hardware Acceleration**: GPU acelera propriedades espec√≠ficas
5. **Timing Functions**: Controle de acelera√ß√£o (easing)

### Pilares Fundamentais (Transitions)

- **`transition-property`**: Qual propriedade animar
- **`transition-duration`**: Dura√ß√£o da anima√ß√£o
- **`transition-timing-function`**: Curva de acelera√ß√£o (ease, linear, cubic-bezier)
- **`transition-delay`**: Atraso antes de iniciar
- **Shorthand**: `transition: property duration timing-function delay;`

### Pilares Fundamentais (Animations)

- **`@keyframes`**: Define sequ√™ncia de estados
- **`animation-name`**: Nome do keyframe
- **`animation-duration`**: Dura√ß√£o
- **`animation-timing-function`**: Easing
- **`animation-iteration-count`**: Repeti√ß√µes (infinite)
- **`animation-direction`**: Normal, reverse, alternate
- **`animation-fill-mode`**: Estado antes/depois da anima√ß√£o

### Vis√£o Geral das Nuances

- **Propriedades Anim√°veis**: Nem todas podem ser animadas (display, height:auto problem√°tico)
- **GPU vs CPU**: Transform/opacity s√£o GPU, width/height s√£o CPU
- **Conditional Classes**: React controla quando anima√ß√µes disparam
- **Animation Events**: `animationend`, `transitionend` para callbacks
- **Prefers Reduced Motion**: Respeitar acessibilidade

---

## üß† Fundamentos Te√≥ricos

### Como Funcionam CSS Transitions

#### Conceito Fundamental

Transition **interpola valores** de uma propriedade ao longo do tempo quando ela muda.

```css
.button {
  background: blue;
  transition: background 0.3s ease;
}

.button:hover {
  background: red;
}
```

**Processo interno**:
1. Mouse entra no bot√£o
2. Navegador detecta `:hover`
3. `background` mudaria instantaneamente de `blue` ‚Üí `red`
4. `transition` intercepta: "Interpole de blue para red em 0.3s usando ease"
5. Navegador calcula frames intermedi√°rios (purple, pink, etc.) e renderiza 60fps

**Conceito crucial**: Transition n√£o cria anima√ß√£o - **suaviza mudan√ßas que j√° aconteceriam**.

#### Timing Functions (Easing)

Controlam **acelera√ß√£o** da anima√ß√£o:

```css
/* Linear: velocidade constante */
transition-timing-function: linear;

/* Ease (padr√£o): come√ßa devagar, acelera, desacelera no fim */
transition-timing-function: ease;

/* Ease-in: come√ßa devagar, acelera */
transition-timing-function: ease-in;

/* Ease-out: come√ßa r√°pido, desacelera */
transition-timing-function: ease-out;

/* Ease-in-out: suave no in√≠cio e fim */
transition-timing-function: ease-in-out;

/* Cubic-bezier customizado */
transition-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55);
```

**Conceito**: Easing cria movimento **natural**. Linear parece rob√≥tico. Ease imita f√≠sica (objetos n√£o mudam velocidade instantaneamente).

**Ferramenta**: [cubic-bezier.com](https://cubic-bezier.com) para visualizar curvas.

### Como Funcionam CSS Animations

#### @keyframes: Sequ√™ncias de Estados

```css
@keyframes slideIn {
  0% {
    transform: translateX(-100%);
    opacity: 0;
  }
  50% {
    opacity: 0.5;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}

.element {
  animation: slideIn 0.5s ease-out;
}
```

**Processo interno**:
1. Elemento recebe `animation: slideIn`
2. Navegador l√™ keyframes de `slideIn`
3. Interpola valores entre 0%, 50%, 100% ao longo de 0.5s
4. Aplica transforma√ß√µes calculadas em cada frame

**Diferen√ßa de Transition**:
- **Transition**: Suaviza mudan√ßa existente (A ‚Üí B)
- **Animation**: Define sequ√™ncia completa (A ‚Üí B ‚Üí C ‚Üí D)

#### Animation Properties

```css
.spinner {
  animation-name: spin;
  animation-duration: 1s;
  animation-timing-function: linear;
  animation-iteration-count: infinite;
  animation-direction: normal;
  animation-fill-mode: forwards;
  animation-play-state: running;

  /* Shorthand */
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
```

**Propriedades importantes**:

- **`animation-iteration-count`**:
  - N√∫mero (1, 2, 3...) ou `infinite`

- **`animation-direction`**:
  - `normal`: 0% ‚Üí 100%
  - `reverse`: 100% ‚Üí 0%
  - `alternate`: 0% ‚Üí 100% ‚Üí 0% (pingpong)
  - `alternate-reverse`: 100% ‚Üí 0% ‚Üí 100%

- **`animation-fill-mode`**:
  - `none`: Reseta ap√≥s anima√ß√£o
  - `forwards`: Mant√©m estado final (100%)
  - `backwards`: Aplica estado inicial (0%) durante delay
  - `both`: Forwards + backwards

**Conceito crucial**: `fill-mode: forwards` √© comum para anima√ß√µes de entrada (elemento fica no estado final).

### GPU Acceleration: O Segredo da Performance

Nem todas propriedades CSS s√£o iguais para anima√ß√£o:

#### Propriedades GPU-Accelerated (R√°pidas)

```css
/* Estas usam compositing thread (GPU) */
.fast-animation {
  transform: translateX(100px);  /* ‚úÖ */
  transform: scale(1.5);          /* ‚úÖ */
  transform: rotate(45deg);       /* ‚úÖ */
  opacity: 0.5;                   /* ‚úÖ */
}
```

**Por qu√™ s√£o r√°pidas**: Navegador cria **layer separada** que GPU pode mover/transformar sem re-calcular layout.

#### Propriedades CPU-Heavy (Lentas)

```css
/* Estas for√ßam layout recalculation (CPU) */
.slow-animation {
  width: 200px;     /* ‚ùå Triggers layout */
  height: 200px;    /* ‚ùå Triggers layout */
  margin: 20px;     /* ‚ùå Triggers layout */
  padding: 10px;    /* ‚ùå Triggers layout */
  top: 50px;        /* ‚ùå Triggers layout (position: absolute) */
  left: 50px;       /* ‚ùå Triggers layout */
}
```

**Por qu√™ s√£o lentas**: Mudar width/height requer recalcular posi√ß√µes de todos elementos na p√°gina (layout thrashing).

**Solu√ß√£o**: Usar `transform: scale()` ao inv√©s de width/height:

```css
/* ‚ùå Lento */
@keyframes grow-slow {
  from { width: 100px; height: 100px; }
  to { width: 200px; height: 200px; }
}

/* ‚úÖ R√°pido */
@keyframes grow-fast {
  from { transform: scale(1); }
  to { transform: scale(2); }
}
```

**Conceito**: **Transform e opacity** s√£o propriedades m√°gicas - use sempre que poss√≠vel.

### React + CSS Animations: Controle Declarativo

#### Classes Condicionais Disparam Anima√ß√µes

```jsx
function Modal({ isOpen }) {
  return (
    <div className={clsx('modal', isOpen && 'modal-open')}>
      Content
    </div>
  );
}
```

```css
.modal {
  opacity: 0;
  transform: translateY(-20px);
  transition: opacity 0.3s, transform 0.3s;
}

.modal-open {
  opacity: 1;
  transform: translateY(0);
}
```

**Fluxo**:
1. `isOpen` muda de `false` ‚Üí `true`
2. React adiciona classe `modal-open`
3. CSS transitions interpolam `opacity` e `transform`
4. Modal desliza suavemente para dentro

**Conceito**: React gerencia **l√≥gica** (quando animar), CSS gerencia **apresenta√ß√£o** (como animar).

---

## üîç An√°lise Conceitual Profunda

### CSS Transitions: Sintaxe e Uso

#### Transition B√°sica

```css
.button {
  background: #3b82f6;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;

  /* Anima background e transform */
  transition: background 0.3s ease, transform 0.2s ease;
}

.button:hover {
  background: #2563eb;
  transform: translateY(-2px);
}

.button:active {
  transform: translateY(0);
}
```

**An√°lise**:
- **M√∫ltiplas propriedades**: Separadas por v√≠rgula
- **Dura√ß√µes diferentes**: `background` (0.3s) vs `transform` (0.2s)
- **Hover**: Bot√£o escurece e levanta
- **Active**: Bot√£o volta posi√ß√£o original (feedback de click)

#### Transition All (Use com Cautela)

```css
.card {
  /* Anima TODAS as propriedades que mudarem */
  transition: all 0.3s ease;
}

.card:hover {
  box-shadow: 0 10px 20px rgba(0,0,0,0.2);
  transform: scale(1.05);
}
```

**Cuidado**: `transition: all` pode causar anima√ß√µes n√£o intencionais. Melhor especificar propriedades:

```css
.card {
  transition: box-shadow 0.3s, transform 0.3s;
}
```

#### Delays para Efeitos Sequenciais

```css
.menu-item {
  opacity: 0;
  transform: translateX(-20px);
  transition: opacity 0.3s, transform 0.3s;
}

.menu-item:nth-child(1) { transition-delay: 0.1s; }
.menu-item:nth-child(2) { transition-delay: 0.2s; }
.menu-item:nth-child(3) { transition-delay: 0.3s; }

.menu.open .menu-item {
  opacity: 1;
  transform: translateX(0);
}
```

**Efeito**: Itens aparecem sequencialmente (cascata).

### CSS Animations com @keyframes

#### Anima√ß√£o de Fade In

```css
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.element {
  animation: fadeIn 0.5s ease-in;
}
```

**Forma alternativa** (`0%` e `100%` ao inv√©s de `from`/`to`):

```css
@keyframes fadeIn {
  0% { opacity: 0; }
  100% { opacity: 1; }
}
```

#### Anima√ß√£o Complexa (M√∫ltiplos Keyframes)

```css
@keyframes bounce {
  0% {
    transform: translateY(0);
  }
  25% {
    transform: translateY(-30px);
  }
  50% {
    transform: translateY(0);
  }
  75% {
    transform: translateY(-15px);
  }
  100% {
    transform: translateY(0);
  }
}

.ball {
  animation: bounce 1s ease-in-out infinite;
}
```

**Efeito**: Bola quicando (sobe alto, desce, sobe menos, desce).

#### Spinner Loading

```css
@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3b82f6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
```

**Conceito**: `linear` timing (n√£o ease) cria rota√ß√£o constante. `infinite` nunca para.

#### Pulse (Aten√ß√£o)

```css
@keyframes pulse {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.1);
    opacity: 0.8;
  }
}

.notification-badge {
  animation: pulse 2s ease-in-out infinite;
}
```

**Efeito**: Badge pulsa suavemente chamando aten√ß√£o.

### Anima√ß√µes Condicionais com React

#### Mostrar/Esconder com Fade

```jsx
function Alert({ show, message }) {
  if (!show) return null;

  return (
    <div className="alert">
      {message}
    </div>
  );
}
```

```css
.alert {
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
```

**Problema**: Fade-in funciona, mas **n√£o h√° fade-out** (componente desmonta instantaneamente).

**Solu√ß√£o**: Controlar visibilidade sem desmontar:

```jsx
function Alert({ show, message }) {
  return (
    <div className={clsx('alert', show && 'alert-visible')}>
      {message}
    </div>
  );
}
```

```css
.alert {
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 0.3s, transform 0.3s;
  pointer-events: none; /* Desabilita intera√ß√£o quando invis√≠vel */
}

.alert-visible {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
```

#### Toggle com Estados

```jsx
function Accordion({ title, children }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="accordion">
      <button onClick={() => setIsOpen(!isOpen)}>
        {title}
      </button>
      <div className={clsx('accordion-content', isOpen && 'open')}>
        {children}
      </div>
    </div>
  );
}
```

```css
.accordion-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.accordion-content.open {
  max-height: 500px; /* Valor estimado maior que conte√∫do */
}
```

**Nota**: `max-height` (n√£o `height: auto`) porque `auto` n√£o √© anim√°vel.

#### Loading States

```jsx
function Button({ loading, onClick, children }) {
  return (
    <button onClick={onClick} disabled={loading}>
      {loading && <span className="spinner" />}
      <span className={loading ? 'fade-out' : ''}>{children}</span>
    </button>
  );
}
```

```css
.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}

.fade-out {
  opacity: 0.5;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
```

### Animation Events para Callbacks

```jsx
function Toast({ message, onClose }) {
  const handleAnimationEnd = (e) => {
    if (e.animationName === 'slideOut') {
      onClose(); // Fecha ap√≥s anima√ß√£o de sa√≠da
    }
  };

  return (
    <div
      className="toast toast-exit"
      onAnimationEnd={handleAnimationEnd}
    >
      {message}
    </div>
  );
}
```

```css
.toast {
  animation: slideIn 0.3s ease-out;
}

.toast-exit {
  animation: slideOut 0.3s ease-in;
}

@keyframes slideIn {
  from { transform: translateX(100%); }
  to { transform: translateX(0); }
}

@keyframes slideOut {
  from { transform: translateX(0); }
  to { transform: translateX(100%); }
}
```

**Conceito**: `onAnimationEnd` permite executar c√≥digo ap√≥s anima√ß√£o completar.

### Prefers Reduced Motion (Acessibilidade)

```css
/* Anima√ß√µes normais */
.button {
  transition: transform 0.3s;
}

.button:hover {
  transform: scale(1.1);
}

/* Desabilita para usu√°rios com prefer√™ncia de movimento reduzido */
@media (prefers-reduced-motion: reduce) {
  .button {
    transition: none;
  }

  .button:hover {
    transform: none;
  }
}
```

**React hook para detectar**:

```jsx
function usePrefersReducedMotion() {
  const [prefersReduced, setPrefersReduced] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReduced(mediaQuery.matches);

    const listener = (e) => setPrefersReduced(e.matches);
    mediaQuery.addEventListener('change', listener);

    return () => mediaQuery.removeEventListener('change', listener);
  }, []);

  return prefersReduced;
}

function Component() {
  const prefersReduced = usePrefersReducedMotion();

  return (
    <div className={prefersReduced ? 'no-animation' : 'with-animation'}>
      Content
    </div>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar CSS Animations

#### 1. Micro-intera√ß√µes

**Contexto**: Feedback visual de a√ß√µes (hover, click, focus).

**Exemplo**: Bot√£o que levanta ao hover, afunda ao click.

**Por qu√™ CSS**: Performance perfeita, sem JavaScript.

#### 2. Loading States

**Contexto**: Spinners, skeleton screens, progress indicators.

**Exemplo**: Spinner girando enquanto dados carregam.

**Por qu√™ CSS**: Anima√ß√£o n√£o para mesmo se JavaScript trava.

#### 3. Page Transitions

**Contexto**: Fade in de conte√∫do ao carregar p√°gina.

**Exemplo**: T√≠tulo e par√°grafo deslizam para dentro sequencialmente.

**Por qu√™ CSS**: Simples, perform√°tico, sem biblioteca.

#### 4. Attention Seekers

**Contexto**: Chamar aten√ß√£o para elemento (badge de notifica√ß√£o).

**Exemplo**: Pulsar, shake, bounce.

**Por qu√™ CSS**: Leve, n√£o afeta resto da aplica√ß√£o.

### Quando Considerar Alternativas

**Framer Motion**: Anima√ß√µes complexas com orchestration (m√∫ltiplos elementos sequenciados).

**React Spring**: Anima√ß√µes baseadas em f√≠sica (movimento natural, interrupt√≠vel).

**GSAP**: Anima√ß√µes extremamente complexas, timelines, SVG morphing.

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Restri√ß√µes

#### 1. height: auto N√£o √© Anim√°vel

```css
/* ‚ùå N√£o funciona */
.element {
  height: 0;
  transition: height 0.3s;
}

.element.open {
  height: auto; /* auto n√£o pode ser interpolado */
}
```

**Solu√ß√µes**:

```css
/* Solu√ß√£o 1: max-height (aproxima√ß√£o) */
.element {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s;
}

.element.open {
  max-height: 500px; /* Estimativa maior que conte√∫do */
}

/* Solu√ß√£o 2: JavaScript para altura real */
```

```jsx
const ref = useRef();
const [height, setHeight] = useState(0);

useEffect(() => {
  if (isOpen) {
    setHeight(ref.current.scrollHeight);
  } else {
    setHeight(0);
  }
}, [isOpen]);

return (
  <div ref={ref} style={{ height, transition: 'height 0.3s', overflow: 'hidden' }}>
    Content
  </div>
);
```

#### 2. display: none N√£o Transiciona

```css
/* ‚ùå Mudan√ßa instant√¢nea */
.modal {
  display: none;
  opacity: 0;
  transition: opacity 0.3s;
}

.modal.open {
  display: block;
  opacity: 1;
}
```

**Problema**: `display` muda instantaneamente, transition n√£o executa.

**Solu√ß√£o**: Usar `visibility` + `opacity`:

```css
.modal {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.3s, visibility 0.3s;
}

.modal.open {
  visibility: visible;
  opacity: 1;
}
```

#### 3. Anima√ß√µes de Sa√≠da em Componentes Desmontados

```jsx
// ‚ùå Componente desmonta instantaneamente
{show && <Modal />}
```

N√£o h√° tempo para anima√ß√£o de sa√≠da.

**Solu√ß√£o**: Bibliotecas como React Transition Group ou gerenciar estado manualmente.

---

## üöÄ Conclus√£o

CSS Animations no React s√£o **fundamento essencial** para UX moderna:

**Vantagens**:
- Performance nativa (GPU)
- Simplicidade (sem bibliotecas)
- Declarativo (React controla triggers)
- Acessibilidade (prefers-reduced-motion)

**Quando usar**: Micro-intera√ß√µes, loading states, feedback visual, page transitions simples.

**Pr√≥ximos passos**: React Transition Group para anima√ß√µes de mount/unmount, Framer Motion para anima√ß√µes complexas.

CSS Animations s√£o base s√≥lida - dominar permite criar 90% das anima√ß√µes necess√°rias sem peso de bibliotecas.
