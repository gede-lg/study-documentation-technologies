# Patterns de Testes no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Patterns de Testes** s√£o **abordagens estruturadas e reutiliz√°veis** para escrever testes que garantem **qualidade**, **manutenibilidade** e **efici√™ncia**. Conceitualmente, representam **best practices consolidadas** - solu√ß√µes testadas pela comunidade para problemas comuns em testing, incluindo setup, mocking, async testing e organiza√ß√£o.

### Problema que Resolve

**Sem Patterns**:
- C√≥digo duplicado em testes
- Setup complexo repetido
- Testes dif√≠ceis de manter
- Mocks inconsistentes

**Com Patterns**:
- Testes DRY (Don't Repeat Yourself)
- Setup centralizado
- Testes leg√≠veis e consistentes
- Mocks padronizados

---

## üèóÔ∏è Setup Patterns

### Custom Render Helper

```javascript
// test-utils.jsx
import { render } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthProvider } from './contexts/AuthContext';
import { ThemeProvider } from './contexts/ThemeContext';

// Cria novo QueryClient para cada teste (isolamento)
const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false }
  }
});

function AllTheProviders({ children }) {
  const queryClient = createTestQueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <AuthProvider>
          <ThemeProvider>
            {children}
          </ThemeProvider>
        </AuthProvider>
      </BrowserRouter>
    </QueryClientProvider>
  );
}

const customRender = (ui, options = {}) => {
  return render(ui, { wrapper: AllTheProviders, ...options });
};

// Re-exporta tudo do RTL + customRender como render
export * from '@testing-library/react';
export { customRender as render };
```

### Render com Props Customizadas

```javascript
// test-utils.jsx
function renderWithProviders(
  ui,
  {
    initialUser = null,
    theme = 'light',
    route = '/',
    ...renderOptions
  } = {}
) {
  const queryClient = createTestQueryClient();

  function Wrapper({ children }) {
    return (
      <QueryClientProvider client={queryClient}>
        <MemoryRouter initialEntries={[route]}>
          <AuthProvider initialUser={initialUser}>
            <ThemeProvider initialTheme={theme}>
              {children}
            </ThemeProvider>
          </AuthProvider>
        </MemoryRouter>
      </QueryClientProvider>
    );
  }

  return {
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
    queryClient
  };
}

// Uso
test('renderiza p√°gina de perfil', () => {
  renderWithProviders(<ProfilePage />, {
    initialUser: { id: 1, name: 'John' },
    route: '/profile'
  });

  expect(screen.getByText('John')).toBeInTheDocument();
});
```

---

## üé≠ Mocking Patterns

### Mock de API com MSW

```javascript
// mocks/handlers.js
import { http, HttpResponse } from 'msw';

export const handlers = [
  http.get('/api/users/:id', ({ params }) => {
    return HttpResponse.json({
      id: params.id,
      name: 'John Doe',
      email: 'john@test.com'
    });
  }),

  http.post('/api/users', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json(
      { id: 1, ...body },
      { status: 201 }
    );
  }),

  http.delete('/api/users/:id', () => {
    return new HttpResponse(null, { status: 204 });
  })
];

// mocks/server.js
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

// setupTests.js
import { server } from './mocks/server';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### Mock de Hooks Customizados

```javascript
// hooks/useAuth.js
export function useAuth() {
  const user = useContext(AuthContext);
  return { user, logout };
}

// __mocks__/useAuth.js
export const useAuth = jest.fn();

// Component.test.js
import { useAuth } from './hooks/useAuth';

jest.mock('./hooks/useAuth');

test('renderiza quando autenticado', () => {
  useAuth.mockReturnValue({
    user: { id: 1, name: 'John' },
    logout: jest.fn()
  });

  render(<ProtectedPage />);

  expect(screen.getByText('Welcome, John')).toBeInTheDocument();
});
```

### Factory Functions para Dados

```javascript
// test-utils/factories.js
export function createUser(overrides = {}) {
  return {
    id: 1,
    name: 'John Doe',
    email: 'john@test.com',
    role: 'user',
    createdAt: new Date('2024-01-01'),
    ...overrides
  };
}

export function createProduct(overrides = {}) {
  return {
    id: 1,
    name: 'Product 1',
    price: 100,
    inStock: true,
    ...overrides
  };
}

// Uso
test('renderiza usu√°rio admin', () => {
  const admin = createUser({ role: 'admin' });

  render(<UserCard user={admin} />);

  expect(screen.getByText('Admin')).toBeInTheDocument();
});
```

---

## üß™ Testing Patterns Comuns

### Page Object Pattern

```javascript
// pageObjects/LoginPage.js
export class LoginPage {
  constructor(user) {
    this.user = user;
  }

  async fillEmail(email) {
    await this.user.type(screen.getByLabelText('Email'), email);
  }

  async fillPassword(password) {
    await this.user.type(screen.getByLabelText('Password'), password);
  }

  async submit() {
    await this.user.click(screen.getByRole('button', { name: 'Login' }));
  }

  async login(email, password) {
    await this.fillEmail(email);
    await this.fillPassword(password);
    await this.submit();
  }

  getErrorMessage() {
    return screen.getByRole('alert');
  }
}

// login.test.js
test('faz login com sucesso', async () => {
  const user = userEvent.setup();
  const loginPage = new LoginPage(user);

  render(<LoginForm />);

  await loginPage.login('test@test.com', 'password123');

  expect(screen.getByText('Welcome')).toBeInTheDocument();
});
```

### Builder Pattern para Setup

```javascript
class TestBuilder {
  constructor() {
    this.user = null;
    this.route = '/';
    this.queryClient = createTestQueryClient();
  }

  withUser(user) {
    this.user = user;
    return this;
  }

  withRoute(route) {
    this.route = route;
    return this;
  }

  withQueryCache(data) {
    Object.entries(data).forEach(([key, value]) => {
      this.queryClient.setQueryData([key], value);
    });
    return this;
  }

  render(component) {
    return renderWithProviders(component, {
      initialUser: this.user,
      route: this.route,
      queryClient: this.queryClient
    });
  }
}

// Uso
test('renderiza dashboard', () => {
  new TestBuilder()
    .withUser({ id: 1, name: 'John' })
    .withRoute('/dashboard')
    .withQueryCache({
      users: [{ id: 1, name: 'John' }]
    })
    .render(<Dashboard />);

  expect(screen.getByText('Dashboard')).toBeInTheDocument();
});
```

---

## üîÑ Async Testing Patterns

### Aguardar Loading Desaparecer

```javascript
async function waitForLoadingToFinish() {
  await waitForElementToBeRemoved(
    () => screen.queryByText(/loading/i),
    { timeout: 3000 }
  );
}

test('carrega dados', async () => {
  render(<UserList />);

  await waitForLoadingToFinish();

  expect(screen.getByText('John')).toBeInTheDocument();
});
```

### Wrapper para findBy

```javascript
async function findByTextWithRetry(text, options = {}) {
  return screen.findByText(text, {}, { timeout: 5000, ...options });
}

test('aguarda dados aparecerem', async () => {
  render(<AsyncComponent />);

  expect(await findByTextWithRetry('Data loaded')).toBeInTheDocument();
});
```

### Pattern para Testar React Query

```javascript
function createWrapper() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}

test('useUsers hook', async () => {
  server.use(
    http.get('/api/users', () => {
      return HttpResponse.json([
        { id: 1, name: 'John' },
        { id: 2, name: 'Jane' }
      ]);
    })
  );

  const { result } = renderHook(() => useUsers(), {
    wrapper: createWrapper()
  });

  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  expect(result.current.data).toHaveLength(2);
  expect(result.current.data[0].name).toBe('John');
});
```

---

## üéØ Accessibility Testing Patterns

### Testar ARIA Attributes

```javascript
test('modal tem atributos ARIA corretos', () => {
  render(<Modal isOpen onClose={() => {}}>Content</Modal>);

  const modal = screen.getByRole('dialog');

  expect(modal).toHaveAttribute('aria-modal', 'true');
  expect(modal).toHaveAttribute('aria-labelledby');
});
```

### Testar Keyboard Navigation

```javascript
async function testKeyboardNavigation(component, expectedOrder) {
  const user = userEvent.setup();

  render(component);

  for (const label of expectedOrder) {
    await user.keyboard('{Tab}');
    expect(screen.getByLabelText(label)).toHaveFocus();
  }
}

test('navega com teclado', async () => {
  await testKeyboardNavigation(
    <Form />,
    ['Name', 'Email', 'Password', 'Submit']
  );
});
```

### Axe Core Integration

```javascript
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

test('n√£o tem viola√ß√µes de acessibilidade', async () => {
  const { container } = render(<App />);

  const results = await axe(container);

  expect(results).toHaveNoViolations();
});
```

---

## üß© Component Testing Patterns

### Container/Presentational Pattern

```javascript
// Presentational - f√°cil de testar
function UserCardPresentation({ user, onEdit, onDelete }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <button onClick={onEdit}>Edit</button>
      <button onClick={onDelete}>Delete</button>
    </div>
  );
}

test('renderiza dados do usu√°rio', () => {
  const user = createUser({ name: 'John' });

  render(
    <UserCardPresentation
      user={user}
      onEdit={jest.fn()}
      onDelete={jest.fn()}
    />
  );

  expect(screen.getByText('John')).toBeInTheDocument();
});

// Container - testa integra√ß√£o
function UserCardContainer({ userId }) {
  const { data: user } = useUser(userId);
  const editMutation = useEditUser();
  const deleteMutation = useDeleteUser();

  if (!user) return <div>Loading...</div>;

  return (
    <UserCardPresentation
      user={user}
      onEdit={() => editMutation.mutate(user)}
      onDelete={() => deleteMutation.mutate(user.id)}
    />
  );
}

test('carrega e renderiza usu√°rio', async () => {
  server.use(
    http.get('/api/users/1', () => {
      return HttpResponse.json({ id: 1, name: 'John' });
    })
  );

  render(<UserCardContainer userId={1} />);

  expect(await screen.findByText('John')).toBeInTheDocument();
});
```

### Snapshot Testing Pattern

```javascript
test('renderiza corretamente', () => {
  const { container } = render(
    <Button variant="primary" size="large">
      Click me
    </Button>
  );

  expect(container.firstChild).toMatchSnapshot();
});

// Apenas para estrutura simples, n√£o para l√≥gica complexa
```

---

## üìä Coverage Patterns

### Cobrir Edge Cases

```javascript
describe('Calculator', () => {
  test.each([
    [2, 3, 5],
    [0, 0, 0],
    [-1, 1, 0],
    [100, 200, 300]
  ])('add(%i, %i) = %i', (a, b, expected) => {
    expect(add(a, b)).toBe(expected);
  });

  test('lan√ßa erro com valores inv√°lidos', () => {
    expect(() => add('a', 'b')).toThrow();
    expect(() => add(null, undefined)).toThrow();
  });
});
```

### Testar Todos os Caminhos

```javascript
function getDiscount(user) {
  if (user.isPremium) return 0.2;
  if (user.orders > 10) return 0.1;
  return 0;
}

describe('getDiscount', () => {
  test('premium user - 20%', () => {
    expect(getDiscount({ isPremium: true })).toBe(0.2);
  });

  test('user com 10+ pedidos - 10%', () => {
    expect(getDiscount({ isPremium: false, orders: 11 })).toBe(0.1);
  });

  test('user comum - 0%', () => {
    expect(getDiscount({ isPremium: false, orders: 5 })).toBe(0);
  });
});
```

---

## üöÄ Conclus√£o

Patterns de Testes incluem:
- **Setup**: Custom render helper, test-utils
- **Mocking**: MSW, factories, hooks mockados
- **Page Objects**: Encapsular intera√ß√µes
- **Builders**: Setup fluente e leg√≠vel
- **Async**: waitFor helpers, React Query patterns
- **A11y**: ARIA testing, keyboard navigation
- **Coverage**: Edge cases, todos caminhos

Patterns padronizam testes, reduzem duplica√ß√£o e garantem qualidade consistente em toda a aplica√ß√£o.
