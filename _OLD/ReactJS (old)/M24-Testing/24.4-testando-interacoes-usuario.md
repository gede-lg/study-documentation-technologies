# Testando Intera√ß√µes do Usu√°rio

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Testar Intera√ß√µes do Usu√°rio** √© a pr√°tica de **simular comportamentos reais** que usu√°rios executam em uma aplica√ß√£o (clicks, typing, navega√ß√£o) para **verificar que a UI responde corretamente**. Conceitualmente, representa **user behavior testing** - garantir que a aplica√ß√£o funciona como esperado do ponto de vista do usu√°rio, n√£o apenas que o c√≥digo est√° correto.

### Problema que Resolve

**Sem Testes de Intera√ß√£o**:
- Bugs aparecem ao usu√°rio clicar/digitar
- Fluxos complexos n√£o testados
- Feedback visual incorreto
- Navega√ß√£o quebrada

**Com Testes de Intera√ß√£o**:
- Fluxos completos validados
- Estados de UI corretos
- Feedback visual testado
- Navega√ß√£o funcional

---

## üñ±Ô∏è Testando Clicks

### Click B√°sico

```javascript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
}

test('incrementa ao clicar', async () => {
  const user = userEvent.setup();

  render(<Counter />);

  expect(screen.getByText('Count: 0')).toBeInTheDocument();

  await user.click(screen.getByRole('button', { name: 'Increment' }));

  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

### M√∫ltiplos Clicks

```javascript
test('incrementa m√∫ltiplas vezes', async () => {
  const user = userEvent.setup();

  render(<Counter />);

  const button = screen.getByRole('button', { name: 'Increment' });

  await user.click(button);
  await user.click(button);
  await user.click(button);

  expect(screen.getByText('Count: 3')).toBeInTheDocument();
});
```

### Double Click

```javascript
function LikeButton() {
  const [liked, setLiked] = useState(false);
  const [loved, setLoved] = useState(false);

  return (
    <button
      onClick={() => setLiked(true)}
      onDoubleClick={() => setLoved(true)}
    >
      {loved ? '‚ù§Ô∏è' : liked ? 'üëç' : 'ü§ç'}
    </button>
  );
}

test('double click para amar', async () => {
  const user = userEvent.setup();

  render(<LikeButton />);

  await user.dblClick(screen.getByRole('button'));

  expect(screen.getByText('‚ù§Ô∏è')).toBeInTheDocument();
});
```

### Click com Callback

```javascript
test('chama callback ao clicar', async () => {
  const user = userEvent.setup();
  const handleClick = jest.fn();

  render(<button onClick={handleClick}>Click me</button>);

  await user.click(screen.getByRole('button'));

  expect(handleClick).toHaveBeenCalledTimes(1);
});

test('passa evento ao callback', async () => {
  const user = userEvent.setup();
  const handleClick = jest.fn();

  render(<button onClick={handleClick}>Click</button>);

  await user.click(screen.getByRole('button'));

  expect(handleClick).toHaveBeenCalledWith(
    expect.objectContaining({
      type: 'click'
    })
  );
});
```

---

## ‚å®Ô∏è Testando Inputs de Texto

### Typing B√°sico

```javascript
function NameForm() {
  const [name, setName] = useState('');

  return (
    <div>
      <input
        type="text"
        value={name}
        onChange={e => setName(e.target.value)}
        aria-label="Name"
      />
      <p>Hello, {name}!</p>
    </div>
  );
}

test('atualiza ao digitar', async () => {
  const user = userEvent.setup();

  render(<NameForm />);

  const input = screen.getByRole('textbox', { name: 'Name' });

  await user.type(input, 'John');

  expect(input).toHaveValue('John');
  expect(screen.getByText('Hello, John!')).toBeInTheDocument();
});
```

### Clear Input

```javascript
test('limpa input', async () => {
  const user = userEvent.setup();

  render(<input type="text" defaultValue="Initial" />);

  const input = screen.getByRole('textbox');

  await user.clear(input);

  expect(input).toHaveValue('');
});
```

### Caracteres Especiais

```javascript
test('digita caracteres especiais', async () => {
  const user = userEvent.setup();

  render(<input type="text" />);
  const input = screen.getByRole('textbox');

  await user.type(input, 'test@example.com');
  expect(input).toHaveValue('test@example.com');

  await user.clear(input);

  await user.type(input, 'Price: $100.50');
  expect(input).toHaveValue('Price: $100.50');
});
```

### Typing com Delay

```javascript
test('digita lentamente', async () => {
  const user = userEvent.setup();

  render(<input type="text" />);

  // 100ms entre cada tecla (simula digita√ß√£o humana)
  await user.type(
    screen.getByRole('textbox'),
    'Hello',
    { delay: 100 }
  );

  expect(screen.getByRole('textbox')).toHaveValue('Hello');
});
```

---

## üìù Testando Formul√°rios

### Submit de Formul√°rio

```javascript
function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit({ email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={e => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}

test('submete formul√°rio com credenciais', async () => {
  const user = userEvent.setup();
  const handleSubmit = jest.fn();

  render(<LoginForm onSubmit={handleSubmit} />);

  await user.type(screen.getByPlaceholderText('Email'), 'test@test.com');
  await user.type(screen.getByPlaceholderText('Password'), 'password123');

  await user.click(screen.getByRole('button', { name: 'Login' }));

  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@test.com',
    password: 'password123'
  });
});
```

### Valida√ß√£o de Formul√°rio

```javascript
function ValidatedForm() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!email.includes('@')) {
      setError('Invalid email');
      return;
    }
    setError('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
        aria-label="Email"
      />
      {error && <p role="alert">{error}</p>}
      <button type="submit">Submit</button>
    </form>
  );
}

test('mostra erro com email inv√°lido', async () => {
  const user = userEvent.setup();

  render(<ValidatedForm />);

  await user.type(screen.getByRole('textbox'), 'invalid');
  await user.click(screen.getByRole('button', { name: 'Submit' }));

  expect(screen.getByRole('alert')).toHaveTextContent('Invalid email');
});

test('n√£o mostra erro com email v√°lido', async () => {
  const user = userEvent.setup();

  render(<ValidatedForm />);

  await user.type(screen.getByRole('textbox'), 'test@test.com');
  await user.click(screen.getByRole('button', { name: 'Submit' }));

  expect(screen.queryByRole('alert')).not.toBeInTheDocument();
});
```

---

## ‚úÖ Testando Checkboxes e Radios

### Checkbox

```javascript
function TermsCheckbox() {
  const [accepted, setAccepted] = useState(false);

  return (
    <div>
      <label>
        <input
          type="checkbox"
          checked={accepted}
          onChange={e => setAccepted(e.target.checked)}
        />
        Accept terms
      </label>
      <button disabled={!accepted}>Continue</button>
    </div>
  );
}

test('habilita bot√£o ao aceitar termos', async () => {
  const user = userEvent.setup();

  render(<TermsCheckbox />);

  const checkbox = screen.getByRole('checkbox', { name: 'Accept terms' });
  const button = screen.getByRole('button', { name: 'Continue' });

  expect(button).toBeDisabled();

  await user.click(checkbox);

  expect(checkbox).toBeChecked();
  expect(button).toBeEnabled();
});
```

### Radio Buttons

```javascript
function PaymentMethod() {
  const [method, setMethod] = useState('');

  return (
    <fieldset>
      <legend>Payment Method</legend>
      <label>
        <input
          type="radio"
          name="payment"
          value="card"
          checked={method === 'card'}
          onChange={e => setMethod(e.target.value)}
        />
        Credit Card
      </label>
      <label>
        <input
          type="radio"
          name="payment"
          value="paypal"
          checked={method === 'paypal'}
          onChange={e => setMethod(e.target.value)}
        />
        PayPal
      </label>
      <p>Selected: {method}</p>
    </fieldset>
  );
}

test('seleciona m√©todo de pagamento', async () => {
  const user = userEvent.setup();

  render(<PaymentMethod />);

  await user.click(screen.getByRole('radio', { name: 'Credit Card' }));

  expect(screen.getByRole('radio', { name: 'Credit Card' })).toBeChecked();
  expect(screen.getByText('Selected: card')).toBeInTheDocument();

  await user.click(screen.getByRole('radio', { name: 'PayPal' }));

  expect(screen.getByRole('radio', { name: 'PayPal' })).toBeChecked();
  expect(screen.getByRole('radio', { name: 'Credit Card' })).not.toBeChecked();
});
```

---

## üìã Testando Select/Dropdown

### Select B√°sico

```javascript
function CountrySelector() {
  const [country, setCountry] = useState('');

  return (
    <div>
      <label htmlFor="country">Country</label>
      <select
        id="country"
        value={country}
        onChange={e => setCountry(e.target.value)}
      >
        <option value="">Select...</option>
        <option value="us">United States</option>
        <option value="ca">Canada</option>
        <option value="mx">Mexico</option>
      </select>
      <p>Selected: {country}</p>
    </div>
  );
}

test('seleciona pa√≠s', async () => {
  const user = userEvent.setup();

  render(<CountrySelector />);

  const select = screen.getByLabelText('Country');

  await user.selectOptions(select, 'ca');

  expect(screen.getByRole('option', { name: 'Canada' })).toBeSelected();
  expect(screen.getByText('Selected: ca')).toBeInTheDocument();
});
```

### Select M√∫ltiplo

```javascript
test('seleciona m√∫ltiplas op√ß√µes', async () => {
  const user = userEvent.setup();

  render(
    <select multiple aria-label="Colors">
      <option value="red">Red</option>
      <option value="green">Green</option>
      <option value="blue">Blue</option>
    </select>
  );

  const select = screen.getByLabelText('Colors');

  await user.selectOptions(select, ['red', 'blue']);

  expect(screen.getByRole('option', { name: 'Red' })).toBeSelected();
  expect(screen.getByRole('option', { name: 'Blue' })).toBeSelected();
  expect(screen.getByRole('option', { name: 'Green' })).not.toBeSelected();
});
```

---

## ‚å®Ô∏è Testando Keyboard Navigation

### Tab Navigation

```javascript
test('navega com Tab', async () => {
  const user = userEvent.setup();

  render(
    <form>
      <input type="text" aria-label="First" />
      <input type="text" aria-label="Second" />
      <button type="submit">Submit</button>
    </form>
  );

  const first = screen.getByLabelText('First');
  const second = screen.getByLabelText('Second');
  const button = screen.getByRole('button');

  first.focus();
  expect(first).toHaveFocus();

  await user.keyboard('{Tab}');
  expect(second).toHaveFocus();

  await user.keyboard('{Tab}');
  expect(button).toHaveFocus();
});
```

### Enter para Submit

```javascript
test('submete com Enter', async () => {
  const user = userEvent.setup();
  const handleSubmit = jest.fn(e => e.preventDefault());

  render(
    <form onSubmit={handleSubmit}>
      <input type="text" aria-label="Search" />
    </form>
  );

  const input = screen.getByLabelText('Search');

  await user.type(input, 'query{Enter}');

  expect(handleSubmit).toHaveBeenCalled();
  expect(input).toHaveValue('query');
});
```

### Escape para Fechar

```javascript
function Modal({ onClose }) {
  useEffect(() => {
    const handler = (e) => {
      if (e.key === 'Escape') onClose();
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, [onClose]);

  return <div role="dialog">Modal content</div>;
}

test('fecha modal com Escape', async () => {
  const user = userEvent.setup();
  const handleClose = jest.fn();

  render(<Modal onClose={handleClose} />);

  await user.keyboard('{Escape}');

  expect(handleClose).toHaveBeenCalled();
});
```

---

## üîÑ Testando Estados de Loading

### Loading State

```javascript
function AsyncButton() {
  const [loading, setLoading] = useState(false);

  const handleClick = async () => {
    setLoading(true);
    await new Promise(r => setTimeout(r, 1000));
    setLoading(false);
  };

  return (
    <button onClick={handleClick} disabled={loading}>
      {loading ? 'Loading...' : 'Click me'}
    </button>
  );
}

test('mostra loading ao clicar', async () => {
  const user = userEvent.setup();

  render(<AsyncButton />);

  const button = screen.getByRole('button', { name: 'Click me' });

  await user.click(button);

  expect(screen.getByRole('button', { name: 'Loading...' })).toBeDisabled();

  await waitFor(() => {
    expect(screen.getByRole('button', { name: 'Click me' })).toBeEnabled();
  });
});
```

---

## üöÄ Conclus√£o

Testar Intera√ß√µes do Usu√°rio inclui:
- **Clicks**: userEvent.click, dblClick
- **Typing**: userEvent.type, clear
- **Forms**: submit, valida√ß√£o
- **Checkboxes/Radios**: toBeChecked
- **Select**: selectOptions, toBeSelected
- **Keyboard**: Tab, Enter, Escape
- **Async**: waitFor, findBy

Simular comportamento real garante que a aplica√ß√£o funciona como usu√°rios esperam, testando fluxos completos ao inv√©s de c√≥digo isolado.
