# Deferred Values no React 18+

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**useDeferredValue** √© um hook do React 18+ que permite **adiar a atualiza√ß√£o de um valor**, criando uma **vers√£o "atrasada"** que s√≥ atualiza quando UI est√° ociosa, mantendo **input responsivo** enquanto **atrasa renderiza√ß√µes custosas dependentes**. Conceitualmente, funciona como **debouncing visual autom√°tico** - o valor original atualiza imediatamente (para input responsivo), mas valor "deferred" atualiza com baixa prioridade (evitando travar UI durante processamento pesado).

Na ess√™ncia, `useDeferredValue` transforma um valor de **sempre s√≠ncrono** para **valor prim√°rio (urgente) + valor secund√°rio (n√£o-urgente)** - permitindo que componentes reajam instantaneamente ao valor fresco enquanto componentes pesados trabalham com valor atrasado.

### Contexto Hist√≥rico e Motiva√ß√£o

Antes do React 18, desenvolvedores usavam **debouncing manual**:

**Problema com debouncing tradicional**:

```jsx
// Debouncing manual - valor n√£o atualiza at√© delay
function Search() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);

    return () => clearTimeout(timer);
  }, [query]);

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <p>Buscando: {query}</p> {/* Atualiza imediatamente */}
      <Results query={debouncedQuery} /> {/* Espera 500ms */}
    </>
  );
}
```

**Limita√ß√µes**:
1. **Delay Fixo**: 500ms pode ser muito ou pouco
2. **Sem Prioriza√ß√£o**: React n√£o sabe que debouncedQuery √© menos urgente
3. **C√≥digo Extra**: Boilerplate com useEffect + setTimeout

**A solu√ß√£o React 18**: `useDeferredValue` - debouncing inteligente baseado em prioridade.

```jsx
// React 18 - debouncing autom√°tico
function Search() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  // deferredQuery atualiza quando UI est√° ociosa

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <p>Buscando: {query}</p> {/* Valor fresco */}
      <Results query={deferredQuery} /> {/* Valor atrasado */}
    </>
  );
}
```

### Problema Fundamental que Resolve

**1. Input Responsivo com Resultados Pesados**:

```jsx
// ‚ùå Sem useDeferredValue - input trava
function Search() {
  const [query, setQuery] = useState('');

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <ExpensiveResults query={query} />
      {/* Re-render pesado a cada keystroke - input trava */}
    </>
  );
}

// ‚úÖ Com useDeferredValue - input fluido
function Search() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <ExpensiveResults query={deferredQuery} />
      {/* Input atualiza imediatamente, results quando poss√≠vel */}
    </>
  );
}
```

**2. Debouncing Visual sem Delay Fixo**:

```jsx
// Tradicional: delay fixo (pode ser inadequado)
const [debounced] = useDebounce(value, 500); // Sempre 500ms

// useDeferredValue: delay adaptativo (baseado em carga)
const deferred = useDeferredValue(value);
// Atrasa apenas o necess√°rio - UI ociosa atualiza r√°pido
```

**3. Mostrar Conte√∫do Stale Durante Atualiza√ß√£o**:

```jsx
function Results({ query }) {
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;

  return (
    <div style={{ opacity: isStale ? 0.5 : 1 }}>
      {isStale && <div>Atualizando...</div>}
      <ExpensiveList query={deferredQuery} />
    </div>
  );
}
```

### Import√¢ncia no Ecossistema

`useDeferredValue` √© **essencial** para:

- **Search/Filter UIs**: Input responsivo com resultados pesados
- **Dashboards**: Atualizar gr√°ficos sem travar controles
- **Live Previews**: Editor de texto com preview custoso
- **Data Visualizations**: Atualizar visualiza√ß√µes complexas sem lag
- **Autocomplete**: Sugest√µes pesadas sem travar input

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Valor Atrasado**: Cria vers√£o do valor que atualiza com baixa prioridade
2. **Debouncing Autom√°tico**: React decide quanto atrasar baseado em carga
3. **Stale Detection**: Comparar valor original vs deferred para detectar "loading"
4. **Sem Delay Fixo**: N√£o tem timeout - atualiza quando UI ociosa
5. **Integra√ß√£o com Transitions**: Funciona com concurrent rendering

### Pilares Fundamentais

- **useDeferredValue(value)**: Hook que retorna vers√£o deferred do valor
- **Alta Prioridade**: Valor original atualiza normalmente
- **Baixa Prioridade**: Valor deferred atualiza quando poss√≠vel
- **Stale Indicator**: `value !== deferredValue` indica atualiza√ß√£o pendente
- **Interruptibilidade**: Update deferred pode ser interrompido

---

## üß† Fundamentos Te√≥ricos

### Como useDeferredValue Funciona Internamente

**Processo**:

```
1. Valor original muda (ex: query = "abc")
   ‚Üì
2. React agenda 2 updates:
   - Alta prioridade: Re-render com query = "abc"
   - Baixa prioridade: Re-render com deferredQuery = "abc"
   ‚Üì
3. React processa update de alta prioridade primeiro
   ‚Üí Input atualiza imediatamente
   ‚Üì
4. React processa update de baixa prioridade quando ociosa
   ‚Üí Results atualizam quando poss√≠vel
   ‚Üì
5. Se novo valor chega durante step 4:
   ‚Üí React abandona update antiga, agenda nova
```

**Compara√ß√£o com Transitions**:

```jsx
// useTransition: Controla QUANDO setState acontece
const [isPending, startTransition] = useTransition();
startTransition(() => {
  setQuery(newValue); // setState dentro de transition
});

// useDeferredValue: Controla QUANDO valor √© USADO
const deferredQuery = useDeferredValue(query);
// setState normal, mas uso do valor √© deferred
```

**Modelo Mental**:

```
setQuery("a")
  ‚Üì
query = "a" (imediato)
deferredQuery = "" (ainda antigo)
  ‚Üì
[React processa quando ociosa]
  ‚Üì
deferredQuery = "a" (atualizado)
```

---

## üîç An√°lise Conceitual Profunda

### Sintaxe B√°sica

```jsx
import { useDeferredValue } from 'react';

function Component() {
  const [value, setValue] = useState('');
  const deferredValue = useDeferredValue(value);

  // value: sempre atualizado (alta prioridade)
  // deferredValue: atualizado quando UI ociosa (baixa prioridade)

  return (
    <>
      <input value={value} onChange={e => setValue(e.target.value)} />
      <ExpensiveComponent value={deferredValue} />
    </>
  );
}
```

### Exemplo Completo: Search

```jsx
function SearchPage() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);

  // Detectar se est√° "stale" (desatualizado)
  const isStale = query !== deferredQuery;

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Buscar..."
      />

      <div style={{ opacity: isStale ? 0.5 : 1 }}>
        {isStale && <div className="loading">Atualizando...</div>}
        <SearchResults query={deferredQuery} />
      </div>
    </div>
  );
}

function SearchResults({ query }) {
  // Componente pesado - filtra 10.000 itens
  const results = useMemo(() => {
    return hugeDataset.filter(item =>
      item.name.toLowerCase().includes(query.toLowerCase())
    );
  }, [query]);

  return (
    <ul>
      {results.map(result => (
        <li key={result.id}>{result.name}</li>
      ))}
    </ul>
  );
}
```

**An√°lise**:
- `query`: Atualiza a cada keystroke (input responsivo)
- `deferredQuery`: Atualiza quando poss√≠vel (n√£o trava input)
- `isStale`: Detecta quando update est√° pendente (para mostrar loading)

### Stale Content Indicator

```jsx
function List({ items }) {
  const [filter, setFilter] = useState('');
  const deferredFilter = useDeferredValue(filter);

  const filteredItems = useMemo(() => {
    return items.filter(item => item.name.includes(deferredFilter));
  }, [items, deferredFilter]);

  const isStale = filter !== deferredFilter;

  return (
    <div>
      <input value={filter} onChange={e => setFilter(e.target.value)} />

      <div className={isStale ? 'stale' : ''}>
        {isStale && <Spinner />}
        {filteredItems.map(item => (
          <div key={item.id}>{item.name}</div>
        ))}
      </div>
    </div>
  );
}
```

### useDeferredValue com Objeto

```jsx
function Dashboard() {
  const [filters, setFilters] = useState({
    name: '',
    category: 'all',
    priceRange: [0, 1000]
  });

  const deferredFilters = useDeferredValue(filters);

  return (
    <div>
      <FiltersPanel filters={filters} onChange={setFilters} />
      <ExpensiveChart filters={deferredFilters} />
    </div>
  );
}
```

**Nota**: Funciona com qualquer valor (primitivos, objetos, arrays).

### Compara√ß√£o: useDeferredValue vs useTransition

#### useDeferredValue

```jsx
function Search() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <Results query={deferredQuery} />
    </>
  );
}
```

**Caracter√≠sticas**:
- Valor deferred automaticamente
- N√£o precisa envolver setState
- Melhor quando voc√™ **n√£o controla** o setState (props, contexto)

#### useTransition

```jsx
function Search() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    setQuery(e.target.value);

    startTransition(() => {
      setResults(filterData(e.target.value));
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      {isPending && <Spinner />}
      <Results data={results} />
    </>
  );
}
```

**Caracter√≠sticas**:
- Controla setState explicitamente
- `isPending` para feedback
- Melhor quando voc√™ **controla** o setState

**Quando Usar Cada Um**:

```jsx
// useDeferredValue: Valor vem de props/contexto
function Child({ externalValue }) {
  const deferred = useDeferredValue(externalValue);
  return <Expensive value={deferred} />;
}

// useTransition: Voc√™ controla o setState
function Parent() {
  const [value, setValue] = useState('');
  const [isPending, startTransition] = useTransition();

  const update = (newValue) => {
    startTransition(() => setValue(newValue));
  };

  return <input onChange={e => update(e.target.value)} />;
}
```

### Casos de Uso Avan√ßados

#### 1. Autocomplete

```jsx
function Autocomplete() {
  const [input, setInput] = useState('');
  const deferredInput = useDeferredValue(input);

  const suggestions = useMemo(() => {
    if (deferredInput.length < 2) return [];

    return database.filter(item =>
      item.startsWith(deferredInput)
    ).slice(0, 10);
  }, [deferredInput]);

  const isSearching = input !== deferredInput;

  return (
    <div>
      <input
        value={input}
        onChange={e => setInput(e.target.value)}
      />

      {isSearching && <div>Buscando...</div>}

      <ul>
        {suggestions.map(s => (
          <li key={s}>{s}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### 2. Live Preview Editor

```jsx
function CodeEditor() {
  const [code, setCode] = useState('');
  const deferredCode = useDeferredValue(code);

  return (
    <div className="editor-layout">
      <textarea
        value={code}
        onChange={e => setCode(e.target.value)}
      />

      <div className="preview">
        <CodePreview code={deferredCode} />
        {/* Preview n√£o trava digita√ß√£o */}
      </div>
    </div>
  );
}
```

#### 3. Dashboard com Gr√°ficos

```jsx
function Dashboard() {
  const [dateRange, setDateRange] = useState({ start: '2024-01-01', end: '2024-12-31' });
  const deferredRange = useDeferredValue(dateRange);

  return (
    <div>
      <DateRangePicker value={dateRange} onChange={setDateRange} />
      {/* Picker responsivo */}

      <ExpensiveChart dateRange={deferredRange} />
      {/* Chart atualiza quando poss√≠vel */}
    </div>
  );
}
```

#### 4. Filtros M√∫ltiplos

```jsx
function ProductList() {
  const [filters, setFilters] = useState({
    search: '',
    category: 'all',
    minPrice: 0,
    maxPrice: 1000
  });

  const deferredFilters = useDeferredValue(filters);
  const isFiltering = filters !== deferredFilters;

  const products = useMemo(() => {
    return allProducts.filter(product => {
      const matchesSearch = product.name.includes(deferredFilters.search);
      const matchesCategory = deferredFilters.category === 'all' ||
                               product.category === deferredFilters.category;
      const matchesPrice = product.price >= deferredFilters.minPrice &&
                           product.price <= deferredFilters.maxPrice;

      return matchesSearch && matchesCategory && matchesPrice;
    });
  }, [deferredFilters]);

  return (
    <div>
      <FiltersPanel filters={filters} onChange={setFilters} />

      <div style={{ opacity: isFiltering ? 0.6 : 1 }}>
        {isFiltering && <LoadingOverlay />}
        <ProductGrid products={products} />
      </div>
    </div>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar useDeferredValue

#### 1. Search/Filter com Grandes Datasets

```jsx
// SEMPRE use para buscas/filtros pesados
const deferredQuery = useDeferredValue(query);
```

#### 2. Valor Vem de Props/Contexto

```jsx
// Quando n√£o controla o setState
function Child({ externalValue }) {
  const deferred = useDeferredValue(externalValue);
  // ...
}
```

#### 3. Componente Pesado que Depende de Input

```jsx
// Preview, visualiza√ß√£o, gr√°ficos
const deferredInput = useDeferredValue(userInput);
<ExpensiveVisualization data={deferredInput} />
```

### Quando N√ÉO Usar

#### 1. Voc√™ Controla o setState (Use useTransition)

```jsx
// ‚ùå useDeferredValue desnecess√°rio
const deferred = useDeferredValue(state);

// ‚úÖ useTransition √© melhor
startTransition(() => setState(newValue));
```

#### 2. Componente J√° √â R√°pido

```jsx
// Desnecess√°rio se render √© r√°pido
const deferred = useDeferredValue(simpleValue);
<FastComponent value={deferred} />
```

#### 3. Delay Fixo √â Requerido

```jsx
// Se precisa exatamente 500ms, use debounce tradicional
const debounced = useDebounce(value, 500);
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes

#### 1. N√£o √â Debouncing com Delay Fixo

```jsx
// useDeferredValue: delay adaptativo (pode ser 0ms ou 500ms)
const deferred = useDeferredValue(value);

// Se precisar delay garantido, use debounce manual
const [debounced, setDebounced] = useState(value);
useEffect(() => {
  const timer = setTimeout(() => setDebounced(value), 500);
  return () => clearTimeout(timer);
}, [value]);
```

#### 2. Requer Concurrent Mode

```jsx
// S√≥ funciona com createRoot (React 18+)
const root = createRoot(document.getElementById('root'));
root.render(<App />);

// N√£o funciona com ReactDOM.render (legado)
ReactDOM.render(<App />, document.getElementById('root'));
```

#### 3. Value Deve Ser Compar√°vel

```jsx
// ‚úÖ Primitivos - compara√ß√£o funciona
const deferredString = useDeferredValue(str);
const deferredNumber = useDeferredValue(num);

// ‚ö†Ô∏è Objetos - compara√ß√£o por refer√™ncia
const deferredObj = useDeferredValue(obj);
// obj !== deferredObj mesmo se conte√∫do igual
```

---

## üîó Interconex√µes Conceituais

### useDeferredValue + useMemo

```jsx
function Component({ query }) {
  const deferredQuery = useDeferredValue(query);

  // useMemo previne rec√°lculo desnecess√°rio
  const results = useMemo(() => {
    return heavyComputation(deferredQuery);
  }, [deferredQuery]);

  return <Results data={results} />;
}
```

### useDeferredValue + Suspense

```jsx
function DataComponent({ query }) {
  const deferredQuery = useDeferredValue(query);

  return (
    <Suspense fallback={<Spinner />}>
      <LazyResults query={deferredQuery} />
    </Suspense>
  );
}
```

### useDeferredValue + Context

```jsx
const FilterContext = createContext();

function FilterProvider({ children }) {
  const [filter, setFilter] = useState('');
  const deferredFilter = useDeferredValue(filter);

  return (
    <FilterContext.Provider value={{ filter, deferredFilter, setFilter }}>
      {children}
    </FilterContext.Provider>
  );
}

// Consumidor
function ExpensiveList() {
  const { deferredFilter } = useContext(FilterContext);
  // Usa valor deferred
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

useDeferredValue prepara para:

1. **Suspense Avan√ßado** (20.4): Deferred values com data fetching
2. **Performance** (M√≥dulo 14): Otimiza√ß√µes com debouncing
3. **Server Components** (M√≥dulo 21): Deferred values em RSC
4. **Custom Hooks** (M√≥dulo 8): `useDebounce` customizado

### Padr√µes de Constru√ß√£o

useDeferredValue √© **base** para:
- Search UIs responsivas
- Live previews
- Dashboard filters
- Data visualizations interativas

---

## üéØ Conclus√£o

useDeferredValue √© **ferramenta essencial** para inputs responsivos:

**Conceito Central**: Criar vers√£o "atrasada" de valor que atualiza com baixa prioridade.

**Principais Benef√≠cios**:
- Input sempre fluido
- Debouncing autom√°tico (sem delay fixo)
- Stale detection (`value !== deferredValue`)
- Integra√ß√£o com concurrent rendering

**Quando Usar**:
- Search/filter com datasets grandes
- Valor vem de props/contexto
- Componentes pesados dependentes de input

**vs useTransition**:
- `useDeferredValue`: Quando **n√£o** controla setState
- `useTransition`: Quando **controla** setState

**Limita√ß√µes**: N√£o √© delay fixo, requer concurrent mode, compara√ß√£o por refer√™ncia em objetos.

useDeferredValue transforma inputs de **trava durante digita√ß√£o** para **sempre responsivo** - essencial para construir UIs fluidas com opera√ß√µes pesadas. Debouncing inteligente baseado em carga da UI ao inv√©s de timeouts arbitr√°rios.
