# Transitions no React 18+

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Transitions** s√£o uma API do React 18+ que permite **marcar atualiza√ß√µes de estado como n√£o-urgentes**, indicando que podem ser **interrompidas por atualiza√ß√µes mais urgentes**, mantendo UI **responsiva durante opera√ß√µes pesadas**. Conceitualmente, representam uma **declara√ß√£o de prioridade** - separar updates cr√≠ticos (input do usu√°rio, hover) de updates secund√°rios (filtrar lista, carregar conte√∫do), permitindo que React otimize experi√™ncia do usu√°rio adiando renderiza√ß√µes custosas que podem esperar.

Na ess√™ncia, Transitions transformam updates de **tudo urgente por padr√£o** para **urgente vs n√£o-urgente expl√≠cito** - dando controle fino sobre o que deve bloquear UI e o que pode renderizar progressivamente.

### Contexto Hist√≥rico e Motiva√ß√£o

Antes do React 18, **todos** updates tinham mesma prioridade:

**Problema**:

```jsx
// React 17 - tudo bloqueante
function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    setQuery(e.target.value);  // Urgente - usu√°rio digitando

    // Filtrar 10.000 itens - pesado, mas trava input!
    setResults(
      bigDataset.filter(item => item.name.includes(e.target.value))
    );
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      {results.map(r => <div key={r.id}>{r.name}</div>)}
    </>
  );
}
// Input "trava" enquanto filtra - p√©ssima UX
```

**A solu√ß√£o React 18**: Transitions - marcar `setResults` como n√£o-urgente.

```jsx
// React 18 - com transition
const handleChange = (e) => {
  setQuery(e.target.value);  // Urgente - alta prioridade

  startTransition(() => {
    setResults(
      bigDataset.filter(item => item.name.includes(e.target.value))
    );  // N√£o-urgente - baixa prioridade, pode ser interrompido
  });
};
// Input responsivo, resultados atualizam quando poss√≠vel
```

### Problema Fundamental que Resolve

**1. Input Responsivo Durante Opera√ß√µes Pesadas**:

```jsx
// ‚ùå Sem transition - input trava
function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);

  const handleChange = (e) => {
    setInput(e.target.value);
    setList(generateHugeList(e.target.value)); // Bloqueante!
  };

  return <input value={input} onChange={handleChange} />;
}

// ‚úÖ Com transition - input fluido
function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);

  const handleChange = (e) => {
    setInput(e.target.value); // Alta prioridade

    startTransition(() => {
      setList(generateHugeList(e.target.value)); // Baixa prioridade
    });
  };

  return <input value={input} onChange={handleChange} />;
}
```

**2. Feedback de Pending State**:

```jsx
function TabContainer() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState('home');

  const switchTab = (newTab) => {
    startTransition(() => {
      setTab(newTab);
    });
  };

  return (
    <>
      <button onClick={() => switchTab('profile')}>
        Profile {isPending && '(loading...)'} {/* Feedback visual */}
      </button>

      {tab === 'profile' && <ExpensiveProfileContent />}
    </>
  );
}
```

**3. Navega√ß√£o N√£o-Bloqueante**:

```jsx
// Navega√ß√£o entre rotas pesadas
function App() {
  const [isPending, startTransition] = useTransition();
  const navigate = useNavigate();

  const goToRoute = (path) => {
    startTransition(() => {
      navigate(path); // N√£o trava clique
    });
  };

  return (
    <button onClick={() => goToRoute('/dashboard')}>
      Dashboard {isPending && <Spinner />}
    </button>
  );
}
```

### Import√¢ncia no Ecossistema

Transitions s√£o **essenciais** para:

- **UX Responsiva**: Inputs fluidos durante opera√ß√µes pesadas
- **Grandes Datasets**: Filtros, buscas em listas longas
- **Navega√ß√£o**: Troca de rotas sem travar cliques
- **Loading States**: Feedback visual durante opera√ß√µes n√£o-urgentes
- **Progressive Enhancement**: Renderiza√ß√£o incremental de conte√∫do

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Marca√ß√£o de Prioridade**: Distinguir updates urgentes de n√£o-urgentes
2. **Interruptibilidade**: Transitions podem ser pausadas/abandonadas
3. **Pending State**: `isPending` indica que transition est√° em andamento
4. **Duas APIs**: `useTransition` (hook) e `startTransition` (fun√ß√£o standalone)
5. **Opt-in**: Deve marcar explicitamente como transition

### Pilares Fundamentais

- **useTransition()**: Hook que retorna `[isPending, startTransition]`
- **startTransition(callback)**: Fun√ß√£o standalone para marcar updates
- **isPending**: Boolean indicando se transition est√° processando
- **Prioridade Baixa**: Updates dentro de transition t√™m baixa prioridade
- **Interrup√ß√£o**: Transitions podem ser interrompidas por updates urgentes

---

## üß† Fundamentos Te√≥ricos

### Como Transitions Funcionam Internamente

**Modelo de Prioridades**:

```
Alta Prioridade (Urgente):
- Updates diretos (setState fora de transition)
- Input do usu√°rio (digitar, clicar)
- Eventos s√≠ncronos

Baixa Prioridade (N√£o-urgente):
- Updates dentro de startTransition()
- Podem ser pausados/abandonados
- Renderizam quando UI est√° ociosa
```

**Processo Interno**:

```
1. setState urgente (setInput)
   ‚Üí React agenda render de alta prioridade
   ‚Üí Executa imediatamente

2. startTransition(() => setList(...))
   ‚Üí React agenda render de baixa prioridade
   ‚Üí Executa quando poss√≠vel

3. Se novo update urgente chega durante transition:
   ‚Üí React pausa transition
   ‚Üí Processa update urgente
   ‚Üí Resume (ou abandona) transition
```

**Visualiza√ß√£o**:

```
Usu√°rio digita "a" ‚Üí "ab" ‚Üí "abc"

Sem transition:
[render "a"] [render "ab"] [render "abc"]
  200ms       200ms         200ms
(UI trava 600ms total)

Com transition:
setQuery("a") [render query] ‚Üê Imediato
startTransition setList     [render list "a"]
  ‚Üì
setQuery("ab") [render query] ‚Üê Interrompe transition anterior
startTransition setList     [render list "ab"]
  ‚Üì
setQuery("abc") [render query] ‚Üê Interrompe novamente
startTransition setList     [render list "abc"]

Query sempre atualiza rapidamente, list quando poss√≠vel
```

---

## üîç An√°lise Conceitual Profunda

### useTransition Hook

#### Sintaxe B√°sica

```jsx
import { useTransition } from 'react';

function Component() {
  const [isPending, startTransition] = useTransition();

  // isPending: boolean - true durante transition
  // startTransition: fun√ß√£o para marcar updates como n√£o-urgentes

  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={() => {
        startTransition(() => {
          // Updates n√£o-urgentes aqui
        });
      }}>
        Action
      </button>
    </div>
  );
}
```

#### Exemplo Completo: Search com Feedback

```jsx
function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleSearch = (e) => {
    const value = e.target.value;

    // Urgente - atualizar input imediatamente
    setQuery(value);

    // N√£o-urgente - pesquisa pode esperar
    startTransition(() => {
      const filtered = hugeDataset.filter(item =>
        item.name.toLowerCase().includes(value.toLowerCase())
      );
      setResults(filtered);
    });
  };

  return (
    <div>
      <input
        value={query}
        onChange={handleSearch}
        placeholder="Buscar..."
      />

      {isPending && <div>Buscando...</div>}

      <ul>
        {results.map(result => (
          <li key={result.id}>{result.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**An√°lise**:
- `setQuery`: Alta prioridade - input sempre responsivo
- `setResults`: Baixa prioridade (transition) - pode atrasar
- `isPending`: Mostra "Buscando..." enquanto filtra

### startTransition Standalone

#### Quando Usar

```jsx
import { startTransition } from 'react';

// Fora de componente (sem hook)
function handleGlobalAction() {
  startTransition(() => {
    store.dispatch(updateAction());
  });
}

// Dentro de componente sem precisar de isPending
function Component() {
  const handleClick = () => {
    startTransition(() => {
      setData(heavyComputation());
    });
  };

  return <button onClick={handleClick}>Update</button>;
}
```

**Diferen√ßa**: `startTransition` standalone n√£o fornece `isPending` - use quando n√£o precisa de feedback visual.

### Casos de Uso Avan√ßados

#### 1. Tabs com Loading State

```jsx
function TabContainer() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState('posts');

  return (
    <div>
      <button
        onClick={() => {
          startTransition(() => {
            setTab('posts');
          });
        }}
        disabled={isPending && tab !== 'posts'}
      >
        Posts
      </button>

      <button
        onClick={() => {
          startTransition(() => {
            setTab('comments');
          });
        }}
        disabled={isPending && tab !== 'comments'}
      >
        Comments {isPending && tab === 'comments' && '‚è≥'}
      </button>

      {tab === 'posts' && <PostsContent />}
      {tab === 'comments' && <CommentsContent />}
    </div>
  );
}
```

#### 2. Filtros M√∫ltiplos

```jsx
function FilteredList({ data }) {
  const [nameFilter, setNameFilter] = useState('');
  const [categoryFilter, setCategoryFilter] = useState('all');
  const [filteredData, setFilteredData] = useState(data);
  const [isPending, startTransition] = useTransition();

  const applyFilters = (name, category) => {
    startTransition(() => {
      const filtered = data.filter(item => {
        const matchesName = item.name.includes(name);
        const matchesCategory = category === 'all' || item.category === category;
        return matchesName && matchesCategory;
      });
      setFilteredData(filtered);
    });
  };

  const handleNameChange = (e) => {
    const value = e.target.value;
    setNameFilter(value);
    applyFilters(value, categoryFilter);
  };

  const handleCategoryChange = (e) => {
    const value = e.target.value;
    setCategoryFilter(value);
    applyFilters(nameFilter, value);
  };

  return (
    <div>
      <input value={nameFilter} onChange={handleNameChange} />
      <select value={categoryFilter} onChange={handleCategoryChange}>
        <option value="all">Todas</option>
        <option value="tech">Tech</option>
        <option value="food">Food</option>
      </select>

      {isPending && <div>Filtrando...</div>}

      <List items={filteredData} />
    </div>
  );
}
```

#### 3. Navega√ß√£o com Router

```jsx
import { useNavigate } from 'react-router-dom';

function Navigation() {
  const [isPending, startTransition] = useTransition();
  const navigate = useNavigate();

  const navigateTo = (path) => {
    startTransition(() => {
      navigate(path);
    });
  };

  return (
    <nav>
      <button onClick={() => navigateTo('/dashboard')}>
        Dashboard {isPending && <Spinner />}
      </button>

      <button onClick={() => navigateTo('/profile')}>
        Profile {isPending && <Spinner />}
      </button>
    </nav>
  );
}
```

#### 4. Ordena√ß√£o de Lista

```jsx
function SortableList({ items }) {
  const [sortedItems, setSortedItems] = useState(items);
  const [isPending, startTransition] = useTransition();

  const sortBy = (key) => {
    startTransition(() => {
      const sorted = [...items].sort((a, b) => {
        if (a[key] < b[key]) return -1;
        if (a[key] > b[key]) return 1;
        return 0;
      });
      setSortedItems(sorted);
    });
  };

  return (
    <div>
      <button onClick={() => sortBy('name')}>
        Ordenar por Nome
      </button>
      <button onClick={() => sortBy('date')}>
        Ordenar por Data
      </button>

      {isPending && <div className="loading-overlay">Ordenando...</div>}

      {sortedItems.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

### M√∫ltiplas Transitions

```jsx
function Component() {
  const [isPending1, startTransition1] = useTransition();
  const [isPending2, startTransition2] = useTransition();

  const action1 = () => {
    startTransition1(() => {
      // Transition 1
    });
  };

  const action2 = () => {
    startTransition2(() => {
      // Transition 2
    });
  };

  return (
    <>
      <button onClick={action1}>
        Action 1 {isPending1 && '‚è≥'}
      </button>
      <button onClick={action2}>
        Action 2 {isPending2 && '‚è≥'}
      </button>
    </>
  );
}
```

**Conceito**: Cada `useTransition` rastreia seu pr√≥prio pending state.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Transitions

#### 1. Input de Busca/Filtro

```jsx
// SEMPRE use transition para filtros que processam grandes datasets
const handleSearch = (value) => {
  setQuery(value); // Urgente

  startTransition(() => {
    setResults(filterLargeDataset(value)); // N√£o-urgente
  });
};
```

#### 2. Navega√ß√£o entre Tabs

```jsx
// Tabs com conte√∫do pesado
const switchTab = (tab) => {
  startTransition(() => {
    setActiveTab(tab);
  });
};
```

#### 3. Renderiza√ß√£o Condicional Pesada

```jsx
// Mostrar/ocultar componente pesado
const toggleView = () => {
  startTransition(() => {
    setShowExpensiveComponent(prev => !prev);
  });
};
```

### Quando N√ÉO Usar

#### 1. Updates que Devem ser Imediatos

```jsx
// ‚ùå N√£o usar transition para formul√°rios cr√≠ticos
const handleSubmit = () => {
  // Deve ser imediato, n√£o pode atrasar
  submitForm();
};

// ‚ùå N√£o usar para anima√ß√µes cr√≠ticas
const handleHover = () => {
  setIsHovered(true); // Deve ser instant√¢neo
};
```

#### 2. Componentes J√° R√°pidos

```jsx
// Desnecess√°rio se render √© r√°pido
const handleClick = () => {
  // Lista pequena - n√£o precisa transition
  setItems([1, 2, 3]);
};
```

#### 3. Controlled Inputs Simples

```jsx
// ‚ùå N√£o usar transition no pr√≥prio input
const handleChange = (e) => {
  startTransition(() => {
    setValue(e.target.value); // Input fica "atrasado"!
  });
};

// ‚úÖ Input urgente, consequ√™ncias n√£o-urgentes
const handleChange = (e) => {
  setValue(e.target.value); // Urgente

  startTransition(() => {
    updateDependentData(e.target.value); // N√£o-urgente
  });
};
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes

#### 1. Apenas setState Dentro

```jsx
// ‚úÖ Correto - setState dentro de transition
startTransition(() => {
  setData(newData);
});

// ‚ùå Errado - side effects diretos
startTransition(() => {
  console.log('log'); // N√£o faz sentido
  fetchData(); // N√£o afeta prioridade de fetch
});
```

#### 2. N√£o Controla C√≥digo S√≠ncrono

```jsx
// Transition n√£o torna c√≥digo s√≠ncrono "n√£o-bloqueante"
startTransition(() => {
  // Este loop AINDA bloqueia thread
  for (let i = 0; i < 1000000; i++) {
    console.log(i);
  }

  setData(result);
});
```

**Conceito**: Transition afeta **prioridade de renderiza√ß√£o**, n√£o execu√ß√£o de c√≥digo JavaScript.

#### 3. Transitions Podem Ser Abandonadas

```jsx
function Component() {
  const [count, setCount] = useState(0);

  const slowUpdate = () => {
    startTransition(() => {
      setCount(c => c + 1);
    });
  };

  const fastUpdate = () => {
    setCount(c => c + 100); // Alta prioridade
  };

  // Se fastUpdate √© chamado durante transition,
  // transition pode ser abandonada (count n√£o incrementa +1)
}
```

---

## üîó Interconex√µes Conceituais

### Transitions + useDeferredValue

```jsx
function Search() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  // Alternativa a transition para "defer" valor

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <Results query={deferredQuery} />
    </>
  );
}
```

**Diferen√ßa**:
- `useTransition`: Controla **quando setState acontece**
- `useDeferredValue`: Controla **quando valor √© usado**

### Transitions + Suspense

```jsx
function Component() {
  const [isPending, startTransition] = useTransition();
  const [resource, setResource] = useState(initialResource);

  const loadData = () => {
    startTransition(() => {
      setResource(fetchNewData()); // Retorna Suspense resource
    });
  };

  return (
    <Suspense fallback={<Spinner />}>
      {isPending && <InlineSpinner />}
      <DataComponent resource={resource} />
    </Suspense>
  );
}
```

### Transitions + Error Boundaries

```jsx
<ErrorBoundary fallback={<ErrorUI />}>
  <Component />
  {/* Erros em transitions tamb√©m s√£o capturados */}
</ErrorBoundary>
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Transitions preparam para:

1. **Deferred Values** (20.3): `useDeferredValue` para debouncing visual
2. **Suspense Avan√ßado** (20.4): Transitions com data fetching
3. **Server Components** (M√≥dulo 21): Navigation transitions em RSC
4. **Performance** (M√≥dulo 14): Otimiza√ß√µes com transitions

### Padr√µes de Constru√ß√£o

Transitions s√£o **base** para:
- Interfaces responsivas com grandes datasets
- Navega√ß√£o fluida entre rotas
- Busca/filtros em tempo real
- Loading states sofisticados

---

## üéØ Conclus√£o

Transitions s√£o **ferramenta essencial** para UX responsiva:

**Conceito Central**: Marcar updates como n√£o-urgentes, permitindo que React priorize input do usu√°rio.

**Principais Benef√≠cios**:
- Input sempre responsivo
- Feedback visual com `isPending`
- Interrup√ß√£o autom√°tica de trabalho antigo
- Renderiza√ß√£o progressiva

**APIs**:
- `useTransition()`: Hook com `isPending` feedback
- `startTransition()`: Fun√ß√£o standalone

**Quando Usar**: Filtros, buscas, navega√ß√£o, qualquer update pesado que n√£o precisa ser imediato.

**Limita√ß√µes**: Apenas para setState, n√£o torna c√≥digo s√≠ncrono n√£o-bloqueante, transitions podem ser abandonadas.

Transitions transformam React de **tudo urgente** para **prioridades expl√≠citas** - essencial para construir interfaces que permanecem fluidas mesmo processando opera√ß√µes custosas. Marcar corretamente urgente vs n√£o-urgente √© chave para excelente UX em aplica√ß√µes modernas.
