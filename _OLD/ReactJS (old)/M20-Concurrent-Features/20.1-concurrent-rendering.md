# Concurrent Rendering no React 18+

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Concurrent Rendering** √© uma arquitetura fundamental do React 18+ que permite ao React **interromper, pausar, resumir ou abandonar** renderiza√ß√µes em progresso, possibilitando que a UI permane√ßa **responsiva durante atualiza√ß√µes pesadas**. Conceitualmente, representa a transforma√ß√£o de renderiza√ß√£o de **s√≠ncrona e bloqueante** para **ass√≠ncrona e interrupt√≠vel** - permitindo que React priorize atualiza√ß√µes urgentes (input do usu√°rio) sobre n√£o-urgentes (atualiza√ß√£o de lista longa), mantendo interface fluida mesmo durante opera√ß√µes custosas.

Na ess√™ncia, Concurrent Rendering trata React como um **sistema operacional de UI** - com scheduler que gerencia prioridades, time-slicing que divide trabalho em chunks, e capacidade de "preempt" (interromper) tarefas de baixa prioridade para atender tarefas urgentes.

### Contexto Hist√≥rico e Motiva√ß√£o

Antes do React 18 (mar√ßo 2022), renderiza√ß√£o era **s√≠ncrona e bloqueante**:

**Problemas do modelo s√≠ncrono**:

1. **Blocking Renders**: Atualiza√ß√£o pesada travava UI completamente
2. **Input Lag**: Digitar em input durante render pesado ficava "travado"
3. **Janky Animations**: Anima√ß√µes travavam durante re-renders
4. **Tudo ou Nada**: Render iniciado tinha que completar - sem prioriza√ß√£o

**Exemplo do problema**:

```jsx
// React 17 - render bloqueante
function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);

  const handleChange = (e) => {
    setInput(e.target.value);

    // Gera lista de 10.000 itens (pesado!)
    const newList = Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      text: e.target.value + i
    }));
    setList(newList);
  };

  return (
    <>
      <input value={input} onChange={handleChange} />
      {/* Renderizar 10k itens trava input! */}
      {list.map(item => <div key={item.id}>{item.text}</div>)}
    </>
  );
}
// Digitar fica "travado" - input n√£o atualiza at√© render completar
```

**A solu√ß√£o React 18**: Concurrent Rendering - permite interromper render pesado (lista) para atualizar input imediatamente.

### Problema Fundamental que Resolve

**1. UI Responsiva Durante Renders Pesados**:

```jsx
// React 18 - Concurrent Mode
function App() {
  const [input, setInput] = useState('');
  const [list, setList] = useState([]);

  const handleChange = (e) => {
    // Atualiza√ß√£o urgente (input) - alta prioridade
    setInput(e.target.value);

    // Atualiza√ß√£o n√£o-urgente (lista) - baixa prioridade
    startTransition(() => {
      const newList = Array.from({ length: 10000 }, (_, i) => ({
        id: i,
        text: e.target.value + i
      }));
      setList(newList);
    });
  };

  return (
    <>
      <input value={input} onChange={handleChange} />
      {list.map(item => <div key={item.id}>{item.text}</div>)}
    </>
  );
}
// Input atualiza instantaneamente, lista atualiza quando poss√≠vel
```

**2. Prioriza√ß√£o Inteligente**:

```
Updates urgentes (alta prioridade):
- Input do usu√°rio (digitar, clicar)
- Hover, focus
- Anima√ß√µes cr√≠ticas

Updates n√£o-urgentes (baixa prioridade):
- Atualiza√ß√£o de lista
- Carregar mais dados
- Analytics, logging
```

**3. Time-Slicing (Fatiar Trabalho)**:

```
Render tradicional (bloqueante):
[========================================] 200ms (UI travada)

Concurrent Rendering (interrupt√≠vel):
[====]  [====]  [====]  [====]  [====]  200ms total
  ‚Üë       ‚Üë       ‚Üë       ‚Üë       ‚Üë
  5ms    5ms     5ms     5ms     5ms
Entre chunks: UI pode responder a inputs
```

### Import√¢ncia no Ecossistema

Concurrent Rendering √© **base** para:

- **Transitions API**: `useTransition`, `startTransition`
- **Deferred Values**: `useDeferredValue`
- **Suspense Avan√ßado**: Streaming SSR, Selective Hydration
- **Server Components**: Renderiza√ß√£o progressiva
- **Future Features**: React Forget (auto-memoization compiler)

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Renderiza√ß√£o Interrupt√≠vel**: React pode pausar, resumir ou abandonar renders
2. **Prioriza√ß√£o de Updates**: Urgentes (alta prioridade) vs n√£o-urgentes (baixa)
3. **Time-Slicing**: Trabalho dividido em pequenos chunks
4. **Batching Autom√°tico**: M√∫ltiplos setState agrupados automaticamente
5. **Opt-in Gradual**: Concurrent features s√£o opt-in (n√£o breaking change)

### Pilares Fundamentais

- **Concurrent Mode**: Modo habilitado via `createRoot` (React 18+)
- **Scheduler**: Sistema interno de prioriza√ß√£o de tarefas
- **Lanes**: Modelo de prioridades (substituiu `expirationTime`)
- **Work Loop**: Loop interrupt√≠vel de processamento de updates
- **Idle Callback**: Aproveita tempo ocioso do navegador

---

## üß† Fundamentos Te√≥ricos

### Como Concurrent Rendering Funciona Internamente

**Arquitetura de Fases**:

```
1. Trigger (setState)
   ‚Üì
2. Schedule (adicionar update √† fila com prioridade)
   ‚Üì
3. Render (interrupt√≠vel - pode pausar)
   ‚Üì
4. Commit (s√≠ncrono - n√£o pode pausar)
   ‚Üì
5. Paint (navegador renderiza pixels)
```

**Diferen√ßa chave**:

```
React 17:
Render: [================] (bloqueante, deve completar)
Commit: [====]

React 18 Concurrent:
Render: [===] pause [===] pause [===] (interrupt√≠vel)
Commit: [====] (ainda s√≠ncrono)
```

**Prioridades (Lanes)**:

```
Prioridade mais alta ‚Üí mais baixa:

SyncLane          - Render s√≠ncrono (legacy)
InputContinuousLane - Input do usu√°rio (digitar, arrastar)
DefaultLane       - Cliques, navega√ß√£o
TransitionLane    - Transitions (startTransition)
IdleLane          - Trabalho de baix√≠ssima prioridade
```

### Batching Autom√°tico (React 18)

**Antes (React 17)**:

```jsx
function handleClick() {
  setCount(c => c + 1);  // Re-render
  setFlag(f => !f);      // Re-render
  // 2 re-renders!
}

// Dentro de Promise - N√ÉO batched
fetch('/api').then(() => {
  setCount(c => c + 1);  // Re-render
  setFlag(f => !f);      // Re-render
  // 2 re-renders!
});
```

**React 18 (Concurrent)**:

```jsx
function handleClick() {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 1 re-render (batched automaticamente)
}

// Agora batched em TODOS os contextos
fetch('/api').then(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 1 re-render (batched!)
});

setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 1 re-render (batched!)
}, 1000);
```

**Conceito**: React 18 agrupa (batch) todas atualiza√ß√µes de estado, n√£o importa onde ocorrem.

---

## üîç An√°lise Conceitual Profunda

### Habilitando Concurrent Mode

#### React 17 (Legacy Root)

```jsx
import ReactDOM from 'react-dom';

// Legacy root - modo s√≠ncrono
ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```

#### React 18 (Concurrent Root)

```jsx
import { createRoot } from 'react-dom/client';

// Concurrent root - habilita concurrent features
const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

**Mudan√ßa**: `createRoot` ao inv√©s de `ReactDOM.render` - habilita concurrent mode.

### Demonstra√ß√£o de Interruptibilidade

```jsx
function App() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);

  const handleClick = () => {
    // Update urgente - alta prioridade
    setCount(c => c + 1);

    // Update n√£o-urgente - pode ser interrompido
    startTransition(() => {
      setItems(
        Array.from({ length: 20000 }, (_, i) => `Item ${i}`)
      );
    });
  };

  return (
    <div>
      <button onClick={handleClick}>
        Clicked: {count}
      </button>

      {/* Renderiza√ß√£o pesada, mas n√£o trava bot√£o */}
      {items.map(item => (
        <div key={item}>{item}</div>
      ))}
    </div>
  );
}
```

**Comportamento**:
- Clicar bot√£o: `count` atualiza **instantaneamente**
- Lista renderiza progressivamente (pode ser interrompida por novos cliques)
- UI permanece responsiva

### Batching Autom√°tico: Casos de Uso

#### Event Handlers

```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  console.log('Render'); // Quantas vezes?

  const handleClick = () => {
    setCount(c => c + 1);
    setFlag(f => !f);
    // React 17: 2 renders
    // React 18: 1 render (batched)
  };

  return <button onClick={handleClick}>Update</button>;
}
```

#### Timers

```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  useEffect(() => {
    setTimeout(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // React 17: 2 renders
      // React 18: 1 render (batched)
    }, 1000);
  }, []);

  return <div>{count}</div>;
}
```

#### Promises/Async

```jsx
function Component() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchData = async () => {
    const response = await fetch('/api/data');
    const result = await response.json();

    setData(result);
    setLoading(false);
    // React 17: 2 renders
    // React 18: 1 render (batched)
  };

  return <div>...</div>;
}
```

#### Opt-out de Batching (React 18)

```jsx
import { flushSync } from 'react-dom';

function handleClick() {
  flushSync(() => {
    setCount(c => c + 1); // Re-render imediato
  });

  flushSync(() => {
    setFlag(f => !f); // Re-render imediato
  });
  // 2 re-renders (for√ßa s√≠ncrono)
}
```

**Uso**: Raro - apenas quando precisa ler DOM imediatamente ap√≥s update.

### Time-Slicing em A√ß√£o

```jsx
// Simular trabalho pesado
function heavyComponent() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    value: Math.random()
  }));

  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.value}</li>
      ))}
    </ul>
  );
}

function App() {
  const [show, setShow] = useState(false);

  return (
    <div>
      <button onClick={() => setShow(true)}>
        Mostrar Lista
      </button>

      {show && <HeavyComponent />}
    </div>
  );
}
```

**React 17**: Clicar bot√£o ‚Üí UI trava at√© renderizar 10k itens

**React 18**: Clicar bot√£o ‚Üí renderiza√ß√£o fatiada em chunks, UI responsiva

### Prioriza√ß√£o de Updates

```jsx
function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;

    // Alta prioridade - atualizar input imediatamente
    setQuery(value);

    // Baixa prioridade - pesquisa pode esperar
    startTransition(() => {
      const filtered = hugeDataset.filter(item =>
        item.name.includes(value)
      );
      setResults(filtered);
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />

      {/* Query sempre atualizado, results podem atrasar */}
      <p>Buscando: {query}</p>

      {results.map(result => (
        <div key={result.id}>{result.name}</div>
      ))}
    </>
  );
}
```

**Comportamento**:
- `query` atualiza a cada keystroke (urgente)
- `results` atualizam quando poss√≠vel (n√£o-urgente)
- Input nunca "trava"

---

## üéØ Aplicabilidade e Contextos

### Quando Concurrent Rendering Ajuda

#### 1. Listas Longas

```jsx
function LongList({ items }) {
  return (
    <div>
      {items.map(item => (
        <ExpensiveItem key={item.id} data={item} />
      ))}
    </div>
  );
}

// Com transition - n√£o trava UI
function App() {
  const [items, setItems] = useState([]);

  const loadItems = () => {
    startTransition(() => {
      setItems(generateHugeList());
    });
  };

  return <button onClick={loadItems}>Carregar</button>;
}
```

#### 2. Filtros/Busca em Tempo Real

```jsx
function FilterableList({ data }) {
  const [filter, setFilter] = useState('');
  const [filteredData, setFilteredData] = useState(data);

  const handleFilterChange = (e) => {
    setFilter(e.target.value); // Urgente

    startTransition(() => {
      // Pesado, mas n√£o trava input
      setFilteredData(
        data.filter(item => item.name.includes(e.target.value))
      );
    });
  };

  return (
    <>
      <input value={filter} onChange={handleFilterChange} />
      <List items={filteredData} />
    </>
  );
}
```

#### 3. Tabs/Navigation

```jsx
function TabContainer() {
  const [tab, setTab] = useState('home');

  const switchTab = (newTab) => {
    startTransition(() => {
      setTab(newTab); // Troca de tab n√£o trava clique
    });
  };

  return (
    <>
      <button onClick={() => switchTab('home')}>Home</button>
      <button onClick={() => switchTab('profile')}>Profile</button>

      {tab === 'home' && <ExpensiveHomeContent />}
      {tab === 'profile' && <ExpensiveProfileContent />}
    </>
  );
}
```

### Quando N√ÉO √© Necess√°rio

1. **Componentes Simples**: Poucos elementos, renders r√°pidos
2. **Updates Isolados**: Um √∫nico update pequeno
3. **J√° Otimizado**: Memoiza√ß√£o resolve (React.memo, useMemo)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes

#### 1. Commit Phase Ainda √© S√≠ncrono

```jsx
// Render phase - interrupt√≠vel
function Component() {
  const expensive = heavyCalculation(); // Pode pausar
  return <div>{expensive}</div>;
}

// Commit phase - s√≠ncrono (n√£o interrupt√≠vel)
useLayoutEffect(() => {
  // S√≠ncrono - trava UI se pesado
  measureDOM();
});
```

**Conceito**: Apenas render phase √© interrupt√≠vel. Commit (atualizar DOM) √© s√≠ncrono.

#### 2. N√£o Substitui Otimiza√ß√µes

```jsx
// ‚ùå Concurrent n√£o resolve componente mal otimizado
function BadList({ items }) {
  return items.map(item => (
    <ExpensiveItem key={Math.random()} data={item} />
    // Key aleat√≥ria for√ßa re-render sempre
  ));
}

// ‚úÖ Otimizar ANTES de confiar em concurrent
function GoodList({ items }) {
  return items.map(item => (
    <ExpensiveItem key={item.id} data={item} />
  ));
}
```

#### 3. Trabalho Ainda √© Feito

```jsx
// Concurrent n√£o acelera trabalho, apenas distribui
const heavyTask = () => {
  // 200ms de trabalho
  return Array.from({ length: 20000 }, () => Math.random());
};

// React 17: 200ms bloqueantes
// React 18: 200ms divididos, mas ainda 200ms total
```

**Conceito**: Concurrent melhora **responsividade**, n√£o **velocidade absoluta**.

---

## üîó Interconex√µes Conceituais

### Concurrent Rendering + Transitions

```jsx
import { useTransition } from 'react';

function App() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState('home');

  return (
    <div>
      <button
        onClick={() => {
          startTransition(() => setTab('profile'));
        }}
      >
        Profile {isPending && '(loading...)'}
      </button>

      {tab === 'profile' && <ProfileContent />}
    </div>
  );
}
```

### Concurrent Rendering + Suspense

```jsx
<Suspense fallback={<Loading />}>
  <LazyComponent />
  {/* Suspense aproveita concurrent rendering para streaming */}
</Suspense>
```

### Concurrent Rendering + useDeferredValue

```jsx
function Search() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  // deferredQuery atualiza com baixa prioridade

  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <Results query={deferredQuery} />
    </>
  );
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Concurrent Rendering prepara para:

1. **Transitions** (20.2): `useTransition`, `startTransition`, `isPending`
2. **Deferred Values** (20.3): `useDeferredValue` para debouncing visual
3. **Suspense Avan√ßado** (20.4): Streaming SSR, Selective Hydration
4. **Server Components** (M√≥dulo 21): Renderiza√ß√£o progressiva
5. **React Compiler** (M√≥dulo 14.8): Memoiza√ß√£o autom√°tica

### Funda√ß√£o para Features Futuras

Concurrent Rendering √© **base arquitetural** para:
- Automatic batching (j√° implementado)
- Transitions API (implementado)
- Suspense for data fetching (em evolu√ß√£o)
- Server Components (React 19)
- Offscreen rendering (futuro)

---

## üéØ Conclus√£o

Concurrent Rendering √© **mudan√ßa arquitetural fundamental** no React:

**Conceito Central**: Renderiza√ß√£o interrupt√≠vel que prioriza updates urgentes sobre n√£o-urgentes.

**Principais Benef√≠cios**:
- UI responsiva durante renders pesados
- Batching autom√°tico em todos contextos
- Prioriza√ß√£o inteligente de updates
- Time-slicing de trabalho custoso

**Como Habilitar**: Usar `createRoot` (React 18+) ao inv√©s de `ReactDOM.render`.

**Features Habilitadas**: Transitions, Deferred Values, Suspense avan√ßado, Streaming SSR.

**Considera√ß√µes**: N√£o substitui otimiza√ß√µes (React.memo, useMemo), commit phase ainda s√≠ncrono, trabalho total n√£o reduz (apenas distribu√≠do).

Concurrent Rendering transforma React de **biblioteca de UI** para **sistema operacional de UI** - com scheduler, prioridades, e capacidade de manter interface fluida mesmo sob carga pesada. Essencial para aplica√ß√µes modernas que exigem UX responsiva.
