# useEffect Patterns no React: Padr√µes e Boas Pr√°ticas

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**useEffect Patterns** s√£o padr√µes de implementa√ß√£o recorrentes e testados para resolver problemas comuns de side effects em React. Representam **best practices consolidadas** pela comunidade para cen√°rios espec√≠ficos: data fetching com cancelamento, subscriptions gerenciadas, event listeners seguros, sincroniza√ß√£o com localStorage, e muito mais.

Conceitualmente, s√£o **solu√ß√µes idiom√°ticas** que encapsulam complexidades de timing, cleanup, race conditions e memory leaks em patterns reutiliz√°veis. Ao inv√©s de reinventar a roda para cada side effect, voc√™ aplica um pattern estabelecido que j√° resolve armadilhas conhecidas.

Esses patterns emergem da experi√™ncia coletiva: **"Como fazer X corretamente em React?"**. S√£o a dist√¢ncia entre c√≥digo que "funciona" e c√≥digo que funciona **corretamente** em todos os edge cases - componente desmontando antes de fetch terminar, usu√°rio clicando r√°pido demais, timer n√£o sendo limpo, etc.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos patterns:**

**2018-2019: Primeiros Hooks**
Ap√≥s lan√ßamento de Hooks (React 16.8), desenvolvedores migraram de classes. Surgiram problemas:
- **Race conditions**: Fetch mais lento retornando depois de fetch mais r√°pido
- **Memory leaks**: Subscriptions n√£o limpas, setStates ap√≥s unmount
- **Stale closures**: Intervalos capturando valores antigos

**2019-2020: Emerg√™ncia de Patterns**
Comunidade identificou patterns recorrentes:
- **Fetch com AbortController**: Cancelar requests pendentes
- **Subscription pattern**: Subscribe no setup, unsubscribe no cleanup
- **Event listener pattern**: Add no setup, remove no cleanup
- **debounce/throttle**: Otimizar effects custosos

**2020-presente: Consolida√ß√£o**
Patterns se tornaram idiom√°ticos. Bibliotecas como `react-use`, `usehooks-ts` consolidaram. React Query/SWR abstra√≠ram data fetching.

**Filosofia:** N√£o basta entender useEffect - precisa conhecer patterns para aplicar corretamente.

### Problema Fundamental que Resolve

**Sem patterns:**

**Problema 1 - Race condition:**
```javascript
// ‚ùå Bug: fetch mais lento sobrescreve fetch mais r√°pido
useEffect(() => {
  fetch(`/api/user/${userId}`)
    .then(res => res.json())
    .then(setUser); // Problema: qual resultado chega primeiro?
}, [userId]);

// userId = 1 ‚Üí fetch1 (lento: 2s)
// userId = 2 ‚Üí fetch2 (r√°pido: 0.5s)
// fetch2 retorna ‚Üí mostra usu√°rio 2 ‚úì
// fetch1 retorna ‚Üí sobrescreve com usu√°rio 1 ‚ùå
```

**Problema 2 - Memory leak:**
```javascript
// ‚ùå setState ap√≥s unmount
useEffect(() => {
  fetch('/api/data')
    .then(res => res.json())
    .then(setData); // Se componente desmontar, causa warning
}, []);
```

**Problema 3 - Subscription n√£o limpa:**
```javascript
// ‚ùå Subscription continua ativa ap√≥s unmount
useEffect(() => {
  const sub = subscribeToMessages();
  // Faltou cleanup!
}, []);
```

**Patterns resolvem:**

```javascript
// ‚úÖ Pattern: Fetch com AbortController
useEffect(() => {
  const controller = new AbortController();

  fetch(`/api/user/${userId}`, { signal: controller.signal })
    .then(res => res.json())
    .then(setUser)
    .catch(err => {
      if (err.name !== 'AbortError') console.error(err);
    });

  return () => controller.abort(); // Cancela fetch anterior
}, [userId]);

// ‚úÖ Pattern: Subscription com cleanup
useEffect(() => {
  const sub = subscribeToMessages();
  return () => sub.unsubscribe(); // Sempre limpa
}, []);
```

### Import√¢ncia no Ecossistema

useEffect patterns s√£o **fundamentais** para c√≥digo React robusto:

- **Produ√ß√£o-ready**: Evitam bugs sutis que s√≥ aparecem em produ√ß√£o
- **Performance**: Cancelar opera√ß√µes desnecess√°rias economiza recursos
- **Seguran√ßa**: Previnem memory leaks e race conditions
- **Manutenibilidade**: Patterns s√£o reconhec√≠veis, facilitam code review

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Cancelamento**: Abort requests/timers pendentes ao desmontar
2. **Race conditions**: Garantir que resultado correto seja aplicado
3. **Cleanup garantido**: Sempre retornar fun√ß√£o de limpeza
4. **Idempot√™ncia**: Effect pode re-executar sem efeitos colaterais duplicados
5. **Error handling**: Tratar erros de cancelamento separadamente

### Pilares Fundamentais

- **AbortController pattern**: Cancelar fetches pendentes
- **Subscription pattern**: Subscribe/unsubscribe garantido
- **Event listener pattern**: Add/remove listeners
- **Debounce pattern**: Atrasar execu√ß√£o de effects
- **Mounted flag pattern**: Evitar setState ap√≥s unmount (legado)

### Vis√£o Geral das Nuances

- **AbortController** √© prefer√≠vel a mounted flag
- **Cleanup sempre executa**: Antes de pr√≥ximo effect ou unmount
- **Multiple effects**: Separar concerns em effects diferentes
- **Custom hooks**: Encapsular patterns para reutiliza√ß√£o
- **Libraries**: react-query/SWR abstraem data fetching

---

## üß† Fundamentos Te√≥ricos

### Race Conditions: O Problema

**Race condition:** Quando ordem de execu√ß√£o ass√≠ncrona afeta resultado.

**Cen√°rio:**
```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetch(`/api/user/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);

  return <div>{user?.name}</div>;
}
```

**Fluxo problem√°tico:**
```
1. userId = 1 ‚Üí dispatch fetch1 (vai demorar 2s)
2. userId = 2 ‚Üí dispatch fetch2 (vai demorar 0.5s)
3. fetch2 retorna (0.5s) ‚Üí setUser(user2) ‚Üí mostra "Bob" ‚úì
4. fetch1 retorna (2s) ‚Üí setUser(user1) ‚Üí mostra "Alice" ‚ùå
```

**Resultado:** Mostra usu√°rio errado (Alice, n√£o Bob).

**Solu√ß√£o:** Cancelar fetch1 quando userId muda.

### AbortController API

**AbortController** √© Web API para cancelar opera√ß√µes ass√≠ncronas.

**Mec√¢nica:**
```javascript
const controller = new AbortController();
const signal = controller.signal;

fetch('/api', { signal })
  .then(res => res.json())
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Fetch cancelado');
    }
  });

// Cancelar
controller.abort(); // Fetch √© abortado, lan√ßa AbortError
```

**Integra√ß√£o com useEffect:**
```javascript
useEffect(() => {
  const controller = new AbortController();

  fetch('/api/data', { signal: controller.signal })
    .then(res => res.json())
    .then(setData)
    .catch(err => {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    });

  return () => controller.abort(); // Cleanup cancela fetch
}, []);
```

### Memory Leaks e Cleanup

**Memory leak:** Recurso n√£o liberado continua consumindo mem√≥ria.

**Casos em React:**

**1. setState ap√≥s unmount:**
```javascript
// ‚ùå Warning: Can't perform a React state update on unmounted component
useEffect(() => {
  fetch('/api')
    .then(res => res.json())
    .then(setData); // Se componente desmontar antes, warning
}, []);
```

**2. Event listener n√£o removido:**
```javascript
// ‚ùå Listener permanece ativo
useEffect(() => {
  window.addEventListener('scroll', handleScroll);
  // Faltou cleanup
}, []);
```

**3. Timer n√£o cancelado:**
```javascript
// ‚ùå Timer continua executando
useEffect(() => {
  const timer = setTimeout(() => console.log('hi'), 1000);
  // Faltou cleanup
}, []);
```

**Solu√ß√µes com cleanup:**
```javascript
// ‚úÖ Abort fetch
useEffect(() => {
  const controller = new AbortController();
  fetch('/api', { signal: controller.signal })
    .then(res => res.json())
    .then(setData)
    .catch(err => {
      if (err.name !== 'AbortError') console.error(err);
    });
  return () => controller.abort();
}, []);

// ‚úÖ Remove listener
useEffect(() => {
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);

// ‚úÖ Clear timer
useEffect(() => {
  const timer = setTimeout(() => console.log('hi'), 1000);
  return () => clearTimeout(timer);
}, []);
```

---

## üîç An√°lise Conceitual Profunda

### 6.3.1 Pattern: Data Fetching com AbortController

#### Implementa√ß√£o B√°sica

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Criar AbortController para este effect
    const controller = new AbortController();

    setLoading(true);
    setError(null);

    fetch(`/api/users/${userId}`, { signal: controller.signal })
      .then(res => {
        if (!res.ok) throw new Error('Fetch failed');
        return res.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        // Ignorar AbortError (cancelamento intencional)
        if (err.name === 'AbortError') {
          console.log('Fetch cancelado');
          return;
        }

        // Erros reais
        setError(err.message);
        setLoading(false);
      });

    // Cleanup: cancela fetch se userId mudar ou unmount
    return () => {
      controller.abort();
    };
  }, [userId]);

  if (loading) return <div>Carregando...</div>;
  if (error) return <div>Erro: {error}</div>;
  if (!user) return null;

  return <div>{user.name}</div>;
}
```

**Fluxo com cancelamento:**
```
1. userId = 1
   ‚Üí Effect executa
   ‚Üí fetch1 inicia com controller1

2. userId = 2 (antes de fetch1 terminar)
   ‚Üí Cleanup executa: controller1.abort()
   ‚Üí fetch1 √© cancelado (lan√ßa AbortError, ignorado)
   ‚Üí Novo effect executa
   ‚Üí fetch2 inicia com controller2

3. fetch2 retorna
   ‚Üí setUser(user2)
   ‚Üí Mostra usu√°rio correto ‚úì
```

#### Pattern com async/await

```javascript
useEffect(() => {
  const controller = new AbortController();

  // Fun√ß√£o async separada (n√£o pode tornar callback do useEffect async)
  const fetchUser = async () => {
    setLoading(true);
    setError(null);

    try {
      const res = await fetch(`/api/users/${userId}`, {
        signal: controller.signal
      });

      if (!res.ok) {
        throw new Error(`HTTP error ${res.status}`);
      }

      const data = await res.json();
      setUser(data);
    } catch (err) {
      if (err.name !== 'AbortError') {
        setError(err.message);
      }
    } finally {
      setLoading(false);
    }
  };

  fetchUser();

  return () => controller.abort();
}, [userId]);
```

### 6.3.2 Pattern: Subscription com Cleanup

#### WebSocket Subscription

```javascript
function ChatMessages({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // Setup: criar e conectar WebSocket
    const ws = new WebSocket(`wss://api.example.com/chat/${roomId}`);

    ws.onopen = () => {
      console.log('WebSocket conectado');
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    // Cleanup: fechar WebSocket ao desmontar ou roomId mudar
    return () => {
      console.log('Fechando WebSocket');
      ws.close();
    };
  }, [roomId]);

  return (
    <ul>
      {messages.map((msg, i) => (
        <li key={i}>{msg.text}</li>
      ))}
    </ul>
  );
}
```

**Fluxo:**
```
Mount (roomId=1):
  ‚Üí ws1 = new WebSocket('room/1')
  ‚Üí ws1 conectado
  ‚Üí Mensagens chegam ‚Üí setMessages

roomId muda para 2:
  ‚Üí Cleanup: ws1.close() (fecha conex√£o anterior)
  ‚Üí ws2 = new WebSocket('room/2')
  ‚Üí ws2 conectado
  ‚Üí Mensagens de room2 chegam

Unmount:
  ‚Üí Cleanup: ws2.close()
```

#### Observable Subscription (RxJS)

```javascript
import { interval } from 'rxjs';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Setup: criar subscription
    const subscription = interval(1000).subscribe(value => {
      setCount(value);
    });

    // Cleanup: unsubscribe
    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return <div>Timer: {count}</div>;
}
```

### 6.3.3 Pattern: Event Listeners

#### Window Events

```javascript
function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    // Handler function
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    // Setup: adicionar listener
    window.addEventListener('resize', handleResize);

    // Cleanup: remover listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Array vazio = apenas mount/unmount

  return <div>{size.width} x {size.height}</div>;
}
```

**Importante:** Usar **mesma refer√™ncia** de fun√ß√£o para add/remove:
```javascript
// ‚ùå ERRADO - fun√ß√µes diferentes
useEffect(() => {
  window.addEventListener('resize', () => console.log('resize'));
  return () => {
    window.removeEventListener('resize', () => console.log('resize')); // Nova fun√ß√£o!
  };
}, []);

// ‚úÖ CORRETO - mesma refer√™ncia
useEffect(() => {
  const handler = () => console.log('resize');
  window.addEventListener('resize', handler);
  return () => window.removeEventListener('resize', handler); // Mesma fun√ß√£o
}, []);
```

#### Document Events (Keyboard)

```javascript
function KeyLogger() {
  const [lastKey, setLastKey] = useState('');

  useEffect(() => {
    const handleKeyDown = (event) => {
      setLastKey(event.key);
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);

  return <div>√öltima tecla: {lastKey}</div>;
}
```

### 6.3.4 Pattern: Timers com Cleanup

#### setTimeout

```javascript
function DelayedMessage({ message, delay }) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(true);
    }, delay);

    // Cleanup: cancelar timer se componente desmontar ou delay mudar
    return () => {
      clearTimeout(timer);
    };
  }, [delay]);

  return visible ? <div>{message}</div> : null;
}
```

**Fluxo:**
```
Mount (delay=1000):
  ‚Üí timer1 = setTimeout(..., 1000)

delay muda para 2000 (aos 500ms):
  ‚Üí Cleanup: clearTimeout(timer1) (cancela timer anterior)
  ‚Üí timer2 = setTimeout(..., 2000)

Unmount (antes de 2000ms):
  ‚Üí Cleanup: clearTimeout(timer2)
  ‚Üí setVisible nunca executa ‚úì
```

#### setInterval

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1); // Forma funcional (evita stale closure)
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, []); // Array vazio = cria interval uma vez

  return <div>Count: {count}</div>;
}
```

**Stale closure evitado:**
```javascript
// ‚ùå Stale closure
useEffect(() => {
  const interval = setInterval(() => {
    setCount(count + 1); // 'count' √© sempre 0 (do momento de cria√ß√£o)
  }, 1000);
  return () => clearInterval(interval);
}, []); // count n√£o est√° nas deps

// ‚úÖ Forma funcional
useEffect(() => {
  const interval = setInterval(() => {
    setCount(prev => prev + 1); // 'prev' sempre tem valor atual
  }, 1000);
  return () => clearInterval(interval);
}, []); // N√£o precisa de count nas deps
```

### 6.3.5 Pattern: Debounce e Throttle

#### Debounce em useEffect

**Conceito:** Atrasar execu√ß√£o at√© input "estabilizar".

```javascript
function SearchInput() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    // N√£o buscar se query vazio
    if (!query.trim()) {
      setResults([]);
      return;
    }

    // Debounce: esperar 500ms ap√≥s √∫ltima digita√ß√£o
    const timer = setTimeout(() => {
      fetch(`/api/search?q=${query}`)
        .then(res => res.json())
        .then(setResults);
    }, 500);

    // Cleanup: cancelar timer se query mudar antes dos 500ms
    return () => {
      clearTimeout(timer);
    };
  }, [query]);

  return (
    <div>
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Buscar..."
      />
      <ul>
        {results.map(r => <li key={r.id}>{r.name}</li>)}
      </ul>
    </div>
  );
}
```

**Fluxo:**
```
Digita√ß√£o r√°pida:
  query = "r"
    ‚Üí timer1 = setTimeout(..., 500)

  query = "re" (100ms depois)
    ‚Üí Cleanup: clearTimeout(timer1) (cancela anterior)
    ‚Üí timer2 = setTimeout(..., 500)

  query = "rea" (100ms depois)
    ‚Üí Cleanup: clearTimeout(timer2)
    ‚Üí timer3 = setTimeout(..., 500)

  query = "react" (100ms depois)
    ‚Üí Cleanup: clearTimeout(timer3)
    ‚Üí timer4 = setTimeout(..., 500)

  Usu√°rio para de digitar
    ‚Üí 500ms depois: fetch('/api/search?q=react')
    ‚Üí Apenas 1 request (ao inv√©s de 4) ‚úì
```

#### Debounce com AbortController

```javascript
function SearchWithCancel() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }

    // AbortController para cancelar fetch
    const controller = new AbortController();

    // Debounce timer
    const timer = setTimeout(() => {
      fetch(`/api/search?q=${query}`, { signal: controller.signal })
        .then(res => res.json())
        .then(setResults)
        .catch(err => {
          if (err.name !== 'AbortError') {
            console.error(err);
          }
        });
    }, 500);

    // Cleanup: cancelar timer E fetch pendente
    return () => {
      clearTimeout(timer);
      controller.abort();
    };
  }, [query]);

  return (
    <div>
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Buscar..."
      />
      <ul>
        {results.map(r => <li key={r.id}>{r.name}</li>)}
      </ul>
    </div>
  );
}
```

### 6.3.6 Pattern: LocalStorage Sync

#### Sincroniza√ß√£o Bidirecional

```javascript
function useLocalStorage(key, initialValue) {
  // Ler de localStorage (apenas no mount)
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  // Sincronizar com localStorage quando value mudar
  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// Uso
function App() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    <div>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle Theme
      </button>
      <p>Current theme: {theme}</p>
    </div>
  );
}
```

#### Sincroniza√ß√£o entre Tabs (storage event)

```javascript
function useSyncedState(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() => {
    // Salvar no localStorage
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  useEffect(() => {
    // Ouvir mudan√ßas de outras tabs
    const handleStorageChange = (event) => {
      if (event.key === key && event.newValue) {
        setValue(JSON.parse(event.newValue));
      }
    };

    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [key]);

  return [value, setValue];
}
```

### 6.3.7 Pattern: Document Title

```javascript
function useDocumentTitle(title) {
  useEffect(() => {
    const prevTitle = document.title;
    document.title = title;

    // Opcional: restaurar t√≠tulo anterior ao desmontar
    return () => {
      document.title = prevTitle;
    };
  }, [title]);
}

// Uso
function PageComponent() {
  const [count, setCount] = useState(0);

  useDocumentTitle(`Notifica√ß√µes (${count})`);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Incrementar
      </button>
    </div>
  );
}
```

### 6.3.8 Pattern: Animation Frame

```javascript
function AnimatedCounter({ target }) {
  const [current, setCurrent] = useState(0);

  useEffect(() => {
    let animationId;
    let start = current;

    const animate = () => {
      start += (target - start) * 0.1; // Interpola√ß√£o suave

      if (Math.abs(target - start) > 0.1) {
        setCurrent(start);
        animationId = requestAnimationFrame(animate);
      } else {
        setCurrent(target); // Snap para valor final
      }
    };

    animationId = requestAnimationFrame(animate);

    return () => {
      cancelAnimationFrame(animationId);
    };
  }, [target]);

  return <div>{Math.round(current)}</div>;
}
```

### 6.3.9 Pattern: Intersection Observer

```javascript
function LazyImage({ src, placeholder }) {
  const [isVisible, setIsVisible] = useState(false);
  const imgRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.disconnect(); // Parar de observar ap√≥s carregar
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => {
      observer.disconnect();
    };
  }, []);

  return (
    <img
      ref={imgRef}
      src={isVisible ? src : placeholder}
      alt=""
    />
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Pattern

**Data Fetching:**
- Use AbortController para cancelar requests pendentes
- Use loading/error states para UX
- Considere React Query/SWR para casos complexos

**Subscriptions:**
- Sempre retorne cleanup (unsubscribe)
- WebSockets, RxJS, EventEmitters

**Event Listeners:**
- Mesma refer√™ncia para add/remove
- Window, document, custom DOM elements

**Debounce:**
- Search inputs
- Window resize
- Scroll handlers

**LocalStorage:**
- Persistir prefer√™ncias do usu√°rio
- Sincronizar entre tabs (storage event)

**Timers:**
- Anima√ß√µes
- Delayed actions
- Polling

### Custom Hooks para Encapsular Patterns

```javascript
// useFetch - encapsula data fetching pattern
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    setLoading(true);
    setError(null);

    fetch(url, { signal: controller.signal })
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        if (err.name !== 'AbortError') {
          setError(err);
          setLoading(false);
        }
      });

    return () => controller.abort();
  }, [url]);

  return { data, loading, error };
}

// Uso
function Component() {
  const { data, loading, error } = useFetch('/api/users');

  if (loading) return <div>Carregando...</div>;
  if (error) return <div>Erro!</div>;
  return <div>{data?.name}</div>;
}
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Armadilhas Comuns

**1. Esquecer cleanup:**
```javascript
// ‚ùå Memory leak
useEffect(() => {
  const interval = setInterval(() => console.log('tick'), 1000);
  // Faltou clearInterval
}, []);

// ‚úÖ Com cleanup
useEffect(() => {
  const interval = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(interval);
}, []);
```

**2. AbortError n√£o tratado:**
```javascript
// ‚ùå Loga erro de cancelamento
fetch('/api', { signal })
  .catch(err => console.error(err)); // Loga AbortError

// ‚úÖ Ignorar AbortError
fetch('/api', { signal })
  .catch(err => {
    if (err.name !== 'AbortError') {
      console.error(err);
    }
  });
```

**3. Deps incorretas em debounce:**
```javascript
// ‚ùå Debounce quebrado
useEffect(() => {
  const timer = setTimeout(() => {
    console.log(query); // query do momento de cria√ß√£o
  }, 500);
  return () => clearTimeout(timer);
}, []); // query deveria estar nas deps!

// ‚úÖ Deps corretas
useEffect(() => {
  const timer = setTimeout(() => {
    console.log(query);
  }, 500);
  return () => clearTimeout(timer);
}, [query]);
```

### Performance Considerations

**Evite re-criar subscriptions desnecessariamente:**
```javascript
// ‚ùå Re-cria WebSocket toda render
useEffect(() => {
  const ws = new WebSocket(url);
  return () => ws.close();
}, [url, someOtherDep]); // someOtherDep causa reconnect

// ‚úÖ Apenas reconectar se URL mudar
useEffect(() => {
  const ws = new WebSocket(url);
  return () => ws.close();
}, [url]); // Apenas URL nas deps
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useRef

useRef armazena valores mut√°veis sem causar re-render. √ötil para:
- Armazenar refer√™ncias a timers/intervals
- Evitar stale closures

### Rela√ß√£o com Custom Hooks

Patterns s√£o encapsulados em custom hooks para reutiliza√ß√£o.

### Rela√ß√£o com Libraries

React Query/SWR abstraem data fetching patterns, oferecendo:
- Cache autom√°tico
- Revalida√ß√£o
- Cancelamento built-in
- Estados de loading/error

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
useEffect b√°sico
    ‚Üì
useEffect patterns (este m√≥dulo)
    ‚Üì
Custom hooks (encapsular patterns)
    ‚Üì
React Query/SWR (abstra√ß√µes avan√ßadas)
```

---

## üìö Conclus√£o

useEffect patterns s√£o **fundamentais** para c√≥digo React robusto. Princ√≠pios:

1. **Sempre retorne cleanup**: Previna memory leaks
2. **Use AbortController**: Cancele fetches pendentes
3. **Debounce inputs**: Otimize opera√ß√µes custosas
4. **Mesma refer√™ncia**: add/remove event listeners
5. **Custom hooks**: Encapsule patterns para reutiliza√ß√£o

**Recomenda√ß√µes:**
- Aprenda patterns core (fetch, subscription, listeners)
- Use AbortController ao inv√©s de mounted flags
- Considere libraries (react-query) para data fetching complexo
- Teste edge cases (unmount r√°pido, mudan√ßas r√°pidas)

**Dominar patterns = escrever c√≥digo React production-ready.**
