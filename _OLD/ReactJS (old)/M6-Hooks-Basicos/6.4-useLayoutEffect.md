# useLayoutEffect no React: Side Effects S√≠ncronos

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useLayoutEffect` √© uma **variante s√≠ncrona** de useEffect, executando side effects **antes** do browser pintar a tela. Conceitualmente, permite **leitura/manipula√ß√£o do DOM** de forma sincronizada com o commit do React, garantindo que mudan√ßas visuais aconte√ßam atomicamente - usu√°rio **nunca v√™** estado intermedi√°rio.

A diferen√ßa fundamental: `useEffect` √© **ass√≠ncrono** (executa ap√≥s pintura), `useLayoutEffect` √© **s√≠ncrono** (executa antes de pintura, bloqueando temporariamente). √â o equivalente funcional de `componentDidMount` e `componentDidUpdate` de classes - executa imediatamente ap√≥s React atualizar DOM, mas antes do browser renderizar.

**Met√°fora:** Se useEffect √© "fazer algo depois de entregar encomenda", useLayoutEffect √© "fazer algo antes de fechar a caixa". Usu√°rio s√≥ v√™ resultado final, nunca estado intermedi√°rio.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o do timing de effects:**

**2013-2018: Lifecycle Methods (Classes)**
Em classes, timing era claro:
- `componentDidMount/Update`: S√≠ncrono ap√≥s commit do React
- C√≥digo executava antes de browser pintar
- √ötil para medir/ajustar DOM antes de exibir

**Problema:** Com Hooks, precisava-se de controle sobre timing:
- `useEffect`: Maioria dos casos (ass√≠ncrono, n√£o bloqueia)
- `useLayoutEffect`: Casos espec√≠ficos (s√≠ncrono, quando necess√°rio)

**2018 - useLayoutEffect (React 16.8):**
Introduzido junto com Hooks para casos onde timing s√≠ncrono √© essencial:
- **Medi√ß√µes de DOM**: Ler dimens√µes antes de pintar
- **Ajustes visuais**: Prevenir "flash" de conte√∫do
- **Anima√ß√µes**: Configurar estado inicial antes de frame

**Filosofia:** Use useEffect por padr√£o, useLayoutEffect apenas quando timing s√≠ncrono for **necess√°rio**.

### Problema Fundamental que Resolve

**Sem useLayoutEffect (usando useEffect):**

**Problema 1 - Flash visual:**
```javascript
function Tooltip({ targetRef }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const rect = targetRef.current.getBoundingClientRect();
    setPosition({ x: rect.x, y: rect.y + rect.height });
  }, []);

  return <div style={{ left: position.x, top: position.y }}>Tooltip</div>;
}

// Problema:
// 1. Primeiro render: position = {0, 0}
// 2. Browser pinta tooltip em (0, 0) üëÅÔ∏è Usu√°rio V√ä
// 3. useEffect executa ‚Üí calcula posi√ß√£o correta
// 4. Re-render com posi√ß√£o correta
// 5. Browser pinta tooltip na posi√ß√£o final üëÅÔ∏è Usu√°rio V√ä
// Resultado: "Flash" - tooltip aparece em canto, depois move
```

**Com useLayoutEffect:**
```javascript
useLayoutEffect(() => {
  const rect = targetRef.current.getBoundingClientRect();
  setPosition({ x: rect.x, y: rect.y + rect.height });
}, []);

// Fluxo:
// 1. Primeiro render: position = {0, 0}
// 2. useLayoutEffect executa (ANTES de pintar) ‚Üí calcula posi√ß√£o
// 3. Re-render com posi√ß√£o correta
// 4. Browser pinta tooltip na posi√ß√£o final üëÅÔ∏è Usu√°rio V√ä apenas isso
// Resultado: Sem flash - tooltip aparece direto na posi√ß√£o correta
```

**Problema 2 - Medi√ß√µes incorretas:**
```javascript
// ‚ùå useEffect - pode ler dimens√µes desatualizadas
useEffect(() => {
  const height = elementRef.current.offsetHeight;
  // Se DOM n√£o tiver sido atualizado, height est√° errado
}, []);

// ‚úÖ useLayoutEffect - garante DOM atualizado
useLayoutEffect(() => {
  const height = elementRef.current.offsetHeight;
  // DOM j√° foi atualizado pelo React, height correto
}, []);
```

### Import√¢ncia no Ecossistema

useLayoutEffect √© **nicho mas cr√≠tico**:

- **Anima√ß√µes**: Configurar estado inicial antes de animar
- **Tooltips/Popovers**: Posicionar baseado em elemento alvo
- **Medi√ß√µes**: Ler dimens√µes para c√°lculos
- **Preven√ß√£o de flashes**: Evitar estados visuais intermedi√°rios

**Regra geral:** 99% dos cases usam `useEffect`. `useLayoutEffect` √© para 1% onde timing s√≠ncrono √© **essencial**.

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Timing s√≠ncrono**: Executa antes de browser pintar
2. **Bloqueia renderiza√ß√£o**: N√£o retornar r√°pido pode causar lag
3. **Leitura de DOM**: Garantia de DOM atualizado
4. **Assinatura id√™ntica**: Mesmo API que useEffect
5. **SSR incompat√≠vel**: N√£o funciona no servidor

### Pilares Fundamentais

- **Execu√ß√£o s√≠ncrona**: Ap√≥s commit do React, antes de paint
- **Bloqueio tempor√°rio**: Interface trava at√© effect terminar
- **Atomicidade visual**: Usu√°rio n√£o v√™ estados intermedi√°rios
- **Mesma API**: Mesmo signature que useEffect
- **Use com cautela**: Performance cost se usar incorretamente

### Vis√£o Geral das Nuances

- **Preferir useEffect**: useLayoutEffect apenas se necess√°rio
- **SSR warning**: Causa warning em servidor (n√£o tem DOM)
- **Performance**: Bloqueia pintura, pode causar lag
- **Rare uso**: Maioria dos apps n√£o precisa
- **Testing**: Pode requerer flush s√≠ncrono em testes

---

## üß† Fundamentos Te√≥ricos

### Diferen√ßa: useEffect vs useLayoutEffect

**Ordem de execu√ß√£o:**

```
RENDER CYCLE:

1. React renderiza componente (chama fun√ß√£o)
   ‚Üì
2. React atualiza DOM (commit)
   ‚Üì
3. useLayoutEffect executa ‚Üê S√çNCRONO (bloqueia)
   ‚Üì
4. Browser pinta tela
   ‚Üì
5. useEffect executa ‚Üê ASS√çNCRONO (n√£o bloqueia)
```

**Visualiza√ß√£o temporal:**

```
useEffect:
  Render ‚Üí Commit ‚Üí Paint ‚Üí useEffect
                      ‚Üë
                   Usu√°rio v√™

useLayoutEffect:
  Render ‚Üí Commit ‚Üí useLayoutEffect ‚Üí Paint
                                        ‚Üë
                                    Usu√°rio v√™
```

**Compara√ß√£o:**

| Aspecto | useEffect | useLayoutEffect |
|---------|-----------|-----------------|
| **Timing** | Ap√≥s paint | Antes de paint |
| **Bloqueio** | N√£o bloqueia | Bloqueia temporariamente |
| **Ass√≠ncrono** | Sim | N√£o |
| **Uso comum** | 99% dos casos | 1% (medi√ß√µes, flashes) |
| **Performance** | Melhor | Pior (se demorar) |
| **SSR** | Funciona | Causa warning |

### Quando useLayoutEffect √â Necess√°rio

**Casos v√°lidos:**

**1. Medi√ß√µes de DOM:**
```javascript
// Precisa ler dimens√µes ANTES de pintar
useLayoutEffect(() => {
  const height = ref.current.offsetHeight;
  setCalculatedValue(height * 2);
}, []);
```

**2. Posicionamento din√¢mico:**
```javascript
// Tooltip/popover precisa posicionar antes de aparecer
useLayoutEffect(() => {
  const rect = targetRef.current.getBoundingClientRect();
  setTooltipPosition({ x: rect.x, y: rect.y + rect.height });
}, []);
```

**3. Prevenir flashes visuais:**
```javascript
// Ajustar estado antes de usu√°rio ver
useLayoutEffect(() => {
  if (needsAdjustment) {
    adjustBeforePaint();
  }
}, [needsAdjustment]);
```

**4. Anima√ß√µes com estado inicial:**
```javascript
// Configurar posi√ß√£o inicial antes de animar
useLayoutEffect(() => {
  element.style.transform = 'translateX(-100%)';
  // Anima√ß√£o come√ßa da posi√ß√£o correta
}, []);
```

**Quando N√ÉO usar:**

```javascript
// ‚ùå Data fetching - n√£o precisa ser s√≠ncrono
useLayoutEffect(() => {
  fetch('/api/data').then(setData);
}, []);

// ‚úÖ Use useEffect
useEffect(() => {
  fetch('/api/data').then(setData);
}, []);

// ‚ùå Subscriptions - n√£o precisa bloquear
useLayoutEffect(() => {
  const sub = subscribe();
  return () => sub.unsubscribe();
}, []);

// ‚úÖ Use useEffect
useEffect(() => {
  const sub = subscribe();
  return () => sub.unsubscribe();
}, []);
```

### Performance e Bloqueio

**Problema de performance:**

```javascript
// ‚ùå RUIM - opera√ß√£o lenta bloqueia interface
useLayoutEffect(() => {
  // Opera√ß√£o lenta (100ms)
  for (let i = 0; i < 1000000; i++) {
    // c√°lculo complexo
  }
}, []);

// Interface trava por 100ms - usu√°rio percebe lag
```

**Regra:** useLayoutEffect deve ser **r√°pido** (< 16ms idealmente, uma frame a 60fps).

**Se opera√ß√£o √© lenta:**
```javascript
// ‚úÖ Use useEffect (n√£o bloqueia)
useEffect(() => {
  // Opera√ß√£o lenta
  heavyCalculation();
}, []);
```

---

## üîç An√°lise Conceitual Profunda

### 6.4.1 Casos de Uso: Tooltip Positioning

#### Problema: Tooltip com Flash

```javascript
// ‚ùå Com useEffect - tooltip "pula"
function Tooltip({ children, text }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const triggerRef = useRef(null);
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    if (visible && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setPosition({
        x: rect.left + rect.width / 2,
        y: rect.bottom + 10
      });
    }
  }, [visible]);

  return (
    <div>
      <span ref={triggerRef} onMouseEnter={() => setVisible(true)}>
        {children}
      </span>
      {visible && (
        <div style={{ position: 'fixed', left: position.x, top: position.y }}>
          {text}
        </div>
      )}
    </div>
  );
}

// Problema:
// 1. Hover ‚Üí setVisible(true)
// 2. Render com visible=true, position={0,0}
// 3. Browser pinta tooltip em (0, 0) üëÅÔ∏è Flash vis√≠vel
// 4. useEffect calcula posi√ß√£o correta
// 5. Re-render e pinta na posi√ß√£o correta
```

#### Solu√ß√£o: useLayoutEffect

```javascript
// ‚úÖ Com useLayoutEffect - sem flash
function Tooltip({ children, text }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const triggerRef = useRef(null);
  const [visible, setVisible] = useState(false);

  useLayoutEffect(() => {
    if (visible && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setPosition({
        x: rect.left + rect.width / 2,
        y: rect.bottom + 10
      });
    }
  }, [visible]);

  return (
    <div>
      <span ref={triggerRef} onMouseEnter={() => setVisible(true)}>
        {children}
      </span>
      {visible && (
        <div style={{ position: 'fixed', left: position.x, top: position.y }}>
          {text}
        </div>
      )}
    </div>
  );
}

// Fluxo:
// 1. Hover ‚Üí setVisible(true)
// 2. Render com visible=true, position={0,0}
// 3. useLayoutEffect calcula posi√ß√£o (ANTES de pintar)
// 4. Re-render com posi√ß√£o correta
// 5. Browser pinta tooltip diretamente na posi√ß√£o correta üëÅÔ∏è Sem flash
```

### 6.4.2 Casos de Uso: Medi√ß√µes de DOM

#### Medir Altura Dinamicamente

```javascript
function DynamicHeight({ children }) {
  const [height, setHeight] = useState(0);
  const contentRef = useRef(null);

  useLayoutEffect(() => {
    if (contentRef.current) {
      const measuredHeight = contentRef.current.offsetHeight;
      setHeight(measuredHeight);
    }
  }, [children]); // Re-medir quando children mudar

  return (
    <div>
      <p>Altura medida: {height}px</p>
      <div ref={contentRef}>
        {children}
      </div>
    </div>
  );
}
```

**Por que useLayoutEffect?**
- Garante que DOM foi atualizado com novos `children`
- Medi√ß√£o acontece antes de pintar
- Usu√°rio v√™ altura correta na primeira frame

#### Auto-scroll para Elemento

```javascript
function ChatMessages({ messages }) {
  const bottomRef = useRef(null);

  useLayoutEffect(() => {
    // Scroll para baixo imediatamente ao adicionar mensagem
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
      <div ref={bottomRef} />
    </div>
  );
}
```

### 6.4.3 Casos de Uso: Prevenir Flash de Conte√∫do

#### Esconder At√© Calcular

```javascript
function ComplexLayout() {
  const [ready, setReady] = useState(false);
  const layoutRef = useRef(null);

  useLayoutEffect(() => {
    if (layoutRef.current) {
      // C√°lculos complexos de layout
      const computedStyle = window.getComputedStyle(layoutRef.current);
      const width = parseInt(computedStyle.width, 10);

      // Ajustar baseado em medi√ß√£o
      if (width < 500) {
        layoutRef.current.classList.add('compact-mode');
      }

      // Marcar como pronto DEPOIS de ajustar
      setReady(true);
    }
  }, []);

  return (
    <div ref={layoutRef} style={{ opacity: ready ? 1 : 0 }}>
      {/* Conte√∫do s√≥ aparece quando ready */}
      Conte√∫do complexo
    </div>
  );
}
```

**Padr√£o:**
1. Render inicial com `opacity: 0` (invis√≠vel)
2. useLayoutEffect mede e ajusta
3. setReady(true) ‚Üí `opacity: 1`
4. Browser pinta tudo de uma vez
5. Usu√°rio v√™ apenas vers√£o final

### 6.4.4 Casos de Uso: Sincronizar com Anima√ß√µes

#### Anima√ß√£o com Estado Inicial

```javascript
function SlideIn({ children }) {
  const elementRef = useRef(null);

  useLayoutEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    // Configurar posi√ß√£o inicial ANTES de pintar
    element.style.transform = 'translateX(-100%)';
    element.style.opacity = '0';

    // For√ßar reflow (necess√°rio para anima√ß√£o CSS)
    element.offsetHeight;

    // Animar para posi√ß√£o final
    element.style.transition = 'transform 0.3s, opacity 0.3s';
    element.style.transform = 'translateX(0)';
    element.style.opacity = '1';
  }, []);

  return <div ref={elementRef}>{children}</div>;
}
```

**Por que useLayoutEffect?**
- Estado inicial (`translateX(-100%)`) deve ser definido antes de primeira paint
- Se usar useEffect, elemento apareceria em posi√ß√£o normal, depois animaria (flash)

### 6.4.5 Intera√ß√£o com Bibliotecas DOM

#### Inicializar Biblioteca Externa

```javascript
function ChartComponent({ data }) {
  const chartRef = useRef(null);
  const chartInstanceRef = useRef(null);

  useLayoutEffect(() => {
    // Inicializar biblioteca de charts (precisa de DOM renderizado)
    chartInstanceRef.current = new Chart(chartRef.current, {
      type: 'bar',
      data: data
    });

    return () => {
      // Cleanup: destruir inst√¢ncia
      chartInstanceRef.current.destroy();
    };
  }, []);

  useLayoutEffect(() => {
    // Atualizar dados
    if (chartInstanceRef.current) {
      chartInstanceRef.current.data = data;
      chartInstanceRef.current.update();
    }
  }, [data]);

  return <canvas ref={chartRef} />;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar useLayoutEffect

**Checklist:**

‚úÖ Use `useLayoutEffect` se:
- Precisa ler/medir DOM antes de pintar
- Prevenir flash visual √© cr√≠tico
- Posicionar elemento baseado em outro
- Sincronizar com anima√ß√µes CSS

‚ùå Use `useEffect` (n√£o useLayoutEffect) se:
- Data fetching
- Subscriptions
- Logging
- Opera√ß√µes lentas (> 16ms)
- Qualquer coisa n√£o relacionada a DOM visual

### Padr√£o de Decis√£o

```
Preciso de side effect
        ‚Üì
    Envolve DOM?
    ‚ÜôÔ∏è        ‚ÜòÔ∏è
  N√£o         Sim
   ‚Üì           ‚Üì
useEffect    Usu√°rio veria flash?
             ‚ÜôÔ∏è              ‚ÜòÔ∏è
           Sim              N√£o
            ‚Üì                ‚Üì
     useLayoutEffect     useEffect
```

### Custom Hook com useLayoutEffect

```javascript
// Hook para medir dimens√µes de elemento
function useMeasure() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const ref = useRef(null);

  useLayoutEffect(() => {
    if (ref.current) {
      const { width, height } = ref.current.getBoundingClientRect();
      setDimensions({ width, height });
    }
  }, []); // Medir apenas no mount

  return [ref, dimensions];
}

// Uso
function Component() {
  const [measureRef, { width, height }] = useMeasure();

  return (
    <div>
      <div ref={measureRef}>Conte√∫do a medir</div>
      <p>Tamanho: {width} x {height}</p>
    </div>
  );
}
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Problemas com SSR (Server-Side Rendering)

**Warning em servidor:**

```javascript
// ‚ùå Causa warning no servidor
useLayoutEffect(() => {
  // Servidor n√£o tem DOM
  const width = elementRef.current.offsetWidth;
}, []);

// Warning: useLayoutEffect does nothing on the server, because its effect
// cannot be encoded into the server renderer's output format.
```

**Solu√ß√£o: Usar useEffect no servidor**

```javascript
// Hook que usa useLayoutEffect no cliente, useEffect no servidor
const useIsomorphicLayoutEffect =
  typeof window !== 'undefined' ? useLayoutEffect : useEffect;

// Uso
function Component() {
  useIsomorphicLayoutEffect(() => {
    // C√≥digo que precisa de DOM
  }, []);
}
```

**Alternativa: Executar apenas no cliente**

```javascript
function Component() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  useLayoutEffect(() => {
    if (!mounted) return; // Skip no servidor

    // C√≥digo que precisa de DOM
  }, [mounted]);
}
```

### Performance: Evitar Bloqueio

**‚ùå Ruim - bloqueia por muito tempo:**
```javascript
useLayoutEffect(() => {
  // Opera√ß√£o lenta (50ms)
  expensiveCalculation();

  // Interface trava, usu√°rio percebe
}, []);
```

**‚úÖ Bom - opera√ß√£o r√°pida:**
```javascript
useLayoutEffect(() => {
  // Medi√ß√£o r√°pida (< 1ms)
  const height = elementRef.current.offsetHeight;
  setHeight(height);
}, []);
```

**Se opera√ß√£o √© lenta, use useEffect:**
```javascript
useEffect(() => {
  // Opera√ß√£o lenta n√£o bloqueia pintura
  expensiveCalculation();
}, []);
```

### Testing: Flush S√≠ncrono

Alguns frameworks de teste (Jest + React Testing Library) executam effects assincronamente. Para testar useLayoutEffect:

```javascript
import { act } from '@testing-library/react';

test('medi√ß√£o de elemento', () => {
  const { getByText } = render(<Component />);

  // Flush effects s√≠ncronos
  act(() => {
    // Esperar effects executarem
  });

  expect(getByText('Altura: 100px')).toBeInTheDocument();
});
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useEffect

useLayoutEffect √© **variante s√≠ncrona** de useEffect. Mesma API, timing diferente.

### Rela√ß√£o com useRef

useRef √© usado para acessar elementos DOM que useLayoutEffect medir√°.

### Rela√ß√£o com Anima√ß√µes

useLayoutEffect sincroniza com ciclo de renderiza√ß√£o, √∫til para configurar anima√ß√µes.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
useEffect (ass√≠ncrono)
    ‚Üì
useLayoutEffect (s√≠ncrono)
    ‚Üì
Entender timing de renderiza√ß√£o
    ‚Üì
Otimizar medi√ß√µes (ResizeObserver)
```

---

## üìö Conclus√£o

useLayoutEffect √© hook **nicho mas essencial** para casos espec√≠ficos. Princ√≠pios:

1. **Timing s√≠ncrono**: Executa antes de pintar
2. **Bloqueia temporariamente**: Use apenas se necess√°rio
3. **Preferir useEffect**: 99% dos casos
4. **Casos v√°lidos**: Medi√ß√µes, tooltips, prevenir flashes
5. **SSR incompat√≠vel**: Precisa de handling especial

**Recomenda√ß√µes:**
- Use useEffect por padr√£o
- useLayoutEffect apenas quando timing s√≠ncrono √© **essencial**
- Opera√ß√µes devem ser r√°pidas (< 16ms)
- Handle SSR warnings com useIsomorphicLayoutEffect
- Considere ResizeObserver/IntersectionObserver para medi√ß√µes cont√≠nuas

**Dominar useLayoutEffect = entender timing profundo de React render cycle.**
