# useEffect no React: Side Effects e SincronizaÃ§Ã£o

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

`useEffect` Ã© o hook para executar **side effects** (efeitos colaterais) em componentes funcionais React. Conceitualmente, permite **sincronizar componente com sistemas externos** - APIs, DOM, subscriptions, timers - que existem fora do fluxo de renderizaÃ§Ã£o puro do React. Ã‰ a ponte entre o mundo declarativo do React (renderizaÃ§Ã£o) e o mundo imperativo de operaÃ§Ãµes assÃ­ncronas, I/O e manipulaÃ§Ã£o direta de recursos.

Representa mudanÃ§a de paradigma: ao invÃ©s de pensar em "lifecycle methods" (componentDidMount, etc.), pense em **"sincronizar com efeito X sempre que dependÃªncias Y mudarem"**. Ã‰ declarativo sobre side effects - vocÃª descreve o que sincronizar, React decide quando executar.

### Contexto HistÃ³rico e MotivaÃ§Ã£o

**EvoluÃ§Ã£o dos side effects:**

**2013-2018: Lifecycle Methods (Classes)**
Em classes, side effects eram gerenciados por lifecycle methods:
- `componentDidMount`: Setup inicial (fetch, subscriptions)
- `componentDidUpdate`: Reagir a mudanÃ§as
- `componentWillUnmount`: Cleanup (cancelar subscriptions)

**Problema:** LÃ³gica relacionada espalhada em mÃºltiplos mÃ©todos. Subscriptions iniciadas em `didMount`, canceladas em `willUnmount` - longe uma da outra.

**2018 - useEffect (React 16.8):**
Hooks unificaram lifecycle em um conceito:
- **Setup e cleanup juntos**: Effect retorna funÃ§Ã£o de limpeza
- **MÃºltiplos effects**: Separar concerns ao invÃ©s de um Ãºnico mÃ©todo
- **DependÃªncias explÃ­citas**: Array de deps declara quando re-executar

**Filosofia:** Pense em "sincronizar com mundo externo", nÃ£o em "fases de vida".

### Problema Fundamental que Resolve

**Sem useEffect:**

**Problema 1 - Data fetching:**
Como buscar dados quando componente monta? NÃ£o pode ser no corpo (roda toda render).

**Problema 2 - Subscriptions:**
Como se inscrever em WebSocket e limpar ao desmontar?

**Problema 3 - SincronizaÃ§Ã£o:**
Como atualizar tÃ­tulo da pÃ¡gina baseado em estado?

**useEffect resolve:**

```javascript
// Fetch ao montar
useEffect(() => {
  fetch('/api/user')
    .then(res => res.json())
    .then(setUser);
}, []); // Array vazio = roda uma vez

// Subscription com cleanup
useEffect(() => {
  const sub = subscribe(userId);
  return () => sub.unsubscribe(); // Cleanup automÃ¡tico
}, [userId]);

// SincronizaÃ§Ã£o
useEffect(() => {
  document.title = `${count} notificaÃ§Ãµes`;
}, [count]); // Re-executa quando count muda
```

### ImportÃ¢ncia no Ecossistema

useEffect Ã© **fundamental** para apps React:

- **Ubiquidade**: Todo app nÃ£o-trivial precisa de side effects
- **Data fetching**: Carregar dados de APIs
- **IntegraÃ§Ã£o**: Bibliotecas externas (charts, maps)
- **Performance**: OperaÃ§Ãµes custosas fora da renderizaÃ§Ã£o

---

## ğŸ“‹ SumÃ¡rio Conceitual

### Aspectos TeÃ³ricos Centrais

1. **Side effects**: OperaÃ§Ãµes que afetam mundo externo
2. **SincronizaÃ§Ã£o**: Manter sistema externo alinhado com React
3. **Timing**: Executa apÃ³s render + commit (assÃ­ncrono)
4. **DependÃªncias**: Array declara quando re-executar
5. **Cleanup**: FunÃ§Ã£o retornada limpa effect anterior

### Pilares Fundamentais

- **Effect function**: FunÃ§Ã£o com side effect
- **Dependencies array**: Quando re-executar
- **Cleanup function**: Return para limpar
- **Timing**: ApÃ³s browser pintar (nÃ£o bloqueia)
- **Closure**: Effect captura props/state do render

### VisÃ£o Geral das Nuances

- **Executa apÃ³s render**: NÃ£o bloqueia interface
- **Closure stale**: Captura valores do momento de criaÃ§Ã£o
- **Dependency array**: Omitir vs vazio vs com valores
- **Cleanup timing**: Antes de prÃ³ximo effect ou unmount
- **ESLint rules**: exhaustive-deps evita bugs

---

## ğŸ§  Fundamentos TeÃ³ricos

### Side Effects: O Que SÃ£o

**Side effect:** Qualquer operaÃ§Ã£o que afeta algo fora do componente.

**Exemplos:**
- **Data fetching**: `fetch('/api')`
- **Subscriptions**: WebSockets, event listeners
- **Timers**: `setTimeout`, `setInterval`
- **DOM manual**: `document.title = ...`
- **Logging**: `console.log`, analytics
- **localStorage**: Ler/escrever storage

**Por que precisam de useEffect?**

Componentes React devem ser **funÃ§Ãµes puras** durante render:
- Mesmo input â†’ sempre mesmo output
- NÃ£o fazem I/O, nÃ£o mutam estado externo

Side effects quebram pureza, entÃ£o vÃ£o em useEffect (executa **apÃ³s** render).

### Timing: Quando useEffect Executa

**Ordem de execuÃ§Ã£o:**

```
1. React renderiza (chama funÃ§Ã£o do componente)
    â†“
2. React atualiza DOM
    â†“
3. Browser pinta tela
    â†“
4. useEffect executa (assÃ­ncrono)
```

**Importante:** useEffect **nÃ£o bloqueia** pintura. Interface fica responsiva.

**ComparaÃ§Ã£o com classe:**

```javascript
// Classe
componentDidMount() {
  // Executa apÃ³s componente montar
}

// FunÃ§Ã£o
useEffect(() => {
  // Equivalente a componentDidMount
}, []);
```

### Array de DependÃªncias

**Conceito:** Determina quando effect re-executa.

**TrÃªs formas:**

```javascript
// 1. Sem array - executa TODA render (raramente desejado)
useEffect(() => {
  console.log('Toda render');
});

// 2. Array vazio - executa UMA vez (mount)
useEffect(() => {
  console.log('Apenas mount');
}, []);

// 3. Com dependÃªncias - executa quando deps mudam
useEffect(() => {
  console.log('Quando count ou name mudar');
}, [count, name]);
```

**Regra:** **Toda variÃ¡vel usada dentro do effect deve estar no array de deps** (ESLint enforÃ§a isso).

---

## ğŸ” AnÃ¡lise Conceitual Profunda

### 6.2.1 Conceito: Side Effects

#### O Que Vai em useEffect

**Side effects tÃ­picos:**

```javascript
function Component() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Fetch de dados
    fetch('/api/user')
      .then(res => res.json())
      .then(data => setUser(data));
  }, []);

  useEffect(() => {
    // Manipular DOM
    document.title = `User: ${user?.name}`;
  }, [user]);

  useEffect(() => {
    // Event listener
    const handleResize = () => console.log('resized');
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  useEffect(() => {
    // Timer
    const timer = setTimeout(() => {
      console.log('Delayed action');
    }, 1000);

    return () => clearTimeout(timer);
  }, []);

  return <div>{user?.name}</div>;
}
```

**O que NÃƒO vai em useEffect:**

```javascript
// âŒ NÃ£o precisa de useEffect
function Component({ items }) {
  // TransformaÃ§Ã£o de dados - faz no corpo do componente
  const filtered = items.filter(x => x.active);

  // Evento de renderizaÃ§Ã£o - faz inline
  return <button onClick={() => console.log('click')}>Click</button>;
}
```

### 6.2.2 ExecuÃ§Ã£o e Array de DependÃªncias

#### DependÃªncias: Como Funciona

**React compara dependÃªncias:**

```javascript
useEffect(() => {
  console.log('Effect');
}, [count, name]);

// Render 1: count=0, name='Ana'
// Effect executa

// Render 2: count=0, name='Ana'
// React compara: count === 0 âœ“, name === 'Ana' âœ“
// Effect NÃƒO executa (deps nÃ£o mudaram)

// Render 3: count=1, name='Ana'
// React compara: count !== 0 âœ—
// Effect executa (count mudou)
```

**ComparaÃ§Ã£o:** React usa `Object.is()` (similar a `===`).

**ImplicaÃ§Ã£o com objetos/arrays:**

```javascript
// âŒ PROBLEMA
useEffect(() => {
  console.log('Effect');
}, [{ id: 1 }]); // Novo objeto toda render!

// Effect executa TODA render (objeto sempre diferente)

// âœ… SoluÃ§Ã£o: DependÃªncia primitiva
useEffect(() => {
  console.log('Effect');
}, [user.id]); // Compara ID (number)
```

#### ESLint Rule: exhaustive-deps

**Regra:** Toda variÃ¡vel **usada** no effect deve estar no **array de deps**.

```javascript
// âŒ ESLint warning
function Component({ userId }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(`/api/user/${userId}`) // Usa userId
      .then(res => res.json())
      .then(setData);
  }, []); // userId nÃ£o estÃ¡ nas deps!

  // Problema: Se userId mudar, effect nÃ£o re-executa
}

// âœ… Correto
useEffect(() => {
  fetch(`/api/user/${userId}`)
    .then(res => res.json())
    .then(setData);
}, [userId]); // userId nas deps
```

**Por que isso importa:**

```javascript
// Sem userId nas deps
// 1. userId = 1 â†’ fetch /api/user/1
// 2. userId muda para 2
// 3. Effect nÃ£o re-executa â†’ ainda mostra dados do usuÃ¡rio 1!

// Com userId nas deps
// 1. userId = 1 â†’ fetch /api/user/1
// 2. userId muda para 2
// 3. Effect re-executa â†’ fetch /api/user/2 âœ“
```

### 6.2.3 Cleanup Function

#### O Que Ã‰ Cleanup

**Conceito:** FunÃ§Ã£o retornada pelo effect, chamada para "limpar" effect anterior.

```javascript
useEffect(() => {
  // Setup
  console.log('Effect started');

  return () => {
    // Cleanup
    console.log('Effect cleaned up');
  };
}, [dependency]);
```

**Quando cleanup executa:**

1. **Antes de prÃ³ximo effect** (se deps mudaram)
2. **Antes de unmount** (componente saindo do DOM)

**Fluxo completo:**

```
Mount:
  â†’ Effect executa

Dependency muda:
  â†’ Cleanup executa (limpa effect anterior)
  â†’ Effect executa (com novos valores)

Unmount:
  â†’ Cleanup executa (limpa Ãºltimo effect)
```

#### Casos de Uso de Cleanup

**1. Subscriptions:**

```javascript
useEffect(() => {
  const subscription = subscribe(userId);

  return () => {
    subscription.unsubscribe(); // Limpa subscription
  };
}, [userId]);

// Quando userId muda:
// 1. Cleanup: unsubscribe do userId anterior
// 2. Setup: subscribe ao novo userId
```

**2. Event Listeners:**

```javascript
useEffect(() => {
  const handleScroll = () => console.log('scrolling');
  window.addEventListener('scroll', handleScroll);

  return () => {
    window.removeEventListener('scroll', handleScroll); // Remove listener
  };
}, []);

// Ao unmount: cleanup remove listener (evita memory leak)
```

**3. Timers:**

```javascript
useEffect(() => {
  const timer = setTimeout(() => {
    console.log('Delayed');
  }, 1000);

  return () => {
    clearTimeout(timer); // Cancela timer pendente
  };
}, []);
```

**4. Cancelar Fetch (AbortController):**

```javascript
useEffect(() => {
  const abortController = new AbortController();

  fetch('/api/data', { signal: abortController.signal })
    .then(res => res.json())
    .then(setData)
    .catch(err => {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    });

  return () => {
    abortController.abort(); // Cancela fetch se componente desmontar
  };
}, []);
```

### 6.2.4 Armadilhas: Stale Closures

**Problema:** Effect captura valores do momento de criaÃ§Ã£o (closure).

```javascript
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count); // Sempre loga 0!
      // count Ã© do momento que effect foi criado
    }, 1000);

    return () => clearInterval(timer);
  }, []); // Deps vazio = cria apenas uma vez

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

**SoluÃ§Ãµes:**

**1. Incluir na dependÃªncia:**

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log(count); // Agora loga valor atual
  }, 1000);

  return () => clearInterval(timer);
}, [count]); // Re-cria timer quando count muda
```

**Problema:** Timer Ã© recriado toda vez (pode nÃ£o ser desejado).

**2. Usar forma funcional de setState:**

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prev => {
      console.log(prev); // Sempre tem valor atual
      return prev + 1;
    });
  }, 1000);

  return () => clearInterval(timer);
}, []); // NÃ£o precisa de count nas deps
```

**3. useRef para valor mutÃ¡vel:**

```javascript
function Component() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  // MantÃ©m ref atualizada
  useEffect(() => {
    countRef.current = count;
  }, [count]);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(countRef.current); // Sempre atual
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

## ğŸ¯ Aplicabilidade e Contextos

### Casos de Uso Comuns

#### Data Fetching

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    setLoading(true);

    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        console.error(err);
        setLoading(false);
      });
  }, [userId]); // Re-fetch quando userId muda

  if (loading) return <div>Loading...</div>;
  return <div>{user?.name}</div>;
}
```

#### Document Title

```javascript
function PageTitle({ title }) {
  useEffect(() => {
    document.title = title;
  }, [title]);

  return <h1>{title}</h1>;
}
```

#### Event Listeners

```javascript
function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <div>{size.width} x {size.height}</div>;
}
```

---

## âš ï¸ LimitaÃ§Ãµes e ConsideraÃ§Ãµes

### Armadilhas Comuns

**1. Deps faltando:**
```javascript
// âŒ userId usado mas nÃ£o nas deps
useEffect(() => {
  fetch(`/api/user/${userId}`);
}, []);

// âœ… userId nas deps
useEffect(() => {
  fetch(`/api/user/${userId}`);
}, [userId]);
```

**2. Infinite loop:**
```javascript
// âŒ Loop infinito
useEffect(() => {
  setData(newData); // Dispara re-render
}, [data]); // data mudou â†’ effect â†’ setData â†’ data mudou...

// âœ… Condicional ou deps corretas
useEffect(() => {
  if (needsUpdate) {
    setData(newData);
  }
}, [needsUpdate]);
```

**3. Objeto/array nas deps:**
```javascript
// âŒ Novo objeto toda render
useEffect(() => {
  console.log('Effect');
}, [{ id: userId }]); // Sempre diferente

// âœ… Primitivos
useEffect(() => {
  console.log('Effect');
}, [userId]);
```

---

## ğŸ”— InterconexÃµes Conceituais

### RelaÃ§Ã£o com useState

useEffect reage a mudanÃ§as de state. setState dispara re-render â†’ effect pode re-executar.

### RelaÃ§Ã£o com useLayoutEffect

useLayoutEffect Ã© sÃ­ncrono (antes de pintar), useEffect Ã© assÃ­ncrono (apÃ³s pintar).

### RelaÃ§Ã£o com Custom Hooks

Effects sÃ£o encapsulados em custom hooks para reutilizaÃ§Ã£o.

---

## ğŸš€ EvoluÃ§Ã£o e PrÃ³ximos Conceitos

### ProgressÃ£o Natural

```
useEffect bÃ¡sico
    â†“
useEffect com cleanup
    â†“
useEffect patterns (data fetching, subscriptions)
    â†“
Custom hooks (encapsular effects)
```

---

## ğŸ“š ConclusÃ£o

useEffect Ã© **essencial** para side effects. PrincÃ­pios:

1. **Side effects**: OperaÃ§Ãµes fora do render puro
2. **Timing**: ApÃ³s render + paint (assÃ­ncrono)
3. **Dependencies**: Declaram quando re-executar
4. **Cleanup**: Limpar resources
5. **Stale closures**: Cuidado com valores capturados

**RecomendaÃ§Ãµes:**
- Toda variÃ¡vel usada deve estar nas deps (ESLint)
- Sempre retorne cleanup se necessÃ¡rio
- Use forma funcional de setState para evitar stale closures
- Separe concerns em mÃºltiplos effects

**Dominar useEffect = dominar side effects em React.**
