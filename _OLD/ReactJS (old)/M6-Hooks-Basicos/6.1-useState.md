# useState no React: Gerenciamento de Estado Local

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useState` √© o **hook fundamental** para adicionar estado local a componentes funcionais React. Conceitualmente, √© uma fun√ß√£o que permite "lembrar" valores entre renderiza√ß√µes, criando **mem√≥ria persistente** em fun√ß√µes que, por natureza, n√£o t√™m estado. Retorna um par: o **valor atual do estado** e uma **fun√ß√£o setter** para atualiz√°-lo, implementando o padr√£o de **estado reativo** onde mudan√ßas disparam automaticamente re-renderiza√ß√£o do componente.

√â a diferen√ßa entre componentes est√°ticos (sempre renderizam o mesmo) e componentes din√¢micos (respondem a intera√ß√µes). Representa a ponte entre **dados mut√°veis** (que mudam) e **UI reativa** (que reflete essas mudan√ßas automaticamente).

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o do estado em React:**

**2013-2018: Era das Classes**
Antes dos hooks, estado local s√≥ existia em componentes de classe via `this.state` e `this.setState()`. Componentes funcionais eram "stateless" - limitados a receber props e renderizar.

**Problema:** Classes t√™m complexidade (binding de `this`, lifecycle methods), mas eram obrigat√≥rias para estado.

**2018 - Revolu√ß√£o dos Hooks (React 16.8):**
Equipe React introduziu Hooks, liderados por `useState`:
- **Motiva√ß√£o prim√°ria**: Estado em fun√ß√µes, sem classes
- **Simplicidade**: Sem `this`, sem binding, sem lifecycle confuso
- **Composi√ß√£o**: M√∫ltiplos `useState` ao inv√©s de um objeto gigante `this.state`
- **Custom hooks**: Reutilizar l√≥gica com estado

**Cita√ß√£o hist√≥rica (Dan Abramov):**
> "Hooks let you use state and other React features without writing a class."

**2019-hoje: Padr√£o dominante**
- Componentes funcionais + hooks viraram recomenda√ß√£o oficial
- Classes consideradas legado (ainda suportadas)
- `useState` √© hook mais usado (junto com `useEffect`)

### Problema Fundamental que Resolve

**Sem estado:**

**Problema 1 - Interatividade:**
Como criar contador que incrementa ao clicar? Vari√°vel local reseta toda render.

**Problema 2 - Formul√°rios:**
Como armazenar valor de input? Props s√£o imut√°veis, precisamos estado mut√°vel.

**Problema 3 - UI din√¢mica:**
Como alternar entre light/dark mode? Precisa "lembrar" prefer√™ncia.

**useState resolve:**

```javascript
// Antes (vari√°vel local - N√ÉO funciona)
function Counter() {
  let count = 0; // Reseta para 0 toda render!

  return (
    <button onClick={() => { count++; }}>
      {count} // Sempre mostra 0
    </button>
  );
}

// Depois (useState - FUNCIONA)
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      {count} // Incrementa corretamente
    </button>
  );
}
```

**Benef√≠cios:**
1. **Persist√™ncia**: Valor sobrevive entre re-renders
2. **Reatividade**: Mudan√ßa dispara re-render autom√°tico
3. **Isolamento**: Cada inst√¢ncia do componente tem seu pr√≥prio estado
4. **Simplicidade**: API minimalista e intuitiva

### Import√¢ncia no Ecossistema

`useState` √© **absolutamente fundamental** no React moderno:

- **Ubiquidade**: Quase todo componente n√£o-trivial usa useState
- **Foundation**: Base para hooks mais complexos (useReducer, custom hooks)
- **Developer Experience**: Revolucionou simplicidade de componentes React
- **Performance**: React otimiza re-renders baseado em mudan√ßas de estado

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Mem√≥ria entre renders**: Hook persiste valor atrav√©s de renderiza√ß√µes
2. **Reatividade**: Setter dispara re-render autom√°tico
3. **Isolamento por inst√¢ncia**: Cada componente tem estado pr√≥prio
4. **Closures**: Hook usa closures para "lembrar" valores
5. **Imutabilidade**: Estado deve ser tratado como imut√°vel

### Pilares Fundamentais

- **Declara√ß√£o**: `const [state, setState] = useState(initialValue)`
- **Valor inicial**: Argumento passado para useState
- **State variable**: Primeiro elemento do array retornado
- **Setter function**: Segundo elemento, atualiza estado
- **Functional updates**: Setter aceita fun√ß√£o para acesso a estado anterior
- **Lazy initialization**: Initial value pode ser fun√ß√£o

### Vis√£o Geral das Nuances

- **Array destructuring**: Nomenclatura livre dos valores retornados
- **M√∫ltiplos estados**: Pode chamar useState m√∫ltiplas vezes
- **Batching**: M√∫ltiplas atualiza√ß√µes agrupadas
- **Async updates**: setState √© ass√≠ncrono
- **Stale closures**: Closures capturam valores "antigos"

---

## üß† Fundamentos Te√≥ricos

### Como useState Funciona Internamente

#### Closures: A Magia por Tr√°s

**Conceito:** JavaScript closures permitem fun√ß√µes "lembrarem" vari√°veis do escopo externo.

```javascript
// Closure simples
function createCounter() {
  let count = 0; // Vari√°vel no escopo externo

  return function increment() {
    count++; // "Captura" count
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2 - count foi "lembrado"!
```

**useState usa closures similarmente:**

```javascript
// Simplifica√ß√£o conceitual de useState
function useState(initialValue) {
  let state = initialValue; // "Mem√≥ria" persistente (na verdade, no Fiber)

  function setState(newValue) {
    state = newValue;
    reRender(); // Dispara re-render
  }

  return [state, setState];
}
```

**Na realidade:** React n√£o usa vari√°veis globais. Cada componente tem um **Fiber node** (estrutura interna) que armazena array de hooks na ordem de chamada.

#### Fiber e Hooks List

**Estrutura interna (conceitual):**

```javascript
// Fiber node do componente
{
  component: MyComponent,
  hooks: [
    { type: 'useState', value: 0, setState: fn },
    { type: 'useState', value: '', setState: fn },
    { type: 'useEffect', effect: fn, deps: [] }
  ]
}
```

**Ordem importa:** React identifica hooks por **posi√ß√£o**, n√£o por nome. Por isso hooks devem ser chamados na mesma ordem sempre.

```javascript
// ‚ùå ERRADO - ordem muda
function Component({ condition }) {
  if (condition) {
    const [state, setState] = useState(0); // √Äs vezes primeira posi√ß√£o, √†s vezes n√£o
  }
  const [name, setName] = useState(''); // Posi√ß√£o varia
}

// ‚úÖ CORRETO - ordem consistente
function Component({ condition }) {
  const [state, setState] = useState(0); // Sempre primeira posi√ß√£o
  const [name, setName] = useState(''); // Sempre segunda posi√ß√£o

  if (condition) {
    // Use state aqui
  }
}
```

### Reatividade: Estado ‚Üí UI

**Fluxo:**

```
1. Usu√°rio interage (ex: clica bot√£o)
    ‚Üì
2. Event handler chama setState(newValue)
    ‚Üì
3. React agenda re-render (n√£o imediato)
    ‚Üì
4. React re-executa fun√ß√£o do componente
    ‚Üì
5. useState retorna novo valor
    ‚Üì
6. JSX √© recalculado com novo valor
    ‚Üì
7. React atualiza DOM
```

**Importante:** setState √© **ass√≠ncrono**. Estado n√£o muda imediatamente.

```javascript
function Component() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(10);
    console.log(count); // Ainda √© 0! (valor do render atual)
  }

  return <button onClick={handleClick}>{count}</button>;
}
```

### Isolamento por Inst√¢ncia

Cada inst√¢ncia de componente tem **estado pr√≥prio**:

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

// Uso - duas inst√¢ncias independentes
<Counter /> // count pr√≥prio
<Counter /> // count pr√≥prio (n√£o compartilha)
```

---

## üîç An√°lise Conceitual Profunda

### 6.1.1 Sintaxe e Declara√ß√£o

#### Sintaxe B√°sica

```javascript
import { useState } from 'react';

function Component() {
  const [state, setState] = useState(initialValue);

  // state: valor atual
  // setState: fun√ß√£o para atualizar
  // initialValue: valor inicial
}
```

**Array destructuring:** Permite nomear valores livremente:

```javascript
const [count, setCount] = useState(0);
const [name, setName] = useState('');
const [isActive, setIsActive] = useState(false);
// Nomes s√£o escolha sua, n√£o impostos pelo React
```

**Por que array, n√£o objeto?**

```javascript
// Se fosse objeto
const { state, setState } = useState(0); // Nomes fixos

// Com array
const [count, setCount] = useState(0); // Nomes livres
const [age, setAge] = useState(0); // Pode usar nomes descritivos
```

#### Tipos de Valores Iniciais

**Primitivos:**

```javascript
const [count, setCount] = useState(0); // Number
const [name, setName] = useState('Jo√£o'); // String
const [isActive, setIsActive] = useState(true); // Boolean
const [value, setValue] = useState(null); // Null
const [data, setData] = useState(undefined); // Undefined
```

**Objetos:**

```javascript
const [user, setUser] = useState({
  name: 'Ana',
  age: 25,
  email: 'ana@example.com'
});
```

**Arrays:**

```javascript
const [items, setItems] = useState([1, 2, 3]);
const [todos, setTodos] = useState([]);
```

**Fun√ß√µes (lazy initialization):**

```javascript
// ‚ùå Fun√ß√£o chamada toda render (ineficiente)
const [data, setData] = useState(expensiveCalculation());

// ‚úÖ Fun√ß√£o passada, React chama apenas uma vez
const [data, setData] = useState(() => expensiveCalculation());

// √ötil quando inicial value √© caro de calcular
const [state, setState] = useState(() => {
  const stored = localStorage.getItem('key');
  return stored ? JSON.parse(stored) : defaultValue;
});
```

#### Nomenclatura Convencional

**Padr√£o:** `[value, setValue]` ou `[thing, setThing]`

```javascript
// ‚úÖ Boas pr√°ticas
const [count, setCount] = useState(0);
const [isOpen, setIsOpen] = useState(false);
const [user, setUser] = useState(null);

// ‚ùå Evitar
const [count, updateCount] = useState(0); // "update" √© menos claro que "set"
const [x, y] = useState(0); // Nomes n√£o descritivos
```

### 6.1.2 Atualiza√ß√£o de Estado (Imutabilidade)

#### Primitivos: Substitui√ß√£o Direta

```javascript
const [count, setCount] = useState(0);

// Atualiza√ß√£o simples
setCount(10); // count vira 10
setCount(count + 1); // Incrementa

const [name, setName] = useState('Jo√£o');
setName('Maria'); // Substitui

const [isActive, setIsActive] = useState(false);
setIsActive(true); // Alterna
setIsActive(!isActive); // Toggle
```

#### Objetos: Spread Operator

**Regra:** **Nunca mute objeto diretamente**. Crie novo objeto.

```javascript
const [user, setUser] = useState({
  name: 'Ana',
  age: 25,
  email: 'ana@example.com'
});

// ‚ùå ERRADO - muta√ß√£o direta
user.age = 26;
setUser(user); // React pode n√£o detectar mudan√ßa (mesma refer√™ncia)

// ‚úÖ CORRETO - cria novo objeto com spread
setUser({
  ...user,
  age: 26 // Sobrescreve apenas age
});

// Atualizar m√∫ltiplas propriedades
setUser({
  ...user,
  age: 26,
  email: 'nova@example.com'
});

// Atualizar propriedade aninhada
const [data, setData] = useState({
  profile: {
    name: 'Ana',
    settings: { theme: 'dark' }
  }
});

setData({
  ...data,
  profile: {
    ...data.profile,
    settings: {
      ...data.profile.settings,
      theme: 'light' // Atualiza profundamente
    }
  }
});
```

**Alternativa para objetos complexos:** Considere `useReducer` ou bibliotecas (Immer).

#### Arrays: M√©todos Imut√°veis

**Regra:** Use m√©todos que **retornam novo array**, n√£o que mutam.

```javascript
const [items, setItems] = useState([1, 2, 3]);

// ‚ùå ERRADO - m√©todos que mutam
items.push(4);
setItems(items); // React pode n√£o detectar

items.sort();
setItems(items);

// ‚úÖ CORRETO - m√©todos imut√°veis

// Adicionar item
setItems([...items, 4]); // Spread + novo item
setItems(items.concat(4)); // concat retorna novo array

// Adicionar no in√≠cio
setItems([0, ...items]);

// Remover item (por √≠ndice)
setItems(items.filter((_, index) => index !== indexToRemove));

// Remover item (por valor)
setItems(items.filter(item => item.id !== idToRemove));

// Atualizar item
setItems(items.map(item =>
  item.id === targetId ? { ...item, done: true } : item
));

// Ordenar
setItems([...items].sort((a, b) => a - b)); // Copia antes de sort

// Reverter
setItems([...items].reverse());
```

**Resumo de m√©todos:**

| Muta | Imut√°vel |
|------|----------|
| push, pop | concat, [...arr, item] |
| shift, unshift | [item, ...arr] |
| splice | filter, slice |
| sort, reverse | [...arr].sort(), [...arr].reverse() |

### 6.1.3 Functional Updates (Forma Funcional)

**Problema:** Closures capturam valores antigos.

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(count + 1);
    setCount(count + 1);
    // Espera: count + 2
    // Realidade: count + 1 (ambas usam count do snapshot atual)
  }
}
```

**Solu√ß√£o:** Passar fun√ß√£o para setState.

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(prev => prev + 1); // prev √© valor mais recente
    setCount(prev => prev + 1);
    // Resultado: count + 2 ‚úÖ
  }
}
```

**Quando usar functional update:**

1. **Novo valor depende do anterior:**
```javascript
setCount(prev => prev + 1);
setItems(prev => [...prev, newItem]);
```

2. **M√∫ltiplas atualiza√ß√µes seguidas:**
```javascript
function handleClick() {
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
  // Todas executam corretamente
}
```

3. **Em callbacks que capturam estado antigo:**
```javascript
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prev => prev + 1); // Sempre acessa valor mais recente
  }, 1000);

  return () => clearInterval(timer);
}, []); // Sem count nas depend√™ncias, mas funciona!
```

#### Forma Funcional com Objetos/Arrays

```javascript
// Objetos
setUser(prev => ({
  ...prev,
  age: prev.age + 1
}));

// Arrays
setItems(prev => [...prev, newItem]);
setItems(prev => prev.filter(item => item.id !== id));
setItems(prev => prev.map(item =>
  item.id === id ? { ...item, done: true } : item
));
```

### 6.1.4 Lazy Initialization

**Problema:** Valor inicial √© computa√ß√£o cara, executa toda render.

```javascript
// ‚ùå expensiveFunction() roda toda render
const [data, setData] = useState(expensiveFunction());
```

**Solu√ß√£o:** Passar fun√ß√£o, React chama apenas primeira render.

```javascript
// ‚úÖ Fun√ß√£o executada apenas uma vez
const [data, setData] = useState(() => expensiveFunction());
```

**Casos de uso:**

```javascript
// localStorage (s√≠ncrono, mas pode ser lento)
const [theme, setTheme] = useState(() => {
  const stored = localStorage.getItem('theme');
  return stored || 'light';
});

// C√°lculo pesado
const [computed, setComputed] = useState(() => {
  return items.map(x => x * 2).reduce((a, b) => a + b, 0);
});

// Gerar ID √∫nico
const [id, setId] = useState(() => Math.random().toString(36));
```

### 6.1.5 M√∫ltiplos Estados

**Padr√£o:** Separar estados relacionados em vari√°veis distintas.

```javascript
function Form() {
  // M√∫ltiplos useState
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Uso independente
  return (
    <form>
      <input value={name} onChange={e => setName(e.target.value)} />
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <input value={age} onChange={e => setAge(Number(e.target.value))} />
      <button disabled={isSubmitting}>Submit</button>
    </form>
  );
}
```

**vs Estado √∫nico (objeto):**

```javascript
const [formData, setFormData] = useState({
  name: '',
  email: '',
  age: 0,
  isSubmitting: false
});

// Atualiza√ß√£o requer spread
setFormData({ ...formData, name: 'Novo nome' });
```

**Quando usar cada:**

| M√∫ltiplos useState | Estado √∫nico (objeto) |
|-------------------|----------------------|
| Valores independentes | Valores sempre atualizados juntos |
| Diferentes tipos | Mesma estrutura |
| Mais leg√≠vel para <5 valores | Mais de 5-10 valores relacionados |
| Performance levemente melhor | Mais organizado para dados complexos |

---

## üéØ Aplicabilidade e Contextos

### Casos de Uso Comuns

#### Contadores

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </>
  );
}
```

#### Toggles/Booleans

```javascript
function Toggle() {
  const [isOn, setIsOn] = useState(false);

  return (
    <button onClick={() => setIsOn(!isOn)}>
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}
```

#### Formul√°rios (Controlled Components)

```javascript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    login(email, password);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button>Login</button>
    </form>
  );
}
```

#### Listas Din√¢micas

```javascript
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');

  const addTodo = () => {
    setTodos([...todos, { id: Date.now(), text: input, done: false }]);
    setInput('');
  };

  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };

  const removeTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.done}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => removeTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Armadilhas Comuns

**1. Muta√ß√£o direta:**
```javascript
// ‚ùå N√£o funciona
const [items, setItems] = useState([1, 2]);
items.push(3);
setItems(items);

// ‚úÖ Correto
setItems([...items, 3]);
```

**2. Depend√™ncia de valor anterior sem functional update:**
```javascript
// ‚ùå Bugado
setCount(count + 1);
setCount(count + 1); // Adiciona 1, n√£o 2

// ‚úÖ Correto
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

**3. Stale closures:**
```javascript
// ‚ùå count capturado √© antigo
useEffect(() => {
  setInterval(() => {
    setCount(count + 1); // count √© do momento de cria√ß√£o
  }, 1000);
}, []);

// ‚úÖ Use functional update
setCount(prev => prev + 1);
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useEffect

Estado dispara re-render ‚Üí useEffect observa mudan√ßas.

### Rela√ß√£o com Props

Props descem, estado √© local. Props inicializam estado.

### Rela√ß√£o com useReducer

useState √© useReducer simplificado. Para l√≥gica complexa, use useReducer.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
useState (b√°sico)
    ‚Üì
useState com objetos/arrays complexos
    ‚Üì
useReducer (l√≥gica de estado complexa)
    ‚Üì
Custom hooks (encapsular useState)
```

---

## üìö Conclus√£o

useState √© **funda√ß√£o** do React moderno. Princ√≠pios essenciais:

1. **Persist√™ncia**: Estado sobrevive entre renders
2. **Imutabilidade**: Sempre crie novos valores
3. **Functional updates**: Use quando depende de anterior
4. **Lazy initialization**: Para valores caros
5. **M√∫ltiplos estados**: Separe valores independentes

**Recomenda√ß√µes:**
- Trate estado como imut√°vel
- Use functional updates para depend√™ncia de valor anterior
- Lazy initialization para computa√ß√µes caras
- Separe estados independentes
- Objetos complexos? Considere useReducer

**Dominar useState = dominar estado local em React.** √â skill absolutamente fundamental para qualquer desenvolvedor React.
