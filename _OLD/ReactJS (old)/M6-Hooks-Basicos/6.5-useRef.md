# useRef no React: Refer√™ncias Mut√°veis

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

`useRef` √© o hook para criar **refer√™ncias mut√°veis persistentes** que sobrevivem entre re-renders sem causar re-renderiza√ß√£o quando modificadas. Conceitualmente, √© uma "caixa" que pode guardar qualquer valor mut√°vel (primitivo, objeto, fun√ß√£o) que voc√™ quer **preservar** mas **n√£o** quer que dispare re-render quando mudar.

Possui dois usos principais: (1) **Acessar elementos DOM diretamente** (como `document.getElementById`, mas "o jeito React"), e (2) **Armazenar valores mut√°veis** que precisam persistir mas n√£o s√£o state (timers, subscriptions, valores anteriores). √â o equivalente a vari√°veis de inst√¢ncia em classes (`this.something`).

**Met√°fora:** Se useState √© "vari√°vel reativa" (muda ‚Üí re-render), useRef √© "vari√°vel silenciosa" (muda, mas React n√£o reage). √â uma "gaveta" onde voc√™ guarda coisas que precisa lembrar, mas n√£o precisa exibir.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o do acesso a DOM e valores mut√°veis:**

**2013-2018: Refs em Classes**
Em classes, refs eram criadas com `createRef()` ou callback refs:
```javascript
class Component extends React.Component {
  inputRef = React.createRef();
  timerId = null; // Vari√°vel de inst√¢ncia

  componentDidMount() {
    this.inputRef.current.focus();
    this.timerId = setInterval(...);
  }
}
```

**Problema com Hooks:** Componentes funcionais n√£o t√™m `this`, ent√£o n√£o h√° lugar para vari√°veis de inst√¢ncia.

**2018 - useRef (React 16.8):**
Hooks introduziram useRef para:
- **Acessar DOM**: Refer√™ncia a elementos
- **Valores mut√°veis**: Substituir vari√°veis de inst√¢ncia
- **Persist√™ncia**: Valores sobrevivem re-renders
- **Sem re-render**: Mutar ref n√£o causa re-renderiza√ß√£o

**Filosofia:** Pense em useRef como "escape hatch" do modelo declarativo - quando voc√™ precisa de **imperatividade** (acessar DOM) ou **mutabilidade silenciosa** (valores que mudam sem re-render).

### Problema Fundamental que Resolve

**Sem useRef:**

**Problema 1 - Acessar DOM:**
```javascript
// ‚ùå Como fazer focus em input sem useRef?
function Form() {
  // N√£o h√° jeito "React" de acessar elemento
  return <input type="text" />;
}

// Solu√ß√£o anti-pattern: document.querySelector (quebra encapsulamento)
document.querySelector('input').focus(); // ‚ùå Fr√°gil, n√£o recomendado
```

**Problema 2 - Valores mut√°veis:**
```javascript
// ‚ùå Vari√°vel local n√£o persiste
function Counter() {
  let count = 0; // Resetado toda render

  const increment = () => {
    count++; // Incrementa, mas perde no pr√≥ximo render
    console.log(count);
  };

  return <button onClick={increment}>{count}</button>;
}
// Clique 1: loga 1, mostra 0
// Clique 2: loga 1 (n√£o 2!), mostra 0
```

**Problema 3 - Stale closures:**
```javascript
// ‚ùå Interval captura valor antigo de count
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count); // Sempre loga 0 (valor do momento de cria√ß√£o)
    }, 1000);

    return () => clearInterval(timer);
  }, []); // Deps vazio

  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

**useRef resolve:**

```javascript
// ‚úÖ Problema 1: Acessar DOM
function Form() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus(); // Acesso direto ao elemento
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>Focar</button>
    </div>
  );
}

// ‚úÖ Problema 2: Valor mut√°vel persistente
function Counter() {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current++; // Persiste entre renders
    console.log(countRef.current);
  };

  return <button onClick={increment}>Clicado {countRef.current} vezes</button>;
}

// ‚úÖ Problema 3: Evitar stale closure
function Component() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  // Manter ref sincronizada
  useEffect(() => {
    countRef.current = count;
  }, [count]);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(countRef.current); // Sempre tem valor atual
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

### Import√¢ncia no Ecossistema

useRef √© **fundamental** para:

- **Acesso a DOM**: Focus, scroll, medi√ß√µes, anima√ß√µes imperativas
- **Integra√ß√£o com bibliotecas**: Passar refer√™ncias para libs externas
- **Performance**: Valores que mudam sem causar re-render desnecess√°rio
- **Evitar stale closures**: Manter valores atualizados em callbacks/effects
- **Armazenar inst√¢ncias**: Timers, subscriptions, workers

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Mutabilidade**: `.current` pode ser mudado sem re-render
2. **Persist√™ncia**: Valor sobrevive entre re-renders
3. **Refer√™ncia est√°vel**: Mesmo objeto retornado sempre
4. **Dois usos**: DOM refs e valores mut√°veis
5. **N√£o reativo**: Mudar ref n√£o dispara atualiza√ß√£o

### Pilares Fundamentais

- **Objeto ref**: `{ current: value }`
- **Atributo current**: Propriedade mut√°vel
- **Inicializa√ß√£o**: Valor inicial passado ao criar
- **Estabilidade**: Mesmo objeto em todas as renders
- **Imperatividade**: Escape do modelo declarativo

### Vis√£o Geral das Nuances

- **N√£o causa re-render**: Mudar `.current` √© silencioso
- **Callback refs**: Alternativa para casos complexos
- **forwardRef**: Expor refs de child components
- **useImperativeHandle**: Customizar ref exposta
- **Compara√ß√£o com state**: Quando usar cada um

---

## ÔøΩüß† Fundamentos Te√≥ricos

### Anatomia de useRef

**Estrutura:**
```javascript
const ref = useRef(initialValue);

// Retorna objeto:
// { current: initialValue }

// Acessar/modificar:
ref.current // Ler valor
ref.current = newValue // Escrever (sem re-render)
```

**Caracter√≠sticas:**

```javascript
function Component() {
  const ref = useRef(0);

  console.log(ref); // { current: 0 }
  console.log(ref.current); // 0

  ref.current = 10; // Muta√ß√£o (sem re-render)
  console.log(ref.current); // 10

  // 'ref' √© SEMPRE o mesmo objeto (identidade est√°vel)
  const ref2 = useRef(0);
  console.log(ref === ref2); // false (refs diferentes)

  return <div>{ref.current}</div>;
}
```

### Diferen√ßa: useRef vs useState

**Compara√ß√£o:**

| Aspecto | useState | useRef |
|---------|----------|---------|
| **Re-render** | Causa re-render | N√£o causa |
| **Mutabilidade** | Imut√°vel (set cria novo) | Mut√°vel (`.current`) |
| **UI** | Para dados exibidos | Para dados internos |
| **Timing** | Ass√≠ncrono (batched) | S√≠ncrono (imediato) |
| **Persist√™ncia** | Sim | Sim |

**Exemplo:**

```javascript
function Comparison() {
  const [count, setCount] = useState(0); // State
  const countRef = useRef(0); // Ref

  const handleStateClick = () => {
    setCount(count + 1); // Re-render
  };

  const handleRefClick = () => {
    countRef.current++; // SEM re-render
    console.log('Ref:', countRef.current);
  };

  return (
    <div>
      <p>State: {count}</p> {/* Atualiza na tela */}
      <p>Ref: {countRef.current}</p> {/* N√ÉO atualiza (precisa re-render) */}
      <button onClick={handleStateClick}>Incrementar State</button>
      <button onClick={handleRefClick}>Incrementar Ref</button>
    </div>
  );
}

// Clicar "Incrementar Ref" n√£o atualiza tela
// Ref muda, mas componente n√£o re-renderiza
```

**Regra:**
- **useState**: Dados exibidos na UI
- **useRef**: Dados internos (timers, subscriptions, valores anteriores)

### Persist√™ncia Entre Renders

**Vari√°veis locais N√ÉO persistem:**

```javascript
function Component() {
  let count = 0; // Resetado toda render

  const increment = () => {
    count++;
    console.log(count); // Sempre loga 1
  };

  return <button onClick={increment}>Incrementar</button>;
}

// Toda render, count reinicia em 0
```

**useRef persiste:**

```javascript
function Component() {
  const countRef = useRef(0); // Persiste

  const increment = () => {
    countRef.current++;
    console.log(countRef.current); // 1, 2, 3, 4...
  };

  return <button onClick={increment}>Incrementar</button>;
}

// countRef.current mant√©m valor entre renders
```

---

## üîç An√°lise Conceitual Profunda

### 6.5.1 Uso 1: Acessar Elementos DOM

#### Focus em Input

```javascript
function AutoFocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    // Focar input ao montar componente
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} type="text" placeholder="Auto-focus" />;
}
```

**Fluxo:**
```
1. Render inicial: inputRef.current = null (ainda n√£o conectado)
2. React atualiza DOM: cria elemento <input>
3. React conecta ref: inputRef.current = <input element>
4. useEffect executa: inputRef.current.focus()
5. Input fica focado ‚úì
```

#### Scroll para Elemento

```javascript
function ChatMessages({ messages }) {
  const bottomRef = useRef(null);

  useEffect(() => {
    // Scroll para baixo quando novas mensagens chegarem
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
      <div ref={bottomRef} /> {/* Elemento invis√≠vel no final */}
    </div>
  );
}
```

#### Medir Dimens√µes

```javascript
function MeasureElement() {
  const elementRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  useLayoutEffect(() => {
    if (elementRef.current) {
      const { width, height } = elementRef.current.getBoundingClientRect();
      setDimensions({ width, height });
    }
  }, []);

  return (
    <div>
      <div ref={elementRef} style={{ width: '50%', height: '100px' }}>
        Conte√∫do
      </div>
      <p>Tamanho: {dimensions.width}px x {dimensions.height}px</p>
    </div>
  );
}
```

#### Reproduzir V√≠deo/√Åudio

```javascript
function VideoPlayer({ src }) {
  const videoRef = useRef(null);

  const handlePlay = () => {
    videoRef.current.play();
  };

  const handlePause = () => {
    videoRef.current.pause();
  };

  return (
    <div>
      <video ref={videoRef} src={src} />
      <button onClick={handlePlay}>Play</button>
      <button onClick={handlePause}>Pause</button>
    </div>
  );
}
```

### 6.5.2 Uso 2: Armazenar Valores Mut√°veis

#### Armazenar Timer ID

```javascript
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const timerIdRef = useRef(null);

  const start = () => {
    // Evitar m√∫ltiplos timers
    if (timerIdRef.current !== null) return;

    timerIdRef.current = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
  };

  const stop = () => {
    clearInterval(timerIdRef.current);
    timerIdRef.current = null;
  };

  const reset = () => {
    stop();
    setSeconds(0);
  };

  return (
    <div>
      <p>Segundos: {seconds}</p>
      <button onClick={start}>Iniciar</button>
      <button onClick={stop}>Parar</button>
      <button onClick={reset}>Resetar</button>
    </div>
  );
}
```

**Por que useRef?**
- `timerIdRef` precisa persistir entre renders
- N√£o precisa ser exibido (n√£o √© UI state)
- N√£o deve causar re-render quando mudar

#### Rastrear Valor Anterior

```javascript
function usePrevious(value) {
  const prevRef = useRef();

  useEffect(() => {
    prevRef.current = value; // Atualizar ap√≥s render
  }, [value]);

  return prevRef.current;
}

// Uso
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Atual: {count}</p>
      <p>Anterior: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Incrementar</button>
    </div>
  );
}

// Fluxo:
// Render 1: count=0, prevCount=undefined
// Click ‚Üí count=1
// Render 2: count=1, prevCount=0 (ainda tem valor anterior)
// useEffect: prevRef.current = 1 (atualiza para pr√≥ximo)
```

#### Evitar Stale Closure

```javascript
function Component() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  // Sincronizar ref com state
  useEffect(() => {
    countRef.current = count;
  }, [count]);

  useEffect(() => {
    const interval = setInterval(() => {
      // countRef.current sempre tem valor atual
      console.log('Count:', countRef.current);
    }, 1000);

    return () => clearInterval(interval);
  }, []); // Deps vazio OK (usa ref, n√£o state)

  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count: {count}
    </button>
  );
}
```

#### Armazenar Subscription

```javascript
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const subscriptionRef = useRef(null);

  useEffect(() => {
    // Criar subscription
    subscriptionRef.current = subscribe(roomId, (message) => {
      setMessages(prev => [...prev, message]);
    });

    return () => {
      // Cleanup: unsubscribe
      subscriptionRef.current?.unsubscribe();
      subscriptionRef.current = null;
    };
  }, [roomId]);

  return (
    <ul>
      {messages.map((msg, i) => (
        <li key={i}>{msg.text}</li>
      ))}
    </ul>
  );
}
```

### 6.5.3 Callback Refs

**Problema com useRef:** Ref n√£o notifica quando elemento √© conectado/desconectado.

**Solu√ß√£o:** Callback ref (fun√ß√£o passada como ref).

```javascript
function MeasureOnMount() {
  const [height, setHeight] = useState(0);

  // Callback ref - chamado quando elemento √© conectado
  const measureRef = useCallback((node) => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <div>
      <div ref={measureRef}>
        Conte√∫do que ser√° medido
      </div>
      <p>Altura: {height}px</p>
    </div>
  );
}
```

**Quando callback √© chamado:**
- `node !== null`: Elemento foi montado
- `node === null`: Elemento foi desmontado

**Caso avan√ßado: Medir quando conte√∫do muda**

```javascript
function DynamicMeasure({ children }) {
  const [height, setHeight] = useState(0);

  const measureRef = useCallback((node) => {
    if (node !== null) {
      // Observar mudan√ßas de tamanho
      const observer = new ResizeObserver(entries => {
        setHeight(entries[0].contentRect.height);
      });

      observer.observe(node);

      // Cleanup
      return () => observer.disconnect();
    }
  }, []);

  return (
    <div>
      <div ref={measureRef}>{children}</div>
      <p>Altura: {height}px</p>
    </div>
  );
}
```

### 6.5.4 forwardRef: Expor Refs de Child

**Problema:** Componentes n√£o aceitam `ref` como prop por padr√£o.

```javascript
// ‚ùå N√£o funciona
function Input(props) {
  return <input {...props} />;
}

function Parent() {
  const inputRef = useRef(null);
  return <Input ref={inputRef} />; // Warning! ref n√£o √© repassada
}
```

**Solu√ß√£o:** `forwardRef`

```javascript
// ‚úÖ forwardRef permite passar ref
const Input = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function Parent() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <Input ref={inputRef} />
      <button onClick={handleFocus}>Focar Input</button>
    </div>
  );
}
```

**Caso complexo: Ref para m√∫ltiplos elementos**

```javascript
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef(null);
  const labelRef = useRef(null);

  // Expor m√∫ltiplas refs
  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    scrollToLabel: () => labelRef.current.scrollIntoView()
  }));

  return (
    <div>
      <label ref={labelRef}>{props.label}</label>
      <input ref={inputRef} />
    </div>
  );
});

// Uso
function Parent() {
  const fancyRef = useRef(null);

  return (
    <div>
      <FancyInput ref={fancyRef} label="Nome" />
      <button onClick={() => fancyRef.current.focus()}>Focar</button>
      <button onClick={() => fancyRef.current.scrollToLabel()}>Scroll</button>
    </div>
  );
}
```

### 6.5.5 useImperativeHandle: Customizar Ref

**Uso:** Controlar o que parent pode acessar via ref.

```javascript
const VideoPlayer = forwardRef((props, ref) => {
  const videoRef = useRef(null);
  const [playing, setPlaying] = useState(false);

  // Expor API customizada via ref
  useImperativeHandle(ref, () => ({
    play: () => {
      videoRef.current.play();
      setPlaying(true);
    },
    pause: () => {
      videoRef.current.pause();
      setPlaying(false);
    },
    isPlaying: () => playing
  }));

  return <video ref={videoRef} src={props.src} />;
});

// Uso
function App() {
  const playerRef = useRef(null);

  return (
    <div>
      <VideoPlayer ref={playerRef} src="video.mp4" />
      <button onClick={() => playerRef.current.play()}>Play</button>
      <button onClick={() => playerRef.current.pause()}>Pause</button>
      <button onClick={() => alert(playerRef.current.isPlaying())}>
        Is Playing?
      </button>
    </div>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar useRef

**Checklist:**

‚úÖ Use `useRef` para:
- Acessar elementos DOM (focus, scroll, medi√ß√µes)
- Armazenar timers/intervals (clearTimeout, clearInterval)
- Armazenar subscriptions/listeners
- Rastrear valores anteriores
- Evitar stale closures em effects
- Armazenar valores que mudam sem causar re-render

‚ùå N√ÉO use `useRef` para:
- Dados exibidos na UI (use useState)
- Dados que devem causar re-render (use useState)
- Props (passe diretamente)

### Padr√µes Comuns

**Pattern 1: Auto-focus**
```javascript
const inputRef = useRef(null);
useEffect(() => {
  inputRef.current?.focus();
}, []);
```

**Pattern 2: Timer persistente**
```javascript
const timerRef = useRef(null);
timerRef.current = setTimeout(...);
// Cleanup: clearTimeout(timerRef.current)
```

**Pattern 3: Valor anterior**
```javascript
const prevRef = useRef();
useEffect(() => {
  prevRef.current = value;
}, [value]);
```

**Pattern 4: Evitar stale closure**
```javascript
const valueRef = useRef(value);
useEffect(() => {
  valueRef.current = value;
}, [value]);
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Armadilhas Comuns

**1. Ref n√£o causa re-render:**
```javascript
// ‚ùå UI n√£o atualiza
const countRef = useRef(0);

return (
  <div>
    <p>{countRef.current}</p> {/* N√£o atualiza */}
    <button onClick={() => countRef.current++}>Incrementar</button>
  </div>
);

// ‚úÖ Use useState para UI
const [count, setCount] = useState(0);
```

**2. Ref inicial √© null (DOM):**
```javascript
// ‚ùå Erro: Cannot read property 'focus' of null
const inputRef = useRef(null);
inputRef.current.focus(); // No corpo do componente, ref ainda √© null

// ‚úÖ Use em useEffect ou event handler
useEffect(() => {
  inputRef.current.focus(); // OK
}, []);
```

**3. N√£o use ref em render:**
```javascript
// ‚ùå Muta√ß√£o durante render (side effect)
function Component() {
  const countRef = useRef(0);
  countRef.current++; // ERRADO no corpo do componente

  return <div>{countRef.current}</div>;
}

// ‚úÖ Mute em effect ou event handler
useEffect(() => {
  countRef.current++;
}, []);
```

### Performance

**Refs s√£o leves:**
- N√£o causam re-render
- Ideal para valores que mudam frequentemente mas n√£o afetam UI

**Quando preferir ref a state:**
```javascript
// ‚ùå Re-render desnecess√°rio
const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

useEffect(() => {
  const handleMove = (e) => {
    setMousePos({ x: e.clientX, y: e.clientY }); // Re-render a cada movimento!
  };
  window.addEventListener('mousemove', handleMove);
  return () => window.removeEventListener('mousemove', handleMove);
}, []);

// ‚úÖ Sem re-render
const mousePosRef = useRef({ x: 0, y: 0 });

useEffect(() => {
  const handleMove = (e) => {
    mousePosRef.current = { x: e.clientX, y: e.clientY }; // Sem re-render
    // Use valor em callback/effect, n√£o na UI
  };
  window.addEventListener('mousemove', handleMove);
  return () => window.removeEventListener('mousemove', handleMove);
}, []);
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useEffect

useRef armazena valores para usar em effects sem causar re-execu√ß√£o.

### Rela√ß√£o com useState

useRef √© alternativa quando n√£o quer re-render. useState para dados de UI.

### Rela√ß√£o com useCallback/useMemo

Refs podem armazenar valores sem causar re-computa√ß√£o.

### Rela√ß√£o com forwardRef

forwardRef permite passar refs para child components.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
useRef b√°sico (DOM access)
    ‚Üì
useRef avan√ßado (valores mut√°veis)
    ‚Üì
forwardRef (expor refs)
    ‚Üì
useImperativeHandle (customizar ref)
```

---

## üìö Conclus√£o

useRef √© hook **essencial** para casos imperativos e valores mut√°veis. Princ√≠pios:

1. **Persist√™ncia**: Valores sobrevivem re-renders
2. **Mutabilidade**: `.current` pode mudar sem re-render
3. **Dois usos**: DOM refs e valores mut√°veis
4. **N√£o reativo**: Mudar ref n√£o atualiza UI
5. **Estabilidade**: Mesmo objeto sempre

**Recomenda√ß√µes:**
- Use para acessar DOM (focus, scroll, medi√ß√µes)
- Use para valores mut√°veis que n√£o s√£o UI (timers, subscriptions)
- N√£o mute refs durante render (apenas em effects/handlers)
- Prefira useState para dados de UI
- Use forwardRef para expor refs de child components

**Dominar useRef = entender quando sair do modelo declarativo para imperativo.**
