# Focus Management no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Focus Management** √© a pr√°tica de **controlar programaticamente qual elemento recebe foco** (keyboard focus), garantindo que **navega√ß√£o por teclado seja l√≥gica e previs√≠vel**. Conceitualmente, representa **cursor do teclado** - assim como o mouse tem cursor visual, o teclado precisa de indica√ß√£o clara de onde est√° e para onde vai, essencial para usu√°rios que n√£o usam mouse.

### Problema que Resolve

**Sem Focus Management**:
- Foco perdido ap√≥s a√ß√µes (modal fecha, item deleta)
- Navega√ß√£o il√≥gica (Tab pula elementos)
- Usu√°rios de teclado desorientados
- Screen readers n√£o sabem onde est√£o

**Com Focus Management**:
- Foco sempre em local esperado
- Navega√ß√£o previs√≠vel
- Feedback claro de a√ß√µes
- Experi√™ncia fluida para teclado

---

## üß† Fundamentos de Focus

### Elementos Focus√°veis Nativos

```jsx
// Nativamente focus√°veis (sem tabIndex):
<a href="/page">Link</a>
<button>Button</button>
<input type="text" />
<textarea />
<select />
<details />
<summary />

// N√ÉO focus√°veis nativamente:
<div>Not focusable</div>
<span>Not focusable</span>
<p>Not focusable</p>
```

### tabIndex

```jsx
// tabIndex={0} - Ordem natural, focus√°vel via Tab
<div tabIndex={0}>Now focusable</div>

// tabIndex={-1} - Focus√°vel programaticamente, n√£o via Tab
<div tabIndex={-1} ref={errorRef}>Error message</div>
errorRef.current.focus(); // Foca programaticamente

// ‚ùå tabIndex > 0 - NUNCA USE (quebra ordem natural)
<div tabIndex={1}>Bad practice!</div>
```

### :focus e :focus-visible

```css
/* :focus - sempre mostra quando focado */
button:focus {
  outline: 2px solid blue;
}

/* :focus-visible - mostra apenas com teclado (n√£o mouse) */
button:focus-visible {
  outline: 2px solid blue;
}

/* Remover outline padr√£o (mas ADICIONE estilo custom!) */
button:focus {
  outline: none; /* ‚ùå Nunca fa√ßa isso sozinho! */
}

/* ‚úÖ Remova outline padr√£o mas adicione custom */
button {
  outline: none;
}

button:focus-visible {
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.5);
}
```

---

## üéØ useRef e focus()

### Focus Program√°tico

```jsx
function SearchForm() {
  const inputRef = useRef(null);

  useEffect(() => {
    // Foca input ao montar
    inputRef.current?.focus();
  }, []);

  return (
    <input
      ref={inputRef}
      type="text"
      placeholder="Search..."
    />
  );
}
```

### Focus Condicional

```jsx
function Form() {
  const [error, setError] = useState('');
  const errorRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();

    if (!isValid) {
      setError('Invalid input');
      // Foca mensagem de erro
      errorRef.current?.focus();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" />
      <button type="submit">Submit</button>

      {error && (
        <div
          ref={errorRef}
          tabIndex={-1}
          role="alert"
        >
          {error}
        </div>
      )}
    </form>
  );
}
```

---

## üîí Focus Trap (Modals)

### Problema

```jsx
// ‚ùå Sem focus trap
function Modal({ isOpen, children }) {
  if (!isOpen) return null;

  return (
    <div className="modal">
      {children}
    </div>
  );
}
// Problema: Tab navega para elementos ATR√ÅS do modal!
```

### Solu√ß√£o Manual

```jsx
function Modal({ isOpen, onClose, children }) {
  const modalRef = useRef(null);

  useEffect(() => {
    if (!isOpen) return;

    const modal = modalRef.current;
    const focusableElements = modal.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    // Foca primeiro elemento
    firstElement?.focus();

    // Trap focus
    const handleTab = (e) => {
      if (e.key !== 'Tab') return;

      if (e.shiftKey) {
        // Shift+Tab
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        // Tab
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };

    modal.addEventListener('keydown', handleTab);

    return () => {
      modal.removeEventListener('keydown', handleTab);
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div ref={modalRef} role="dialog" aria-modal="true">
      {children}
    </div>
  );
}
```

### Usando Biblioteca (focus-trap-react)

```jsx
import FocusTrap from 'focus-trap-react';

function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;

  return (
    <FocusTrap>
      <div role="dialog" aria-modal="true">
        {children}
        <button onClick={onClose}>Close</button>
      </div>
    </FocusTrap>
  );
}
```

---

## ‚Ü©Ô∏è Restaurar Focus

### Salvar e Restaurar

```jsx
function Modal({ isOpen, onClose, children }) {
  const previousActiveElement = useRef(null);

  useEffect(() => {
    if (isOpen) {
      // Salvar elemento focado antes do modal
      previousActiveElement.current = document.activeElement;

      return () => {
        // Restaurar foco ao fechar
        previousActiveElement.current?.focus();
      };
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div role="dialog">
      {children}
      <button onClick={onClose}>Close</button>
    </div>
  );
}
```

### Exemplo Completo

```jsx
function DeleteButton({ itemId, onDelete }) {
  const [showConfirm, setShowConfirm] = useState(false);
  const buttonRef = useRef(null);
  const previousFocus = useRef(null);

  const handleDelete = () => {
    onDelete(itemId);
    // Foco retorna para bot√£o que abriu (mas ele foi deletado!)
    // Ent√£o foca pr√≥ximo item ou mensagem de sucesso
  };

  useEffect(() => {
    if (showConfirm) {
      previousFocus.current = document.activeElement;
    } else if (previousFocus.current) {
      previousFocus.current.focus();
    }
  }, [showConfirm]);

  return (
    <>
      <button
        ref={buttonRef}
        onClick={() => setShowConfirm(true)}
      >
        Delete
      </button>

      {showConfirm && (
        <FocusTrap>
          <div role="dialog">
            <p>Are you sure?</p>
            <button onClick={handleDelete}>Yes</button>
            <button onClick={() => setShowConfirm(false)}>No</button>
          </div>
        </FocusTrap>
      )}
    </>
  );
}
```

---

## üß≠ Roving tabIndex (Widget Navigation)

### Problema

```jsx
// ‚ùå Todos focus√°veis = muitos Tabs
<div role="toolbar">
  <button>Bold</button>
  <button>Italic</button>
  <button>Underline</button>
  {/* 20+ bot√µes - precisa Tab 20 vezes! */}
</div>
```

### Solu√ß√£o: Roving tabIndex

```jsx
// Apenas um item focus√°vel via Tab, Arrow keys para navegar
function Toolbar() {
  const [focusedIndex, setFocusedIndex] = useState(0);
  const buttons = ['Bold', 'Italic', 'Underline', 'Strike'];

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowRight') {
      setFocusedIndex((i) => (i + 1) % buttons.length);
    } else if (e.key === 'ArrowLeft') {
      setFocusedIndex((i) => (i - 1 + buttons.length) % buttons.length);
    }
  };

  return (
    <div role="toolbar" onKeyDown={handleKeyDown}>
      {buttons.map((label, i) => (
        <button
          key={label}
          tabIndex={i === focusedIndex ? 0 : -1}
          onClick={() => console.log(label)}
        >
          {label}
        </button>
      ))}
    </div>
  );
}
// Tab entra no toolbar (primeiro bot√£o)
// Arrow keys navegam entre bot√µes
// Tab sai do toolbar
```

### Tabs com Roving Index

```jsx
function Tabs({ tabs }) {
  const [selectedTab, setSelectedTab] = useState(0);
  const [focusedTab, setFocusedTab] = useState(0);
  const tabRefs = useRef([]);

  useEffect(() => {
    tabRefs.current[focusedTab]?.focus();
  }, [focusedTab]);

  const handleKeyDown = (e) => {
    switch (e.key) {
      case 'ArrowRight':
        setFocusedTab((i) => (i + 1) % tabs.length);
        break;
      case 'ArrowLeft':
        setFocusedTab((i) => (i - 1 + tabs.length) % tabs.length);
        break;
      case 'Home':
        setFocusedTab(0);
        break;
      case 'End':
        setFocusedTab(tabs.length - 1);
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        setSelectedTab(focusedTab);
        break;
    }
  };

  return (
    <div>
      <div role="tablist" onKeyDown={handleKeyDown}>
        {tabs.map((tab, i) => (
          <button
            key={i}
            ref={(el) => (tabRefs.current[i] = el)}
            role="tab"
            aria-selected={i === selectedTab}
            tabIndex={i === focusedTab ? 0 : -1}
            onClick={() => {
              setSelectedTab(i);
              setFocusedTab(i);
            }}
          >
            {tab.label}
          </button>
        ))}
      </div>
      <div role="tabpanel">{tabs[selectedTab].content}</div>
    </div>
  );
}
```

---

## üéØ Focus com Anima√ß√µes

### Aguardar Anima√ß√£o Terminar

```jsx
function Accordion({ items }) {
  const [openIndex, setOpenIndex] = useState(null);
  const contentRef = useRef(null);

  const handleToggle = (index) => {
    setOpenIndex(index === openIndex ? null : index);
  };

  useEffect(() => {
    if (openIndex !== null) {
      // Aguarda anima√ß√£o terminar antes de focar
      const timeout = setTimeout(() => {
        contentRef.current?.focus();
      }, 300); // Dura√ß√£o da anima√ß√£o

      return () => clearTimeout(timeout);
    }
  }, [openIndex]);

  return (
    <div>
      {items.map((item, i) => (
        <div key={i}>
          <button
            aria-expanded={i === openIndex}
            onClick={() => handleToggle(i)}
          >
            {item.title}
          </button>
          {i === openIndex && (
            <div
              ref={contentRef}
              tabIndex={-1}
              className="accordion-content"
            >
              {item.content}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

---

## üö´ Skip Links

### Pular Navega√ß√£o

```jsx
function Layout({ children }) {
  return (
    <>
      <a href="#main" className="skip-link">
        Skip to main content
      </a>

      <nav>
        {/* Muitos links */}
        <a href="/">Home</a>
        <a href="/about">About</a>
        {/* ... 20+ links */}
      </nav>

      <main id="main" tabIndex={-1}>
        {children}
      </main>
    </>
  );
}

// CSS
.skip-link {
  position: absolute;
  top: -40px;
  left: 0;
  background: #000;
  color: #fff;
  padding: 8px;
  z-index: 100;
}

.skip-link:focus {
  top: 0;
}
```

---

## üöÄ Conclus√£o

Focus Management inclui:
- **tabIndex**: 0 (focus√°vel), -1 (program√°tico), nunca > 0
- **useRef + focus()**: Controle program√°tico
- **Focus Trap**: Manter foco em modals
- **Restaurar Focus**: Salvar/restaurar ap√≥s a√ß√µes
- **Roving tabIndex**: Arrow navigation em toolbars/tabs
- **Skip Links**: Pular navega√ß√£o repetitiva

Essencial para usu√°rios de teclado e screen readers - foco deve sempre estar em local l√≥gico e previs√≠vel.
