# Screen Readers e Tecnologias Assistivas

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**Screen Readers** sÃ£o **softwares de tecnologia assistiva** que **convertem texto e elementos da UI em fala ou braille**, permitindo que pessoas cegas ou com baixa visÃ£o **naveguem e interajam** com aplicaÃ§Ãµes web. Conceitualmente, representam **voz da interface** - transformam representaÃ§Ã£o visual em representaÃ§Ã£o auditiva/tÃ¡til, tornando a web acessÃ­vel a milhÃµes de usuÃ¡rios.

### Screen Readers Principais

```
Desktop:
â”œâ”€â”€ NVDA (Windows) - Gratuito, mais usado
â”œâ”€â”€ JAWS (Windows) - Pago, profissional
â””â”€â”€ VoiceOver (macOS/iOS) - Nativo

Mobile:
â”œâ”€â”€ TalkBack (Android) - Nativo
â””â”€â”€ VoiceOver (iOS) - Nativo

Browser:
â””â”€â”€ ChromeVox (Chrome Extension)
```

### Problema que Resolve

**Sem Screen Readers**:
- Cegos nÃ£o conseguem usar web
- Baixa visÃ£o precisa de muito zoom
- ConteÃºdo visual inacessÃ­vel

**Com Screen Readers**:
- NavegaÃ§Ã£o completa via Ã¡udio/braille
- Acesso a toda informaÃ§Ã£o
- InteraÃ§Ã£o com apps complexas

---

## ğŸ§  Como Screen Readers Funcionam

### Ãrvore de Acessibilidade

```
DOM Tree â†’ Accessibility Tree â†’ Screen Reader

<button>
  <img src="icon.svg" alt="Delete" />
  Delete Item
</button>

â†“ Accessibility Tree

Button: "Delete Item Delete"
Role: button
State: focusable, enabled
```

### O Que Screen Readers Anunciam

```jsx
<button aria-label="Close dialog">
  <XIcon />
</button>

// Screen reader anuncia:
// "Close dialog, button"
// (label + role)
```

```jsx
<input
  type="text"
  id="email"
  aria-label="Email address"
  aria-required="true"
  aria-invalid={hasError}
  aria-describedby="email-help"
/>
<p id="email-help">We'll never share your email</p>

// Screen reader anuncia:
// "Email address, edit text, required, invalid"
// (ao focar)
// "We'll never share your email"
// (descriÃ§Ã£o adicional)
```

---

## âŒ¨ï¸ Comandos de NavegaÃ§Ã£o

### NVDA (Windows)

```
NavegaÃ§Ã£o:
â”œâ”€â”€ Tab / Shift+Tab - PrÃ³ximo/anterior elemento focusÃ¡vel
â”œâ”€â”€ H / Shift+H - PrÃ³ximo/anterior heading
â”œâ”€â”€ K / Shift+K - PrÃ³ximo/anterior link
â”œâ”€â”€ B / Shift+B - PrÃ³ximo/anterior button
â”œâ”€â”€ F / Shift+F - PrÃ³ximo/anterior form field
â””â”€â”€ D / Shift+D - PrÃ³ximo/anterior landmark

Leitura:
â”œâ”€â”€ Insert+Down Arrow - Ler tudo
â”œâ”€â”€ Down/Up Arrow - PrÃ³xima/anterior linha
â”œâ”€â”€ Ctrl+Right/Left - PrÃ³xima/anterior palavra
â””â”€â”€ Insert+T - Ler tÃ­tulo da janela

Outras:
â”œâ”€â”€ Insert+F7 - Lista de elementos (headings, links, etc)
â”œâ”€â”€ Insert+Space - Modo foco/navegaÃ§Ã£o
â””â”€â”€ Insert+Q - Sair do NVDA
```

### VoiceOver (macOS/iOS)

```
macOS:
â”œâ”€â”€ Cmd+F5 - Ligar/desligar VoiceOver
â”œâ”€â”€ VO+Right/Left - PrÃ³ximo/anterior item (VO = Ctrl+Option)
â”œâ”€â”€ VO+Space - Ativar item
â”œâ”€â”€ VO+H - PrÃ³ximo heading
â””â”€â”€ VO+U - Web rotor (navegaÃ§Ã£o por elemento)

iOS:
â”œâ”€â”€ Swipe Right/Left - PrÃ³ximo/anterior item
â”œâ”€â”€ Double Tap - Ativar item
â”œâ”€â”€ Rotor (girar 2 dedos) - Mudar modo navegaÃ§Ã£o
â””â”€â”€ Swipe Up/Down - Navegar em modo selecionado
```

---

## ğŸ¯ Otimizando para Screen Readers

### Ordem de Leitura (DOM Order)

```jsx
// âŒ Ordem visual â‰  ordem DOM
<div style={{ display: 'flex', flexDirection: 'column-reverse' }}>
  <div>Visually first, but last in DOM</div>
  <div>Visually last, but first in DOM</div>
</div>
// Screen reader lÃª na ordem DOM, nÃ£o visual!

// âœ… Ordem DOM = ordem lÃ³gica
<div>
  <div>First</div>
  <div>Second</div>
</div>
```

### Texto Visualmente Escondido

```jsx
// Texto apenas para screen readers
function VisuallyHidden({ children }) {
  return (
    <span
      style={{
        position: 'absolute',
        width: '1px',
        height: '1px',
        padding: 0,
        margin: '-1px',
        overflow: 'hidden',
        clip: 'rect(0, 0, 0, 0)',
        whiteSpace: 'nowrap',
        border: 0
      }}
    >
      {children}
    </span>
  );
}

// Uso
<button>
  <TrashIcon />
  <VisuallyHidden>Delete item</VisuallyHidden>
</button>
// Visual: apenas Ã­cone
// Screen reader: "Delete item, button"
```

### Anunciar MudanÃ§as DinÃ¢micas

```jsx
// Live region para notificaÃ§Ãµes
function Notification({ message }) {
  return (
    <div
      role="status"
      aria-live="polite"
      aria-atomic="true"
    >
      {message}
    </div>
  );
}

// Uso
function Form() {
  const [saved, setSaved] = useState(false);

  return (
    <>
      <form onSubmit={handleSubmit}>
        {/* ... */}
      </form>
      <Notification
        message={saved ? 'Form saved successfully' : ''}
      />
    </>
  );
}
// Screen reader anuncia quando mensagem aparecer
```

### Loading States

```jsx
// âŒ Loading nÃ£o comunicado
{isLoading && <Spinner />}

// âœ… Loading comunicado
{isLoading && (
  <div
    role="status"
    aria-live="polite"
    aria-label="Loading content"
  >
    <Spinner />
    <VisuallyHidden>Loading...</VisuallyHidden>
  </div>
)}

// âœ… Alternativa
<button
  onClick={handleSubmit}
  disabled={isLoading}
  aria-label={isLoading ? 'Submitting...' : 'Submit'}
>
  {isLoading ? 'Submitting...' : 'Submit'}
</button>
```

---

## ğŸ“‹ Lists e NavegaÃ§Ã£o

### Listas SemÃ¢nticas

```jsx
// âœ… Lista real (screen reader conta itens)
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
// Screen reader: "List, 3 items"

// âŒ Divs (screen reader nÃ£o identifica como lista)
<div>
  <div>Item 1</div>
  <div>Item 2</div>
</div>

// âœ… Se precisar de divs, use roles
<div role="list">
  <div role="listitem">Item 1</div>
  <div role="listitem">Item 2</div>
</div>
```

### Landmarks

```jsx
// âœ… Landmarks permitem navegaÃ§Ã£o rÃ¡pida
function Layout() {
  return (
    <>
      <header>
        <nav aria-label="Main navigation">
          <a href="/">Home</a>
          <a href="/about">About</a>
        </nav>
      </header>

      <main>
        <h1>Page Title</h1>
        <article>
          <h2>Article Title</h2>
          Content
        </article>
      </main>

      <aside aria-label="Related links">
        Sidebar
      </aside>

      <footer>
        Copyright
      </footer>
    </>
  );
}
// Screen reader: "Banner, navigation, main, complementary, contentinfo"
```

---

## ğŸ” Forms e Inputs

### Labels Corretos

```jsx
// âœ… Label associado
<label htmlFor="email">Email</label>
<input id="email" type="email" />
// Screen reader: "Email, edit text"

// âœ… Label envolvendo
<label>
  Email
  <input type="email" />
</label>

// âŒ Sem label
<input type="email" placeholder="Email" />
// Screen reader: apenas "edit text" (placeholder nÃ£o Ã© label!)

// âœ… Se nÃ£o puder ter label visual
<input
  type="email"
  aria-label="Email address"
/>
```

### Field Sets

```jsx
// âœ… Agrupar campos relacionados
<fieldset>
  <legend>Shipping Address</legend>
  <label htmlFor="street">Street</label>
  <input id="street" type="text" />

  <label htmlFor="city">City</label>
  <input id="city" type="text" />
</fieldset>
// Screen reader anuncia "Shipping Address" antes de cada campo
```

### Mensagens de Erro

```jsx
function EmailInput() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  return (
    <div>
      <label htmlFor="email">Email</label>
      <input
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        aria-invalid={!!error}
        aria-describedby={error ? "email-error" : undefined}
      />
      {error && (
        <p id="email-error" role="alert">
          {error}
        </p>
      )}
    </div>
  );
}
// Screen reader: "Email, edit text, invalid"
// E anuncia erro automaticamente (role="alert")
```

---

## ğŸ­ Componentes Complexos

### Modal/Dialog

```jsx
function Modal({ isOpen, onClose, title, children }) {
  const modalRef = useRef(null);
  const previousActiveElement = useRef(null);

  useEffect(() => {
    if (isOpen) {
      // Salvar elemento focado
      previousActiveElement.current = document.activeElement;

      // Focar modal
      modalRef.current?.focus();

      // Restaurar foco ao fechar
      return () => {
        previousActiveElement.current?.focus();
      };
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
      ref={modalRef}
      tabIndex={-1}
    >
      <h2 id="modal-title">{title}</h2>
      {children}
      <button onClick={onClose}>Close</button>
    </div>
  );
}
// Screen reader: "Dialog, [title]"
// E comunica que Ã© modal (context fora nÃ£o acessÃ­vel)
```

### Tabs

```jsx
function Tabs({ tabs }) {
  const [selected, setSelected] = useState(0);

  return (
    <div>
      <div role="tablist" aria-label="Content sections">
        {tabs.map((tab, i) => (
          <button
            key={i}
            role="tab"
            id={`tab-${i}`}
            aria-selected={i === selected}
            aria-controls={`panel-${i}`}
            onClick={() => setSelected(i)}
          >
            {tab.title}
          </button>
        ))}
      </div>

      {tabs.map((tab, i) => (
        <div
          key={i}
          role="tabpanel"
          id={`panel-${i}`}
          aria-labelledby={`tab-${i}`}
          hidden={i !== selected}
        >
          {tab.content}
        </div>
      ))}
    </div>
  );
}
// Screen reader navega com Arrow keys
// Anuncia "tab, selected/not selected, X of Y"
```

---

## ğŸš€ ConclusÃ£o

Screen Readers exigem:
- **Estrutura SemÃ¢ntica**: headings, landmarks, lists
- **Labels**: htmlFor, aria-label, aria-labelledby
- **Estados**: aria-expanded, aria-selected, aria-invalid
- **Live Regions**: role="alert", aria-live
- **Focus Management**: restaurar foco, trap em modals
- **Ordem DOM**: lÃ³gica e sequencial

Testar com screen reader real (NVDA, VoiceOver) Ã© essencial - automated tests nÃ£o capturam experiÃªncia completa.
