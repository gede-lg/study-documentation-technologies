# Formul√°rios Acess√≠veis no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Formul√°rios Acess√≠veis** s√£o formul√°rios que **todos podem usar**, incluindo pessoas com defici√™ncias, atrav√©s de **labels claros**, **valida√ß√£o acess√≠vel**, **mensagens de erro anunciadas** e **navega√ß√£o l√≥gica**. Conceitualmente, representam **entrada de dados inclusiva** - garantir que processo cr√≠tico de input/submiss√£o seja acess√≠vel a 100% dos usu√°rios, n√£o apenas visualmente.

### Problema que Resolve

**Formul√°rios Inacess√≠veis**:
- Screen readers n√£o sabem o que cada campo √©
- Erros n√£o comunicados
- Campos obrigat√≥rios n√£o indicados
- Navega√ß√£o confusa

**Formul√°rios Acess√≠veis**:
- Cada campo claramente rotulado
- Erros anunciados e descritivos
- Indica√ß√£o clara de campos obrigat√≥rios
- Navega√ß√£o l√≥gica e previs√≠vel

---

## üè∑Ô∏è Labels

### Label com htmlFor

```jsx
// ‚úÖ Label associado corretamente
<label htmlFor="email">Email</label>
<input id="email" type="email" />
// Screen reader: "Email, edit text"

// ‚úÖ Label envolvendo (n√£o precisa id)
<label>
  Email
  <input type="email" />
</label>

// ‚ùå Sem label
<input type="email" />
// Screen reader: apenas "edit text" (sem contexto!)

// ‚ùå Placeholder como label
<input type="email" placeholder="Email" />
// Placeholder N√ÉO √© label!
```

### aria-label (Quando N√£o H√° Label Visual)

```jsx
// ‚úÖ Quando n√£o pode ter label visual
<input
  type="search"
  aria-label="Search products"
  placeholder="Search..."
/>

// ‚úÖ M√∫ltiplos campos similares
<div>
  <h2>Contact Information</h2>
  <input aria-label="First name" />
  <input aria-label="Last name" />
</div>
```

### aria-labelledby (Referencia Elemento Existente)

```jsx
// ‚úÖ Label em outro elemento
<h2 id="shipping-title">Shipping Address</h2>
<div>
  <input aria-labelledby="shipping-title street-label" />
  <span id="street-label">Street</span>
</div>
// Screen reader: "Shipping Address Street, edit text"
```

---

## üìã Fieldsets e Legends

### Agrupar Campos Relacionados

```jsx
// ‚úÖ Fieldset para grupo
<fieldset>
  <legend>Contact Information</legend>

  <label htmlFor="name">Name</label>
  <input id="name" type="text" />

  <label htmlFor="email">Email</label>
  <input id="email" type="email" />
</fieldset>
// Screen reader anuncia "Contact Information" ao entrar no grupo
```

### Radio Buttons

```jsx
// ‚úÖ Radio buttons SEMPRE precisam de fieldset
<fieldset>
  <legend>Shipping Method</legend>

  <label>
    <input type="radio" name="shipping" value="standard" />
    Standard (5-7 days)
  </label>

  <label>
    <input type="radio" name="shipping" value="express" />
    Express (1-2 days)
  </label>
</fieldset>
// Screen reader: "Shipping Method, Standard, radio button, not checked"
```

### Checkboxes em Grupo

```jsx
<fieldset>
  <legend>Interests</legend>

  <label>
    <input type="checkbox" name="interests" value="tech" />
    Technology
  </label>

  <label>
    <input type="checkbox" name="interests" value="design" />
    Design
  </label>
</fieldset>
```

---

## ‚ö†Ô∏è Campos Obrigat√≥rios

### Indicar Visualmente e Programaticamente

```jsx
// ‚úÖ required + indica√ß√£o visual
<label htmlFor="email">
  Email
  <span aria-label="required"> *</span>
</label>
<input
  id="email"
  type="email"
  required
  aria-required="true"
/>
// Screen reader: "Email, required, edit text"

// ‚úÖ Alternativa: texto em par√™nteses
<label htmlFor="email">
  Email (required)
</label>
<input id="email" type="email" required />
```

### Mensagem no In√≠cio do Form

```jsx
<form>
  <p>
    <span aria-label="required">*</span> indicates required field
  </p>

  <label htmlFor="name">
    Name <span aria-label="required">*</span>
  </label>
  <input id="name" required />

  {/* ... */}
</form>
```

---

## ‚ùå Valida√ß√£o e Erros

### aria-invalid

```jsx
function EmailInput() {
  const [email, setEmail] = useState('');
  const [touched, setTouched] = useState(false);

  const isValid = email.includes('@');
  const showError = touched && !isValid;

  return (
    <div>
      <label htmlFor="email">Email</label>
      <input
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        onBlur={() => setTouched(true)}
        aria-invalid={showError}
        aria-describedby={showError ? "email-error" : undefined}
      />
      {showError && (
        <p id="email-error" role="alert">
          Please enter a valid email address
        </p>
      )}
    </div>
  );
}
// Screen reader: "Email, edit text, invalid"
// E anuncia erro automaticamente (role="alert")
```

### aria-describedby para Ajuda

```jsx
<label htmlFor="password">Password</label>
<input
  id="password"
  type="password"
  aria-describedby="password-help"
/>
<p id="password-help">
  Must be at least 8 characters with 1 number
</p>
// Screen reader l√™ ajuda ap√≥s anunciar campo
```

### Erro no In√≠cio do Form

```jsx
function Form() {
  const [errors, setErrors] = useState([]);
  const errorRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();

    const newErrors = validate();

    if (newErrors.length > 0) {
      setErrors(newErrors);
      // Foca lista de erros
      errorRef.current?.focus();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {errors.length > 0 && (
        <div
          ref={errorRef}
          tabIndex={-1}
          role="alert"
          aria-labelledby="error-title"
        >
          <h2 id="error-title">Please fix the following errors:</h2>
          <ul>
            {errors.map((error, i) => (
              <li key={i}>
                <a href={`#${error.field}`}>{error.message}</a>
              </li>
            ))}
          </ul>
        </div>
      )}

      <label htmlFor="email">Email</label>
      <input
        id="email"
        type="email"
        aria-invalid={errors.some((e) => e.field === 'email')}
      />

      {/* ... */}
    </form>
  );
}
```

---

## üéØ Tipos de Input Corretos

### Input Types Sem√¢nticos

```jsx
// ‚úÖ Use type correto (habilita keyboard apropriado em mobile)
<input type="email" /> // Keyboard com @
<input type="tel" />   // Keyboard num√©rico
<input type="url" />   // Keyboard com .com
<input type="number" /> // Spinbutton
<input type="date" />  // Date picker
<input type="time" />  // Time picker
<input type="search" /> // Bot√£o "Search"

// ‚ùå N√£o use text para tudo
<input type="text" placeholder="Email" /> // Sem valida√ß√£o nativa
```

### Autocomplete

```jsx
// ‚úÖ Autocomplete para dados pessoais
<input type="email" autoComplete="email" />
<input type="text" autoComplete="name" />
<input type="tel" autoComplete="tel" />
<input type="text" autoComplete="address-line1" />
<input type="text" autoComplete="postal-code" />

// Ajuda browsers e password managers
// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill
```

---

## üîç Select e Combobox

### Select B√°sico

```jsx
<label htmlFor="country">Country</label>
<select id="country">
  <option value="">-- Select a country --</option>
  <option value="us">United States</option>
  <option value="ca">Canada</option>
  <option value="mx">Mexico</option>
</select>
// Screen reader: "Country, combobox"
```

### Combobox/Autocomplete Acess√≠vel

```jsx
function Combobox({ options, value, onChange, label }) {
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState(value);
  const [activeIndex, setActiveIndex] = useState(0);

  const filtered = options.filter((opt) =>
    opt.toLowerCase().includes(inputValue.toLowerCase())
  );

  const handleKeyDown = (e) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setActiveIndex((i) => Math.min(i + 1, filtered.length - 1));
        break;
      case 'ArrowUp':
        e.preventDefault();
        setActiveIndex((i) => Math.max(i - 1, 0));
        break;
      case 'Enter':
        e.preventDefault();
        onChange(filtered[activeIndex]);
        setIsOpen(false);
        break;
      case 'Escape':
        setIsOpen(false);
        break;
    }
  };

  return (
    <div>
      <label id="combobox-label">{label}</label>
      <input
        type="text"
        role="combobox"
        aria-expanded={isOpen}
        aria-autocomplete="list"
        aria-controls="listbox"
        aria-labelledby="combobox-label"
        aria-activedescendant={isOpen ? `option-${activeIndex}` : undefined}
        value={inputValue}
        onChange={(e) => {
          setInputValue(e.target.value);
          setIsOpen(true);
        }}
        onKeyDown={handleKeyDown}
        onFocus={() => setIsOpen(true)}
      />

      {isOpen && filtered.length > 0 && (
        <ul id="listbox" role="listbox">
          {filtered.map((option, i) => (
            <li
              key={option}
              id={`option-${i}`}
              role="option"
              aria-selected={i === activeIndex}
              onClick={() => {
                onChange(option);
                setIsOpen(false);
              }}
            >
              {option}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

---

## üîò Custom Checkboxes/Radios

### Checkbox Estilizado

```jsx
// ‚ùå Esconder checkbox nativo (perde acessibilidade)
<input type="checkbox" style={{ display: 'none' }} />
<div className="custom-checkbox" onClick={toggle} />

// ‚úÖ Esconder visualmente mas manter acess√≠vel
<label className="custom-checkbox">
  <input
    type="checkbox"
    className="visually-hidden"
    checked={checked}
    onChange={(e) => setChecked(e.target.checked)}
  />
  <span className="checkbox-visual" aria-hidden="true">
    {checked ? '‚òë' : '‚òê'}
  </span>
  Accept terms
</label>

// CSS
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

---

## üì± Formul√°rios Multi-Step

### Indicar Progresso

```jsx
function MultiStepForm() {
  const [step, setStep] = useState(1);
  const totalSteps = 3;

  return (
    <div>
      <nav aria-label="Form progress">
        <ol>
          <li aria-current={step === 1 ? 'step' : undefined}>
            Step 1: Personal Info
          </li>
          <li aria-current={step === 2 ? 'step' : undefined}>
            Step 2: Address
          </li>
          <li aria-current={step === 3 ? 'step' : undefined}>
            Step 3: Review
          </li>
        </ol>
      </nav>

      <form aria-label={`Step ${step} of ${totalSteps}`}>
        {step === 1 && <PersonalInfoFields />}
        {step === 2 && <AddressFields />}
        {step === 3 && <ReviewFields />}

        {step > 1 && (
          <button onClick={() => setStep(step - 1)}>Previous</button>
        )}
        {step < totalSteps && (
          <button onClick={() => setStep(step + 1)}>Next</button>
        )}
        {step === totalSteps && (
          <button type="submit">Submit</button>
        )}
      </form>
    </div>
  );
}
```

---

## üöÄ Conclus√£o

Formul√°rios Acess√≠veis exigem:
- **Labels**: htmlFor, aria-label, aria-labelledby
- **Fieldsets**: legend para grupos (radio, checkbox)
- **Required**: required + aria-required + indica√ß√£o visual
- **Valida√ß√£o**: aria-invalid, aria-describedby, role="alert"
- **Input Types**: email, tel, url (keyboard correto)
- **Autocomplete**: autoComplete para dados pessoais
- **Custom Inputs**: Manter input nativo, estilizar visualmente

Formul√°rios s√£o cr√≠ticos - investir em acessibilidade aqui tem alto ROI em convers√£o e compliance.
