# Componentes Acess√≠veis no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Componentes Acess√≠veis** s√£o componentes React constru√≠dos com **ARIA, HTML sem√¢ntico, keyboard navigation e focus management**, garantindo que **todos os usu√°rios** possam interagir com UI complexas (modals, dropdowns, tabs, tooltips). Conceitualmente, representam **widgets inclusivos** - reimplementar comportamento de desktop apps na web sem perder acessibilidade.

### Problema que Resolve

**Componentes Inacess√≠veis**:
- Screen readers n√£o entendem
- Navega√ß√£o por teclado quebrada
- Estados n√£o comunicados
- Focus perdido

**Componentes Acess√≠veis**:
- ARIA roles comunicam prop√≥sito
- Keyboard navigation completa
- Estados anunciados dinamicamente
- Focus management correto

---

## ü™ü Modal/Dialog

### Modal Acess√≠vel Completo

```jsx
import { useEffect, useRef } from 'react';
import FocusTrap from 'focus-trap-react';

function Modal({ isOpen, onClose, title, children }) {
  const modalRef = useRef(null);
  const previousActiveElement = useRef(null);

  // Salvar e restaurar foco
  useEffect(() => {
    if (isOpen) {
      previousActiveElement.current = document.activeElement;
      return () => {
        previousActiveElement.current?.focus();
      };
    }
  }, [isOpen]);

  // Fechar com Escape
  useEffect(() => {
    if (!isOpen) return;

    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, onClose]);

  // Prevenir scroll da p√°gina
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = '';
      };
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <FocusTrap>
      <div
        className="modal-overlay"
        onClick={onClose}
        aria-hidden="true"
      >
        <div
          ref={modalRef}
          role="dialog"
          aria-modal="true"
          aria-labelledby="modal-title"
          className="modal-content"
          onClick={(e) => e.stopPropagation()}
        >
          <h2 id="modal-title">{title}</h2>

          {children}

          <button onClick={onClose} aria-label="Close dialog">
            &times;
          </button>
        </div>
      </div>
    </FocusTrap>
  );
}

// Uso
function App() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>

      <Modal
        isOpen={isOpen}
        onClose={() => setIsOpen(false)}
        title="Confirm Action"
      >
        <p>Are you sure you want to proceed?</p>
        <button onClick={() => setIsOpen(false)}>Yes</button>
        <button onClick={() => setIsOpen(false)}>No</button>
      </Modal>
    </>
  );
}
```

---

## üìë Tabs

### Tabs com ARIA e Keyboard

```jsx
function Tabs({ tabs }) {
  const [selectedTab, setSelectedTab] = useState(0);
  const tabRefs = useRef([]);

  const handleKeyDown = (e, index) => {
    let newIndex;

    switch (e.key) {
      case 'ArrowRight':
        newIndex = (index + 1) % tabs.length;
        break;
      case 'ArrowLeft':
        newIndex = (index - 1 + tabs.length) % tabs.length;
        break;
      case 'Home':
        newIndex = 0;
        break;
      case 'End':
        newIndex = tabs.length - 1;
        break;
      default:
        return;
    }

    setSelectedTab(newIndex);
    tabRefs.current[newIndex]?.focus();
  };

  return (
    <div>
      <div role="tablist" aria-label="Content sections">
        {tabs.map((tab, i) => (
          <button
            key={i}
            ref={(el) => (tabRefs.current[i] = el)}
            role="tab"
            id={`tab-${i}`}
            aria-selected={i === selectedTab}
            aria-controls={`panel-${i}`}
            tabIndex={i === selectedTab ? 0 : -1}
            onClick={() => setSelectedTab(i)}
            onKeyDown={(e) => handleKeyDown(e, i)}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {tabs.map((tab, i) => (
        <div
          key={i}
          role="tabpanel"
          id={`panel-${i}`}
          aria-labelledby={`tab-${i}`}
          hidden={i !== selectedTab}
          tabIndex={0}
        >
          {tab.content}
        </div>
      ))}
    </div>
  );
}

// Uso
<Tabs
  tabs={[
    { label: 'Tab 1', content: <p>Content 1</p> },
    { label: 'Tab 2', content: <p>Content 2</p> },
    { label: 'Tab 3', content: <p>Content 3</p> }
  ]}
/>
```

---

## üéöÔ∏è Accordion

### Accordion Acess√≠vel

```jsx
function Accordion({ items }) {
  const [openIndex, setOpenIndex] = useState(null);

  const toggle = (index) => {
    setOpenIndex(openIndex === index ? null : index);
  };

  return (
    <div>
      {items.map((item, i) => (
        <div key={i}>
          <h3>
            <button
              id={`accordion-header-${i}`}
              aria-expanded={i === openIndex}
              aria-controls={`accordion-panel-${i}`}
              onClick={() => toggle(i)}
            >
              {item.title}
            </button>
          </h3>

          <div
            id={`accordion-panel-${i}`}
            role="region"
            aria-labelledby={`accordion-header-${i}`}
            hidden={i !== openIndex}
          >
            {item.content}
          </div>
        </div>
      ))}
    </div>
  );
}

// Uso
<Accordion
  items={[
    { title: 'Section 1', content: <p>Content 1</p> },
    { title: 'Section 2', content: <p>Content 2</p> }
  ]}
/>
```

---

## üí¨ Tooltip

### Tooltip com aria-describedby

```jsx
function Tooltip({ children, content }) {
  const [isVisible, setIsVisible] = useState(false);
  const tooltipId = useId();

  return (
    <div className="tooltip-container">
      <button
        aria-describedby={isVisible ? tooltipId : undefined}
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
        onFocus={() => setIsVisible(true)}
        onBlur={() => setIsVisible(false)}
      >
        {children}
      </button>

      {isVisible && (
        <div id={tooltipId} role="tooltip" className="tooltip">
          {content}
        </div>
      )}
    </div>
  );
}

// Uso
<Tooltip content="Click to save your changes">
  <button>Save</button>
</Tooltip>
// Screen reader: "Save, button, Click to save your changes"
```

---

## üìã Dropdown Menu

### Dropdown com aria-haspopup

```jsx
function Dropdown({ label, items }) {
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef(null);
  const [focusedIndex, setFocusedIndex] = useState(0);

  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e) => {
      switch (e.key) {
        case 'Escape':
          setIsOpen(false);
          break;
        case 'ArrowDown':
          e.preventDefault();
          setFocusedIndex((i) => (i + 1) % items.length);
          break;
        case 'ArrowUp':
          e.preventDefault();
          setFocusedIndex((i) => (i - 1 + items.length) % items.length);
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, items.length]);

  return (
    <div>
      <button
        aria-haspopup="true"
        aria-expanded={isOpen}
        onClick={() => setIsOpen(!isOpen)}
      >
        {label}
      </button>

      {isOpen && (
        <ul ref={menuRef} role="menu">
          {items.map((item, i) => (
            <li key={i} role="none">
              <button
                role="menuitem"
                tabIndex={i === focusedIndex ? 0 : -1}
                onClick={() => {
                  item.onClick();
                  setIsOpen(false);
                }}
              >
                {item.label}
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

// Uso
<Dropdown
  label="Actions"
  items={[
    { label: 'Edit', onClick: () => console.log('Edit') },
    { label: 'Delete', onClick: () => console.log('Delete') }
  ]}
/>
```

---

## üé† Carousel/Slider

### Carousel Acess√≠vel

```jsx
function Carousel({ slides }) {
  const [currentSlide, setCurrentSlide] = useState(0);

  const goToSlide = (index) => {
    setCurrentSlide(index);
  };

  const next = () => {
    setCurrentSlide((i) => (i + 1) % slides.length);
  };

  const prev = () => {
    setCurrentSlide((i) => (i - 1 + slides.length) % slides.length);
  };

  return (
    <div
      aria-roledescription="carousel"
      aria-label="Image carousel"
    >
      {/* Slides */}
      <div className="slides">
        {slides.map((slide, i) => (
          <div
            key={i}
            role="group"
            aria-roledescription="slide"
            aria-label={`${i + 1} of ${slides.length}`}
            hidden={i !== currentSlide}
          >
            <img src={slide.image} alt={slide.alt} />
          </div>
        ))}
      </div>

      {/* Controles */}
      <button onClick={prev} aria-label="Previous slide">
        &larr;
      </button>
      <button onClick={next} aria-label="Next slide">
        &rarr;
      </button>

      {/* Indicadores */}
      <div role="tablist" aria-label="Slide controls">
        {slides.map((_, i) => (
          <button
            key={i}
            role="tab"
            aria-selected={i === currentSlide}
            aria-label={`Go to slide ${i + 1}`}
            onClick={() => goToSlide(i)}
          />
        ))}
      </div>
    </div>
  );
}
```

---

## üîî Notifications/Toast

### Toast com Live Region

```jsx
function Toast({ message, type = 'info', onClose }) {
  useEffect(() => {
    const timer = setTimeout(onClose, 5000);
    return () => clearTimeout(timer);
  }, [onClose]);

  return (
    <div
      role="status"
      aria-live={type === 'error' ? 'assertive' : 'polite'}
      aria-atomic="true"
      className={`toast toast-${type}`}
    >
      <p>{message}</p>
      <button onClick={onClose} aria-label="Close notification">
        &times;
      </button>
    </div>
  );
}

function ToastContainer() {
  const [toasts, setToasts] = useState([]);

  const addToast = (message, type) => {
    const id = Date.now();
    setToasts((t) => [...t, { id, message, type }]);
  };

  const removeToast = (id) => {
    setToasts((t) => t.filter((toast) => toast.id !== id));
  };

  return (
    <div
      aria-live="polite"
      aria-atomic="false"
      className="toast-container"
    >
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          message={toast.message}
          type={toast.type}
          onClose={() => removeToast(toast.id)}
        />
      ))}
    </div>
  );
}
```

---

## üéõÔ∏è Toggle Switch

### Toggle Acess√≠vel

```jsx
function Toggle({ checked, onChange, label }) {
  return (
    <label className="toggle-label">
      <input
        type="checkbox"
        role="switch"
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
        aria-checked={checked}
        className="visually-hidden"
      />
      <span className="toggle-visual" aria-hidden="true">
        <span className="toggle-slider" />
      </span>
      {label}
    </label>
  );
}

// Uso
<Toggle
  checked={isEnabled}
  onChange={setIsEnabled}
  label="Enable notifications"
/>
// Screen reader: "Enable notifications, switch, on/off"
```

---

## üìä Progress Bar

### Progress Bar com ARIA

```jsx
function ProgressBar({ value, max = 100, label }) {
  const percentage = (value / max) * 100;

  return (
    <div>
      <label id="progress-label">{label}</label>
      <div
        role="progressbar"
        aria-valuenow={value}
        aria-valuemin={0}
        aria-valuemax={max}
        aria-labelledby="progress-label"
        aria-valuetext={`${percentage.toFixed(0)}% complete`}
        className="progress-bar"
      >
        <div
          className="progress-fill"
          style={{ width: `${percentage}%` }}
        />
      </div>
      <p aria-live="polite" aria-atomic="true">
        {percentage.toFixed(0)}% complete
      </p>
    </div>
  );
}

// Uso
<ProgressBar value={75} max={100} label="Upload progress" />
// Screen reader: "Upload progress, progress bar, 75% complete"
```

---

## üîç Search/Combobox

### Search com Live Results

```jsx
function SearchCombobox({ options, onSelect }) {
  const [query, setQuery] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [activeIndex, setActiveIndex] = useState(0);

  const filtered = options.filter((opt) =>
    opt.toLowerCase().includes(query.toLowerCase())
  );

  const handleKeyDown = (e) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setActiveIndex((i) => Math.min(i + 1, filtered.length - 1));
        break;
      case 'ArrowUp':
        e.preventDefault();
        setActiveIndex((i) => Math.max(i - 1, 0));
        break;
      case 'Enter':
        e.preventDefault();
        if (filtered[activeIndex]) {
          onSelect(filtered[activeIndex]);
          setIsOpen(false);
        }
        break;
      case 'Escape':
        setIsOpen(false);
        break;
    }
  };

  return (
    <div>
      <label id="search-label">Search</label>
      <input
        type="text"
        role="combobox"
        aria-expanded={isOpen}
        aria-autocomplete="list"
        aria-controls="search-listbox"
        aria-activedescendant={isOpen ? `option-${activeIndex}` : undefined}
        aria-labelledby="search-label"
        value={query}
        onChange={(e) => {
          setQuery(e.target.value);
          setIsOpen(true);
          setActiveIndex(0);
        }}
        onKeyDown={handleKeyDown}
      />

      {isOpen && filtered.length > 0 && (
        <ul id="search-listbox" role="listbox">
          {filtered.map((option, i) => (
            <li
              key={option}
              id={`option-${i}`}
              role="option"
              aria-selected={i === activeIndex}
              onClick={() => {
                onSelect(option);
                setIsOpen(false);
              }}
            >
              {option}
            </li>
          ))}
        </ul>
      )}

      <div role="status" aria-live="polite" aria-atomic="true">
        {isOpen && (
          <p>{filtered.length} results available</p>
        )}
      </div>
    </div>
  );
}
```

---

## üöÄ Conclus√£o

Componentes Acess√≠veis exigem:
- **Modal**: role="dialog", aria-modal, focus trap
- **Tabs**: role="tablist/tab/tabpanel", arrow navigation
- **Accordion**: aria-expanded, aria-controls
- **Tooltip**: aria-describedby
- **Dropdown**: aria-haspopup, role="menu"
- **Carousel**: aria-roledescription, aria-label
- **Toast**: aria-live, role="status/alert"
- **Toggle**: role="switch", aria-checked
- **Progress**: role="progressbar", aria-valuenow

Sempre combine ARIA + keyboard + focus management para componentes complexos acess√≠veis.
