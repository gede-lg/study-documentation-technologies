# Separa√ß√£o de Responsabilidades no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Separa√ß√£o de Responsabilidades (Separation of Concerns)** √© o princ√≠pio de **dividir c√≥digo em partes distintas** onde cada parte tem **uma responsabilidade √∫nica e bem definida**, isolando l√≥gica de apresenta√ß√£o, dados e neg√≥cio. Conceitualmente, representa **single purpose** - cada m√≥dulo/componente/fun√ß√£o faz **uma coisa bem feita**, facilitando manuten√ß√£o, teste e reuso.

### Problema que Resolve

**Sem Separa√ß√£o**:
- Componentes gigantes (1000+ linhas)
- L√≥gica e UI misturadas
- Imposs√≠vel testar isoladamente
- Reuso dif√≠cil
- Mudan√ßas quebram tudo

**Com Separa√ß√£o**:
- Componentes pequenos e focados
- L√≥gica isol√°vel e test√°vel
- Reuso f√°cil
- Mudan√ßas localizadas
- C√≥digo leg√≠vel

---

## üé® UI vs L√≥gica

### Problema: Tudo Misturado

```tsx
// ‚ùå UI + L√≥gica + Data Fetching misturados
function UserProfile({ userId }: { userId: number }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [editing, setEditing] = useState(false);
  const [formData, setFormData] = useState({ name: '', email: '' });

  useEffect(() => {
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then(r => r.json())
      .then(data => {
        setUser(data);
        setFormData({ name: data.name, email: data.email });
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);

  const handleSubmit = (e) => {
    e.preventDefault();
    fetch(`/api/users/${userId}`, {
      method: 'PUT',
      body: JSON.stringify(formData)
    })
      .then(r => r.json())
      .then(data => {
        setUser(data);
        setEditing(false);
      });
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return null;

  return (
    <div>
      {editing ? (
        <form onSubmit={handleSubmit}>
          <input
            value={formData.name}
            onChange={e => setFormData({ ...formData, name: e.target.value })}
          />
          <input
            value={formData.email}
            onChange={e => setFormData({ ...formData, email: e.target.value })}
          />
          <button type="submit">Save</button>
          <button onClick={() => setEditing(false)}>Cancel</button>
        </form>
      ) : (
        <div>
          <h2>{user.name}</h2>
          <p>{user.email}</p>
          <button onClick={() => setEditing(true)}>Edit</button>
        </div>
      )}
    </div>
  );
}
```

### Solu√ß√£o: Separar Responsabilidades

```tsx
// 1. Data Layer (API)
// api/usersApi.ts
export const usersApi = {
  getById: (id: number) =>
    axios.get(`/api/users/${id}`).then(r => r.data),

  update: (id: number, data: UserUpdate) =>
    axios.put(`/api/users/${id}`, data).then(r => r.data)
};

// 2. Business Logic Layer (Hooks)
// hooks/useUser.ts
export function useUser(userId: number) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => usersApi.getById(userId)
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => usersApi.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries(['user', id]);
    }
  });
}

// hooks/useUserForm.ts
export function useUserForm(initialData: User) {
  const [formData, setFormData] = useState({
    name: initialData.name,
    email: initialData.email
  });

  const handleChange = (field: keyof typeof formData) => (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    setFormData(prev => ({ ...prev, [field]: e.target.value }));
  };

  return { formData, handleChange };
}

// 3. Presentation Layer (Components)
// components/UserProfile.tsx
function UserProfile({ userId }: { userId: number }) {
  const { data: user, isLoading, error } = useUser(userId);
  const [isEditing, setIsEditing] = useState(false);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return null;

  return (
    <div>
      {isEditing ? (
        <UserEditForm
          user={user}
          onCancel={() => setIsEditing(false)}
          onSuccess={() => setIsEditing(false)}
        />
      ) : (
        <UserDisplay
          user={user}
          onEdit={() => setIsEditing(true)}
        />
      )}
    </div>
  );
}

// components/UserDisplay.tsx
type UserDisplayProps = {
  user: User;
  onEdit: () => void;
};

function UserDisplay({ user, onEdit }: UserDisplayProps) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={onEdit}>Edit</button>
    </div>
  );
}

// components/UserEditForm.tsx
type UserEditFormProps = {
  user: User;
  onCancel: () => void;
  onSuccess: () => void;
};

function UserEditForm({ user, onCancel, onSuccess }: UserEditFormProps) {
  const { formData, handleChange } = useUserForm(user);
  const updateUser = useUpdateUser();

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    updateUser.mutate(
      { id: user.id, data: formData },
      { onSuccess }
    );
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.name}
        onChange={handleChange('name')}
        placeholder="Name"
      />
      <input
        value={formData.email}
        onChange={handleChange('email')}
        placeholder="Email"
      />
      <button type="submit" disabled={updateUser.isPending}>
        Save
      </button>
      <button type="button" onClick={onCancel}>
        Cancel
      </button>
    </form>
  );
}
```

---

## üß© Container/Presentational Pattern

### Presentational Components (UI Puro)

```tsx
// ‚úÖ Apenas UI - sem l√≥gica, sem estado
type ButtonProps = {
  children: React.ReactNode;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
};

export function Button({
  children,
  onClick,
  variant = 'primary',
  disabled = false
}: ButtonProps) {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}

// F√°cil de testar
test('Button renderiza children', () => {
  render(<Button onClick={() => {}}>Click me</Button>);
  expect(screen.getByText('Click me')).toBeInTheDocument();
});
```

### Container Components (L√≥gica + Dados)

```tsx
// ‚úÖ L√≥gica, dados, conecta com hooks
export function ProductListContainer() {
  const { data: products, isLoading } = useProducts();
  const addToCart = useAddToCart();

  const handleAddToCart = (productId: number) => {
    addToCart.mutate(productId);
  };

  if (isLoading) return <LoadingSpinner />;

  return (
    <ProductList
      products={products}
      onAddToCart={handleAddToCart}
    />
  );
}

// Presentational
type ProductListProps = {
  products: Product[];
  onAddToCart: (id: number) => void;
};

function ProductList({ products, onAddToCart }: ProductListProps) {
  return (
    <div>
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={onAddToCart}
        />
      ))}
    </div>
  );
}
```

---

## üîß Custom Hooks (L√≥gica Reutiliz√°vel)

### Extrair L√≥gica Complexa

```tsx
// ‚ùå L√≥gica no componente
function SearchPage() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);
    return () => clearTimeout(timer);
  }, [query]);

  useEffect(() => {
    if (!debouncedQuery) {
      setResults([]);
      return;
    }

    setLoading(true);
    fetch(`/api/search?q=${debouncedQuery}`)
      .then(r => r.json())
      .then(data => {
        setResults(data);
        setLoading(false);
      });
  }, [debouncedQuery]);

  return (/* JSX */);
}

// ‚úÖ L√≥gica em hook customizado
function useSearch() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);

  const { data: results, isLoading } = useQuery({
    queryKey: ['search', debouncedQuery],
    queryFn: () => searchApi.search(debouncedQuery),
    enabled: !!debouncedQuery
  });

  return {
    query,
    setQuery,
    results: results ?? [],
    isLoading
  };
}

// Componente simples
function SearchPage() {
  const { query, setQuery, results, isLoading } = useSearch();

  return (
    <div>
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Search..."
      />
      {isLoading ? <LoadingSpinner /> : (
        <SearchResults results={results} />
      )}
    </div>
  );
}
```

---

## üì¶ Service Layer (API Abstraction)

### Centralizar L√≥gica de API

```tsx
// ‚ùå Fetch espalhado pela aplica√ß√£o
function ProductList() {
  useEffect(() => {
    fetch('/api/products').then(/*...*/);
  }, []);
}

function ProductDetail({ id }) {
  useEffect(() => {
    fetch(`/api/products/${id}`).then(/*...*/);
  }, [id]);
}

// ‚úÖ Camada de servi√ßo centralizada
// services/productsService.ts
class ProductsService {
  private baseUrl = '/api/products';

  async getAll(): Promise<Product[]> {
    const response = await axios.get(this.baseUrl);
    return response.data;
  }

  async getById(id: number): Promise<Product> {
    const response = await axios.get(`${this.baseUrl}/${id}`);
    return response.data;
  }

  async create(data: ProductCreate): Promise<Product> {
    const response = await axios.post(this.baseUrl, data);
    return response.data;
  }

  async update(id: number, data: ProductUpdate): Promise<Product> {
    const response = await axios.put(`${this.baseUrl}/${id}`, data);
    return response.data;
  }

  async delete(id: number): Promise<void> {
    await axios.delete(`${this.baseUrl}/${id}`);
  }
}

export const productsService = new ProductsService();

// Hooks usam service
function useProducts() {
  return useQuery({
    queryKey: ['products'],
    queryFn: () => productsService.getAll()
  });
}
```

---

## üéØ Domain Logic (Business Rules)

### Separar Regras de Neg√≥cio

```tsx
// ‚ùå Regras espalhadas
function ProductCard({ product }) {
  const canPurchase = product.stock > 0 && !product.discontinued;
  const discount = product.salePrice
    ? ((product.price - product.salePrice) / product.price) * 100
    : 0;
  const finalPrice = product.salePrice || product.price;

  return (/* JSX */);
}

// ‚úÖ Regras centralizadas em domain layer
// domain/product.ts
export class ProductDomain {
  constructor(private product: Product) {}

  canPurchase(): boolean {
    return this.product.stock > 0 && !this.product.discontinued;
  }

  getDiscount(): number {
    if (!this.product.salePrice) return 0;
    return ((this.product.price - this.product.salePrice) / this.product.price) * 100;
  }

  getFinalPrice(): number {
    return this.product.salePrice || this.product.price;
  }

  hasDiscount(): boolean {
    return !!this.product.salePrice;
  }

  isLowStock(): boolean {
    return this.product.stock > 0 && this.product.stock <= 5;
  }
}

// Componente usa domain
function ProductCard({ product }: { product: Product }) {
  const productDomain = new ProductDomain(product);

  return (
    <div>
      <h3>{product.name}</h3>

      <div>
        {productDomain.hasDiscount() && (
          <span className="discount">
            {productDomain.getDiscount().toFixed(0)}% OFF
          </span>
        )}
        <span className="price">
          ${productDomain.getFinalPrice()}
        </span>
      </div>

      {productDomain.isLowStock() && (
        <p className="warning">Only {product.stock} left!</p>
      )}

      <button disabled={!productDomain.canPurchase()}>
        {productDomain.canPurchase() ? 'Add to Cart' : 'Out of Stock'}
      </button>
    </div>
  );
}
```

---

## üöÄ Conclus√£o

Separa√ß√£o de Responsabilidades inclui:
- **UI vs L√≥gica**: Componentes puros vs hooks
- **Container/Presentational**: Dados vs apresenta√ß√£o
- **Custom Hooks**: L√≥gica reutiliz√°vel extra√≠da
- **Service Layer**: API centralizada
- **Domain Logic**: Regras de neg√≥cio isoladas

Cada parte faz **uma coisa bem feita** - facilita teste, manuten√ß√£o e entendimento do sistema como um todo.
