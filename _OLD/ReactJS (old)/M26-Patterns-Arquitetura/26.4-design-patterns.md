# Design Patterns no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Design Patterns** s√£o **solu√ß√µes reutiliz√°veis** para problemas comuns em desenvolvimento React, representando **best practices consolidadas** pela comunidade. Conceitualmente, s√£o **receitas testadas** - ao inv√©s de reinventar a roda, aplicar patterns comprovados que resolvem problemas de composi√ß√£o, estado, performance e reutiliza√ß√£o.

### Problema que Resolve

**Sem Patterns**:
- Reinventar solu√ß√µes
- C√≥digo inconsistente
- Problemas conhecidos n√£o resolvidos
- Dif√≠cil comunica√ß√£o entre devs

**Com Patterns**:
- Solu√ß√µes comprovadas
- C√≥digo consistente e reconhec√≠vel
- Problemas resolvidos eficientemente
- Linguagem comum (todos entendem "Compound Component")

---

## üß© Compound Component Pattern

### Problema

```tsx
// ‚ùå API complexa com muitas props
<Accordion
  title="Section 1"
  content="Content here"
  icon={<Icon />}
  onToggle={() => {}}
  isOpen={false}
  headerStyle={{ color: 'red' }}
  contentStyle={{ padding: 20 }}
/>
```

### Solu√ß√£o: Componentes Compostos

```tsx
// ‚úÖ API flex√≠vel e declarativa
<Accordion>
  <Accordion.Header>
    <Icon />
    Section 1
  </Accordion.Header>
  <Accordion.Content>
    Content here
  </Accordion.Content>
</Accordion>

// Implementa√ß√£o
type AccordionContextType = {
  isOpen: boolean;
  toggle: () => void;
};

const AccordionContext = createContext<AccordionContextType | null>(null);

function useAccordionContext() {
  const context = useContext(AccordionContext);
  if (!context) {
    throw new Error('Accordion components must be used within <Accordion>');
  }
  return context;
}

type AccordionProps = {
  children: React.ReactNode;
  defaultOpen?: boolean;
};

export function Accordion({ children, defaultOpen = false }: AccordionProps) {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  const toggle = () => setIsOpen(prev => !prev);

  return (
    <AccordionContext.Provider value={{ isOpen, toggle }}>
      <div className="accordion">{children}</div>
    </AccordionContext.Provider>
  );
}

Accordion.Header = function AccordionHeader({
  children
}: {
  children: React.ReactNode;
}) {
  const { isOpen, toggle } = useAccordionContext();

  return (
    <button className="accordion-header" onClick={toggle}>
      {children}
      <span>{isOpen ? '‚ñ≤' : '‚ñº'}</span>
    </button>
  );
};

Accordion.Content = function AccordionContent({
  children
}: {
  children: React.ReactNode;
}) {
  const { isOpen } = useAccordionContext();

  if (!isOpen) return null;

  return <div className="accordion-content">{children}</div>;
};
```

---

## üéõÔ∏è Render Props Pattern

### Problema: Compartilhar L√≥gica Entre Componentes

```tsx
// ‚ùå L√≥gica duplicada
function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return <div>Mouse: {position.x}, {position.y}</div>;
}

function MouseFollower() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return <div style={{ left: position.x, top: position.y }}>üëÜ</div>;
}
```

### Solu√ß√£o: Render Props

```tsx
// ‚úÖ L√≥gica compartilhada
type MousePosition = { x: number; y: number };

type MouseProps = {
  render: (position: MousePosition) => React.ReactNode;
};

function Mouse({ render }: MouseProps) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e: MouseEvent) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return <>{render(position)}</>;
}

// Uso
<Mouse
  render={({ x, y }) => (
    <div>Mouse: {x}, {y}</div>
  )}
/>

<Mouse
  render={({ x, y }) => (
    <div style={{ left: x, top: y }}>üëÜ</div>
  )}
/>
```

### Alternativa Moderna: Custom Hook

```tsx
// ‚úÖ Mais idiom√°tico no React moderno
function useMouse() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e: MouseEvent) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return position;
}

// Uso
function MouseTracker() {
  const { x, y } = useMouse();
  return <div>Mouse: {x}, {y}</div>;
}

function MouseFollower() {
  const { x, y } = useMouse();
  return <div style={{ left: x, top: y }}>üëÜ</div>;
}
```

---

## üè≠ Provider Pattern (Context)

### Estado Global Organizado

```tsx
// ‚úÖ Provider com hook customizado
type AuthContextType = {
  user: User | null;
  login: (credentials: Credentials) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
};

const AuthContext = createContext<AuthContextType | null>(null);

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const login = async (credentials: Credentials) => {
    setIsLoading(true);
    try {
      const user = await authApi.login(credentials);
      setUser(user);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

// Uso
<AuthProvider>
  <App />
</AuthProvider>

// Em componentes
function UserMenu() {
  const { user, logout } = useAuth();

  return (
    <div>
      <p>{user?.name}</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

---

## üé® HOC (Higher-Order Component) Pattern

### Adicionar Comportamento a Componentes

```tsx
// HOC para autentica√ß√£o
function withAuth<P extends object>(
  Component: React.ComponentType<P>
) {
  return function WithAuthComponent(props: P) {
    const { user, isLoading } = useAuth();

    if (isLoading) return <LoadingSpinner />;
    if (!user) return <Navigate to="/login" />;

    return <Component {...props} />;
  };
}

// Uso
const ProtectedDashboard = withAuth(Dashboard);

<Route path="/dashboard" element={<ProtectedDashboard />} />
```

### HOC com Props Adicionais

```tsx
// HOC para tracking
type WithTrackingProps = {
  trackingId: string;
};

function withTracking<P extends object>(
  Component: React.ComponentType<P & WithTrackingProps>
) {
  return function WithTrackingComponent(props: P) {
    const trackingId = useId();

    useEffect(() => {
      analytics.track('component_mounted', { trackingId });

      return () => {
        analytics.track('component_unmounted', { trackingId });
      };
    }, [trackingId]);

    return <Component {...props} trackingId={trackingId} />;
  };
}

// Uso
const TrackedProductList = withTracking(ProductList);
```

**Nota**: HOCs s√£o menos comuns no React moderno - **custom hooks** geralmente s√£o prefer√≠veis.

---

## üé≠ State Reducer Pattern

### Controle Avan√ßado de Estado

```tsx
// ‚úÖ Usu√°rio pode controlar l√≥gica de estado
type ToggleState = { isOn: boolean };

type ToggleAction =
  | { type: 'TOGGLE' }
  | { type: 'SET_ON' }
  | { type: 'SET_OFF' }
  | { type: 'RESET' };

function toggleReducer(state: ToggleState, action: ToggleAction): ToggleState {
  switch (action.type) {
    case 'TOGGLE':
      return { isOn: !state.isOn };
    case 'SET_ON':
      return { isOn: true };
    case 'SET_OFF':
      return { isOn: false };
    case 'RESET':
      return { isOn: false };
    default:
      return state;
  }
}

type UseToggleOptions = {
  initialState?: boolean;
  reducer?: typeof toggleReducer;
};

function useToggle({
  initialState = false,
  reducer = toggleReducer
}: UseToggleOptions = {}) {
  const [state, dispatch] = useReducer(reducer, { isOn: initialState });

  const toggle = () => dispatch({ type: 'TOGGLE' });
  const setOn = () => dispatch({ type: 'SET_ON' });
  const setOff = () => dispatch({ type: 'SET_OFF' });
  const reset = () => dispatch({ type: 'RESET' });

  return {
    isOn: state.isOn,
    toggle,
    setOn,
    setOff,
    reset
  };
}

// Uso padr√£o
function Component1() {
  const { isOn, toggle } = useToggle();
  return <button onClick={toggle}>{isOn ? 'ON' : 'OFF'}</button>;
}

// Uso com reducer customizado (ex: log todas as a√ß√µes)
function Component2() {
  const customReducer = (state: ToggleState, action: ToggleAction) => {
    console.log('Action:', action);
    return toggleReducer(state, action);
  };

  const { isOn, toggle } = useToggle({ reducer: customReducer });
  return <button onClick={toggle}>{isOn ? 'ON' : 'OFF'}</button>;
}
```

---

## üîå Control Props Pattern

### Componente Controlado e N√£o-Controlado

```tsx
// ‚úÖ Suporta ambos os modos
type ToggleProps = {
  // Controlled
  isOn?: boolean;
  onChange?: (isOn: boolean) => void;

  // Uncontrolled
  defaultIsOn?: boolean;

  children: React.ReactNode;
};

function Toggle({ isOn: controlledIsOn, onChange, defaultIsOn = false, children }: ToggleProps) {
  const [uncontrolledIsOn, setUncontrolledIsOn] = useState(defaultIsOn);

  // Se isOn foi passado, √© controlled
  const isControlled = controlledIsOn !== undefined;
  const isOn = isControlled ? controlledIsOn : uncontrolledIsOn;

  const toggle = () => {
    const newValue = !isOn;

    if (!isControlled) {
      setUncontrolledIsOn(newValue);
    }

    onChange?.(newValue);
  };

  return (
    <button onClick={toggle}>
      {isOn ? 'ON' : 'OFF'}: {children}
    </button>
  );
}

// Uso n√£o-controlado (gerencia pr√≥prio estado)
<Toggle defaultIsOn={false}>
  Uncontrolled
</Toggle>

// Uso controlado (estado externo)
function Parent() {
  const [isOn, setIsOn] = useState(false);

  return (
    <Toggle isOn={isOn} onChange={setIsOn}>
      Controlled
    </Toggle>
  );
}
```

---

## üöÄ Conclus√£o

Design Patterns incluem:
- **Compound Component**: API flex√≠vel, componentes compostos
- **Render Props**: Compartilhar l√≥gica (menos comum hoje)
- **Custom Hooks**: Moderna alternativa a render props/HOC
- **Provider**: Context com hook customizado
- **HOC**: Adicionar comportamento (menos comum hoje)
- **State Reducer**: Controle avan√ßado de l√≥gica
- **Control Props**: Componente controlled/uncontrolled

Patterns modernos (2024): **Custom Hooks > Compound Components > Provider**. HOC e Render Props s√£o legados, mas ainda aparecem em libs antigas.
