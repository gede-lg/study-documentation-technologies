# Scaling Patterns no React

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**Scaling Patterns** sÃ£o **estratÃ©gias arquiteturais** para escalar aplicaÃ§Ãµes React de pequenas (5-10 telas) para grandes (100+ telas), mantendo **performance, manutenibilidade e velocidade de desenvolvimento**. Conceitualmente, representam **crescimento sustentÃ¡vel** - garantir que aplicaÃ§Ã£o escale linearmente sem colapso de complexidade, build time ou experiÃªncia do desenvolvedor.

### Problema que Resolve

**AplicaÃ§Ã£o Pequena que Cresceu**:
- Build time > 5 minutos
- Componentes gigantes (1000+ linhas)
- Imports circulares
- Testes demoram horas
- Onboarding leva semanas

**AplicaÃ§Ã£o EscalÃ¡vel**:
- Build incremental rÃ¡pido
- Componentes pequenos e focados
- DependÃªncias claras
- Testes rÃ¡pidos e isolados
- Onboarding em dias

---

## ğŸ“¦ Code Splitting e Lazy Loading

### Route-Based Code Splitting

```tsx
// âŒ Bundle Ãºnico gigante
import Dashboard from './pages/Dashboard';
import Products from './pages/Products';
import Settings from './pages/Settings';
// ... 50+ pages
// Bundle: 5MB ğŸ˜±

// âœ… Code splitting por rota
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./pages/Dashboard'));
const Products = lazy(() => import('./pages/Products'));
const Settings = lazy(() => import('./pages/Settings'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/products" element={<Products />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Suspense>
  );
}
// Bundles: dashboard.js (200KB), products.js (150KB), settings.js (100KB) âœ…
```

### Component-Based Code Splitting

```tsx
// âœ… Carregar componente pesado apenas quando necessÃ¡rio
import { lazy, Suspense, useState } from 'react';

const HeavyChart = lazy(() => import('./components/HeavyChart'));

function Dashboard() {
  const [showChart, setShowChart] = useState(false);

  return (
    <div>
      <button onClick={() => setShowChart(true)}>
        Show Chart
      </button>

      {showChart && (
        <Suspense fallback={<ChartSkeleton />}>
          <HeavyChart data={data} />
        </Suspense>
      )}
    </div>
  );
}
```

### Prefetch Critical Routes

```tsx
// âœ… Prefetch rotas que usuÃ¡rio provavelmente vai acessar
function HomePage() {
  useEffect(() => {
    // Prefetch dashboard quando hover no link
    const dashboardLink = document.querySelector('[href="/dashboard"]');

    const prefetch = () => {
      import('./pages/Dashboard');
    };

    dashboardLink?.addEventListener('mouseenter', prefetch, { once: true });

    return () => {
      dashboardLink?.removeEventListener('mouseenter', prefetch);
    };
  }, []);

  return (
    <div>
      <Link to="/dashboard">Go to Dashboard</Link>
    </div>
  );
}
```

---

## ğŸ¢ Micro-Frontends Pattern

### Monorepo com Workspaces

```
project/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ main-app/        # App principal
â”‚   â”œâ”€â”€ admin-app/       # Admin separado
â”‚   â””â”€â”€ mobile-app/      # Mobile
â”‚
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ ui/              # Componentes compartilhados
â”‚   â”œâ”€â”€ auth/            # LÃ³gica de auth compartilhada
â”‚   â”œâ”€â”€ api-client/      # API client
â”‚   â””â”€â”€ utils/           # Utils
â”‚
â””â”€â”€ package.json

// package.json (root)
{
  "workspaces": [
    "apps/*",
    "packages/*"
  ]
}
```

### Module Federation (Webpack 5)

```javascript
// app1/webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',
      filename: 'remoteEntry.js',
      exposes: {
        './ProductList': './src/components/ProductList'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// app2/webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app2',
      remotes: {
        app1: 'app1@http://localhost:3001/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// app2 - Usa componente de app1
import ProductList from 'app1/ProductList';

function App2() {
  return <ProductList />;
}
```

---

## ğŸ¯ Feature Flags

### Habilitar/Desabilitar Features Dinamicamente

```tsx
// âœ… Feature flags para release gradual
type FeatureFlags = {
  newCheckout: boolean;
  betaDashboard: boolean;
  experimentalSearch: boolean;
};

const FeatureFlagsContext = createContext<FeatureFlags>({
  newCheckout: false,
  betaDashboard: false,
  experimentalSearch: false
});

export function useFeatureFlag(flag: keyof FeatureFlags): boolean {
  const flags = useContext(FeatureFlagsContext);
  return flags[flag];
}

// Provider
function App() {
  const [flags, setFlags] = useState<FeatureFlags>({
    newCheckout: false,
    betaDashboard: false,
    experimentalSearch: false
  });

  useEffect(() => {
    // Buscar flags do servidor
    fetch('/api/feature-flags')
      .then(r => r.json())
      .then(setFlags);
  }, []);

  return (
    <FeatureFlagsContext.Provider value={flags}>
      <Router />
    </FeatureFlagsContext.Provider>
  );
}

// Uso
function CheckoutPage() {
  const newCheckoutEnabled = useFeatureFlag('newCheckout');

  if (newCheckoutEnabled) {
    return <NewCheckout />;
  }

  return <LegacyCheckout />;
}

// Componente com flag
function FeatureToggle({
  flag,
  children
}: {
  flag: keyof FeatureFlags;
  children: React.ReactNode;
}) {
  const enabled = useFeatureFlag(flag);

  if (!enabled) return null;

  return <>{children}</>;
}

// Uso
<FeatureToggle flag="betaDashboard">
  <NewDashboard />
</FeatureToggle>
```

---

## ğŸ—‚ï¸ Domain-Driven Design (DDD)

### OrganizaÃ§Ã£o por DomÃ­nio de NegÃ³cio

```
src/
â”œâ”€â”€ domains/
â”‚   â”œâ”€â”€ e-commerce/
â”‚   â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ cart/
â”‚   â”‚   â”œâ”€â”€ checkout/
â”‚   â”‚   â””â”€â”€ orders/
â”‚   â”‚
â”‚   â”œâ”€â”€ user-management/
â”‚   â”‚   â”œâ”€â”€ authentication/
â”‚   â”‚   â”œâ”€â”€ profile/
â”‚   â”‚   â””â”€â”€ permissions/
â”‚   â”‚
â”‚   â””â”€â”€ analytics/
â”‚       â”œâ”€â”€ dashboards/
â”‚       â”œâ”€â”€ reports/
â”‚       â””â”€â”€ metrics/
â”‚
â””â”€â”€ shared/
    â”œâ”€â”€ components/
    â”œâ”€â”€ hooks/
    â””â”€â”€ utils/
```

### Bounded Contexts

```tsx
// âœ… Cada domÃ­nio tem prÃ³prio modelo de dados
// domains/e-commerce/products/types/Product.ts
export type Product = {
  id: string;
  name: string;
  price: number;
  stock: number;
};

// domains/analytics/types/Product.ts (diferente!)
export type Product = {
  id: string;
  name: string;
  totalSales: number;
  averageRating: number;
};

// Adaptadores quando necessÃ¡rio
// domains/e-commerce/products/adapters/toAnalyticsProduct.ts
export function toAnalyticsProduct(
  product: ECommerceProduct,
  analytics: ProductAnalytics
): AnalyticsProduct {
  return {
    id: product.id,
    name: product.name,
    totalSales: analytics.sales,
    averageRating: analytics.rating
  };
}
```

---

## âš¡ Performance Patterns em Escala

### Virtual Lists (react-window)

```tsx
// âœ… Renderizar apenas itens visÃ­veis
import { FixedSizeList } from 'react-window';

function LargeProductList({ products }: { products: Product[] }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={products.length}
      itemSize={100}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          <ProductCard product={products[index]} />
        </div>
      )}
    </FixedSizeList>
  );
}
// Renderiza apenas ~10 itens ao invÃ©s de 10,000 âœ…
```

### Memoization Strategy

```tsx
// âœ… Memo apenas componentes pesados/frequentes
import { memo } from 'react';

// Componente simples - NÃƒO precisa memo
function UserName({ name }: { name: string }) {
  return <span>{name}</span>;
}

// Componente complexo - PRECISA memo
const ProductCard = memo(function ProductCard({ product }: { product: Product }) {
  const { data: reviews } = useProductReviews(product.id);
  const averageRating = useMemo(() => calculateAverage(reviews), [reviews]);

  return (
    <div>
      <h3>{product.name}</h3>
      <Stars rating={averageRating} />
      <ExpensiveChart data={reviews} />
    </div>
  );
});
```

---

## ğŸ§ª Testing em Escala

### Test Pyramid para Grandes Apps

```
        /\
       /E2E\       â† 5% (Fluxos crÃ­ticos: login, checkout)
      /------\
     /Integration\ â† 15% (Features completas)
    /------------\
   / Unit Tests  \ â† 80% (FunÃ§Ãµes, hooks, utils)
  /----------------\
```

### Parallel Test Execution

```json
// package.json
{
  "scripts": {
    "test": "jest --maxWorkers=4",
    "test:watch": "jest --watch --maxWorkers=2",
    "test:coverage": "jest --coverage --maxWorkers=50%"
  }
}
```

### Test Organization

```
src/
â”œâ”€â”€ features/
â”‚   â””â”€â”€ products/
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â”œâ”€â”€ ProductCard.tsx
â”‚       â”‚   â””â”€â”€ ProductCard.test.tsx  â† Co-located
â”‚       â””â”€â”€ hooks/
â”‚           â”œâ”€â”€ useProducts.ts
â”‚           â””â”€â”€ useProducts.test.ts   â† Co-located

tests/
â”œâ”€â”€ e2e/                              â† E2E separados
â”‚   â”œâ”€â”€ checkout.spec.ts
â”‚   â””â”€â”€ login.spec.ts
â””â”€â”€ integration/
    â””â”€â”€ product-flow.test.ts
```

---

## ğŸ“Š Monitoramento e Observabilidade

### Error Boundary com Tracking

```tsx
// âœ… Error boundaries que reportam erros
import * as Sentry from '@sentry/react';

function App() {
  return (
    <Sentry.ErrorBoundary
      fallback={<ErrorFallback />}
      onError={(error, errorInfo) => {
        // Sentry jÃ¡ captura automaticamente
        console.error('Error caught:', error, errorInfo);
      }}
    >
      <Router />
    </Sentry.ErrorBoundary>
  );
}
```

### Performance Monitoring

```tsx
// âœ… Monitorar performance de rotas
import { useEffect } from 'react';

function useRoutePerformance(routeName: string) {
  useEffect(() => {
    const startTime = performance.now();

    return () => {
      const endTime = performance.now();
      const duration = endTime - startTime;

      analytics.track('route_render_time', {
        route: routeName,
        duration
      });

      if (duration > 3000) {
        analytics.track('slow_route', {
          route: routeName,
          duration
        });
      }
    };
  }, [routeName]);
}

function ProductsPage() {
  useRoutePerformance('products');

  return <ProductList />;
}
```

---

## ğŸš€ ConclusÃ£o

Scaling Patterns incluem:
- **Code Splitting**: Route-based, component-based
- **Micro-Frontends**: Monorepo, Module Federation
- **Feature Flags**: Release gradual e A/B testing
- **DDD**: OrganizaÃ§Ã£o por domÃ­nio de negÃ³cio
- **Performance**: Virtual lists, memoization estratÃ©gica
- **Testing**: Test pyramid (80/15/5), parallel execution
- **Monitoring**: Error boundaries, performance tracking

Escalar Ã© planejar para o futuro - decisÃµes arquiteturais hoje determinam se aplicaÃ§Ã£o vai escalar para 1M usuÃ¡rios ou colapsar em 10K.
