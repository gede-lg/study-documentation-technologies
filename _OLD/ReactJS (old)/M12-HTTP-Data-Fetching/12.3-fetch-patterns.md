# Fetch Patterns no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Fetch Patterns** s√£o padr√µes arquiteturais para gerenciar requisi√ß√µes HTTP em React: **loading states** (loading/error/data), **AbortController** (cancelamento em cleanup), **pagination** (p√°gina a p√°gina), **infinite scroll** (carregar mais), e **dependent requests** (requisi√ß√µes sequenciais). Representam **best practices** consolidadas pela comunidade para resolver problemas recorrentes de data fetching.

Esses patterns transformam c√≥digo na√Øve (fetch direto em component) em arquitetura **robusta**: tratamento de race conditions, cleanup adequado, UX de loading consistente, performance otimizada. S√£o diferen√ßa entre "funciona no happy path" e **"funciona em produ√ß√£o"** (edge cases, concorr√™ncia, memory leaks).

**Filosofia:** "Data fetching is complex, patterns simplify." Cada pattern resolve problema espec√≠fico testado em milhares de apps. Usar patterns = evitar reinventar roda e bugs sutis.

### Import√¢ncia no Ecossistema

Fetch patterns s√£o **essenciais** para:

- **UX consistente**: Loading/error states padronizados
- **Performance**: Cancelamento, debouncing
- **Escalabilidade**: Pagination, infinite scroll
- **Robustez**: Race conditions, cleanup, dependent requests

**Contexto:** Patterns emergiram organicamente (2015-2020) conforme comunidade descobriu armadilhas. Hoje s√£o **standard** - bibliotecas como React Query abstraem esses patterns internamente.

---

## üìã Sum√°rio Conceitual

### Patterns Cobertos

1. **Loading/Error/Data States**: Triple state pattern
2. **AbortController Cleanup**: Prevenir memory leaks
3. **Race Conditions**: Stale data prevention
4. **Pagination**: Page-based data loading
5. **Infinite Scroll**: Load more pattern
6. **Dependent Requests**: Sequential fetching

---

## üîç Fundamentos Te√≥ricos

### Triple State Pattern

Todo fetch tem 3 estados poss√≠veis:
```
Initial ‚Üí Loading ‚Üí Success (data)
                 ‚Üò Error
```

**State machine:**
```javascript
const [state, setState] = useState({
  loading: false,
  error: null,
  data: null
});
```

### Race Condition

**Problema:** User navega r√°pido, requests completam out of order:
```
Request A (/users?page=1) ‚Üí Response A (3s)
Request B (/users?page=2) ‚Üí Response B (1s)
// B completa primeiro, depois A sobrescreve com p√°gina errada
```

**Solu√ß√£o:** Ignore stale responses (AbortController ou flag).

---

## üîç An√°lise Conceitual Profunda

### 12.3.1 Loading/Error/Data States

**Pattern b√°sico:**
```javascript
function UsersList() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchUsers = async () => {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch('/api/users');

        if (!response.ok) {
          throw new Error('Failed to fetch');
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return null;

  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**Single state object (alternative):**
```javascript
function UsersList() {
  const [state, setState] = useState({
    loading: true,
    error: null,
    data: null
  });

  useEffect(() => {
    const fetchUsers = async () => {
      setState({ loading: true, error: null, data: null });

      try {
        const response = await fetch('/api/users');
        const result = await response.json();

        setState({ loading: false, error: null, data: result });
      } catch (error) {
        setState({ loading: false, error: error.message, data: null });
      }
    };

    fetchUsers();
  }, []);

  const { loading, error, data } = state;

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**Custom hook (reutiliz√°vel):**
```javascript
function useFetch(url) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { loading, error, data };
}

// Uso
function UsersList() {
  const { loading, error, data } = useFetch('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 12.3.2 AbortController Cleanup

**Problema: Memory leak sem cleanup:**
```javascript
useEffect(() => {
  fetch('/api/users')
    .then(r => r.json())
    .then(setData);
  // Se component unmount, setState ainda executa ‚Üí warning
}, []);
```

**‚úÖ Solu√ß√£o: AbortController:**
```javascript
useEffect(() => {
  const controller = new AbortController();

  const fetchUsers = async () => {
    try {
      const response = await fetch('/api/users', {
        signal: controller.signal
      });

      const data = await response.json();
      setUsers(data);
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Request cancelled');
      } else {
        setError(error.message);
      }
    }
  };

  fetchUsers();

  return () => {
    controller.abort(); // Cleanup
  };
}, []);
```

**Com loading state:**
```javascript
useEffect(() => {
  const controller = new AbortController();
  let isCancelled = false;

  const fetchUsers = async () => {
    setLoading(true);

    try {
      const response = await fetch('/api/users', {
        signal: controller.signal
      });

      const data = await response.json();

      if (!isCancelled) {
        setUsers(data);
        setLoading(false);
      }
    } catch (error) {
      if (!isCancelled && error.name !== 'AbortError') {
        setError(error.message);
        setLoading(false);
      }
    }
  };

  fetchUsers();

  return () => {
    controller.abort();
    isCancelled = true;
  };
}, []);
```

### 12.3.3 Race Conditions Prevention

**Problema: Stale data:**
```javascript
function UserDetail({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // User navega userId: 1 ‚Üí 2 ‚Üí 3 rapidamente
    fetch(`/api/users/${userId}`)
      .then(r => r.json())
      .then(setUser);
    // Responses podem completar fora de ordem!
  }, [userId]);
}
```

**‚úÖ Solu√ß√£o 1: AbortController:**
```javascript
useEffect(() => {
  const controller = new AbortController();

  fetch(`/api/users/${userId}`, { signal: controller.signal })
    .then(r => r.json())
    .then(setUser)
    .catch(err => {
      if (err.name !== 'AbortError') {
        console.error(err);
      }
    });

  return () => {
    controller.abort(); // Cancela request anterior
  };
}, [userId]);
```

**‚úÖ Solu√ß√£o 2: Ignore flag:**
```javascript
useEffect(() => {
  let ignore = false;

  const fetchUser = async () => {
    const response = await fetch(`/api/users/${userId}`);
    const data = await response.json();

    if (!ignore) {
      setUser(data);
    }
  };

  fetchUser();

  return () => {
    ignore = true; // Ignora response de request anterior
  };
}, [userId]);
```

**Custom hook com race condition protection:**
```javascript
function useFetch(url) {
  const [state, setState] = useState({
    loading: true,
    error: null,
    data: null
  });

  useEffect(() => {
    const controller = new AbortController();

    const fetchData = async () => {
      setState(prev => ({ ...prev, loading: true }));

      try {
        const response = await fetch(url, { signal: controller.signal });
        const data = await response.json();

        setState({ loading: false, error: null, data });
      } catch (error) {
        if (error.name !== 'AbortError') {
          setState({ loading: false, error: error.message, data: null });
        }
      }
    };

    fetchData();

    return () => {
      controller.abort();
    };
  }, [url]);

  return state;
}
```

### 12.3.4 Pagination Pattern

**Page-based pagination:**
```javascript
function PaginatedList() {
  const [page, setPage] = useState(1);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [totalPages, setTotalPages] = useState(0);

  useEffect(() => {
    const controller = new AbortController();

    const fetchPage = async () => {
      setLoading(true);

      try {
        const response = await fetch(`/api/users?page=${page}&limit=10`, {
          signal: controller.signal
        });

        const result = await response.json();

        setData(result.data);
        setTotalPages(result.totalPages);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error(error);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchPage();

    return () => {
      controller.abort();
    };
  }, [page]);

  return (
    <div>
      {loading && <div>Loading...</div>}

      <ul>
        {data.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>

      <div>
        <button
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1 || loading}
        >
          Previous
        </button>

        <span>Page {page} of {totalPages}</span>

        <button
          onClick={() => setPage(p => p + 1)}
          disabled={page === totalPages || loading}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

**Custom hook para pagination:**
```javascript
function usePagination(url, initialPage = 1) {
  const [page, setPage] = useState(initialPage);
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState([]);
  const [totalPages, setTotalPages] = useState(0);

  useEffect(() => {
    const controller = new AbortController();

    const fetchPage = async () => {
      setLoading(true);

      try {
        const response = await fetch(`${url}?page=${page}&limit=10`, {
          signal: controller.signal
        });

        const result = await response.json();

        setData(result.data);
        setTotalPages(result.totalPages);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error(error);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchPage();

    return () => {
      controller.abort();
    };
  }, [url, page]);

  const nextPage = () => setPage(p => Math.min(totalPages, p + 1));
  const prevPage = () => setPage(p => Math.max(1, p - 1));
  const goToPage = (pageNum) => setPage(pageNum);

  return {
    data,
    loading,
    page,
    totalPages,
    nextPage,
    prevPage,
    goToPage
  };
}

// Uso
function UsersList() {
  const { data, loading, page, totalPages, nextPage, prevPage } = usePagination('/api/users');

  return (
    <div>
      {loading && <div>Loading...</div>}
      <ul>
        {data.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      <button onClick={prevPage} disabled={page === 1}>Previous</button>
      <span>{page}/{totalPages}</span>
      <button onClick={nextPage} disabled={page === totalPages}>Next</button>
    </div>
  );
}
```

### 12.3.5 Infinite Scroll Pattern

**Load more button:**
```javascript
function InfiniteScrollList() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const loadMore = async () => {
    if (loading || !hasMore) return;

    setLoading(true);

    try {
      const response = await fetch(`/api/items?page=${page}&limit=20`);
      const result = await response.json();

      setItems(prev => [...prev, ...result.data]);
      setHasMore(result.hasMore);
      setPage(p => p + 1);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadMore();
  }, []); // Load inicial

  return (
    <div>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>

      {loading && <div>Loading...</div>}

      {hasMore && !loading && (
        <button onClick={loadMore}>Load More</button>
      )}

      {!hasMore && <div>No more items</div>}
    </div>
  );
}
```

**Intersection Observer (auto-load ao scroll):**
```javascript
function InfiniteScrollAuto() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const loaderRef = useRef(null);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;

    setLoading(true);

    try {
      const response = await fetch(`/api/items?page=${page}&limit=20`);
      const result = await response.json();

      setItems(prev => [...prev, ...result.data]);
      setHasMore(result.hasMore);
      setPage(p => p + 1);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  }, [page, loading, hasMore]);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          loadMore();
        }
      },
      { threshold: 1.0 }
    );

    if (loaderRef.current) {
      observer.observe(loaderRef.current);
    }

    return () => {
      if (loaderRef.current) {
        observer.unobserve(loaderRef.current);
      }
    };
  }, [loadMore, hasMore, loading]);

  return (
    <div>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>

      {loading && <div>Loading...</div>}

      <div ref={loaderRef} style={{ height: '20px' }}>
        {!hasMore && 'No more items'}
      </div>
    </div>
  );
}
```

### 12.3.6 Dependent Requests

**Sequential requests:**
```javascript
function UserWithPosts({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchUserAndPosts = async () => {
      setLoading(true);

      try {
        // 1. Fetch user
        const userResponse = await fetch(`/api/users/${userId}`);
        const userData = await userResponse.json();
        setUser(userData);

        // 2. Fetch posts (depende de user)
        const postsResponse = await fetch(`/api/users/${userId}/posts`);
        const postsData = await postsResponse.json();
        setPosts(postsData);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    };

    fetchUserAndPosts();
  }, [userId]);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      <h1>{user?.name}</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

**Parallel requests (Promise.all):**
```javascript
useEffect(() => {
  const fetchData = async () => {
    setLoading(true);

    try {
      // Fetch em paralelo
      const [userResponse, postsResponse, commentsResponse] = await Promise.all([
        fetch(`/api/users/${userId}`),
        fetch(`/api/users/${userId}/posts`),
        fetch(`/api/users/${userId}/comments`)
      ]);

      const [userData, postsData, commentsData] = await Promise.all([
        userResponse.json(),
        postsResponse.json(),
        commentsResponse.json()
      ]);

      setUser(userData);
      setPosts(postsData);
      setComments(commentsData);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, [userId]);
```

**Conditional fetch:**
```javascript
function UserPosts({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);

  // Fetch user
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(r => r.json())
      .then(setUser);
  }, [userId]);

  // Fetch posts only ap√≥s user carregado
  useEffect(() => {
    if (!user) return;

    fetch(`/api/users/${user.id}/posts`)
      .then(r => r.json())
      .then(setPosts);
  }, [user]);

  if (!user) return <div>Loading user...</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      {posts.length === 0 ? (
        <div>Loading posts...</div>
      ) : (
        <ul>
          {posts.map(post => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

### 12.3.7 Debouncing Fetch

**Search com debounce:**
```javascript
function SearchWithDebounce() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!query) {
      setResults([]);
      return;
    }

    setLoading(true);

    // Debounce: aguarda 500ms ap√≥s parar de digitar
    const timeoutId = setTimeout(async () => {
      try {
        const response = await fetch(`/api/search?q=${query}`);
        const data = await response.json();
        setResults(data);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    }, 500);

    return () => {
      clearTimeout(timeoutId);
    };
  }, [query]);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />

      {loading && <div>Searching...</div>}

      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Pattern

**Loading/Error/Data:** SEMPRE (todo fetch precisa)

**AbortController:** SEMPRE em useEffect (previne memory leaks)

**Race Conditions:** Quando deps mudam r√°pido (search, tabs, params)

**Pagination:** Datasets grandes (>100 items)

**Infinite Scroll:** Feeds (Twitter, Instagram style)

**Dependent Requests:** Dados relacionados (user ‚Üí posts)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Performance

**Pagination vs Infinite Scroll:**
- Pagination: Melhor para busca (vai para p√°gina X)
- Infinite Scroll: Melhor para discovery (scroll infinito)

### UX

**Loading states:**
- Skeleton loaders > Spinners (menos jarring)
- Optimistic updates > Loading (percep√ß√£o de velocidade)

### Memory

**Infinite scroll acumula itens:**
```javascript
// ‚ö†Ô∏è Problema: Lista cresce indefinidamente
setItems(prev => [...prev, ...newItems]);

// ‚úÖ Solu√ß√£o: Virtualization (react-window)
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Custom Hooks

Patterns s√£o encapsulados em custom hooks:
```javascript
useFetch(), usePagination(), useInfiniteScroll()
```

### Rela√ß√£o com React Query

React Query abstrai TODOS esses patterns:
```javascript
// Sem library (50+ linhas)
// Com React Query (5 linhas)
const { data, isLoading, error } = useQuery('users', fetchUsers);
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Pr√≥ximos Passos

Este m√≥dulo cobriu patterns manuais. Pr√≥ximos:

1. **12.4 Advanced Data Fetching** - Caching, optimistic updates
2. **12.5 React Query** - Library que abstrai TODOS patterns (game changer)
3. **12.6 SWR** - Alternative lightweight

**Prepara√ß√£o:** Entender patterns manuais = apreciar valor de React Query/SWR.

---

## üìö Conclus√£o

### Pontos-Chave

Fetch patterns essenciais:

1. **Triple state**: loading/error/data
2. **AbortController**: Cleanup em useEffect
3. **Race conditions**: Ignore stale responses
4. **Pagination**: Page-based loading
5. **Infinite scroll**: Load more pattern
6. **Dependent requests**: Sequential/parallel

### Best Practices

1. **SEMPRE use AbortController** em useEffect
2. **Triple state pattern** para UX consistente
3. **Debounce search inputs** (500ms)
4. **Race condition protection** em deps din√¢micos
5. **Custom hooks** para reutiliza√ß√£o

### Recomenda√ß√£o

**Para apps simples:** Patterns manuais suficientes.
**Para apps complexos:** React Query/SWR (pr√≥ximos m√≥dulos) - abstraem toda essa complexidade.

**Dominar fetch patterns = base para libraries avan√ßadas.**
