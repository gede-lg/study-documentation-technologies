# React Query (TanStack Query)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**React Query** (agora TanStack Query) √© biblioteca **especializada** em data fetching que abstrai toda complexidade: **caching autom√°tico**, **background refetching**, **stale-while-revalidate**, **optimistic updates**, **infinite scroll**, **prefetching**, e **devtools**. Representa **game changer** - centenas de linhas de c√≥digo manual ‚Üí poucas linhas de API declarativa.

React Query trata server state como **first-class citizen**: diferencia state local (UI) de server state (cache de API). Gerencia lifecycle completo: fetch, cache, sync, invalidation, garbage collection. Resultado: **zero boilerplate**, **UX superior** (instant cache hits, background updates), **performance** otimizada (deduplication, parallelization).

**Filosofia:** "Server state is not client state." State local (useState) √© s√≠ncrono e controlado. Server state √© **ass√≠ncrono**, **pode estar stale**, **ownership no servidor**. React Query √© framework para gerenciar essa complexidade.

### Import√¢ncia no Ecossistema

React Query √© **essencial** para:

- **Eliminar boilerplate**: 50+ linhas ‚Üí 5 linhas
- **Cache inteligente**: Autom√°tico, com revalidation
- **UX superior**: Instant cache, background updates
- **DevTools**: Visualizar queries, cache, timings

**Contexto:** 40k+ stars GitHub, usado por empresas Fortune 500. Mudou paradigma de data fetching em React (2019+). Hoje √© **standard** para apps s√©rios.

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **Setup**: QueryClient, Provider
2. **useQuery**: Fetch data com cache
3. **useMutation**: POST/PUT/DELETE
4. **Query Keys**: Cache identification
5. **Invalidation**: Refresh cache
6. **Optimistic Updates**: UI instant

---

## üîç An√°lise Conceitual Profunda

### 12.5.1 Setup e Instala√ß√£o

**Instala√ß√£o:**
```bash
npm install @tanstack/react-query
```

**Setup b√°sico:**
```javascript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}
```

**Com DevTools:**
```javascript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

**QueryClient config:**
```javascript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60000, // Data fresh por 60s
      cacheTime: 300000, // Cache persiste 5min
      retry: 3, // Retry 3x em caso de erro
      refetchOnWindowFocus: true // Refetch ao focus window
    }
  }
});
```

### 12.5.2 useQuery - Fetch Data

**B√°sico:**
```javascript
import { useQuery } from '@tanstack/react-query';

function UsersList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await fetch('/api/users');
      return response.json();
    }
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**Com axios:**
```javascript
import axios from 'axios';

const fetchUsers = async () => {
  const { data } = await axios.get('/api/users');
  return data;
};

function UsersList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers
  });

  // ...
}
```

**Query com par√¢metros:**
```javascript
function UserDetail({ userId }) {
  const { data: user, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      return response.json();
    }
  });

  if (isLoading) return <div>Loading...</div>;

  return <div>{user.name}</div>;
}
```

**Query states:**
```javascript
const {
  data,
  error,
  isLoading,      // Loading primeira vez
  isFetching,     // Loading (incluindo background refetch)
  isError,
  isSuccess,
  status,         // 'loading' | 'error' | 'success'
  fetchStatus     // 'fetching' | 'paused' | 'idle'
} = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers
});
```

**Dependent queries:**
```javascript
function UserPosts({ userId }) {
  // Query 1: User
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  });

  // Query 2: Posts (depende de user)
  const { data: posts } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => fetchPosts(user.id),
    enabled: !!user // S√≥ executa ap√≥s user carregar
  });

  return (
    <div>
      <h1>{user?.name}</h1>
      <ul>
        {posts?.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 12.5.3 Query Keys

**Query key √© unique identifier do cache:**
```javascript
// String simple
queryKey: ['users']

// Array com params
queryKey: ['user', userId]

// Array com m√∫ltiplos params
queryKey: ['posts', { userId, page: 1, limit: 10 }]
```

**Matching pattern:**
```javascript
// Query exata
queryClient.invalidateQueries({ queryKey: ['users'] });

// Query com prefix (invalida todos users)
queryClient.invalidateQueries({ queryKey: ['user'] });
// Invalida: ['user', 1], ['user', 2], etc.
```

**Best practices:**
```javascript
// ‚úÖ Bom: Espec√≠fico, hierarchical
['users']
['user', userId]
['user', userId, 'posts']
['user', userId, 'posts', { page: 1 }]

// ‚ùå Ruim: Gen√©rico demais
['data']
['fetch']
```

### 12.5.4 useMutation - Create/Update/Delete

**POST (create):**
```javascript
import { useMutation } from '@tanstack/react-query';

function CreateUserForm() {
  const mutation = useMutation({
    mutationFn: async (newUser) => {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      });
      return response.json();
    }
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    mutation.mutate({ name: 'Jo√£o', email: 'joao@example.com' });
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Creating...' : 'Create User'}
      </button>

      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>User created!</div>}
    </form>
  );
}
```

**PUT (update):**
```javascript
const updateUserMutation = useMutation({
  mutationFn: async ({ id, data }) => {
    const response = await fetch(`/api/users/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }
});

// Uso
updateUserMutation.mutate({ id: 1, data: { name: 'Jo√£o Silva' } });
```

**DELETE:**
```javascript
const deleteUserMutation = useMutation({
  mutationFn: async (userId) => {
    await fetch(`/api/users/${userId}`, { method: 'DELETE' });
  }
});

// Uso
deleteUserMutation.mutate(userId);
```

### 12.5.5 Invalidation e Refetching

**Invalidate ap√≥s mutation:**
```javascript
import { useMutation, useQueryClient } from '@tanstack/react-query';

function CreateUserForm() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // Invalida cache de users ‚Üí refetch autom√°tico
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });

  return (
    <button onClick={() => mutation.mutate(userData)}>
      Create User
    </button>
  );
}
```

**Invalidate espec√≠fico:**
```javascript
// Invalida query exata
queryClient.invalidateQueries({ queryKey: ['user', userId] });

// Invalida todas queries de user
queryClient.invalidateQueries({ queryKey: ['user'] });

// Invalida com predicate
queryClient.invalidateQueries({
  predicate: (query) => query.queryKey[0] === 'user'
});
```

**Refetch manual:**
```javascript
function UsersList() {
  const { data, refetch } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers
  });

  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      {/* ... */}
    </div>
  );
}
```

### 12.5.6 Optimistic Updates

**Update UI antes de response:**
```javascript
function TodoList() {
  const queryClient = useQueryClient();

  const toggleMutation = useMutation({
    mutationFn: async (todoId) => {
      await fetch(`/api/todos/${todoId}/toggle`, { method: 'POST' });
    },
    onMutate: async (todoId) => {
      // 1. Cancela refetches em andamento
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // 2. Snapshot do estado anterior
      const previousTodos = queryClient.getQueryData(['todos']);

      // 3. Optimistic update
      queryClient.setQueryData(['todos'], (old) =>
        old.map((todo) =>
          todo.id === todoId ? { ...todo, completed: !todo.completed } : todo
        )
      );

      // 4. Retorna context com snapshot (para rollback)
      return { previousTodos };
    },
    onError: (err, todoId, context) => {
      // 5. Rollback em caso de erro
      queryClient.setQueryData(['todos'], context.previousTodos);
    },
    onSettled: () => {
      // 6. Refetch ap√≥s sucesso ou erro
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleMutation.mutate(todo.id)}
          />
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

### 12.5.7 Pagination

**Page-based:**
```javascript
function PaginatedUsers() {
  const [page, setPage] = useState(1);

  const { data, isLoading, isPreviousData } = useQuery({
    queryKey: ['users', page],
    queryFn: () => fetchUsers(page),
    keepPreviousData: true // Mant√©m data anterior enquanto fetch novo
  });

  return (
    <div>
      {isLoading ? (
        <div>Loading...</div>
      ) : (
        <ul>
          {data.users.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      )}

      <button
        onClick={() => setPage(old => Math.max(old - 1, 1))}
        disabled={page === 1}
      >
        Previous
      </button>

      <span>Page {page}</span>

      <button
        onClick={() => {
          if (!isPreviousData && data?.hasMore) {
            setPage(old => old + 1);
          }
        }}
        disabled={isPreviousData || !data?.hasMore}
      >
        Next
      </button>
    </div>
  );
}
```

### 12.5.8 Infinite Query

**Infinite scroll:**
```javascript
import { useInfiniteQuery } from '@tanstack/react-query';

function InfiniteUsersList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['users'],
    queryFn: async ({ pageParam = 1 }) => {
      const response = await fetch(`/api/users?page=${pageParam}`);
      return response.json();
    },
    getNextPageParam: (lastPage, pages) => {
      return lastPage.hasMore ? pages.length + 1 : undefined;
    }
  });

  return (
    <div>
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.users.map(user => (
            <div key={user.id}>{user.name}</div>
          ))}
        </div>
      ))}

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage ? 'Loading more...' : 'Load More'}
      </button>
    </div>
  );
}
```

### 12.5.9 Prefetching

**Prefetch ao hover:**
```javascript
function UsersList() {
  const queryClient = useQueryClient();

  const { data: users } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers
  });

  const handleMouseEnter = (userId) => {
    // Prefetch user detail
    queryClient.prefetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetchUser(userId)
    });
  };

  return (
    <ul>
      {users.map(user => (
        <li
          key={user.id}
          onMouseEnter={() => handleMouseEnter(user.id)}
        >
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </li>
      ))}
    </ul>
  );
}
// User detail carrega instantaneamente (j√° em cache)
```

### 12.5.10 Initial Data

**Data inicial de outra query:**
```javascript
function UserDetail({ userId }) {
  const queryClient = useQueryClient();

  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    initialData: () => {
      // Tenta pegar de cache de users list
      const users = queryClient.getQueryData(['users']);
      return users?.find(u => u.id === userId);
    }
  });

  return <div>{user?.name}</div>;
}
// Mostra data imediatamente se em cache
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar React Query

**‚úÖ Use quando:**
- App com m√∫ltiplas requisi√ß√µes
- Precisa cache inteligente
- Real-time data (polling, refetch on focus)
- Optimistic updates
- Infinite scroll, pagination

**‚ùå N√£o use quando:**
- App trivial (1-2 requests)
- Bundle size cr√≠tico (+40kb)
- Preferir vanilla approach

### React Query vs Manual

**Manual (50+ linhas):**
```javascript
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const controller = new AbortController();
  // ... fetch, cache, cleanup
}, []);
```

**React Query (5 linhas):**
```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers
});
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Bundle Size

**React Query: ~40kb gzipped** (consider√°vel, mas vale o ROI).

### Learning Curve

**Conceitos novos:**
- Query keys (hierarchical)
- StaleTime vs CacheTime
- Invalidation patterns

### Over-engineering

**Para 2-3 requests simples, pode ser overkill.**

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com useEffect

React Query **substitui** 90% dos useEffect de fetching:
```javascript
// Antes
useEffect(() => {
  fetch('/api/users').then(setUsers);
}, []);

// Depois
useQuery({ queryKey: ['users'], queryFn: fetchUsers });
```

### Rela√ß√£o com Context

Cache do React Query pode **substituir** Context para server state:
```javascript
// N√£o precisa Context para compartilhar user data
// Query key ['user'] √© compartilhado automaticamente
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### React Query v5

**Novidades:**
- Simplified API
- Melhor TypeScript
- Suspense-ready

### Pr√≥ximos Passos

**12.6 SWR** - Alternative lightweight (Vercel)

---

## üìö Conclus√£o

### Pontos-Chave

React Query fornece:

1. **Cache autom√°tico** com smart revalidation
2. **Background refetching** (focus, interval)
3. **Optimistic updates** built-in
4. **Pagination/Infinite scroll** f√°cil
5. **DevTools** para debug

### Best Practices

1. **Query keys hierarchical** (['users'], ['user', id])
2. **Invalidate ap√≥s mutations**
3. **keepPreviousData para pagination**
4. **Prefetch ao hover** (UX instant)
5. **Configure staleTime/cacheTime** global

### Recomenda√ß√£o

**Para apps produ√ß√£o: React Query √© essencial.**

Elimina boilerplate, melhora UX (cache, optimistic), simplifica c√≥digo. ROI √© imenso - 40kb bundle vs centenas de linhas economizadas.

**Dominar React Query = data fetching moderno e profissional.**
