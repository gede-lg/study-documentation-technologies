# SWR (Stale-While-Revalidate)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**SWR** (Stale-While-Revalidate) √© biblioteca **lightweight** de data fetching da Vercel que implementa estrat√©gia hom√¥nima: **retornar cache** (stale) imediatamente, **revalidar** em background. Similar a React Query mas com API mais **minimalista** - menos features, menos bundle (~5kb vs ~40kb), foco em **simplicidade**. Nome vem de HTTP cache strategy (RFC 5861).

SWR representa filosofia "cache-first": toda request vai para cache, component renderiza com cache (instant), background fetch atualiza. Resultado: **perceived performance** excelente - UX sem loading spinners para data visitada anteriormente. Trade-off: menos features que React Query, mas bundle tiny e DX simples.

**Filosofia:** "Fast first, correct eventually." Mostrar algo (cache) imediatamente > esperar fetch. Data stale por segundos √© aceit√°vel se UX √© instant. Revalidation garante eventual consistency.

### Import√¢ncia no Ecossistema

SWR √© **essencial** para:

- **Performance percebida**: Cache instant, no spinners
- **Bundle size**: 5kb (vs React Query 40kb)
- **Simplicidade**: API minimal, learning curve baixa
- **Next.js integration**: First-class da Vercel

**Contexto:** Criado por Vercel (2019), 30k+ stars. Popular em apps Next.js. Alternative lightweight a React Query - escolha depende de trade-off features vs bundle size.

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **Setup e useSWR**: B√°sico
2. **Revalidation**: Focus, interval, manual
3. **Mutations**: useSWRMutation
4. **Optimistic UI**: Update local cache
5. **SWR vs React Query**: Compara√ß√£o

---

## üîç An√°lise Conceitual Profunda

### 12.6.1 Instala√ß√£o e Setup

**Instala√ß√£o:**
```bash
npm install swr
```

**Uso b√°sico:**
```javascript
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UsersList() {
  const { data, error, isLoading } = useSWR('/api/users', fetcher);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**Global fetcher (SWRConfig):**
```javascript
import { SWRConfig } from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function App() {
  return (
    <SWRConfig value={{ fetcher }}>
      <YourApp />
    </SWRConfig>
  );
}

// Agora components n√£o precisam passar fetcher
function UsersList() {
  const { data } = useSWR('/api/users');
  // ...
}
```

**Com axios:**
```javascript
import axios from 'axios';

const fetcher = (url) => axios.get(url).then(res => res.data);

function UsersList() {
  const { data } = useSWR('/api/users', fetcher);
  // ...
}
```

### 12.6.2 Revalidation Strategies

**Revalidate on focus:**
```javascript
const { data } = useSWR('/api/users', fetcher, {
  revalidateOnFocus: true // Default: true
});
// Refetch quando usu√°rio volta para tab
```

**Revalidate on interval (polling):**
```javascript
const { data } = useSWR('/api/stats', fetcher, {
  refreshInterval: 5000 // Refetch a cada 5s
});
```

**Revalidate on mount:**
```javascript
const { data } = useSWR('/api/users', fetcher, {
  revalidateOnMount: true // Refetch ao montar component
});
```

**Disable auto revalidation:**
```javascript
const { data } = useSWR('/api/static-data', fetcher, {
  revalidateOnFocus: false,
  revalidateOnReconnect: false
});
// Data never revalidates automaticamente
```

**Manual revalidation:**
```javascript
function UsersList() {
  const { data, mutate } = useSWR('/api/users', fetcher);

  return (
    <div>
      <button onClick={() => mutate()}>Refresh</button>
      {/* ... */}
    </div>
  );
}
```

### 12.6.3 Conditional Fetching

**Fetch condicional:**
```javascript
function UserDetail({ userId }) {
  // null key = n√£o fetch
  const { data: user } = useSWR(
    userId ? `/api/users/${userId}` : null,
    fetcher
  );

  if (!userId) return <div>Select a user</div>;
  if (!user) return <div>Loading...</div>;

  return <div>{user.name}</div>;
}
```

**Dependent requests:**
```javascript
function UserPosts({ userId }) {
  const { data: user } = useSWR(`/api/users/${userId}`, fetcher);

  const { data: posts } = useSWR(
    user ? `/api/users/${user.id}/posts` : null,
    fetcher
  );

  return (
    <div>
      <h1>{user?.name}</h1>
      <ul>
        {posts?.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 12.6.4 Mutations com useSWRMutation

**POST (create):**
```javascript
import { useSWRMutation } from 'swr';

function CreateUserForm() {
  const { trigger, isMutating, error } = useSWRMutation(
    '/api/users',
    async (url, { arg }) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(arg)
      });
      return response.json();
    }
  );

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      await trigger({ name: 'Jo√£o', email: 'joao@example.com' });
      alert('User created!');
    } catch (err) {
      console.error(err);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit" disabled={isMutating}>
        {isMutating ? 'Creating...' : 'Create User'}
      </button>
      {error && <div>Error: {error.message}</div>}
    </form>
  );
}
```

**DELETE:**
```javascript
function UsersList() {
  const { data: users, mutate } = useSWR('/api/users', fetcher);

  const { trigger: deleteUser } = useSWRMutation(
    '/api/users',
    async (url, { arg: userId }) => {
      await fetch(`${url}/${userId}`, { method: 'DELETE' });
    }
  );

  const handleDelete = async (userId) => {
    await deleteUser(userId);

    // Revalidate users list
    mutate();
  };

  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => handleDelete(user.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### 12.6.5 Optimistic Updates

**Update local cache:**
```javascript
function TodoList() {
  const { data: todos, mutate } = useSWR('/api/todos', fetcher);

  const toggleTodo = async (id) => {
    // 1. Optimistic update (local cache)
    mutate(
      todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      ),
      false // Don't revalidate yet
    );

    try {
      // 2. Update no servidor
      await fetch(`/api/todos/${id}/toggle`, { method: 'POST' });

      // 3. Revalidate (buscar data fresh)
      mutate();
    } catch (error) {
      // 4. Rollback em caso de erro
      mutate();
    }
  };

  return (
    <ul>
      {todos?.map(todo => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          />
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

**Optimistic create:**
```javascript
function TodoList() {
  const { data: todos, mutate } = useSWR('/api/todos', fetcher);

  const addTodo = async (text) => {
    const optimisticTodo = {
      id: Date.now(),
      text,
      completed: false
    };

    // Optimistic update
    mutate([...todos, optimisticTodo], false);

    try {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });

      const serverTodo = await response.json();

      // Update com data real do servidor
      mutate(
        todos.map(t => t.id === optimisticTodo.id ? serverTodo : t)
      );
    } catch (error) {
      // Rollback
      mutate(todos.filter(t => t.id !== optimisticTodo.id));
    }
  };

  return (
    <div>
      <button onClick={() => addTodo('New todo')}>Add Todo</button>
      <ul>
        {todos?.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 12.6.6 Pagination

**Page-based:**
```javascript
function PaginatedUsers() {
  const [page, setPage] = useState(1);

  const { data, isLoading } = useSWR(
    `/api/users?page=${page}&limit=10`,
    fetcher
  );

  return (
    <div>
      {isLoading ? (
        <div>Loading...</div>
      ) : (
        <ul>
          {data.users.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      )}

      <button onClick={() => setPage(p => p - 1)} disabled={page === 1}>
        Previous
      </button>
      <span>Page {page}</span>
      <button onClick={() => setPage(p => p + 1)} disabled={!data?.hasMore}>
        Next
      </button>
    </div>
  );
}
```

**Infinite scroll com useSWRInfinite:**
```javascript
import { useSWRInfinite } from 'swr';

function InfiniteUsersList() {
  const getKey = (pageIndex, previousPageData) => {
    if (previousPageData && !previousPageData.hasMore) return null;
    return `/api/users?page=${pageIndex + 1}&limit=20`;
  };

  const { data, size, setSize, isLoading } = useSWRInfinite(
    getKey,
    fetcher
  );

  const users = data ? data.flatMap(page => page.users) : [];
  const hasMore = data?.[data.length - 1]?.hasMore;

  return (
    <div>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>

      {isLoading && <div>Loading...</div>}

      {hasMore && (
        <button onClick={() => setSize(size + 1)}>
          Load More
        </button>
      )}
    </div>
  );
}
```

### 12.6.7 Prefetching

**Prefetch data:**
```javascript
import { preload } from 'swr';

function UsersList() {
  const { data: users } = useSWR('/api/users', fetcher);

  const handleMouseEnter = (userId) => {
    // Prefetch user detail
    preload(`/api/users/${userId}`, fetcher);
  };

  return (
    <ul>
      {users?.map(user => (
        <li
          key={user.id}
          onMouseEnter={() => handleMouseEnter(user.id)}
        >
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </li>
      ))}
    </ul>
  );
}
```

### 12.6.8 Error Handling

**Error retry:**
```javascript
const { data, error } = useSWR('/api/users', fetcher, {
  onErrorRetry: (error, key, config, revalidate, { retryCount }) => {
    // N√£o retry em 404
    if (error.status === 404) return;

    // Max 3 retries
    if (retryCount >= 3) return;

    // Retry ap√≥s 5s
    setTimeout(() => revalidate({ retryCount }), 5000);
  }
});
```

**Global error handler:**
```javascript
<SWRConfig
  value={{
    onError: (error, key) => {
      if (error.status === 401) {
        // Redirect to login
        window.location.href = '/login';
      }

      console.error('SWR Error:', key, error);
    }
  }}
>
  <App />
</SWRConfig>
```

---

## üéØ Aplicabilidade e Contextos

### SWR vs React Query

| Feature | SWR | React Query |
|---------|-----|-------------|
| **Bundle size** | ‚úÖ ~5kb | ‚ö†Ô∏è ~40kb |
| **API** | ‚úÖ Minimal | ‚ö†Ô∏è Mais complexa |
| **DevTools** | ‚ùå N√£o tem | ‚úÖ Excelente |
| **Mutations** | ‚ö†Ô∏è B√°sico | ‚úÖ Avan√ßado |
| **TypeScript** | ‚úÖ Bom | ‚úÖ Excelente |
| **Docs** | ‚úÖ Boas | ‚úÖ Excelentes |

### Quando Usar SWR

**‚úÖ Use SWR quando:**
- Bundle size √© cr√≠tico
- API simples suficiente
- Next.js app (integra√ß√£o first-class)
- Preferir simplicidade

**‚úÖ Use React Query quando:**
- Precisa features avan√ßadas (DevTools, query invalidation complexa)
- TypeScript heavy
- Mutations complexas
- Bundle size n√£o √© issue

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Less Features than React Query

**SWR n√£o tem:**
- DevTools visual
- Query invalidation granular
- Dependent mutations
- Parallel queries helpers

### Menor Comunidade

**React Query:**
- 40k+ stars
- Mais recursos, tutorials

**SWR:**
- 30k stars
- Comunidade menor (mas ativa)

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com React Query

Ambos resolvem mesmo problema com filosofias diferentes:
- SWR: Minimal, lightweight
- React Query: Full-featured, heavier

### Rela√ß√£o com Next.js

SWR √© da Vercel (criadores de Next.js):
- Integra√ß√£o first-class
- SSR/SSG support nativo

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### SWR 2.0

**Novidades:**
- Melhor TypeScript
- useSWRMutation (mutations simplificadas)
- Optimistic UI helpers

### M√≥dulo Completo

**M√≥dulo 12 completo!** Pr√≥ximo: **M√≥dulo 13 - Gerenciamento de Estado**

---

## üìö Conclus√£o

### Pontos-Chave

SWR fornece:

1. **Stale-while-revalidate**: Cache instant + background refresh
2. **Auto revalidation**: Focus, interval, reconnect
3. **Lightweight**: ~5kb (vs React Query 40kb)
4. **Simple API**: useSWR hook minimalista
5. **Next.js integration**: First-class support

### Best Practices

1. **Global fetcher** (SWRConfig)
2. **Conditional fetching** (null key)
3. **Optimistic updates** com mutate()
4. **Prefetch ao hover** (preload)
5. **Error retry strategy** customizada

### Recomenda√ß√£o

**SWR √© excelente para:**
- Apps Next.js
- Bundle size cr√≠tico
- API simples

**React Query √© melhor para:**
- Apps complexos
- DevTools necess√°rio
- Mutations avan√ßadas

**Ambos s√£o √≥timos - escolha depende de trade-offs.**

**Dominar SWR = data fetching eficiente e lightweight.**

---

## üìñ Recursos Adicionais

**Documenta√ß√£o:**
- SWR Docs: https://swr.vercel.app/
- Examples: https://swr.vercel.app/examples

**Compara√ß√µes:**
- SWR vs React Query: https://swr.vercel.app/docs/comparison

**M√≥dulo 12 - HTTP & DATA FETCHING completo! üéâ**

Pr√≥ximo: **M√≥dulo 13 - GERENCIAMENTO DE ESTADO**
