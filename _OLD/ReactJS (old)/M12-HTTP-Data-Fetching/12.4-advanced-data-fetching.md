# Advanced Data Fetching no React

## ðŸŽ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**Advanced Data Fetching** cobre estratÃ©gias sofisticadas: **caching** (armazenar responses para evitar re-fetch), **stale-while-revalidate** (mostrar cache enquanto atualiza), **optimistic updates** (UI instant antes de response), **polling** (fetch periÃ³dico), e **WebSockets** (real-time bidirectional). Representam tÃ©cnicas **production-grade** para performance e UX superior.

Essas estratÃ©gias transformam apps de "functional" para **exceptional**: cache elimina spinners desnecessÃ¡rios, optimistic updates criam ilusÃ£o de velocidade instantÃ¢nea, polling mantÃ©m dados atualizados, WebSockets possibilitam real-time. SÃ£o diferenÃ§a entre app comum e **app que parece nativo**.

**Filosofia:** "Perception is reality." UsuÃ¡rio nÃ£o importa se request leva 100ms - importa se **parece** instantÃ¢neo. Advanced fetching Ã© sobre **perceived performance** e **always-fresh data**.

### ImportÃ¢ncia no Ecossistema

Advanced fetching Ã© **essencial** para:

- **Performance percebida**: Cache, optimistic updates
- **Data freshness**: Polling, WebSockets, revalidation
- **Offline-first**: Cache persistente
- **Real-time**: Chat, notifications, live updates

**Contexto:** Patterns consolidados por apps grandes (Facebook, Twitter). Bibliotecas como React Query/SWR implementam esses patterns internamente.

---

## ðŸ“‹ SumÃ¡rio Conceitual

### EstratÃ©gias Cobertas

1. **Caching**: In-memory e persistent cache
2. **Stale-While-Revalidate**: SWR pattern
3. **Optimistic Updates**: UI antes de response
4. **Polling**: Fetch periÃ³dico
5. **WebSockets**: Real-time communication

---

## ðŸ” AnÃ¡lise Conceitual Profunda

### 12.4.1 Caching BÃ¡sico

**In-memory cache:**
```javascript
const cache = {};

async function fetchWithCache(url) {
  // Check cache
  if (cache[url]) {
    console.log('Cache hit');
    return cache[url];
  }

  // Fetch e cache
  console.log('Cache miss, fetching...');
  const response = await fetch(url);
  const data = await response.json();

  cache[url] = data;
  return data;
}

// Uso em component
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchWithCache(`/api/users/${userId}`).then(setUser);
  }, [userId]);

  return <div>{user?.name}</div>;
}
// Segunda visita ao mesmo userId: instant (cache)
```

**Cache com TTL (Time To Live):**
```javascript
const cache = new Map();

async function fetchWithTTL(url, ttl = 60000) {
  const cached = cache.get(url);

  // Cache vÃ¡lido
  if (cached && Date.now() - cached.timestamp < ttl) {
    return cached.data;
  }

  // Fetch novo
  const response = await fetch(url);
  const data = await response.json();

  cache.set(url, {
    data,
    timestamp: Date.now()
  });

  return data;
}
```

**localStorage cache (persistent):**
```javascript
async function fetchWithLocalStorageCache(url, ttl = 3600000) {
  const cacheKey = `cache_${url}`;
  const cached = localStorage.getItem(cacheKey);

  if (cached) {
    const { data, timestamp } = JSON.parse(cached);

    if (Date.now() - timestamp < ttl) {
      return data;
    }
  }

  const response = await fetch(url);
  const data = await response.json();

  localStorage.setItem(cacheKey, JSON.stringify({
    data,
    timestamp: Date.now()
  }));

  return data;
}
```

### 12.4.2 Stale-While-Revalidate Pattern

**Mostrar cache, fetch em background:**
```javascript
function useSWR(url) {
  const [data, setData] = useState(null);
  const [isValidating, setIsValidating] = useState(false);

  useEffect(() => {
    // 1. Mostrar cache imediatamente
    const cached = cache.get(url);
    if (cached) {
      setData(cached.data);
    }

    // 2. Revalidate em background
    const revalidate = async () => {
      setIsValidating(true);

      try {
        const response = await fetch(url);
        const freshData = await response.json();

        cache.set(url, { data: freshData, timestamp: Date.now() });
        setData(freshData);
      } catch (error) {
        console.error(error);
      } finally {
        setIsValidating(false);
      }
    };

    revalidate();
  }, [url]);

  return { data, isValidating };
}

// Uso
function UserProfile({ userId }) {
  const { data: user, isValidating } = useSWR(`/api/users/${userId}`);

  return (
    <div>
      {user?.name}
      {isValidating && <span> (updating...)</span>}
    </div>
  );
}
// UX: Mostra cache instant, atualiza em background
```

**Com focus revalidation:**
```javascript
function useSWRWithFocus(url) {
  const [data, setData] = useState(null);

  const revalidate = useCallback(async () => {
    const response = await fetch(url);
    const freshData = await response.json();
    setData(freshData);
  }, [url]);

  useEffect(() => {
    // Revalidate ao focus window
    const handleFocus = () => {
      revalidate();
    };

    window.addEventListener('focus', handleFocus);

    return () => {
      window.removeEventListener('focus', handleFocus);
    };
  }, [revalidate]);

  useEffect(() => {
    revalidate();
  }, [revalidate]);

  return { data, revalidate };
}
```

### 12.4.3 Optimistic Updates

**Atualizar UI antes de response:**
```javascript
function TodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = async (text) => {
    const optimisticTodo = {
      id: Date.now(), // Temporary ID
      text,
      completed: false,
      _optimistic: true
    };

    // 1. Update UI imediatamente
    setTodos(prev => [...prev, optimisticTodo]);

    try {
      // 2. Send to server
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });

      const serverTodo = await response.json();

      // 3. Replace optimistic com real
      setTodos(prev =>
        prev.map(todo =>
          todo.id === optimisticTodo.id ? serverTodo : todo
        )
      );
    } catch (error) {
      // 4. Rollback em caso de erro
      setTodos(prev =>
        prev.filter(todo => todo.id !== optimisticTodo.id)
      );

      alert('Failed to add todo');
    }
  };

  return (
    <div>
      <ul>
        {todos.map(todo => (
          <li key={todo.id} style={{ opacity: todo._optimistic ? 0.5 : 1 }}>
            {todo.text}
          </li>
        ))}
      </ul>
      <button onClick={() => addTodo('New todo')}>Add</button>
    </div>
  );
}
// UX: Todo aparece instantaneamente
```

**Optimistic delete:**
```javascript
const deleteTodo = async (id) => {
  // Backup
  const backup = [...todos];

  // 1. Remove imediatamente
  setTodos(prev => prev.filter(todo => todo.id !== id));

  try {
    // 2. Delete no servidor
    await fetch(`/api/todos/${id}`, { method: 'DELETE' });
  } catch (error) {
    // 3. Restore em caso de erro
    setTodos(backup);
    alert('Failed to delete');
  }
};
```

**Optimistic update:**
```javascript
const toggleTodo = async (id) => {
  // 1. Update imediatamente
  setTodos(prev =>
    prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    )
  );

  const todo = todos.find(t => t.id === id);

  try {
    // 2. Sync com servidor
    await fetch(`/api/todos/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ completed: !todo.completed })
    });
  } catch (error) {
    // 3. Revert
    setTodos(prev =>
      prev.map(t =>
        t.id === id ? { ...t, completed: todo.completed } : t
      )
    );
  }
};
```

### 12.4.4 Polling (Fetch PeriÃ³dico)

**Polling bÃ¡sico:**
```javascript
function usePolling(url, interval = 5000) {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error(error);
      }
    };

    // Fetch imediato
    fetchData();

    // Polling
    const intervalId = setInterval(fetchData, interval);

    return () => {
      clearInterval(intervalId);
    };
  }, [url, interval]);

  return data;
}

// Uso
function LiveStats() {
  const stats = usePolling('/api/stats', 10000); // A cada 10s

  return <div>Active users: {stats?.activeUsers}</div>;
}
```

**Polling com pause/resume:**
```javascript
function usePolling(url, interval = 5000, enabled = true) {
  const [data, setData] = useState(null);

  useEffect(() => {
    if (!enabled) return;

    const fetchData = async () => {
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    };

    fetchData();
    const intervalId = setInterval(fetchData, interval);

    return () => clearInterval(intervalId);
  }, [url, interval, enabled]);

  return data;
}

// Uso
function LiveStats() {
  const [paused, setPaused] = useState(false);
  const stats = usePolling('/api/stats', 5000, !paused);

  return (
    <div>
      <div>Active users: {stats?.activeUsers}</div>
      <button onClick={() => setPaused(!paused)}>
        {paused ? 'Resume' : 'Pause'}
      </button>
    </div>
  );
}
```

**Polling adaptativo (backoff):**
```javascript
function useAdaptivePolling(url, baseInterval = 5000) {
  const [data, setData] = useState(null);
  const [interval, setInterval] = useState(baseInterval);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const result = await response.json();

        // Se data mudou, volta para interval base
        if (JSON.stringify(result) !== JSON.stringify(data)) {
          setInterval(baseInterval);
        } else {
          // Se data igual, aumenta interval (backoff)
          setInterval(prev => Math.min(prev * 1.5, 60000));
        }

        setData(result);
      } catch (error) {
        console.error(error);
      }
    };

    fetchData();
    const intervalId = setInterval(fetchData, interval);

    return () => clearInterval(intervalId);
  }, [url, interval, baseInterval, data]);

  return data;
}
```

### 12.4.5 WebSockets (Real-Time)

**WebSocket bÃ¡sico:**
```javascript
function useLiveData(url) {
  const [data, setData] = useState(null);
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const ws = new WebSocket(url);

    ws.onopen = () => {
      console.log('Connected');
      setConnected(true);
    };

    ws.onmessage = (event) => {
      const newData = JSON.parse(event.data);
      setData(newData);
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    ws.onclose = () => {
      console.log('Disconnected');
      setConnected(false);
    };

    return () => {
      ws.close();
    };
  }, [url]);

  return { data, connected };
}

// Uso
function LiveChat() {
  const { data: messages, connected } = useLiveData('ws://localhost:3000/chat');

  return (
    <div>
      <div>Status: {connected ? 'Connected' : 'Disconnected'}</div>
      <ul>
        {messages?.map((msg, i) => (
          <li key={i}>{msg.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

**WebSocket com reconnect:**
```javascript
function useWebSocketWithReconnect(url, maxRetries = 5) {
  const [data, setData] = useState(null);
  const [connected, setConnected] = useState(false);
  const retriesRef = useRef(0);

  useEffect(() => {
    let ws;

    const connect = () => {
      ws = new WebSocket(url);

      ws.onopen = () => {
        console.log('Connected');
        setConnected(true);
        retriesRef.current = 0; // Reset retries
      };

      ws.onmessage = (event) => {
        setData(JSON.parse(event.data));
      };

      ws.onclose = () => {
        console.log('Disconnected');
        setConnected(false);

        // Reconnect com backoff
        if (retriesRef.current < maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, retriesRef.current), 30000);
          retriesRef.current++;

          console.log(`Reconnecting in ${delay}ms...`);
          setTimeout(connect, delay);
        }
      };
    };

    connect();

    return () => {
      ws?.close();
    };
  }, [url, maxRetries]);

  return { data, connected };
}
```

**WebSocket com send:**
```javascript
function useWebSocket(url) {
  const [data, setData] = useState(null);
  const [connected, setConnected] = useState(false);
  const wsRef = useRef(null);

  useEffect(() => {
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => setConnected(true);
    ws.onmessage = (event) => setData(JSON.parse(event.data));
    ws.onclose = () => setConnected(false);

    return () => {
      ws.close();
    };
  }, [url]);

  const send = useCallback((message) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    }
  }, []);

  return { data, connected, send };
}

// Uso
function Chat() {
  const { data: messages, connected, send } = useWebSocket('ws://localhost:3000/chat');
  const [input, setInput] = useState('');

  const handleSend = () => {
    send({ type: 'message', text: input });
    setInput('');
  };

  return (
    <div>
      <div>Status: {connected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'}</div>
      <ul>
        {messages?.map((msg, i) => (
          <li key={i}>{msg.text}</li>
        ))}
      </ul>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={handleSend} disabled={!connected}>Send</button>
    </div>
  );
}
```

---

## ðŸŽ¯ Aplicabilidade e Contextos

### Quando Usar Cada EstratÃ©gia

**Caching:** Dados que nÃ£o mudam frequentemente (user profile, static content)

**SWR:** Dados que podem mudar, mas stale data Ã© aceitÃ¡vel temporariamente

**Optimistic Updates:** Actions do usuÃ¡rio (like, delete, create) - UX instant

**Polling:** Dados que mudam periodicamente (notifications, stats)

**WebSockets:** Real-time crÃ­tico (chat, live collaboration, gaming)

---

## âš ï¸ LimitaÃ§Ãµes e ConsideraÃ§Ãµes

### Caching

**Cache invalidation Ã© difÃ­cil:**
- Quando invalidar? (TTL, manual, event-based)
- Cache inconsistente = bugs sutis

**Memory leaks:**
```javascript
// âŒ Cache cresce infinitamente
cache[url] = data;

// âœ… LRU cache (limitar tamanho)
```

### Optimistic Updates

**Rollback complexo:**
- MÃºltiplas mutations simultÃ¢neas
- Dependent updates (cascade)

### WebSockets

**Scaling challenges:**
- Stateful connections (load balancing difÃ­cil)
- Reconnect logic complexo
- Fallback para polling

---

## ðŸ”— InterconexÃµes Conceituais

### RelaÃ§Ã£o com React Query

React Query implementa TODOS esses patterns:
```javascript
// Caching, SWR, refetch on focus - tudo automÃ¡tico
const { data } = useQuery('users', fetchUsers);
```

### RelaÃ§Ã£o com Redux

Cache pode viver em Redux:
```javascript
// Normalizar e cache em store global
```

---

## ðŸš€ EvoluÃ§Ã£o e PrÃ³ximos Conceitos

### PrÃ³ximos Passos

Este mÃ³dulo cobriu strategies manuais. PrÃ³ximos:

**12.5 React Query** - Abstrai TODOS patterns deste mÃ³dulo (caching, SWR, optimistic, etc.)
**12.6 SWR** - Alternative lightweight

**PreparaÃ§Ã£o:** Entender patterns manuais = apreciar React Query/SWR.

---

## ðŸ“š ConclusÃ£o

### Pontos-Chave

Advanced data fetching envolve:

1. **Caching**: In-memory/persistent, TTL
2. **SWR**: Stale-while-revalidate pattern
3. **Optimistic Updates**: UI antes de response
4. **Polling**: Fetch periÃ³dico (com backoff)
5. **WebSockets**: Real-time bidirectional

### Best Practices

1. **Cache com TTL** (evitar stale data infinita)
2. **Optimistic updates com rollback** (UX instant + error handling)
3. **Polling adaptativo** (backoff quando sem mudanÃ§as)
4. **WebSocket reconnect logic** (rede instÃ¡vel)
5. **Fallback polling â†’ WebSocket** (graceful degradation)

### Filosofia

**"Perception > Reality."**

Advanced fetching Ã© sobre **perceived performance**. Cache e optimistic updates fazem app parecer instantÃ¢neo. SWR e polling mantÃªm dados fresh. WebSockets fornecem real-time. Resultado: UX superior.

**Dominar advanced fetching = apps que parecem nativos.**

**PrÃ³ximo:** React Query - biblioteca que abstrai TODA essa complexidade.
