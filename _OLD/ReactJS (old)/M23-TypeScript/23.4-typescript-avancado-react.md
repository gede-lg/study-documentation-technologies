# TypeScript Avan√ßado no React

## üéØ Componentes Polim√≥rficos

```tsx
// Componente que aceita prop 'as' para mudar elemento
type AsProp<C extends React.ElementType> = {
  as?: C;
};

type PropsToOmit<C extends React.ElementType, P> = keyof (AsProp<C> & P);

type PolymorphicComponentProp<
  C extends React.ElementType,
  Props = {}
> = React.PropsWithChildren<Props & AsProp<C>> &
  Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>;

type TextProps<C extends React.ElementType> = PolymorphicComponentProp<
  C,
  { color?: string }
>;

function Text<C extends React.ElementType = 'span'>({
  as,
  color,
  children,
  ...props
}: TextProps<C>) {
  const Component = as || 'span';
  return <Component style={{ color }} {...props}>{children}</Component>;
}

// Uso
<Text>Default span</Text>
<Text as="h1">Heading</Text>
<Text as="a" href="/home">Link</Text> {/* href tipado! */}
```

## üìã Type Guards

```tsx
// Type guard para verificar tipo em runtime
function isUser(value: unknown): value is User {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'name' in value
  );
}

// Uso
function processData(data: unknown) {
  if (isUser(data)) {
    // TypeScript sabe que data √© User aqui
    console.log(data.name);
  }
}
```

## üîç Conditional Types

```tsx
// Tipo condicional baseado em prop
type ButtonProps<T extends 'button' | 'link'> = T extends 'button'
  ? { type?: 'button' | 'submit'; onClick: () => void }
  : { href: string; target?: string };

function Button<T extends 'button' | 'link'>(
  props: { variant: T } & ButtonProps<T>
) {
  if (props.variant === 'button') {
    return <button onClick={props.onClick} />;
  }
  return <a href={props.href} />;
}

// Uso - type-safe!
<Button variant="button" onClick={() => {}} /> {/* onClick required */}
<Button variant="link" href="/home" /> {/* href required */}
```

## üéØ Template Literal Types

```tsx
// Criar tipos a partir de strings
type Color = 'red' | 'blue' | 'green';
type Shade = 'light' | 'dark';

type ColorVariant = `${Color}-${Shade}`;
// 'red-light' | 'red-dark' | 'blue-light' | 'blue-dark' | ...

interface ThemeProps {
  color: ColorVariant;
}
```

## üîç Mapped Types

```tsx
// Criar tipo baseado em outro
interface User {
  id: number;
  name: string;
  email: string;
}

// Todos campos readonly
type ReadonlyUser = {
  readonly [K in keyof User]: User[K];
};

// Todos campos opcionais
type PartialUser = {
  [K in keyof User]?: User[K];
};

// Todos campos string (para erros de formul√°rio)
type UserErrors = {
  [K in keyof User]?: string;
};
```

## üéØ Infer Keyword

```tsx
// Extrair tipo de retorno de fun√ß√£o
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: 'John' };
}

type User = GetReturnType<typeof getUser>;
// { id: number; name: string; }

// Extrair tipo de array
type ArrayElement<T> = T extends (infer E)[] ? E : T;

type Numbers = number[];
type Num = ArrayElement<Numbers>; // number
```

## üîç Tipagem de API DTOs

```tsx
// Response da API
interface ApiResponse<T> {
  data: T;
  meta: {
    page: number;
    total: number;
  };
}

// DTO (Data Transfer Object)
interface UserDTO {
  id: number;
  firstName: string;
  lastName: string;
  createdAt: string; // ISO string
}

// Domain model (usado no app)
interface User {
  id: number;
  name: string; // combinado
  createdAt: Date; // parsed
}

// Transformer
function transformUser(dto: UserDTO): User {
  return {
    id: dto.id,
    name: `${dto.firstName} ${dto.lastName}`,
    createdAt: new Date(dto.createdAt)
  };
}

// Hook tipado
function useUsers() {
  const [users, setUsers] = useState<User[]>([]);

  useEffect(() => {
    fetch('/api/users')
      .then(r => r.json() as Promise<ApiResponse<UserDTO[]>>)
      .then(response => {
        const transformed = response.data.map(transformUser);
        setUsers(transformed);
      });
  }, []);

  return users;
}
```

## üöÄ Conclus√£o

TypeScript Avan√ßado no React inclui:
- **Componentes Polim√≥rficos**: Prop 'as' type-safe
- **Type Guards**: Verifica√ß√£o de tipos em runtime
- **Conditional Types**: Tipos baseados em condi√ß√µes
- **Template Literals**: Tipos de strings compostos
- **Mapped Types**: Transformar tipos existentes
- **Infer**: Extrair tipos de estruturas complexas
- **API DTOs**: Tipagem de comunica√ß√£o com backend

Ferramentas para c√≥digo TypeScript React extremamente type-safe e flex√≠vel.
