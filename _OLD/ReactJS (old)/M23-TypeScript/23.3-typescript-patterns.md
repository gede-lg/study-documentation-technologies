# TypeScript Patterns no React

## üéØ useContext Tipado

```tsx
// Criar context tipado
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Hook customizado tipado
function useTheme() {
  const context = useContext(ThemeContext);

  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }

  return context;
}

// Provider
function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const value: ThemeContextType = {
    theme,
    toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light')
  };

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}
```

## üìã useReducer Tipado

```tsx
// State
interface State {
  count: number;
  user: User | null;
}

// Actions com discriminated union
type Action =
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'SET_USER'; payload: User }
  | { type: 'CLEAR_USER' };

// Reducer
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET_USER':
      return { ...state, user: action.payload }; // payload dispon√≠vel
    case 'CLEAR_USER':
      return { ...state, user: null };
    default:
      return state;
  }
}

// Uso
function Component() {
  const [state, dispatch] = useReducer(reducer, { count: 0, user: null });

  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({
        type: 'SET_USER',
        payload: { id: 1, name: 'John' }
      })}>
        Set User
      </button>
    </div>
  );
}
```

## üîç forwardRef Tipado

```tsx
interface InputProps {
  label: string;
  error?: string;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, ...props }, ref) => {
    return (
      <div>
        <label>{label}</label>
        <input ref={ref} {...props} />
        {error && <span>{error}</span>}
      </div>
    );
  }
);

// Uso
function Parent() {
  const inputRef = useRef<HTMLInputElement>(null);

  return <Input ref={inputRef} label="Email" />;
}
```

## üéØ Higher-Order Component (HOC) Tipado

```tsx
// HOC que adiciona loading prop
function withLoading<P extends object>(
  Component: React.ComponentType<P>
) {
  return function WithLoadingComponent(
    props: P & { isLoading: boolean }
  ) {
    const { isLoading, ...restProps } = props;

    if (isLoading) {
      return <div>Loading...</div>;
    }

    return <Component {...(restProps as P)} />;
  };
}

// Uso
interface UserListProps {
  users: User[];
}

function UserList({ users }: UserListProps) {
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}

const UserListWithLoading = withLoading(UserList);

<UserListWithLoading users={users} isLoading={false} />
```

## üîç Render Props Tipado

```tsx
interface MouseTrackerProps {
  render: (position: { x: number; y: number }) => React.ReactNode;
}

function MouseTracker({ render }: MouseTrackerProps) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (e: React.MouseEvent) => {
    setPosition({ x: e.clientX, y: e.clientY });
  };

  return (
    <div onMouseMove={handleMouseMove}>
      {render(position)}
    </div>
  );
}

// Uso
<MouseTracker
  render={({ x, y }) => (
    <p>Mouse at {x}, {y}</p>
  )}
/>
```

## üöÄ Conclus√£o

TypeScript Patterns fornecem:
- **useContext**: Context tipado com erro se n√£o wrapped
- **useReducer**: Actions com discriminated unions
- **forwardRef**: Refs tipados corretamente
- **HOC**: Higher-Order Components type-safe
- **Render Props**: Props function tipadas

Patterns essenciais para c√≥digo React TypeScript robusto.
