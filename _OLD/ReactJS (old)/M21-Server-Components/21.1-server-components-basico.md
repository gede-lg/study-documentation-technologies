# Server Components B√°sico (RSC)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**React Server Components (RSC)** s√£o componentes React que **renderizam exclusivamente no servidor**, enviando apenas o **resultado** (n√£o c√≥digo JavaScript) para o cliente, permitindo **acesso direto a recursos do servidor** (banco de dados, filesystem, APIs internas) sem expor credenciais, reduzindo drasticamente **bundle JavaScript** e melhorando **performance**. Conceitualmente, representam **separa√ß√£o fundamental entre servidor e cliente** - componentes Server nunca hidratam no navegador, componentes Client funcionam como React tradicional, com composi√ß√£o livre entre ambos.

Na ess√™ncia, RSC transforma React de **biblioteca apenas client-side** para **arquitetura full-stack** - permitindo escrever componentes que rodam no servidor (zero JavaScript no cliente), componentes que rodam no cliente (interatividade), e compor ambos naturalmente na mesma √°rvore de componentes.

### Contexto Hist√≥rico e Motiva√ß√£o

Antes de RSC, React era **exclusivamente client-side** ou **SSR tradicional**:

**Modelos Anteriores**:

1. **Client-Side Rendering (CSR)**:
   - Todo c√≥digo JavaScript enviado ao cliente
   - Bundle grande, loading lento
   - Fetch de dados no cliente (waterfalls)

2. **Server-Side Rendering (SSR)**:
   - HTML gerado no servidor
   - MAS: todo JavaScript ainda vai ao cliente para hidrata√ß√£o
   - Bundle permanece grande

**Problema Fundamental**:

```jsx
// SSR tradicional - componente renderiza no servidor E cliente
function ProductPage({ id }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // Fetch no CLIENTE (mesmo com SSR)
    fetch(`/api/products/${id}`)
      .then(res => res.json())
      .then(setProduct);
  }, [id]);

  if (!product) return <Loading />;
  return <ProductDisplay product={product} />;
}

// Problemas:
// 1. JavaScript deste componente vai ao cliente (bundle++)
// 2. Fetch acontece no cliente (waterfall)
// 3. Credenciais de DB n√£o podem estar no c√≥digo (vai ao cliente)
```

**A solu√ß√£o RSC (React 18+)**:

```jsx
// Server Component - roda APENAS no servidor
async function ProductPage({ id }) {
  // Acesso direto ao banco (no servidor!)
  const product = await db.products.findById(id);

  return <ProductDisplay product={product} />;
}

// Benef√≠cios:
// 1. ZERO JavaScript deste componente no cliente
// 2. Acesso direto ao DB (sem API intermedi√°ria)
// 3. Credenciais seguras (servidor)
```

### Problema Fundamental que Resolve

**1. Bundle Size (JavaScript no Cliente)**:

```jsx
// ‚ùå Componente tradicional - JavaScript vai ao cliente
import { MarkdownParser } from 'heavy-lib'; // 500KB!

function BlogPost({ content }) {
  const html = MarkdownParser.parse(content);
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}
// Cliente baixa 500KB de heavy-lib

// ‚úÖ Server Component - processa no servidor
import { MarkdownParser } from 'heavy-lib';

async function BlogPost({ content }) {
  const html = MarkdownParser.parse(content); // Roda no servidor
  return <div dangerouslySetInnerHTML={{ __html: html }} />;
}
// Cliente recebe apenas HTML renderizado, ZERO JavaScript desta lib
```

**2. Acesso Direto a Recursos do Servidor**:

```jsx
// ‚ùå Tradicional - precisa criar API route
// app/api/posts/route.js
export async function GET() {
  const posts = await db.posts.findAll();
  return Response.json(posts);
}

// app/page.js
function PostsPage() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    fetch('/api/posts')
      .then(res => res.json())
      .then(setPosts);
  }, []);

  return posts.map(post => <Post key={post.id} data={post} />);
}

// ‚úÖ Server Component - acesso direto
async function PostsPage() {
  const posts = await db.posts.findAll(); // Direto!

  return posts.map(post => <Post key={post.id} data={post} />);
}
// Sem API route intermedi√°ria, sem fetch no cliente
```

**3. Waterfalls Eliminados**:

```jsx
// ‚ùå Tradicional - waterfall
function Page() {
  const user = useFetch('/api/user'); // Request 1
  const posts = useFetch(`/api/users/${user.id}/posts`); // Request 2 (espera 1)
  const comments = useFetch(`/api/posts/${posts[0].id}/comments`); // Request 3 (espera 2)
}

// ‚úÖ Server Component - paralelo
async function Page() {
  const user = await getUser();
  const [posts, profile] = await Promise.all([
    getPosts(user.id),
    getProfile(user.id)
  ]);

  return (
    <>
      <Posts data={posts} />
      <Profile data={profile} />
    </>
  );
}
```

### Import√¢ncia no Ecossistema

RSC s√£o **futuro do React** e **base** para:

- **Next.js App Router**: Implementa√ß√£o principal de RSC
- **Frameworks Modernos**: Remix est√° adicionando suporte
- **Zero JavaScript por Padr√£o**: Componentes s√£o Server por padr√£o
- **Performance**: Bundle reduzido, sem waterfalls
- **Developer Experience**: Acesso direto a backend sem APIs

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Server vs Client Components**: Dois tipos fundamentalmente diferentes
2. **Servidor por Padr√£o**: Componentes s√£o Server Component por padr√£o
3. **"use client" Directive**: Marcar componentes que precisam rodar no cliente
4. **Zero Bundle**: Server Components n√£o enviam JavaScript ao cliente
5. **Composi√ß√£o**: Server pode conter Client, Client pode conter Server (com limita√ß√µes)

### Pilares Fundamentais

- **Server Component**: Renderiza no servidor, zero JS no cliente
- **Client Component**: Renderiza no cliente (React tradicional)
- **"use client"**: Diretiva para marcar arquivo como Client Component
- **Async Components**: Server Components podem ser async
- **Streaming**: Resultados enviados progressivamente

---

## üß† Fundamentos Te√≥ricos

### Server Components vs Client Components

**Server Component**:

```jsx
// Arquivo: app/ServerComponent.jsx
// SEM "use client" = Server Component por padr√£o

import { db } from '@/lib/db';

async function ServerComponent() {
  const data = await db.query('SELECT * FROM products');

  return (
    <div>
      {data.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}

export default ServerComponent;
```

**Caracter√≠sticas**:
- Roda **apenas no servidor**
- Pode ser **async** (await direto no corpo)
- Acesso a **recursos do servidor** (DB, filesystem, env vars)
- **Zero JavaScript** enviado ao cliente
- **N√£o pode** usar hooks (useState, useEffect, etc)
- **N√£o pode** usar event handlers (onClick, onChange)

**Client Component**:

```jsx
// Arquivo: app/ClientComponent.jsx
'use client'; // Diretiva no topo!

import { useState } from 'react';

function ClientComponent() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count: {count}
    </button>
  );
}

export default ClientComponent;
```

**Caracter√≠sticas**:
- Roda no **servidor (SSR) E cliente (hidrata√ß√£o)**
- **N√£o pode** ser async
- **Pode** usar hooks (useState, useEffect, etc)
- **Pode** usar event handlers
- **JavaScript enviado** ao cliente (para hidrata√ß√£o)

### Como RSC Funciona Internamente

**Fluxo de Renderiza√ß√£o**:

```
1. Servidor recebe request
   ‚Üì
2. React renderiza Server Components
   - Executa queries, l√™ arquivos, etc
   - Gera payload especial (n√£o HTML)
   ‚Üì
3. Server Components retornam payload com:
   - Descri√ß√£o da UI (virtual tree)
   - Props para Client Components
   - Placeholders para Suspense
   ‚Üì
4. Cliente recebe payload
   - Reconstr√≥i √°rvore de componentes
   - Hidrata Client Components
   - Mescla com Server Components
   ‚Üì
5. UI completa renderizada
```

**Payload RSC** (formato interno):

```
// Simplificado - formato real √© bin√°rio otimizado
{
  type: 'div',
  props: {},
  children: [
    { type: 'h1', props: {}, children: 'T√≠tulo' },
    {
      type: ClientComponent,
      props: { data: {...} }, // Props serializadas
      children: []
    }
  ]
}
```

### "use client" Boundary

**Conceito**: "use client" cria **boundary** - tudo importado por Client Component vira Client Component.

```
√Årvore de componentes:

ServerComponent (server)
  ‚îú‚îÄ ServerChild (server)
  ‚îú‚îÄ ClientComponent ('use client') ‚Üê Boundary
  ‚îÇ   ‚îú‚îÄ ClientChild (client - importado por client)
  ‚îÇ   ‚îî‚îÄ AnotherClientChild (client)
  ‚îî‚îÄ AnotherServerComponent (server)
```

**Exemplo**:

```jsx
// app/page.jsx (Server Component - padr√£o)
import ClientButton from './ClientButton'; // Client
import ServerList from './ServerList'; // Server

async function Page() {
  const data = await fetchData();

  return (
    <div>
      <ServerList data={data} /> {/* Server */}
      <ClientButton /> {/* Client - boundary */}
    </div>
  );
}
```

---

## üîç An√°lise Conceitual Profunda

### Sintaxe B√°sica

#### Server Component (Padr√£o)

```jsx
// app/products/page.jsx
import { db } from '@/lib/database';

// Async! S√≥ poss√≠vel em Server Component
async function ProductsPage() {
  const products = await db.products.findAll();

  return (
    <div>
      <h1>Produtos</h1>
      {products.map(product => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <p>{product.price}</p>
        </div>
      ))}
    </div>
  );
}

export default ProductsPage;
```

#### Client Component (com "use client")

```jsx
// app/components/AddToCart.jsx
'use client'; // DEVE estar no topo do arquivo

import { useState } from 'react';

function AddToCart({ productId }) {
  const [added, setAdded] = useState(false);

  const handleClick = async () => {
    await fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId })
    });
    setAdded(true);
  };

  return (
    <button onClick={handleClick}>
      {added ? 'Adicionado!' : 'Adicionar ao Carrinho'}
    </button>
  );
}

export default AddToCart;
```

### Composi√ß√£o Server + Client

#### Server Cont√©m Client

```jsx
// Server Component
import ClientButton from './ClientButton'; // Client Component

async function ServerPage() {
  const data = await fetchData();

  return (
    <div>
      <h1>Servidor</h1>
      <p>Data: {data.value}</p>

      {/* Client Component dentro de Server */}
      <ClientButton label="Click me" />
    </div>
  );
}
```

**‚úÖ Permitido**: Server pode importar e renderizar Client Components.

#### Client Cont√©m Server (via Children)

```jsx
// Client Component
'use client';

function ClientWrapper({ children }) {
  const [show, setShow] = useState(true);

  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && children} {/* children pode ser Server Component! */}
    </div>
  );
}

// Server Component usa Client Component
async function ServerPage() {
  const data = await fetchData();

  return (
    <ClientWrapper>
      {/* Server Component como children */}
      <ServerComponent data={data} />
    </ClientWrapper>
  );
}
```

**‚úÖ Permitido**: Client pode receber Server Component via `children` ou props.

#### Client N√ÉO Pode Importar Server

```jsx
// ‚ùå ERRADO
'use client';

import ServerComponent from './ServerComponent'; // Server Component

function ClientComponent() {
  return <ServerComponent />; // ERRO!
}
```

**‚ùå Proibido**: Client Component n√£o pode **importar** Server Component diretamente.

**Solu√ß√£o**: Passar via children/props.

### Casos de Uso Pr√°ticos

#### 1. Dashboard com Dados do Servidor

```jsx
// app/dashboard/page.jsx (Server Component)
import { db } from '@/lib/db';
import Chart from './Chart'; // Client Component (interativo)

async function Dashboard() {
  // Queries paralelas
  const [sales, users, revenue] = await Promise.all([
    db.sales.count(),
    db.users.count(),
    db.revenue.sum()
  ]);

  return (
    <div className="dashboard">
      <h1>Dashboard</h1>

      {/* Dados est√°ticos - Server Component */}
      <div className="stats">
        <div>Sales: {sales}</div>
        <div>Users: {users}</div>
        <div>Revenue: ${revenue}</div>
      </div>

      {/* Gr√°fico interativo - Client Component */}
      <Chart data={{ sales, users, revenue }} />
    </div>
  );
}
```

#### 2. Blog Post com Markdown

```jsx
// app/blog/[slug]/page.jsx (Server Component)
import { readFile } from 'fs/promises';
import { markdownToHtml } from '@/lib/markdown'; // Lib pesada
import Comments from './Comments'; // Client Component

async function BlogPost({ params }) {
  // Ler arquivo do filesystem (servidor!)
  const markdown = await readFile(`./content/${params.slug}.md`, 'utf-8');

  // Processar markdown no servidor
  const html = await markdownToHtml(markdown);

  return (
    <article>
      <div dangerouslySetInnerHTML={{ __html: html }} />

      {/* Coment√°rios interativos - Client Component */}
      <Comments postSlug={params.slug} />
    </article>
  );
}
```

**Vantagem**: `markdownToHtml` e suas depend√™ncias (500KB+) **n√£o v√£o ao cliente**.

#### 3. Lista de Produtos com Filtro Interativo

```jsx
// app/products/page.jsx (Server Component)
import { db } from '@/lib/db';
import ProductFilter from './ProductFilter'; // Client

async function ProductsPage({ searchParams }) {
  // Filtro aplicado no servidor (query otimizada)
  const products = await db.products.findMany({
    where: {
      category: searchParams.category || undefined,
      price: {
        gte: searchParams.minPrice || 0,
        lte: searchParams.maxPrice || 99999
      }
    }
  });

  return (
    <div>
      {/* Filtros interativos - Client */}
      <ProductFilter />

      {/* Lista - Server */}
      <div className="grid">
        {products.map(p => (
          <ProductCard key={p.id} product={p} />
        ))}
      </div>
    </div>
  );
}
```

### Async/Await em Server Components

```jsx
// ‚úÖ Server Component - async permitido
async function ServerComponent() {
  const data1 = await fetch('/api/data1').then(r => r.json());
  const data2 = await db.query('SELECT * FROM table');
  const data3 = await readFile('./file.txt');

  return <div>{data1.value}</div>;
}

// ‚ùå Client Component - async N√ÉO permitido
'use client';

async function ClientComponent() { // ERRO!
  const data = await fetch('/api/data');
  return <div>{data}</div>;
}
```

### Streaming com Suspense

```jsx
// Server Component com Suspense
import { Suspense } from 'react';

async function FastComponent() {
  const data = await fetchFast(); // 100ms
  return <div>{data}</div>;
}

async function SlowComponent() {
  const data = await fetchSlow(); // 3s
  return <div>{data}</div>;
}

function Page() {
  return (
    <div>
      <FastComponent /> {/* Renderiza imediatamente */}

      <Suspense fallback={<Loading />}>
        <SlowComponent /> {/* Stream depois */}
      </Suspense>
    </div>
  );
}
```

**Fluxo**:
1. Cliente recebe HTML com `<FastComponent />` e `<Loading />`
2. 3s depois, `<SlowComponent />` termina e "stream" para cliente
3. `<Loading />` substitu√≠do por `<SlowComponent />`

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Server Components

#### ‚úÖ Use Server Components Para:

1. **Data Fetching**: Queries de banco, leitura de arquivos
2. **Acesso a Recursos Backend**: Env vars, credenciais
3. **Processamento Pesado**: Parsing, transforma√ß√µes que podem rodar no servidor
4. **SEO**: Conte√∫do que deve estar no HTML inicial
5. **Reduzir Bundle**: Libs pesadas que podem rodar no servidor

#### ‚úÖ Use Client Components Para:

1. **Interatividade**: Clicks, hovers, inputs
2. **Hooks**: useState, useEffect, useContext
3. **Browser APIs**: localStorage, window, document
4. **Event Handlers**: onClick, onChange, onSubmit
5. **Real-time**: WebSockets, subscriptions

### Decis√£o: Server ou Client?

```
Precisa de interatividade? (useState, onClick)
  ‚îî‚îÄ SIM ‚Üí Client Component ('use client')
  ‚îî‚îÄ N√ÉO
      ‚îî‚îÄ Precisa acessar backend? (DB, filesystem)
          ‚îî‚îÄ SIM ‚Üí Server Component (padr√£o)
          ‚îî‚îÄ N√ÉO ‚Üí Server Component (menor bundle)
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes de Server Components

#### 1. N√£o Podem Usar Hooks

```jsx
// ‚ùå ERRADO - Server Component n√£o pode usar hooks
async function ServerComponent() {
  const [state, setState] = useState(0); // ERRO!

  useEffect(() => {}, []); // ERRO!

  return <div>...</div>;
}
```

#### 2. N√£o Podem Usar Event Handlers

```jsx
// ‚ùå ERRADO - Server Component n√£o tem eventos
async function ServerComponent() {
  const handleClick = () => console.log('click'); // Nunca executar√°!

  return <button onClick={handleClick}>Click</button>; // ERRO!
}
```

#### 3. Props Devem Ser Serializ√°veis

```jsx
// ‚ùå ERRADO - fun√ß√£o n√£o √© serializ√°vel
<ClientComponent onAction={() => console.log('action')} />

// ‚úÖ CORRETO - dados primitivos/objetos
<ClientComponent data={{ name: 'John', age: 30 }} />
```

### Client Component Restrictions

#### 1. N√£o Podem Importar Server Components

```jsx
// ‚ùå ERRADO
'use client';

import ServerComponent from './ServerComponent';

function ClientComponent() {
  return <ServerComponent />; // ERRO!
}

// ‚úÖ CORRETO - receber via props
'use client';

function ClientComponent({ serverContent }) {
  return <div>{serverContent}</div>;
}

// Server Component passa Server Component como children
<ClientComponent serverContent={<ServerComponent />} />
```

---

## üîó Interconex√µes Conceituais

### RSC + Suspense

```jsx
<Suspense fallback={<Loading />}>
  <ServerComponent /> {/* Suspende at√© data fetch completar */}
</Suspense>
```

### RSC + Error Boundaries

```jsx
<ErrorBoundary fallback={<Error />}>
  <ServerComponent /> {/* Erros no servidor capturados */}
</ErrorBoundary>
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Server Components B√°sico prepara para:

1. **Server Components Avan√ßado** (21.2): Server Actions, streaming, composi√ß√£o complexa
2. **Patterns com RSC** (21.3): Data fetching, caching, revalidation
3. **Next.js App Router** (M√≥dulo 28): Implementa√ß√£o completa de RSC

---

## üéØ Conclus√£o

React Server Components s√£o **mudan√ßa paradigm√°tica**:

**Conceito Central**: Componentes que rodam **apenas no servidor**, zero JavaScript no cliente.

**Principais Benef√≠cios**:
- Bundle JavaScript reduzido drasticamente
- Acesso direto a backend sem APIs
- Sem waterfalls de dados
- SEO melhor (conte√∫do no HTML)

**Server vs Client**:
- **Server**: Padr√£o, async, acesso backend, zero JS no cliente
- **Client**: "use client", hooks, eventos, JavaScript no cliente

**Composi√ß√£o**:
- Server pode conter Client ‚úÖ
- Client pode conter Server (via children) ‚úÖ
- Client n√£o pode importar Server ‚ùå

**Quando Usar**:
- **Server**: Data fetching, processamento pesado, backend access
- **Client**: Interatividade, hooks, browser APIs

RSC transforma React de **biblioteca client-side** para **arquitetura full-stack** - permitindo escrever componentes que aproveitam melhor servidor e cliente, reduzindo bundle e melhorando performance. Base para o futuro do React e frameworks modernos.
