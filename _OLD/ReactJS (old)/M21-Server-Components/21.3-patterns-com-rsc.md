# Patterns com RSC (React Server Components)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Patterns com RSC** s√£o **padr√µes arquiteturais** e **best practices** para data fetching, caching, revalidation, e composi√ß√£o de componentes em aplica√ß√µes React Server Components, incluindo **parallel data fetching**, **sequential data fetching**, **streaming patterns**, **cache strategies**, **static vs dynamic rendering**, e **patterns de composi√ß√£o** Client/Server. Conceitualmente, representam **arquitetura de dados otimizada** - aproveitando servidor para fetches eficientes, cache para performance, e composi√ß√£o inteligente para UX responsiva com bundle m√≠nimo.

Na ess√™ncia, Patterns com RSC tratam de **como organizar data fetching e rendering** em aplica√ß√µes full-stack React - escolher entre static/dynamic, paralelo/sequencial, cache/revalidate, Server/Client para cada cen√°rio espec√≠fico.

### Contexto Hist√≥rico e Motiva√ß√£o

Aplica√ß√µes tradicionais React tinham **padr√µes problem√°ticos**:

**Problemas Comuns**:

1. **Request Waterfalls**: Componente pai fetch ‚Üí renderiza ‚Üí filho fetch ‚Üí renderiza...
2. **Overfetching**: Buscar dados que n√£o ser√£o usados
3. **Underfetching**: M√∫ltiplos fetches quando 1 bastaria
4. **Cache Manual**: Gerenciar cache manualmente (React Query, SWR)
5. **Loading States**: Gerenciar loading/error em cada componente

**RSC Patterns resolvem**:

```jsx
// ‚ùå Waterfall tradicional
function Page() {
  const user = useFetch('/api/user'); // Request 1
  if (!user) return <Loading />;

  return <Posts userId={user.id} />; // Espera user
}

function Posts({ userId }) {
  const posts = useFetch(`/api/users/${userId}/posts`); // Request 2
  if (!posts) return <Loading />;

  return posts.map(p => <Post id={p.id} />);
}

function Post({ id }) {
  const post = useFetch(`/api/posts/${id}`); // Request 3 (para cada post!)
  // ...
}
// 1 + 1 + N requests sequenciais!

// ‚úÖ Parallel fetching com RSC
async function Page() {
  // Todos fetches paralelos
  const [user, posts] = await Promise.all([
    getUser(),
    getPosts()
  ]);

  return (
    <>
      <UserInfo user={user} />
      <PostsList posts={posts} />
    </>
  );
}
// 2 requests paralelos, total
```

### Problema Fundamental que Resolve

**1. Elimina√ß√£o de Waterfalls**:

```jsx
// Server Component - fetches paralelos
async function Dashboard() {
  const [sales, users, revenue] = await Promise.all([
    db.sales.count(),
    db.users.count(),
    db.revenue.sum()
  ]);

  return (
    <div>
      <SalesWidget data={sales} />
      <UsersWidget data={users} />
      <RevenueWidget data={revenue} />
    </div>
  );
}
```

**2. Cache Autom√°tico com Revalidation**:

```jsx
// Fetch com cache
async function getData() {
  const res = await fetch('https://api.com/data', {
    next: {
      revalidate: 3600 // Cache por 1 hora
    }
  });

  return res.json();
}

// Ou cache infinito (static)
const res = await fetch('...', { cache: 'force-cache' });

// Ou sem cache (dynamic)
const res = await fetch('...', { cache: 'no-store' });
```

**3. Static vs Dynamic Rendering**:

```jsx
// Static - renderiza em build time
async function StaticPage() {
  const posts = await fetch('/api/posts', { cache: 'force-cache' });
  return <PostsList posts={posts} />; // HTML gerado em build
}

// Dynamic - renderiza em request time
async function DynamicPage() {
  const user = await getCurrentUser(); // Depende de request
  return <Profile user={user} />; // HTML gerado por request
}
```

### Import√¢ncia no Ecossistema

Patterns com RSC s√£o **essenciais** para:

- **Performance**: Cache otimizado, fetches paralelos
- **SEO**: Static rendering para conte√∫do p√∫blico
- **Personalization**: Dynamic rendering para conte√∫do personalizado
- **UX**: Streaming para carregamento progressivo
- **Scalability**: Cache reduz carga no servidor

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Parallel vs Sequential Fetching**: Quando fetch em paralelo vs sequencial
2. **Cache Strategies**: force-cache, no-store, revalidate
3. **Static vs Dynamic Rendering**: Quando pr√©-renderizar vs renderizar por request
4. **Streaming Patterns**: Suspense boundaries para UX progressiva
5. **Composition Patterns**: Organizar Server/Client components

### Pilares Fundamentais

- **Promise.all()**: Fetches paralelos
- **fetch() Options**: `cache`, `next.revalidate`, `next.tags`
- **Static Generation**: Build-time rendering
- **Dynamic Rendering**: Request-time rendering
- **Incremental Static Regeneration (ISR)**: Static + revalidation

---

## üß† Fundamentos Te√≥ricos

### Parallel vs Sequential Data Fetching

**Parallel (Recomendado)**:

```jsx
async function Page() {
  // Fetches iniciam simultaneamente
  const dataPromise1 = fetch('/api/data1');
  const dataPromise2 = fetch('/api/data2');
  const dataPromise3 = fetch('/api/data3');

  // Aguarda todos completarem
  const [data1, data2, data3] = await Promise.all([
    dataPromise1.then(r => r.json()),
    dataPromise2.then(r => r.json()),
    dataPromise3.then(r => r.json())
  ]);

  return (
    <>
      <Widget1 data={data1} />
      <Widget2 data={data2} />
      <Widget3 data={data3} />
    </>
  );
}
```

**Sequential (Quando Necess√°rio)**:

```jsx
async function Page() {
  // Fetch 1 precisa completar antes de fetch 2
  const user = await getUser();

  // User ID necess√°rio para pr√≥ximo fetch
  const posts = await getPosts(user.id);

  return (
    <>
      <UserInfo user={user} />
      <PostsList posts={posts} />
    </>
  );
}
```

**Decis√£o**:
- **Parallel**: Fetches independentes (n√£o dependem um do outro)
- **Sequential**: Fetches dependentes (precisa resultado anterior)

### Cache Strategies

#### force-cache (Static)

```jsx
// Cache permanente (at√© rebuild)
const data = await fetch('/api/data', {
  cache: 'force-cache' // Padr√£o
});

// Equivalente a n√£o especificar cache
const data = await fetch('/api/data');
```

**Quando Usar**: Dados que nunca mudam (ou raramente).

#### no-store (Dynamic)

```jsx
// Sem cache, fetch toda request
const data = await fetch('/api/data', {
  cache: 'no-store'
});
```

**Quando Usar**: Dados personalizados por usu√°rio, real-time.

#### Revalidate (ISR)

```jsx
// Cache por X segundos, depois revalida
const data = await fetch('/api/data', {
  next: { revalidate: 60 } // 60 segundos
});
```

**Comportamento**:
1. Request 1: Fetch dados, cache por 60s
2. Requests dentro de 60s: Retorna cache
3. Request ap√≥s 60s: Retorna cache stale, trigger revalidation em background
4. Request seguinte: Retorna dados frescos

**Quando Usar**: Dados que mudam periodicamente (posts, produtos).

#### Tag-based Revalidation

```jsx
// Fetch com tag
const data = await fetch('/api/posts', {
  next: { tags: ['posts'] }
});

// Server Action invalida tag
async function createPost(formData) {
  'use server';

  await db.posts.create({ ... });

  revalidateTag('posts'); // Invalida TODOS fetches com tag 'posts'
}
```

---

## üîç An√°lise Conceitual Profunda

### Pattern: Parallel Data Fetching

```jsx
// app/dashboard/page.jsx
async function Dashboard() {
  // Iniciar fetches simultaneamente
  const salesPromise = db.sales.aggregate();
  const usersPromise = db.users.count();
  const revenuePromise = db.revenue.sum();
  const ordersPromise = db.orders.findRecent();

  // Aguardar todos
  const [sales, users, revenue, orders] = await Promise.all([
    salesPromise,
    usersPromise,
    revenuePromise,
    ordersPromise
  ]);

  return (
    <div className="dashboard">
      <StatsBar sales={sales} users={users} revenue={revenue} />
      <RecentOrders orders={orders} />
    </div>
  );
}
```

**Vantagem**: 4 queries executam em paralelo ao inv√©s de sequencialmente.

### Pattern: Sequential Data Fetching

```jsx
async function UserProfile({ username }) {
  // Fetch 1: Buscar usu√°rio
  const user = await db.users.findByUsername(username);

  if (!user) {
    notFound(); // Next.js helper
  }

  // Fetch 2: Buscar posts do usu√°rio (precisa user.id)
  const posts = await db.posts.findByUserId(user.id);

  // Fetch 3: Buscar followers (precisa user.id)
  const followers = await db.followers.findByUserId(user.id);

  return (
    <>
      <UserInfo user={user} />
      <UserPosts posts={posts} />
      <UserFollowers followers={followers} />
    </>
  );
}
```

**Sequencial Necess√°rio**: Posts e followers precisam de `user.id`.

**Otimiza√ß√£o Poss√≠vel**:

```jsx
const user = await db.users.findByUsername(username);

// Posts e followers podem ser paralelos
const [posts, followers] = await Promise.all([
  db.posts.findByUserId(user.id),
  db.followers.findByUserId(user.id)
]);
```

### Pattern: Streaming com Suspense

```jsx
async function Dashboard() {
  return (
    <div>
      {/* Renderiza imediatamente */}
      <Header />

      <div className="grid">
        {/* Widget r√°pido - sem Suspense */}
        <QuickWidget />

        {/* Widgets lentos - stream separadamente */}
        <Suspense fallback={<WidgetSkeleton />}>
          <SlowWidget1 />
        </Suspense>

        <Suspense fallback={<WidgetSkeleton />}>
          <SlowWidget2 />
        </Suspense>

        <Suspense fallback={<WidgetSkeleton />}>
          <SlowWidget3 />
        </Suspense>
      </div>
    </div>
  );
}

async function SlowWidget1() {
  const data = await fetch('/api/slow1').then(r => r.json());
  await new Promise(r => setTimeout(r, 2000)); // Simular lentid√£o
  return <div>{data.value}</div>;
}
```

**UX**: Usu√°rio v√™ Header e QuickWidget imediatamente, SlowWidgets "popam" quando prontos.

### Pattern: Static + Dynamic Mixing

```jsx
// Static parte
async function StaticContent() {
  const posts = await fetch('/api/posts', {
    cache: 'force-cache' // Static
  }).then(r => r.json());

  return <PostsList posts={posts} />;
}

// Dynamic parte
async function DynamicContent() {
  const user = await getCurrentUser(); // Request-specific

  return <UserGreeting name={user.name} />;
}

// P√°gina combina ambos
function Page() {
  return (
    <>
      <StaticContent /> {/* Pr√©-renderizado */}
      <DynamicContent /> {/* Renderizado por request */}
    </>
  );
}
```

**Conceito**: Parte da p√°gina static (cache), parte dynamic (personalizada).

### Pattern: Request Deduplication

```jsx
// getData √© chamado 3 vezes, MAS fetch acontece apenas 1 vez!
async function getData() {
  const res = await fetch('/api/data');
  return res.json();
}

async function Component1() {
  const data = await getData(); // Fetch 1
  return <div>{data.value}</div>;
}

async function Component2() {
  const data = await getData(); // Deduplicated (usa resultado do fetch 1)
  return <div>{data.value}</div>;
}

async function Page() {
  return (
    <>
      <Component1 />
      <Component2 />
      {await getData()} {/* Tamb√©m deduplicated */}
    </>
  );
}
```

**Conceito**: React deduplica fetches id√™nticos automaticamente (durante mesmo render).

### Pattern: Preloading Data

```jsx
// Iniciar fetch cedo, mesmo antes de renderizar
async function Page() {
  // Preload - fetch inicia imediatamente
  const dataPromise = getData();

  return (
    <div>
      <Header />

      <Suspense fallback={<Loading />}>
        <DataComponent dataPromise={dataPromise} />
      </Suspense>
    </div>
  );
}

async function DataComponent({ dataPromise }) {
  const data = await dataPromise; // Aguarda fetch j√° iniciado
  return <div>{data.value}</div>;
}
```

**Vantagem**: Fetch inicia antes de Suspense, reduzindo tempo de loading.

### Pattern: Error Handling

```jsx
// Server Component com tratamento de erro
async function DataComponent() {
  try {
    const data = await fetch('/api/data').then(r => {
      if (!r.ok) throw new Error('Fetch failed');
      return r.json();
    });

    return <div>{data.value}</div>;
  } catch (error) {
    return <ErrorDisplay message={error.message} />;
  }
}

// Ou com Error Boundary
<ErrorBoundary fallback={<ErrorUI />}>
  <DataComponent />
</ErrorBoundary>
```

### Pattern: Cache Tags por Feature

```jsx
// Organizar por features
const posts = await fetch('/api/posts', {
  next: { tags: ['posts', 'blog'] }
});

const comments = await fetch('/api/comments', {
  next: { tags: ['comments', 'blog'] }
});

// Invalidar apenas posts
revalidateTag('posts');

// Invalidar tudo relacionado a blog
revalidateTag('blog');
```

### Pattern: Incremental Static Regeneration (ISR)

```jsx
// P√°gina est√°tica que revalida a cada 1 hora
async function BlogPost({ params }) {
  const post = await fetch(`/api/posts/${params.slug}`, {
    next: { revalidate: 3600 } // 1 hora
  }).then(r => r.json());

  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  );
}
```

**Comportamento**:
1. Build: Gera HTML est√°tico para todas rotas conhecidas
2. Request (dentro de 1h): Serve HTML cached
3. Request (ap√≥s 1h): Serve HTML stale, revalida em background
4. Pr√≥xima request: HTML atualizado

### Pattern: On-Demand Revalidation

```jsx
// Server Action para revalidar sob demanda
async function publishPost(formData) {
  'use server';

  const slug = formData.get('slug');

  await db.posts.update(slug, { published: true });

  // Revalidar rota espec√≠fica
  revalidatePath(`/blog/${slug}`);

  // Revalidar lista de posts
  revalidatePath('/blog');
}
```

### Pattern: Composition - Server com Client Islands

```jsx
// app/products/[id]/page.jsx (Server Component)
async function ProductPage({ params }) {
  const product = await db.products.findById(params.id);
  const reviews = await db.reviews.findByProduct(params.id);
  const relatedProducts = await db.products.findRelated(product.category);

  return (
    <div>
      {/* Server - est√°tico */}
      <ProductInfo product={product} />

      {/* Client island - interativo */}
      <AddToCartButton productId={product.id} />

      {/* Server - est√°tico */}
      <Reviews data={reviews} />

      {/* Client island - form interativo */}
      <ReviewForm productId={product.id} />

      {/* Server - est√°tico */}
      <RelatedProducts products={relatedProducts} />
    </div>
  );
}
```

**Conceito**: Maioria Server (zero JS), Client apenas onde necess√°rio.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Pattern

#### Parallel Fetching

**Use Quando**: M√∫ltiplos fetches independentes.

```jsx
// ‚úÖ Paralelo - independentes
const [users, posts, comments] = await Promise.all([
  getUsers(),
  getPosts(),
  getComments()
]);
```

#### Sequential Fetching

**Use Quando**: Fetch depende de resultado anterior.

```jsx
// ‚úÖ Sequencial - dependente
const user = await getUser();
const posts = await getPosts(user.id);
```

#### Static Rendering (cache: 'force-cache')

**Use Quando**:
- Conte√∫do p√∫blico (blog posts, docs)
- Dados que n√£o mudam (ou raramente)
- SEO cr√≠tico

#### Dynamic Rendering (cache: 'no-store')

**Use Quando**:
- Conte√∫do personalizado por usu√°rio
- Dados real-time
- Depende de cookies/headers

#### ISR (revalidate: seconds)

**Use Quando**:
- Conte√∫do que muda periodicamente
- Quer static performance + dados frescos
- Ex: produtos, posts de blog

#### Streaming (Suspense)

**Use Quando**:
- Componentes lentos n√£o devem bloquear r√°pidos
- Quer mostrar conte√∫do progressivamente
- Dashboard com m√∫ltiplos widgets

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Cuidados com Caching

#### 1. Cache pode Ficar Stale

```jsx
// Post atualizado, mas cache ainda tem vers√£o antiga
const post = await fetch('/api/posts/1', {
  next: { revalidate: 3600 }
});

// Solu√ß√£o: revalidar ap√≥s muta√ß√£o
async function updatePost(id, data) {
  'use server';

  await db.posts.update(id, data);
  revalidatePath(`/posts/${id}`);
}
```

#### 2. Deduplication pode Causar Surpresa

```jsx
// Fetch 1
const data1 = await fetch('/api/data'); // Fetch real

// Fetch 2 (dentro do mesmo render)
const data2 = await fetch('/api/data'); // Deduplicated!

// data1 === data2 (mesma inst√¢ncia)
```

**Cuidado**: Se API retorna dados diferentes por request, deduplication pode ser problem√°tico.

#### 3. Dynamic Rendering Autom√°tico

```jsx
// Qualquer uso de cookies/headers torna rota dynamic
function Page() {
  const cookieStore = cookies(); // Dynamic!
  const headersList = headers(); // Dynamic!

  // Toda p√°gina agora √© dynamic (mesmo com fetches cached)
}
```

---

## üîó Interconex√µes Conceituais

### Patterns + Server Actions

```jsx
// Pattern: Mutation + Revalidation
async function createPost(formData) {
  'use server';

  const post = await db.posts.create({ ... });

  // Revalidar m√∫ltiplas rotas
  revalidatePath('/posts');
  revalidatePath('/');
  revalidateTag('posts');

  redirect(`/posts/${post.id}`);
}
```

### Patterns + Suspense

```jsx
// Pattern: Parallel fetches + Suspense
async function Page() {
  return (
    <div className="grid">
      <Suspense fallback={<Skeleton />}>
        <Widget1 />
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <Widget2 />
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <Widget3 />
      </Suspense>
    </div>
  );
}

async function Widget1() {
  const data = await fetch('/api/widget1').then(r => r.json());
  return <div>{data.value}</div>;
}
// Widgets carregam em paralelo, cada com seu loading state
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Patterns com RSC preparam para:

1. **Next.js App Router** (M√≥dulo 28): Implementa√ß√£o completa destes patterns
2. **Data Fetching** (M√≥dulo 12): React Query, SWR com RSC
3. **Performance** (M√≥dulo 14): Otimiza√ß√µes de cache e rendering

---

## üéØ Conclus√£o

Patterns com RSC s√£o **essenciais para arquitetura otimizada**:

**Principais Patterns**:
- **Parallel Fetching**: `Promise.all()` para fetches independentes
- **Sequential Fetching**: Await sequencial para fetches dependentes
- **Cache Strategies**: force-cache (static), no-store (dynamic), revalidate (ISR)
- **Streaming**: Suspense para UX progressiva
- **Composition**: Server (maioria) + Client islands (interatividade)

**Cache Options**:
- `cache: 'force-cache'`: Static (padr√£o)
- `cache: 'no-store'`: Dynamic
- `next: { revalidate: seconds }`: ISR
- `next: { tags: [...] }`: Tag-based revalidation

**Quando Usar**:
- **Static**: Conte√∫do p√∫blico, SEO
- **Dynamic**: Personalizado, real-time
- **ISR**: Balance entre static performance e dados frescos
- **Streaming**: Componentes lentos n√£o bloqueiam r√°pidos

**Revalidation**:
- `revalidatePath()`: Invalidar rota
- `revalidateTag()`: Invalidar por tag
- On-demand: Ap√≥s muta√ß√µes

Patterns com RSC transformam data fetching de **manual e propenso a erros** para **declarativo e otimizado** - essenciais para construir aplica√ß√µes perform√°ticas com React Server Components. Dominar estes patterns √© chave para aproveitar todo potencial de RSC.
