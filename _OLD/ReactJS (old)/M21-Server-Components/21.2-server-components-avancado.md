# Server Components Avan√ßado (RSC)

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Server Components Avan√ßado** refere-se a t√©cnicas sofisticadas de RSC incluindo **Server Actions** (muta√ß√µes executadas no servidor via "use server"), **streaming progressivo** com m√∫ltiplos Suspense boundaries, **composi√ß√£o complexa** entre Server/Client components, **revalidation strategies**, e **otimiza√ß√µes de performance** (deduplication, caching). Conceitualmente, representa **arquitetura full-stack completa** - n√£o apenas ler dados no servidor, mas tamb√©m **mutar dados**, **gerenciar formul√°rios**, **invalidar cache**, tudo integrado na √°rvore de componentes React de forma declarativa.

Na ess√™ncia, Server Components Avan√ßado transforma React de **UI library** para **framework full-stack** - onde formul√°rios podem submeter diretamente para servidor sem API routes, cache √© gerenciado automaticamente, e streaming permite UX progressiva sofisticada.

### Contexto Hist√≥rico e Motiva√ß√£o

RSC B√°sico (React 18) permitiu **leitura** de dados no servidor. React 19 e frameworks (Next.js 13+) adicionaram **Server Actions** para muta√ß√µes:

**Problema antes de Server Actions**:

```jsx
// Server Component l√™ dados
async function TodoList() {
  const todos = await db.todos.findAll();

  return todos.map(todo => <Todo key={todo.id} data={todo} />);
}

// MAS: adicionar todo precisa API route separada
// app/api/todos/route.js
export async function POST(request) {
  const data = await request.json();
  await db.todos.create(data);
  return Response.json({ success: true });
}

// E Client Component para chamar API
'use client';

function AddTodoForm() {
  const handleSubmit = async (e) => {
    e.preventDefault();
    await fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify({ text: e.target.text.value })
    });
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

**Com Server Actions** (React 19):

```jsx
// Server Action - muta√ß√£o no servidor
async function addTodo(formData) {
  'use server'; // Marca como Server Action

  const text = formData.get('text');
  await db.todos.create({ text });
  revalidatePath('/todos'); // Atualiza cache
}

// Formul√°rio Server Component
async function TodoPage() {
  const todos = await db.todos.findAll();

  return (
    <>
      {/* Formul√°rio submete direto para Server Action */}
      <form action={addTodo}>
        <input name="text" />
        <button type="submit">Add</button>
      </form>

      {todos.map(todo => <Todo key={todo.id} data={todo} />)}
    </>
  );
}
// Sem API route, sem Client Component, sem fetch manual!
```

### Problema Fundamental que Resolve

**1. Elimina√ß√£o de API Routes para Muta√ß√µes**:

```jsx
// ‚ùå Antes: API route + Client Component
// route.js
export async function POST(req) { await db.create(...) }

// Component
'use client';
function Form() {
  const submit = async () => {
    await fetch('/api/...', { method: 'POST', ... });
  };
}

// ‚úÖ Agora: Server Action direto
async function addItem(formData) {
  'use server';
  await db.create({ name: formData.get('name') });
}

<form action={addItem}>...</form>
```

**2. Progressive Enhancement (Funciona sem JavaScript)**:

```jsx
// Server Action funciona mesmo se JavaScript falhar!
<form action={serverAction}>
  <input name="email" required />
  <button>Subscribe</button>
</form>

// Se JS desabilitado:
// - Formul√°rio ainda submete (POST request)
// - Server Action processa
// - P√°gina recarrega com novo estado
```

**3. Invalida√ß√£o de Cache Declarativa**:

```jsx
async function deletePost(id) {
  'use server';

  await db.posts.delete(id);

  // Invalidar cache de rotas espec√≠ficas
  revalidatePath('/posts');
  revalidatePath(`/posts/${id}`);

  // Ou invalidar por tag
  revalidateTag('posts');
}
```

### Import√¢ncia no Ecossistema

Server Components Avan√ßado s√£o **essenciais** para:

- **Full-Stack React**: Ler e escrever dados sem sair do React
- **Frameworks**: Next.js App Router baseia-se extensivamente
- **Progressive Enhancement**: Apps funcionam sem JavaScript
- **Performance**: Streaming, caching autom√°tico, deduplication
- **Developer Experience**: Menos boilerplate (sem API routes)

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Server Actions**: Fun√ß√µes async marcadas com "use server" para muta√ß√µes
2. **Form Actions**: Formul√°rios que submetem para Server Actions
3. **Revalidation**: Invalidar cache de rotas/dados ap√≥s muta√ß√µes
4. **Streaming Avan√ßado**: M√∫ltiplos Suspense para UX progressiva
5. **Composi√ß√£o Complexa**: Patterns para Server/Client interaction

### Pilares Fundamentais

- **"use server"**: Diretiva para marcar Server Actions
- **action Prop**: `<form action={serverAction}>`
- **revalidatePath()**: Invalidar cache de rota
- **revalidateTag()**: Invalidar cache por tag
- **Progressive Enhancement**: Funciona sem JS no cliente

---

## üß† Fundamentos Te√≥ricos

### Server Actions: Como Funcionam

**Conceito**: Server Action √© fun√ß√£o async que **roda no servidor** mas pode ser **chamada do cliente**.

**Processo Interno**:

```
1. Definir Server Action com "use server"
   ‚Üì
2. Next.js gera endpoint autom√°tico
   ‚Üì
3. Formul√°rio/cliente chama action
   ‚Üì
4. Request POST enviado ao endpoint
   ‚Üì
5. Servidor executa fun√ß√£o
   ‚Üì
6. Resultado retornado ao cliente
   ‚Üì
7. React re-renderiza com novos dados
```

**Exemplo Conceitual**:

```jsx
// Desenvolvedor escreve:
async function addTodo(formData) {
  'use server';
  const text = formData.get('text');
  await db.todos.create({ text });
}

// Framework gera automaticamente:
// POST /actions/addTodo (endpoint oculto)
// Serializa formData, envia ao servidor, executa fun√ß√£o
```

### "use server" Placement

#### Inline Server Action

```jsx
// Server Component
async function Page() {
  // Server Action definida inline
  async function createItem(formData) {
    'use server'; // DENTRO da fun√ß√£o

    const name = formData.get('name');
    await db.items.create({ name });
    revalidatePath('/items');
  }

  return (
    <form action={createItem}>
      <input name="name" />
      <button>Create</button>
    </form>
  );
}
```

#### Server Actions Module

```jsx
// app/actions.js
'use server'; // NO TOPO do arquivo - todas fun√ß√µes s√£o Server Actions

export async function createItem(formData) {
  const name = formData.get('name');
  await db.items.create({ name });
  revalidatePath('/items');
}

export async function deleteItem(id) {
  await db.items.delete(id);
  revalidatePath('/items');
}

// app/page.jsx
import { createItem } from './actions';

<form action={createItem}>...</form>
```

**Diferen√ßa**:
- **Inline**: "use server" dentro da fun√ß√£o (apenas ela √© Server Action)
- **Module**: "use server" no topo (todas fun√ß√µes exportadas s√£o Server Actions)

---

## üîç An√°lise Conceitual Profunda

### Server Actions: Sintaxe e Uso

#### Form Action B√°sico

```jsx
// app/todos/page.jsx
import { revalidatePath } from 'next/cache';
import { db } from '@/lib/db';

async function TodosPage() {
  const todos = await db.todos.findAll();

  async function addTodo(formData) {
    'use server';

    const text = formData.get('text');

    if (!text) {
      throw new Error('Text is required');
    }

    await db.todos.create({
      text,
      completed: false
    });

    revalidatePath('/todos');
  }

  return (
    <div>
      <form action={addTodo}>
        <input name="text" placeholder="New todo" required />
        <button type="submit">Add</button>
      </form>

      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

**An√°lise**:
- Formul√°rio submete diretamente para `addTodo` (Server Action)
- Sem `onSubmit`, sem `e.preventDefault()`, sem `fetch()`
- `revalidatePath('/todos')` invalida cache - pr√≥xima visita refetch dados

#### Server Action com Redirecionamento

```jsx
import { redirect } from 'next/navigation';

async function createPost(formData) {
  'use server';

  const title = formData.get('title');
  const content = formData.get('content');

  const post = await db.posts.create({ title, content });

  revalidatePath('/posts');
  redirect(`/posts/${post.id}`); // Redirecionar ap√≥s sucesso
}

<form action={createPost}>
  <input name="title" />
  <textarea name="content" />
  <button>Create Post</button>
</form>
```

#### Server Action com Valida√ß√£o

```jsx
import { z } from 'zod';

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

async function register(formData) {
  'use server';

  // Validar dados
  const validated = schema.safeParse({
    email: formData.get('email'),
    password: formData.get('password')
  });

  if (!validated.success) {
    return { error: validated.error.flatten() };
  }

  // Criar usu√°rio
  await db.users.create(validated.data);

  redirect('/dashboard');
}
```

### Server Actions em Client Components

```jsx
// actions.js
'use server';

export async function updateProfile(formData) {
  const name = formData.get('name');
  await db.users.update({ name });
  revalidatePath('/profile');
}

// Profile.jsx (Client Component)
'use client';

import { updateProfile } from './actions';
import { useState } from 'react';

function Profile() {
  const [pending, setPending] = useState(false);

  const handleSubmit = async (formData) => {
    setPending(true);
    await updateProfile(formData);
    setPending(false);
  };

  return (
    <form action={handleSubmit}>
      <input name="name" />
      <button disabled={pending}>
        {pending ? 'Saving...' : 'Save'}
      </button>
    </form>
  );
}
```

**Conceito**: Client Component pode **importar** e **chamar** Server Actions.

### Revalidation Strategies

#### revalidatePath

```jsx
async function deletePost(id) {
  'use server';

  await db.posts.delete(id);

  // Invalidar rota espec√≠fica
  revalidatePath('/posts');

  // Invalidar rota din√¢mica
  revalidatePath(`/posts/${id}`);

  // Invalidar layout (afeta todas subrotas)
  revalidatePath('/posts', 'layout');
}
```

#### revalidateTag

```jsx
// Fetch com tag
const posts = await fetch('https://api.com/posts', {
  next: { tags: ['posts'] }
}).then(r => r.json());

// Server Action invalida por tag
async function createPost(formData) {
  'use server';

  await db.posts.create({ ... });

  // Invalida TODAS requests com tag 'posts'
  revalidateTag('posts');
}
```

**Vantagem**: Tag permite invalidar m√∫ltiplas rotas/fetches de uma vez.

### Streaming Avan√ßado com Suspense

#### Streaming Progressivo

```jsx
async function Dashboard() {
  return (
    <div>
      {/* Renderiza imediatamente */}
      <Header />

      {/* Stream independentes */}
      <div className="grid">
        <Suspense fallback={<WidgetSkeleton />}>
          <SalesWidget /> {/* Stream 1 */}
        </Suspense>

        <Suspense fallback={<WidgetSkeleton />}>
          <UsersWidget /> {/* Stream 2 */}
        </Suspense>

        <Suspense fallback={<WidgetSkeleton />}>
          <RevenueWidget /> {/* Stream 3 */}
        </Suspense>
      </div>

      {/* Stream grande */}
      <Suspense fallback={<TableSkeleton />}>
        <TransactionsTable /> {/* Stream 4 */}
      </Suspense>
    </div>
  );
}

async function SalesWidget() {
  // Query lenta (1s)
  const sales = await db.sales.count();
  return <div>Sales: {sales}</div>;
}

async function UsersWidget() {
  // Query r√°pida (100ms)
  const users = await db.users.count();
  return <div>Users: {users}</div>;
}
```

**Fluxo**:
1. Cliente recebe HTML com `<Header />` e 4 skeletons imediatamente
2. `UsersWidget` termina (100ms) ‚Üí stream widget
3. `SalesWidget` termina (1s) ‚Üí stream widget
4. Outros widgets terminam ‚Üí stream conforme prontos

#### Nested Suspense

```jsx
async function Page() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <PageContent />
    </Suspense>
  );
}

async function PageContent() {
  const data = await fetchPageData();

  return (
    <div>
      <h1>{data.title}</h1>

      {/* Suspense aninhado */}
      <Suspense fallback={<CommentsSkeleton />}>
        <Comments postId={data.id} />
      </Suspense>
    </div>
  );
}

async function Comments({ postId }) {
  const comments = await fetchComments(postId);

  return comments.map(c => (
    <div key={c.id}>
      {c.text}

      {/* Mais nesting */}
      <Suspense fallback={<RepliesSkeleton />}>
        <Replies commentId={c.id} />
      </Suspense>
    </div>
  ));
}
```

### Composi√ß√£o Complexa Server/Client

#### Pattern: Server Wrapper com Client Children

```jsx
// Server Component (layout)
async function Layout({ children }) {
  const user = await getUser();

  return (
    <div>
      <ServerHeader user={user} />
      <ClientSidebar userId={user.id} />
      <main>{children}</main>
    </div>
  );
}

// Client Component
'use client';

function ClientSidebar({ userId }) {
  const [expanded, setExpanded] = useState(false);

  return (
    <aside>
      <button onClick={() => setExpanded(!expanded)}>
        Toggle
      </button>
      {expanded && <ServerContent userId={userId} />}
    </aside>
  );
}
```

#### Pattern: Client Island em Server Ocean

```jsx
// Server Component (maioria da p√°gina)
async function ProductPage({ id }) {
  const product = await db.products.findById(id);
  const reviews = await db.reviews.findByProduct(id);

  return (
    <div>
      {/* Server content */}
      <h1>{product.name}</h1>
      <p>{product.description}</p>

      {/* Client "island" para interatividade */}
      <AddToCartButton productId={product.id} />

      {/* Server content */}
      <Reviews data={reviews} />

      {/* Client "island" */}
      <ReviewForm productId={product.id} />
    </div>
  );
}
```

**Conceito**: Maioria da p√°gina √© Server (zero JS), "ilhas" de Client onde necess√°rio (interatividade).

### useFormStatus e useFormState (React 19)

#### useFormStatus (Pending State)

```jsx
// actions.js
'use server';

export async function submitForm(formData) {
  await new Promise(r => setTimeout(r, 2000)); // Simular delay
  // Process form...
}

// SubmitButton.jsx (Client Component)
'use client';

import { useFormStatus } from 'react-dom';

function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : 'Submit'}
    </button>
  );
}

// Form (Server Component)
import { submitForm } from './actions';

<form action={submitForm}>
  <input name="email" />
  <SubmitButton />
</form>
```

**Conceito**: `useFormStatus` fornece estado de pending do formul√°rio pai.

#### useFormState (Form State Management)

```jsx
// actions.js
'use server';

export async function createUser(prevState, formData) {
  const email = formData.get('email');

  if (!email.includes('@')) {
    return { error: 'Invalid email' };
  }

  await db.users.create({ email });
  return { success: true };
}

// Form.jsx (Client Component)
'use client';

import { useFormState } from 'react-dom';
import { createUser } from './actions';

function SignupForm() {
  const [state, formAction] = useFormState(createUser, { error: null });

  return (
    <form action={formAction}>
      <input name="email" />
      <button>Sign Up</button>

      {state.error && <p className="error">{state.error}</p>}
      {state.success && <p className="success">Welcome!</p>}
    </form>
  );
}
```

**Conceito**: `useFormState` gerencia estado retornado por Server Action.

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Server Actions

#### ‚úÖ Use Server Actions Para:

1. **CRUD Operations**: Create, Update, Delete
2. **Form Submissions**: Qualquer formul√°rio
3. **Mutations**: Qualquer mudan√ßa de dados
4. **Authentication**: Login, logout, signup
5. **File Uploads**: Processar uploads no servidor

#### Exemplo: CRUD Completo

```jsx
// actions.js
'use server';

import { db } from '@/lib/db';
import { revalidatePath } from 'next/cache';

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');

  await db.posts.create({ title, content });
  revalidatePath('/posts');
}

export async function updatePost(id, formData) {
  const title = formData.get('title');
  const content = formData.get('content');

  await db.posts.update(id, { title, content });
  revalidatePath('/posts');
  revalidatePath(`/posts/${id}`);
}

export async function deletePost(id) {
  await db.posts.delete(id);
  revalidatePath('/posts');
}
```

### Quando N√ÉO Usar Server Actions

1. **Read Operations**: Use Server Component direto (n√£o precisa action)
2. **Real-time Updates**: Use WebSockets/polling no cliente
3. **Client-only State**: Use useState no Client Component

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes de Server Actions

#### 1. Serializa√ß√£o de Argumentos

```jsx
// ‚ùå ERRADO - fun√ß√£o n√£o √© serializ√°vel
async function serverAction(callback) {
  'use server';
  callback(); // N√£o funciona!
}

// ‚úÖ CORRETO - apenas dados primitivos/objetos
async function serverAction(data) {
  'use server';
  const { id, name } = data; // OK
}
```

#### 2. N√£o Retornam JSX

```jsx
// ‚ùå ERRADO
async function serverAction() {
  'use server';
  return <div>Hello</div>; // N√£o funciona!
}

// ‚úÖ CORRETO - retornar dados
async function serverAction() {
  'use server';
  return { message: 'Hello' };
}
```

#### 3. Closures Limitados

```jsx
async function Component() {
  const userId = await getUserId();

  async function updateUser(formData) {
    'use server';

    // ‚úÖ Closure funciona (Next.js serializa)
    await db.users.update(userId, { ... });
  }

  return <form action={updateUser}>...</form>;
}
```

**Nota**: Next.js serializa closures, mas valores devem ser serializ√°veis.

---

## üîó Interconex√µes Conceituais

### Server Actions + Revalidation

```jsx
async function deleteItem(id) {
  'use server';

  await db.items.delete(id);

  // Revalidar m√∫ltiplas rotas
  revalidatePath('/items');
  revalidatePath('/dashboard');
  revalidateTag('items');
}
```

### Server Actions + Redirect

```jsx
import { redirect } from 'next/navigation';

async function createPost(formData) {
  'use server';

  const post = await db.posts.create({ ... });

  revalidatePath('/posts');
  redirect(`/posts/${post.id}`);
}
```

### Server Actions + Error Handling

```jsx
async function serverAction(formData) {
  'use server';

  try {
    await riskyOperation();
    return { success: true };
  } catch (error) {
    console.error(error);
    return { error: error.message };
  }
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Server Components Avan√ßado prepara para:

1. **Patterns com RSC** (21.3): Data fetching, caching, patterns de composi√ß√£o
2. **Next.js Features** (M√≥dulo 28): App Router, layouts, routing
3. **Forms** (M√≥dulo 10): Integra√ß√£o de formul√°rios com Server Actions

---

## üéØ Conclus√£o

Server Components Avan√ßado completam **arquitetura full-stack React**:

**Conceito Central**: Server Actions permitem muta√ß√µes no servidor chamadas do cliente, sem API routes.

**Principais Features**:
- **Server Actions**: "use server" para muta√ß√µes
- **Form Actions**: Formul√°rios submetem para servidor
- **Revalidation**: Invalidar cache declarativamente
- **Streaming**: Suspense para UX progressiva
- **Progressive Enhancement**: Funciona sem JavaScript

**Benef√≠cios**:
- Menos boilerplate (sem API routes)
- Progressive enhancement
- Invalida√ß√£o de cache integrada
- Streaming para melhor UX

**Hooks React 19**:
- `useFormStatus`: Pending state
- `useFormState`: Form state management

**Quando Usar**:
- **Server Actions**: CRUD, formul√°rios, muta√ß√µes
- **Streaming**: Dashboard, p√°ginas complexas
- **Revalidation**: Ap√≥s muta√ß√µes

Server Components Avan√ßado elevam React de **UI library** para **framework full-stack completo** - permitindo construir aplica√ß√µes inteiras sem sair do React, com performance excelente e DX superior. Base para aplica√ß√µes modernas com Next.js App Router.
