# Autentica√ß√£o no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Autentica√ß√£o** √© o processo de **verificar identidade do usu√°rio** (quem voc√™ √©) atrav√©s de **credenciais** (email/senha, OAuth, tokens), garantindo que apenas **usu√°rios autenticados** acessam recursos protegidos. Conceitualmente, representa **portaria digital** - validar identidade antes de permitir entrada em √°reas restritas da aplica√ß√£o.

### Problema que Resolve

**Sem Autentica√ß√£o**:
- Qualquer um acessa dados privados
- Sem controle de quem faz o qu√™
- Dados n√£o atribu√≠dos a usu√°rios

**Com Autentica√ß√£o**:
- Apenas usu√°rios verificados acessam
- Rastreabilidade de a√ß√µes
- Dados personalizados por usu√°rio

---

## üîê Estrat√©gias de Autentica√ß√£o

### 1. JWT (JSON Web Token)

**Como Funciona**:
```
1. User ‚Üí Login (email/senha)
2. Backend ‚Üí Valida credenciais
3. Backend ‚Üí Gera JWT
4. Backend ‚Üí Retorna JWT para frontend
5. Frontend ‚Üí Armazena JWT
6. Frontend ‚Üí Envia JWT em todas as requests (Authorization header)
7. Backend ‚Üí Valida JWT
```

**Estrutura JWT**:
```
Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VySWQiOiIxMjMiLCJyb2xlIjoidXNlciJ9.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### Implementa√ß√£o JWT

```tsx
// api/auth.ts
export const authApi = {
  async login(email: string, password: string) {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });

    if (!response.ok) throw new Error('Login failed');

    const { token, user } = await response.json();
    return { token, user };
  },

  async getProfile(token: string) {
    const response = await fetch('/api/auth/profile', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (!response.ok) throw new Error('Unauthorized');

    return response.json();
  },

  logout() {
    // Apenas remove token (stateless)
    localStorage.removeItem('authToken');
  }
};

// contexts/AuthContext.tsx
type AuthContextType = {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
};

const AuthContext = createContext<AuthContextType | null>(null);

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be within AuthProvider');
  return context;
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Carregar user ao montar
  useEffect(() => {
    const token = localStorage.getItem('authToken');

    if (token) {
      authApi
        .getProfile(token)
        .then(setUser)
        .catch(() => {
          localStorage.removeItem('authToken');
        })
        .finally(() => setIsLoading(false));
    } else {
      setIsLoading(false);
    }
  }, []);

  const login = async (email: string, password: string) => {
    const { token, user } = await authApi.login(email, password);

    localStorage.setItem('authToken', token);
    setUser(user);
  };

  const logout = () => {
    authApi.logout();
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

// Axios Interceptor (adiciona token automaticamente)
import axios from 'axios';

const apiClient = axios.create({
  baseURL: '/api'
});

apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('authToken');

  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }

  return config;
});

export { apiClient };
```

**Problemas do JWT em localStorage**:
- ‚ùå Vulner√°vel a XSS (JavaScript pode acessar)
- ‚ùå N√£o pode ser revogado (stateless)
- ‚ùå Exp√µe dados sens√≠veis (payload √© apenas base64)

---

### 2. Session Cookies (Recomendado)

```tsx
// ‚úÖ MAIS SEGURO - httpOnly cookies
// Backend (Express)
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;

  const user = await validateCredentials(email, password);

  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // Criar sess√£o
  req.session.userId = user.id;

  // Cookie httpOnly (JavaScript n√£o acessa)
  res.cookie('sessionId', req.session.id, {
    httpOnly: true,   // XSS protection
    secure: true,     // HTTPS only
    sameSite: 'strict', // CSRF protection
    maxAge: 24 * 60 * 60 * 1000 // 24h
  });

  res.json({ user });
});

// Frontend
export const authApi = {
  async login(email: string, password: string) {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      credentials: 'include', // Envia cookies
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });

    if (!response.ok) throw new Error('Login failed');

    return response.json();
  },

  async getProfile() {
    const response = await fetch('/api/auth/profile', {
      credentials: 'include' // Envia cookies
    });

    if (!response.ok) throw new Error('Unauthorized');

    return response.json();
  },

  async logout() {
    await fetch('/api/auth/logout', {
      method: 'POST',
      credentials: 'include'
    });
  }
};
```

**Vantagens**:
- ‚úÖ httpOnly (XSS protection)
- ‚úÖ Revog√°vel (sess√£o no servidor)
- ‚úÖ Stateful (server-side validation)

---

### 3. OAuth 2.0 / Social Login

```tsx
// ‚úÖ Google OAuth
import { GoogleLogin } from '@react-oauth/google';

function LoginPage() {
  const handleGoogleSuccess = async (credentialResponse) => {
    // Enviar token para backend
    const response = await fetch('/api/auth/google', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        token: credentialResponse.credential
      })
    });

    const { user } = await response.json();
    // Backend valida token com Google e cria sess√£o
  };

  return (
    <GoogleLogin
      onSuccess={handleGoogleSuccess}
      onError={() => console.error('Login failed')}
    />
  );
}

// Backend
app.post('/api/auth/google', async (req, res) => {
  const { token } = req.body;

  // Validar token com Google
  const googleUser = await verifyGoogleToken(token);

  // Criar/atualizar user no DB
  const user = await upsertUser({
    email: googleUser.email,
    name: googleUser.name,
    provider: 'google'
  });

  // Criar sess√£o
  req.session.userId = user.id;

  res.json({ user });
});
```

---

## üõ°Ô∏è Protected Routes

### B√°sico

```tsx
// components/ProtectedRoute.tsx
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!user) {
    // Redireciona para login, salva tentativa de acesso
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
}

// App.tsx
<Routes>
  <Route path="/login" element={<LoginPage />} />

  <Route
    path="/dashboard"
    element={
      <ProtectedRoute>
        <Dashboard />
      </ProtectedRoute>
    }
  />
</Routes>

// LoginPage - Redirecionar ap√≥s login
function LoginPage() {
  const navigate = useNavigate();
  const location = useLocation();
  const { login } = useAuth();

  const from = location.state?.from?.pathname || '/dashboard';

  const handleLogin = async (email, password) => {
    await login(email, password);
    navigate(from, { replace: true }); // Volta para p√°gina tentada
  };

  return <LoginForm onSubmit={handleLogin} />;
}
```

### Com Role-Based Access

```tsx
// components/RequireRole.tsx
type Role = 'user' | 'admin' | 'moderator';

function RequireRole({
  allowedRoles,
  children
}: {
  allowedRoles: Role[];
  children: React.ReactNode;
}) {
  const { user, isLoading } = useAuth();

  if (isLoading) return <LoadingSpinner />;

  if (!user) return <Navigate to="/login" />;

  if (!allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" />;
  }

  return <>{children}</>;
}

// Uso
<Route
  path="/admin"
  element={
    <RequireRole allowedRoles={['admin']}>
      <AdminPanel />
    </RequireRole>
  }
/>
```

---

## üîÑ Token Refresh

### Refresh Token Pattern

```tsx
// Problema: Access token expira em 15min
// Solu√ß√£o: Refresh token (v√°lido por 7 dias)

let refreshTokenPromise: Promise<string> | null = null;

async function refreshAccessToken(): Promise<string> {
  // Evitar m√∫ltiplos refreshes simult√¢neos
  if (refreshTokenPromise) return refreshTokenPromise;

  refreshTokenPromise = fetch('/api/auth/refresh', {
    method: 'POST',
    credentials: 'include' // Envia refresh token (httpOnly cookie)
  })
    .then((r) => r.json())
    .then((data) => {
      localStorage.setItem('accessToken', data.accessToken);
      return data.accessToken;
    })
    .finally(() => {
      refreshTokenPromise = null;
    });

  return refreshTokenPromise;
}

// Axios interceptor
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Se 401 e n√£o tentou refresh ainda
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const newToken = await refreshAccessToken();
        originalRequest.headers.Authorization = `Bearer ${newToken}`;
        return apiClient(originalRequest);
      } catch (refreshError) {
        // Refresh falhou ‚Üí logout
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

---

## üöÄ Conclus√£o

Autentica√ß√£o no React inclui:
- **JWT**: Stateless, armazenar em localStorage (ou melhor: httpOnly cookie)
- **Session Cookies**: MAIS SEGURO - httpOnly, secure, sameSite
- **OAuth**: Google, GitHub, etc - delegar autentica√ß√£o
- **Protected Routes**: Componente que valida auth antes de renderizar
- **RBAC**: Role-Based Access Control (admin, user, etc)
- **Token Refresh**: Access token (15min) + Refresh token (7 days)

**Recomenda√ß√£o**: **Session Cookies (httpOnly)** > JWT em localStorage. Se usar JWT, armazene em httpOnly cookie tamb√©m.

Sempre validar no backend - frontend √© apenas UX!
