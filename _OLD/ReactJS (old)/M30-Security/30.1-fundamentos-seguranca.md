# Fundamentos de Seguran√ßa no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Seguran√ßa no React** √© a pr√°tica de **proteger aplica√ß√µes contra vulnerabilidades** como XSS, CSRF, injection attacks e data leaks, atrav√©s de **valida√ß√£o, sanitiza√ß√£o, autentica√ß√£o e boas pr√°ticas de c√≥digo**. Conceitualmente, representa **defesa em profundidade** - m√∫ltiplas camadas de prote√ß√£o para garantir que dados do usu√°rio est√£o seguros e aplica√ß√£o n√£o pode ser explorada.

### Problema que Resolve

**Aplica√ß√£o Insegura**:
- Dados sens√≠veis expostos
- XSS permite execu√ß√£o de c√≥digo malicioso
- CSRF permite a√ß√µes n√£o autorizadas
- Injection attacks roubam dados

**Aplica√ß√£o Segura**:
- Dados criptografados e protegidos
- XSS bloqueado por sanitiza√ß√£o
- CSRF tokens impedem ataques
- Input validado previne injection

---

## üõ°Ô∏è OWASP Top 10 para React

### 1. Injection (SQL, NoSQL, Command)

```tsx
// ‚ùå VULNER√ÅVEL - SQL Injection
function getUserByEmail(email: string) {
  // NUNCA fa√ßa isso!
  const query = `SELECT * FROM users WHERE email = '${email}'`;
  // Ataque: email = "' OR '1'='1"
  // Query: SELECT * FROM users WHERE email = '' OR '1'='1'
  // Retorna TODOS os usu√°rios!
}

// ‚úÖ SEGURO - Prepared statements / ORMs
function getUserByEmail(email: string) {
  // Use ORM (Prisma, TypeORM) ou prepared statements
  return prisma.user.findUnique({
    where: { email }
  });

  // Ou SQL parametrizado
  return db.query('SELECT * FROM users WHERE email = $1', [email]);
}
```

### 2. Cross-Site Scripting (XSS)

```tsx
// ‚ùå VULNER√ÅVEL - XSS
function UserComment({ comment }: { comment: string }) {
  // NUNCA use dangerouslySetInnerHTML com input do usu√°rio!
  return <div dangerouslySetInnerHTML={{ __html: comment }} />;
  // Ataque: comment = '<script>alert(document.cookie)</script>'
}

// ‚úÖ SEGURO - React escapa automaticamente
function UserComment({ comment }: { comment: string }) {
  return <div>{comment}</div>;
  // React escapa caracteres especiais automaticamente
  // <script> vira &lt;script&gt;
}

// ‚úÖ Se precisar de HTML, sanitize!
import DOMPurify from 'dompurify';

function UserComment({ comment }: { comment: string }) {
  const clean = DOMPurify.sanitize(comment);
  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
}
```

### 3. Sensitive Data Exposure

```tsx
// ‚ùå VULNER√ÅVEL - Dados sens√≠veis no frontend
const API_KEY = 'sk_live_abc123xyz'; // NO NO NO!

localStorage.setItem('password', password); // NUNCA!

// ‚úÖ SEGURO - Secrets no backend
// .env (backend)
API_KEY=sk_live_abc123xyz

// Frontend apenas envia request ao backend
async function fetchData() {
  // Backend adiciona API_KEY
  const response = await fetch('/api/data');
  return response.json();
}

// ‚úÖ Tokens em httpOnly cookies (n√£o localStorage)
// Backend:
res.cookie('token', jwt, {
  httpOnly: true,  // JavaScript n√£o pode acessar
  secure: true,    // Apenas HTTPS
  sameSite: 'strict'
});
```

### 4. Cross-Site Request Forgery (CSRF)

```tsx
// ‚ùå VULNER√ÅVEL - Sem prote√ß√£o CSRF
<form action="https://bank.com/transfer" method="POST">
  <input name="amount" value="1000" />
  <input name="to" value="attacker" />
</form>
// Ataque: Enviar link com este form para v√≠tima logada

// ‚úÖ SEGURO - CSRF Token
// Backend gera token √∫nico por sess√£o
function TransferForm() {
  const csrfToken = document.querySelector('meta[name="csrf-token"]').content;

  const handleSubmit = async (e) => {
    e.preventDefault();

    await fetch('/api/transfer', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: JSON.stringify({ amount, to })
    });
  };

  return <form onSubmit={handleSubmit}>{/* ... */}</form>;
}

// ‚úÖ SameSite cookies (defesa adicional)
// Backend:
res.cookie('token', jwt, {
  httpOnly: true,
  sameSite: 'strict' // Bloqueia requests cross-site
});
```

---

## üîê Autentica√ß√£o e Autoriza√ß√£o

### Armazenar Tokens com Seguran√ßa

```tsx
// ‚ùå VULNER√ÅVEL - localStorage
localStorage.setItem('token', jwt);
// Acess√≠vel via JavaScript (XSS risk)

// ‚úÖ SEGURO - httpOnly cookies
// Backend:
res.cookie('authToken', jwt, {
  httpOnly: true,   // JavaScript n√£o acessa
  secure: true,     // Apenas HTTPS
  sameSite: 'strict',
  maxAge: 3600000   // 1 hora
});

// Frontend:
// Cookie enviado automaticamente em todas as requests!
await fetch('/api/protected', {
  credentials: 'include' // Envia cookies
});
```

### Protected Routes

```tsx
// ‚úÖ Verificar autentica√ß√£o
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, isLoading } = useAuth();

  if (isLoading) return <LoadingSpinner />;

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}

// Uso
<Route
  path="/dashboard"
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  }
/>
```

### Role-Based Access Control (RBAC)

```tsx
// ‚úÖ Verificar permiss√µes
type User = {
  id: string;
  role: 'user' | 'admin' | 'moderator';
};

function RequireRole({
  allowedRoles,
  children
}: {
  allowedRoles: User['role'][];
  children: React.ReactNode;
}) {
  const { user } = useAuth();

  if (!user || !allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" />;
  }

  return <>{children}</>;
}

// Uso
<Route
  path="/admin"
  element={
    <RequireRole allowedRoles={['admin']}>
      <AdminPanel />
    </RequireRole>
  }
/>
```

---

## üîí Input Validation

### Client-Side Validation

```tsx
// ‚úÖ Validar input do usu√°rio
import { z } from 'zod';

const emailSchema = z.string().email();
const passwordSchema = z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/);

function LoginForm() {
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');

  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setEmail(value);

    try {
      emailSchema.parse(value);
      setEmailError('');
    } catch (error) {
      setEmailError('Invalid email');
    }
  };

  return (
    <form>
      <input
        type="email"
        value={email}
        onChange={handleEmailChange}
        aria-invalid={!!emailError}
      />
      {emailError && <p role="alert">{emailError}</p>}
    </form>
  );
}
```

**IMPORTANTE**: Client-side validation √© UX, **SEMPRE valide no backend tamb√©m**!

### Sanitiza√ß√£o

```tsx
// ‚úÖ Sanitize antes de renderizar HTML
import DOMPurify from 'dompurify';

function RichTextDisplay({ html }: { html: string }) {
  const clean = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
    ALLOWED_ATTR: []
  });

  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
}
```

---

## üåê Secure Communication

### HTTPS Only

```tsx
// ‚úÖ For√ßar HTTPS
// vite.config.ts
export default defineConfig({
  server: {
    https: {
      key: fs.readFileSync('key.pem'),
      cert: fs.readFileSync('cert.pem')
    }
  }
});

// ‚úÖ Upgrade insecure requests
// index.html
<meta http-equiv="Content-Security-Policy"
      content="upgrade-insecure-requests" />
```

### Content Security Policy (CSP)

```html
<!-- index.html -->
<meta
  http-equiv="Content-Security-Policy"
  content="
    default-src 'self';
    script-src 'self' 'unsafe-inline';
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self' data:;
    connect-src 'self' https://api.example.com;
  "
/>
```

---

## üö´ Security Headers

### Headers Recomendados

```javascript
// Backend (Express)
app.use((req, res, next) => {
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY');

  // Prevent MIME sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff');

  // Enable XSS filter
  res.setHeader('X-XSS-Protection', '1; mode=block');

  // HTTPS only
  res.setHeader(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains'
  );

  // Referrer policy
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

  // Permissions policy
  res.setHeader(
    'Permissions-Policy',
    'camera=(), microphone=(), geolocation=()'
  );

  next();
});
```

---

## üîç Dependency Security

### Audit Vulnerabilities

```bash
# Verificar vulnerabilidades
npm audit

# Corrigir automaticamente
npm audit fix

# Ver detalhes
npm audit --json | jq
```

### Dependabot

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "daily"
    open-pull-requests-limit: 5
```

---

## üöÄ Conclus√£o

Fundamentos de Seguran√ßa incluem:
- **OWASP Top 10**: Injection, XSS, Sensitive Data, CSRF
- **Autentica√ß√£o**: httpOnly cookies (n√£o localStorage)
- **Autoriza√ß√£o**: Protected routes, RBAC
- **Validation**: Client + Server (sempre ambos!)
- **Sanitiza√ß√£o**: DOMPurify para HTML
- **HTTPS**: Sempre, sem exce√ß√µes
- **CSP**: Content Security Policy headers
- **Audit**: npm audit, dependabot

**Regra de Ouro**: **NUNCA confie no frontend** - valida√ß√£o/autoriza√ß√£o sempre no backend, frontend √© apenas UX.
