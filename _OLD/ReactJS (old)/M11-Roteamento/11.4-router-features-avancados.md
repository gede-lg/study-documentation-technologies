# Router Features Avan√ßados

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Router Features Avan√ßados** cobrem t√©cnicas sofisticadas: **rotas protegidas** (protected/guarded routes com autentica√ß√£o), **code splitting** (lazy loading de rotas), **data loaders** (v6.4+, fetch antes de renderizar), e **error boundaries** espec√≠ficos de rota. Representam patterns **production-ready** que resolvem problemas reais: seguran√ßa, performance, UX de loading, e error handling robusto.

Esses features transformam roteamento de "mapear URLs ‚Üí componentes" para **orquestra√ß√£o completa** de navega√ß√£o: verificar permiss√µes antes de renderizar, carregar bundles sob demanda, fetch data parallel √† navega√ß√£o, capturar erros espec√≠ficos de rotas. S√£o diferen√ßa entre prot√≥tipo e **aplica√ß√£o enterprise**.

**Filosofia:** "Routing is orchestration, not just mapping." Roteamento moderno n√£o √© apenas `path ‚Üí component`. √â **coordenar** auth checks, data loading, error handling, performance optimization - tudo de forma declarativa.

### Import√¢ncia no Ecossistema

Features avan√ßados s√£o **cr√≠ticos** para:

- **Seguran√ßa**: Protected routes impedem acesso n√£o autorizado
- **Performance**: Lazy loading reduz bundle inicial
- **UX**: Data loaders evitam spinners ap√≥s navega√ß√£o
- **Robustez**: Error boundaries capturam falhas de rotas

**Contexto:** React Router v6.4 introduziu **data APIs** (loaders, actions) que revolucionaram data fetching. Protected routes s√£o pattern universal. Lazy loading √© standard em apps grandes.

---

## üìã Sum√°rio Conceitual

### Features Cobertos

1. **Protected Routes**: Guards de autentica√ß√£o/autoriza√ß√£o
2. **Code Splitting**: Lazy loading de rotas
3. **Data Loaders**: Fetch antes de renderizar (v6.4+)
4. **Error Boundaries**: Error handling por rota
5. **Suspense**: Loading states elegantes

---

## üîç Fundamentos Te√≥ricos

### Protected Routes Pattern

**Problema:** Impedir acesso a rotas sem autentica√ß√£o.

**Solu√ß√£o:** Wrapper component que checa auth e redireciona:
```javascript
<Route
  path="/dashboard"
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  }
/>
```

### Code Splitting + Suspense

**Problem:** Bundle √∫nico gigante ‚Üí load time lento.

**Solu√ß√£o:** Split por rota, load on-demand:
```javascript
const Dashboard = lazy(() => import('./Dashboard'));

<Suspense fallback={<Loading />}>
  <Dashboard />
</Suspense>
```

### Data Loaders (v6.4+)

**Problema:** Fetch ap√≥s component render ‚Üí loading spinner, delayed content.

**Solu√ß√£o:** Fetch **antes** de navigation complete:
```javascript
<Route
  path="/products/:id"
  loader={({ params }) => fetch(`/api/products/${params.id}`)}
  element={<ProductDetail />}
/>
```

---

## üîç An√°lise Conceitual Profunda

### 11.4.1 Protected Routes

**Implementa√ß√£o b√°sica:**
```javascript
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const isAuthenticated = useAuth(); // Custom hook

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return children;
}

// Uso
<Routes>
  <Route path="/login" element={<Login />} />

  <Route
    path="/dashboard"
    element={
      <ProtectedRoute>
        <Dashboard />
      </ProtectedRoute>
    }
  />
</Routes>
```

**Com redirect para origem:**
```javascript
import { Navigate, useLocation } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const isAuthenticated = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    // Salvar location atual no state
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

// Login component
function Login() {
  const navigate = useNavigate();
  const location = useLocation();

  const from = location.state?.from?.pathname || '/';

  const handleLogin = async () => {
    await login();
    navigate(from, { replace: true }); // Volta para origem
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

**Protected route com loading:**
```javascript
function ProtectedRoute({ children }) {
  const { user, loading } = useAuth();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return children;
}
```

**Role-based protection:**
```javascript
function ProtectedRoute({ children, requiredRole }) {
  const { user } = useAuth();

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
}

// Uso
<Route
  path="/admin"
  element={
    <ProtectedRoute requiredRole="admin">
      <AdminPanel />
    </ProtectedRoute>
  }
/>
```

**Pattern com layout route:**
```javascript
<Routes>
  {/* Public */}
  <Route path="/login" element={<Login />} />

  {/* Protected section (layout route) */}
  <Route element={<ProtectedLayout />}>
    <Route path="/dashboard" element={<Dashboard />} />
    <Route path="/profile" element={<Profile />} />
    <Route path="/settings" element={<Settings />} />
  </Route>
</Routes>

function ProtectedLayout() {
  const { user, loading } = useAuth();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return (
    <div>
      <Sidebar />
      <Outlet />
    </div>
  );
}
// Todas child routes automaticamente protegidas
```

### 11.4.2 Code Splitting com React.lazy

**Lazy load de rotas:**
```javascript
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

// Dynamic imports
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </Suspense>
  );
}
```

**Suspense por rota (loading espec√≠fico):**
```javascript
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />

      <Route
        path="/dashboard"
        element={
          <Suspense fallback={<DashboardSkeleton />}>
            <Dashboard />
          </Suspense>
        }
      />
    </Routes>
  );
}
```

**Loading component sofisticado:**
```javascript
function LazyLoadingFallback() {
  return (
    <div style={{ textAlign: 'center', padding: '50px' }}>
      <div className="spinner"></div>
      <p>Loading page...</p>
    </div>
  );
}

<Suspense fallback={<LazyLoadingFallback />}>
  <Routes>
    {/* ... */}
  </Routes>
</Suspense>
```

**Preload de rota (ao hover):**
```javascript
const Dashboard = lazy(() => import('./pages/Dashboard'));

function Navigation() {
  // Preload ao hover
  const handleMouseEnter = () => {
    import('./pages/Dashboard'); // Preload
  };

  return (
    <nav>
      <Link to="/dashboard" onMouseEnter={handleMouseEnter}>
        Dashboard
      </Link>
    </nav>
  );
}
```

### 11.4.3 Data Loaders (React Router v6.4+)

**‚ö†Ô∏è Requer createBrowserRouter (v6.4+):**
```javascript
import { createBrowserRouter, RouterProvider } from 'react-router-dom';

const router = createBrowserRouter([
  {
    path: '/',
    element: <Home />
  },
  {
    path: '/products/:id',
    loader: async ({ params }) => {
      const response = await fetch(`/api/products/${params.id}`);
      return response.json();
    },
    element: <ProductDetail />
  }
]);

function App() {
  return <RouterProvider router={router} />;
}
```

**Acessar data no component:**
```javascript
import { useLoaderData } from 'react-router-dom';

function ProductDetail() {
  const product = useLoaderData();

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}
// Data j√° carregada quando component renderiza
```

**Loader com error handling:**
```javascript
{
  path: '/products/:id',
  loader: async ({ params }) => {
    const response = await fetch(`/api/products/${params.id}`);

    if (!response.ok) {
      throw new Response('Product not found', { status: 404 });
    }

    return response.json();
  },
  element: <ProductDetail />,
  errorElement: <ErrorPage />
}
```

**Multiple data sources:**
```javascript
{
  path: '/dashboard',
  loader: async () => {
    const [user, stats, notifications] = await Promise.all([
      fetch('/api/user').then(r => r.json()),
      fetch('/api/stats').then(r => r.json()),
      fetch('/api/notifications').then(r => r.json())
    ]);

    return { user, stats, notifications };
  },
  element: <Dashboard />
}

function Dashboard() {
  const { user, stats, notifications } = useLoaderData();
  // Todos dados carregados em parallel
}
```

**Loader com auth check:**
```javascript
{
  path: '/dashboard',
  loader: async ({ request }) => {
    const token = localStorage.getItem('token');

    if (!token) {
      throw redirect('/login');
    }

    const response = await fetch('/api/dashboard', {
      headers: { Authorization: `Bearer ${token}` }
    });

    if (response.status === 401) {
      throw redirect('/login');
    }

    return response.json();
  },
  element: <Dashboard />
}
```

### 11.4.4 Actions (Form Mutations v6.4+)

**Action para form submit:**
```javascript
import { Form, redirect } from 'react-router-dom';

{
  path: '/products/new',
  element: <ProductCreate />,
  action: async ({ request }) => {
    const formData = await request.formData();

    const response = await fetch('/api/products', {
      method: 'POST',
      body: formData
    });

    const newProduct = await response.json();

    return redirect(`/products/${newProduct.id}`);
  }
}

function ProductCreate() {
  return (
    <Form method="post">
      <input name="name" placeholder="Product name" />
      <input name="price" type="number" placeholder="Price" />
      <button type="submit">Create</button>
    </Form>
  );
}
// Form submit chama action automaticamente
```

**Action state (pending, errors):**
```javascript
import { Form, useNavigation, useActionData } from 'react-router-dom';

function ProductCreate() {
  const navigation = useNavigation();
  const actionData = useActionData();

  const isSubmitting = navigation.state === 'submitting';

  return (
    <Form method="post">
      <input name="name" />
      {actionData?.error && <p style={{ color: 'red' }}>{actionData.error}</p>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Creating...' : 'Create'}
      </button>
    </Form>
  );
}

// Action com error
{
  action: async ({ request }) => {
    try {
      const formData = await request.formData();
      const response = await fetch('/api/products', {
        method: 'POST',
        body: JSON.stringify(Object.fromEntries(formData)),
        headers: { 'Content-Type': 'application/json' }
      });

      if (!response.ok) {
        return { error: 'Failed to create product' };
      }

      const product = await response.json();
      return redirect(`/products/${product.id}`);
    } catch (error) {
      return { error: error.message };
    }
  }
}
```

### 11.4.5 Error Boundaries de Rota

**Error boundary global:**
```javascript
{
  path: '/',
  element: <App />,
  errorElement: <ErrorPage />,
  children: [
    {
      path: 'products/:id',
      element: <ProductDetail />,
      loader: productLoader
    }
  ]
}

function ErrorPage() {
  const error = useRouteError();

  return (
    <div>
      <h1>Oops!</h1>
      <p>{error.statusText || error.message}</p>
    </div>
  );
}
```

**Error boundary por rota:**
```javascript
{
  path: '/products/:id',
  element: <ProductDetail />,
  loader: productLoader,
  errorElement: <ProductError />
}

function ProductError() {
  const error = useRouteError();

  if (error.status === 404) {
    return <div>Product not found</div>;
  }

  return <div>Error loading product</div>;
}
```

**Error boundary com layout preservado:**
```javascript
{
  path: '/',
  element: <AppLayout />,
  children: [
    {
      path: 'products/:id',
      element: <ProductDetail />,
      loader: productLoader,
      errorElement: <ProductError />
    }
  ]
}

// AppLayout (sidebar, header) permanece, apenas content mostra erro
```

### 11.4.6 Exemplo Completo: App com Todos Features

```javascript
import { createBrowserRouter, RouterProvider, Navigate, Outlet } from 'react-router-dom';
import { lazy, Suspense } from 'react';

// Lazy loaded
const Dashboard = lazy(() => import('./pages/Dashboard'));
const ProductDetail = lazy(() => import('./pages/ProductDetail'));
const AdminPanel = lazy(() => import('./pages/AdminPanel'));

// Loaders
const dashboardLoader = async () => {
  const token = localStorage.getItem('token');
  if (!token) throw redirect('/login');

  const [user, stats] = await Promise.all([
    fetch('/api/user', { headers: { Authorization: `Bearer ${token}` } }).then(r => r.json()),
    fetch('/api/stats', { headers: { Authorization: `Bearer ${token}` } }).then(r => r.json())
  ]);

  return { user, stats };
};

const productLoader = async ({ params }) => {
  const response = await fetch(`/api/products/${params.id}`);

  if (!response.ok) {
    throw new Response('Not found', { status: 404 });
  }

  return response.json();
};

// Protected layout
function ProtectedLayout() {
  const { user, loading } = useAuth();

  if (loading) return <Loading />;
  if (!user) return <Navigate to="/login" replace />;

  return (
    <div>
      <Sidebar />
      <Suspense fallback={<Loading />}>
        <Outlet />
      </Suspense>
    </div>
  );
}

// Router configuration
const router = createBrowserRouter([
  {
    path: '/',
    element: <Home />
  },
  {
    path: '/login',
    element: <Login />
  },
  {
    path: '/products/:id',
    element: <ProductDetail />,
    loader: productLoader,
    errorElement: <ProductError />
  },
  {
    element: <ProtectedLayout />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: '/dashboard',
        element: <Dashboard />,
        loader: dashboardLoader
      },
      {
        path: '/admin',
        element: <AdminPanel />,
        loader: async () => {
          const { user } = await dashboardLoader();
          if (user.role !== 'admin') {
            throw new Response('Unauthorized', { status: 403 });
          }
          return user;
        }
      }
    ]
  },
  {
    path: '*',
    element: <NotFound />
  }
]);

function App() {
  return <RouterProvider router={router} />;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Feature

**Protected Routes:**
- SEMPRE para rotas autenticadas
- Role-based access (admin, user, etc.)

**Code Splitting:**
- Apps m√©dios/grandes (>100kb bundle)
- Rotas raramente visitadas (admin, settings)
- Melhorar initial load time

**Data Loaders (v6.4+):**
- Fetch antes de renderizar (melhor UX)
- Parallel data loading
- Prototyping r√°pido (menos boilerplate)

**Error Boundaries:**
- SEMPRE (capturar erros de loader/render)
- Custom error pages por se√ß√£o
- Fallback gracioso

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Loaders Requerem v6.4+

**Loaders n√£o funcionam com `<BrowserRouter>`:**
```javascript
// ‚ùå N√£o suporta loaders
<BrowserRouter>
  <Routes>
    <Route path="/" loader={...} /> {/* Ignorado */}
  </Routes>
</BrowserRouter>

// ‚úÖ Suporta loaders
const router = createBrowserRouter([...]);
<RouterProvider router={router} />
```

### Lazy Loading Aumenta Requests

**Trade-off:** Bundle menor, mas mais requests HTTP.

**Solu√ß√£o:** Balance entre initial load e total requests:
- Lazy load rotas raramente visitadas
- Bundle cr√≠tico (home, login) junto

### Protected Routes e Flash of Content

**Problema:** User v√™ conte√∫do protegido por frame antes de redirect.

**Solu√ß√£o:** Loading state expl√≠cito:
```javascript
function ProtectedRoute({ children }) {
  const { user, loading } = useAuth();

  if (loading) return <Loading />; // Evita flash

  if (!user) return <Navigate to="/login" replace />;

  return children;
}
```

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Suspense

Code splitting usa Suspense:
```javascript
const Dashboard = lazy(() => import('./Dashboard'));

<Suspense fallback={<Loading />}>
  <Dashboard />
</Suspense>
```

### Rela√ß√£o com Error Boundaries

Error boundaries de rota = error boundaries do React:
```javascript
// Error boundary de rota (v6.4+)
{
  errorElement: <ErrorPage />
}

// Error boundary manual
<ErrorBoundary fallback={<ErrorPage />}>
  <Component />
</ErrorBoundary>
```

### Rela√ß√£o com Context API

Protected routes usam Context (auth):
```javascript
const { user } = useAuth(); // Context hook

if (!user) return <Navigate to="/login" />;
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### React Router v6.4 Data APIs

**Revolu√ß√£o:** Loaders/Actions inspirados em Remix.

**Antes (v6.0-6.3):**
```javascript
function ProductDetail() {
  const { id } = useParams();
  const [product, setProduct] = useState(null);

  useEffect(() => {
    fetch(`/api/products/${id}`).then(r => r.json()).then(setProduct);
  }, [id]);

  if (!product) return <Loading />;

  return <div>{product.name}</div>;
}
```

**Depois (v6.4+):**
```javascript
{
  loader: ({ params }) => fetch(`/api/products/${params.id}`).then(r => r.json()),
  element: <ProductDetail />
}

function ProductDetail() {
  const product = useLoaderData();
  return <div>{product.name}</div>;
}
// Menos c√≥digo, melhor UX
```

### React 19 + React Router

**React 19 Actions** + **Router Actions** = powerful combo.

### Pr√≥ximos Passos

M√≥dulo 11 (ROTEAMENTO) completo! Pr√≥ximo: **M√≥dulo 12 - REQUISI√á√ïES HTTP E DATA FETCHING**

**Prepara√ß√£o:** Loaders (11.4) s√£o preview de data fetching. M√≥dulo 12 cobre fetch patterns, React Query, SWR em profundidade.

---

## üìö Conclus√£o

### Pontos-Chave

Router Features Avan√ßados incluem:

1. **Protected Routes**: Guards de auth/autoriza√ß√£o
2. **Code Splitting**: Lazy loading com React.lazy + Suspense
3. **Data Loaders**: Fetch antes de render (v6.4+)
4. **Actions**: Form mutations (v6.4+)
5. **Error Boundaries**: Error handling por rota

### Best Practices

1. **SEMPRE proteja rotas autenticadas**
2. **Lazy load rotas grandes/raramente visitadas**
3. **Use loaders (v6.4+) para melhor UX** (fetch antes de render)
4. **Error boundaries em TODAS rotas** com data loading
5. **Loading states expl√≠citos** (evitar flash of content)

### Pattern Production-Ready

```javascript
const router = createBrowserRouter([
  {
    path: '/',
    element: <Home />
  },
  {
    path: '/login',
    element: <Login />
  },
  {
    // Protected section
    element: <ProtectedLayout />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: '/dashboard',
        element: <Dashboard />,
        loader: dashboardLoader // Fetch antes de render
      }
    ]
  },
  {
    path: '/products/:id',
    element: <ProductDetail />,
    loader: productLoader,
    errorElement: <ProductError />
  },
  {
    path: '*',
    element: <NotFound />
  }
]);

// Lazy loading
const Dashboard = lazy(() => import('./Dashboard'));

<Suspense fallback={<Loading />}>
  <RouterProvider router={router} />
</Suspense>
```

### Filosofia

**"Routing is orchestration, not just mapping."**

Features avan√ßados transformam roteamento de simples `path ‚Üí component` para **orquestra√ß√£o completa**: auth checks, code splitting, data loading, error handling - tudo declarativo. Resultado: apps seguras, perform√°ticas, com UX superior.

**Dominar router features avan√ßados = aplica√ß√µes enterprise-grade.**

---

## üìñ Recursos Adicionais

**Documenta√ß√£o:**
- React Router v6.4+ Data APIs: https://reactrouter.com/en/main/start/overview
- Protected Routes guide: https://reactrouter.com/en/main/start/faq#how-do-i-add-a-no-match-404-route

**Libraries Complementares:**
- React Query: Data fetching avan√ßado (pr√≥ximo m√≥dulo)
- React Suspense: Concurrent features

**M√≥dulo 11 - ROTEAMENTO completo! üéâ**

Pr√≥ximo: **M√≥dulo 12 - REQUISI√á√ïES HTTP E DATA FETCHING**
