# Performance Patterns no React: Uma An√°lise Conceitual Profunda

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

Performance Patterns no React referem-se a **padr√µes arquiteturais e t√©cnicas de design** que previnem problemas de performance antes mesmo que ocorram, atrav√©s da estrutura√ß√£o inteligente de componentes e fluxo de dados. S√£o estrat√©gias que evitam re-renders desnecess√°rios por design, ao inv√©s de otimiz√°-los posteriormente.

Conceitualmente, Performance Patterns implementam o princ√≠pio de **design for performance**: estruturar aplica√ß√£o de forma que performance emergente seja boa por padr√£o, n√£o como resultado de otimiza√ß√µes posteriores. √â "performance by design" ao inv√©s de "performance by optimization".

Os padr√µes principais incluem:

1. **Evitar Re-renders Desnecess√°rios** - Estruturar componentes para minimizar propaga√ß√£o de renders
2. **Lifting Content Up** - Elevar conte√∫do est√°tico para fora de componentes com estado
3. **Children como Escape Hatch** - Usar `children` prop para isolar mudan√ßas de estado

### Contexto Hist√≥rico e Motiva√ß√£o

Nas primeiras aplica√ß√µes React, desenvolvedores frequentemente criavam **hierarquias profundas** de componentes sem pensar em performance:

```javascript
// Pattern comum mas problem√°tico
function App() {
  const [count, setCount] = useState(0);

  return (
    <Layout> {/* Re-renderiza quando count muda */}
      <Header /> {/* Re-renderiza desnecessariamente */}
      <Sidebar /> {/* Re-renderiza desnecessariamente */}
      <Content>
        <Counter count={count} onChange={setCount} />
      </Content>
      <Footer /> {/* Re-renderiza desnecessariamente */}
    </Layout>
  );
}
```

**Problema:** Mudar `count` causa re-render de **todo** App, incluindo Header, Sidebar, Footer que n√£o dependem de count.

**Descoberta da Comunidade:** Estrutura de componentes **afeta dramaticamente** performance. Pequenas mudan√ßas arquiteturais (como mover estado para baixo ou conte√∫do para cima) podem eliminar milhares de re-renders sem adicionar uma linha de otimiza√ß√£o (memo, useMemo, etc).

**Dan Abramov** (core team React) popularizou esses patterns em artigos como "Before You memo()", enfatizando: **estrutura correta > otimiza√ß√£o prematura**.

### Problema Fundamental que Resolve

Performance Patterns resolvem o problema de **cascata de re-renders**:

**Cen√°rio Problem√°tico:**
```
Estado muda em componente pai
  ‚Üì
Pai re-renderiza
  ‚Üì
TODOS os filhos re-renderizam (mesmo que props n√£o mudaram)
  ‚Üì
Filhos dos filhos re-renderizam
  ‚Üì
Cascata de centenas/milhares de re-renders desnecess√°rios
```

**Solu√ß√£o via Patterns:**
- **State Colocation:** Mover estado para o componente que realmente o usa
- **Composi√ß√£o Inteligente:** Estruturar √°rvore para isolar mudan√ßas
- **Children Props:** Passar componentes est√°ticos como children para evitar re-cria√ß√£o

### Import√¢ncia no Ecossistema

Performance Patterns s√£o considerados **best practices fundamentais**:

- **Primeiro Passo:** Antes de usar React.memo, useMemo, useCallback, estruture bem os componentes
- **Legibilidade:** C√≥digo bem estruturado √© mais leg√≠vel E mais perform√°tico
- **Manutenibilidade:** Patterns facilitam compreens√£o e modifica√ß√£o futura
- **Escalabilidade:** Aplica√ß√µes grandes com boa estrutura escalam melhor

**Filosofia React:** "Performance problems are often architecture problems". Resolver na arquitetura √© melhor que otimizar c√≥digo mal estruturado.

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **State Colocation:** Estado deve viver o mais pr√≥ximo poss√≠vel de onde √© usado
2. **Composition over Inheritance:** Usar composi√ß√£o para isolar mudan√ßas
3. **Render Isolation:** Isolar partes que mudam de partes est√°ticas
4. **Props Stability:** Manter props est√°veis para componentes memoizados
5. **Component Splitting:** Dividir componentes grandes em pequenos focados

### Pilares Fundamentais

- **Minimize Scope of State:** Estado com escopo m√≠nimo causa menos re-renders
- **Leverage Component Boundaries:** Componentes s√£o boundaries naturais de otimiza√ß√£o
- **Compose with Children:** `children` prop √© ferramenta poderosa de performance
- **Avoid Inline Objects/Functions:** Criar objetos/fun√ß√µes inline quebra memoiza√ß√£o
- **Think in React:** Seguir modelo mental React resulta em c√≥digo perform√°tico

### Vis√£o Geral das Nuances

- **Trade-off Granularidade:** Muitos componentes pequenos vs poucos grandes
- **When to Split:** Quando dividir componente melhora performance vs adiciona complexidade
- **Premature Optimization:** Quando aplicar patterns preventivamente vs reativamente
- **Composability:** Patterns que melhoram performance geralmente melhoram composi√ß√£o
- **Mental Models:** Visualizar fluxo de re-renders ajuda escolher estrutura correta

---

## üß† Fundamentos Te√≥ricos

### Como Re-renders Propagam

#### O Modelo de Propaga√ß√£o Padr√£o

**Regra Fundamental do React:** Quando componente re-renderiza, **todos os filhos** tamb√©m re-renderizam por padr√£o.

```javascript
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>+</button>
      <Child /> {/* Re-renderiza TODA VEZ que Parent re-renderiza */}
    </div>
  );
}

function Child() {
  console.log('Child renderizou'); // Imprime a cada click!
  return <div>Sou child</div>;
}
```

**Por qu√™ isso acontece?**

React n√£o sabe se Child depende de algo dentro de Parent. Para seguran√ßa (corre√ß√£o), assume que pode depender e re-renderiza. √â **conservador**: prefere re-renderizar demais do que de menos.

#### Quando Re-renders Param (Bailout)

Re-render **n√£o** propaga se:

1. **Componente est√° memoizado** (React.memo) e props n√£o mudaram
2. **Estado n√£o mudou** (setState com mesmo valor)
3. **Context n√£o mudou** (para consumidores de context)

**Exemplo com memo:**

```javascript
const ChildMemo = React.memo(function Child() {
  console.log('Child renderizou');
  return <div>Sou child</div>;
});

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>+</button>
      <ChildMemo /> {/* N√ÉO re-renderiza (sem props, nada mudou) */}
    </div>
  );
}
```

**Conceito de Bailout:** React "desiste" de re-renderizar sub√°rvore quando detecta que n√£o √© necess√°rio.

### State Colocation: Conceito Profundo

**Defini√ß√£o:** "State should live as close as possible to where it's used"

**Princ√≠pio:** Se estado √© usado apenas por um componente, deve viver nesse componente. N√£o no pai, n√£o globalmente.

**Exemplo Ruim (estado elevado desnecessariamente):**

```javascript
function App() {
  const [searchQuery, setSearchQuery] = useState(''); // Usado apenas em SearchBar!

  return (
    <div>
      <Header />
      <SearchBar query={searchQuery} onChange={setSearchQuery} />
      <MainContent /> {/* Re-renderiza quando searchQuery muda! */}
      <Footer />
    </div>
  );
}
```

**Problema:** `searchQuery` muda ‚Üí App re-renderiza ‚Üí Header, MainContent, Footer re-renderizam desnecessariamente.

**Exemplo Bom (estado colocado corretamente):**

```javascript
function App() {
  return (
    <div>
      <Header />
      <SearchBar /> {/* Estado interno */}
      <MainContent />
      <Footer />
    </div>
  );
}

function SearchBar() {
  const [searchQuery, setSearchQuery] = useState(''); // Estado local!

  return <input value={searchQuery} onChange={e => setSearchQuery(e.target.value)} />;
}
```

**Benef√≠cio:** `searchQuery` muda ‚Üí apenas SearchBar re-renderiza. Resto da app n√£o √© afetado.

**M√©trica:** Se App tinha 1000 componentes e searchQuery mudava a cada keystroke, economiza 999 re-renders por keystroke!

### Lifting Content Up: Padr√£o Contra-Intuitivo

**Problema Cl√°ssico:**

```javascript
function App() {
  const [color, setColor] = useState('blue');

  return (
    <div style={{ backgroundColor: color }}>
      <Header /> {/* Componente pesado */}
      <Sidebar /> {/* Componente pesado */}
      <MainContent /> {/* Componente pesado */}
      <ColorPicker value={color} onChange={setColor} />
    </div>
  );
}
```

**Problema:** Mudar `color` re-renderiza Header, Sidebar, MainContent (que n√£o dependem de color).

**Solu√ß√£o - Lifting Content Up:**

```javascript
function App() {
  return (
    <ColoredContainer>
      <Header />
      <Sidebar />
      <MainContent />
      <ColorPicker /> {/* Passa conte√∫do como children */}
    </ColoredContainer>
  );
}

function ColoredContainer({ children }) {
  const [color, setColor] = useState('blue');

  return (
    <div style={{ backgroundColor: color }}>
      {children} {/* Children N√ÉO re-renderizam quando color muda! */}
      <ColorPicker value={color} onChange={setColor} />
    </div>
  );
}
```

**Por qu√™ funciona?**

`children` √© **prop** passada para ColoredContainer. Quando ColoredContainer re-renderiza (color muda), children √© a **mesma refer√™ncia** (mesmos elementos criados em App). React faz bailout de children.

**Conceito Crucial:** Elementos React (resultado de JSX) s√£o objetos imut√°veis. Se refer√™ncia n√£o muda, React sabe que conte√∫do √© igual.

### Children como Escape Hatch

**Pattern:** Passar componentes como `children` para "escapar" de re-renders.

**Exemplo sem pattern:**

```javascript
function ExpensivePage() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <HeavyHeader /> {/* Re-renderiza a cada count++ */}
      <HeavyContent /> {/* Re-renderiza a cada count++ */}
      <Counter count={count} onChange={setCount} />
      <HeavyFooter /> {/* Re-renderiza a cada count++ */}
    </div>
  );
}
```

**Com pattern:**

```javascript
function ExpensivePage() {
  return (
    <CounterProvider>
      <HeavyHeader />
      <HeavyContent />
      <Counter /> {/* Consome estado de CounterProvider */}
      <HeavyFooter />
    </CounterProvider>
  );
}

function CounterProvider({ children }) {
  const [count, setCount] = useState(0);

  return (
    <div>
      {children} {/* N√ÉO re-renderizam quando count muda */}
      {/* Apenas Counter (que consome count) re-renderiza */}
    </div>
  );
}
```

**Resultado:** Heavy components n√£o re-renderizam quando count muda.

### Princ√≠pios e Conceitos Subjacentes

#### 1. Component Boundaries como Optimization Points

Cada componente √© um **ponto potencial de otimiza√ß√£o**:

- Componente pode ser memoizado (React.memo)
- Componente encapsula estado (state colocation)
- Componente pode isolar mudan√ßas (children pattern)

**Implica√ß√£o:** Estrutura de componentes n√£o √© apenas organiza√ß√£o - √© ferramenta de performance.

#### 2. Reference Equality vs Value Equality

React usa **reference equality** (`===`) para decidir se props mudaram:

```javascript
const obj1 = { x: 1 };
const obj2 = { x: 1 };
obj1 === obj2; // false - diferentes refer√™ncias!

const obj3 = obj1;
obj1 === obj3; // true - mesma refer√™ncia
```

**Implica√ß√£o para Performance:**

```javascript
// ‚ùå Cria novo objeto a cada render
<Component data={{ x: 1 }} />

// ‚úÖ Mesma refer√™ncia (se conte√∫do n√£o muda)
const data = useMemo(() => ({ x: 1 }), []);
<Component data={data} />
```

#### 3. Custo Relativo de Re-renders

Nem todo re-render √© caro:

- **Barato:** Componente simples (< 1ms)
- **M√©dio:** Componente com l√≥gica moderada (1-10ms)
- **Caro:** Componente com muitos filhos ou c√°lculos pesados (> 10ms)

**Princ√≠pio:** Otimizar cascatas que afetam componentes **caros**. Re-renders de componentes baratos s√£o aceit√°veis.

#### 4. Composi√ß√£o vs Heran√ßa

React favorece **composi√ß√£o** - combinar componentes simples para criar complexos:

```javascript
// Composi√ß√£o permite isolar mudan√ßas
<Layout>
  <StaticHeader />
  <DynamicContent /> {/* Apenas esta parte re-renderiza */}
  <StaticFooter />
</Layout>
```

**Heran√ßa** (classes estendendo classes) n√£o oferece mesma flexibilidade de isolamento.

### Rela√ß√£o com Outros Conceitos

#### Virtual DOM e Reconcilia√ß√£o

Performance Patterns reduzem trabalho **antes** do Virtual DOM:

```
Sem patterns: 1000 componentes executam ‚Üí 1000 VDOMs criados ‚Üí Reconcilia√ß√£o
Com patterns: 10 componentes executam ‚Üí 10 VDOMs criados ‚Üí Reconcilia√ß√£o
```

**Economia:** Menos componentes executando = menos trabalho para React em todas as fases.

#### React.memo e Memoiza√ß√£o

Patterns **complementam** memoiza√ß√£o:

- **Patterns:** Estrutura para minimizar re-renders
- **Memoiza√ß√£o:** Otimiza√ß√£o adicional quando estrutura n√£o √© suficiente

**Ordem de aplica√ß√£o:**
1. Aplicar patterns (state colocation, children, etc)
2. Profile para ver se ainda h√° problemas
3. Aplicar memoiza√ß√£o onde necess√°rio

**N√£o o inverso!** Memoizar estrutura ruim apenas mascara problema.

---

## üîç An√°lise Conceitual Profunda

### Pattern: State Colocation

#### Sintaxe e Exemplos

**Exemplo Completo:**

```javascript
// ‚ùå Estado elevado desnecessariamente
function Dashboard() {
  const [userMenuOpen, setUserMenuOpen] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  return (
    <div>
      <Header
        userMenuOpen={userMenuOpen}
        onUserMenuToggle={setUserMenuOpen}
        searchQuery={searchQuery}
        onSearchChange={setSearchQuery}
      />
      <Sidebar
        collapsed={sidebarCollapsed}
        onToggle={setSidebarCollapsed}
      />
      <MainContent /> {/* Re-renderiza quando QUALQUER estado muda */}
      <Footer />
    </div>
  );
}

// ‚úÖ Estado colocado nos componentes que o usam
function Dashboard() {
  return (
    <div>
      <Header /> {/* Estado userMenuOpen e searchQuery aqui dentro */}
      <Sidebar /> {/* Estado sidebarCollapsed aqui dentro */}
      <MainContent />
      <Footer />
    </div>
  );
}

function Header() {
  const [userMenuOpen, setUserMenuOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  // Apenas Header re-renderiza quando estados mudam
  return (/* ... */);
}

function Sidebar() {
  const [collapsed, setCollapsed] = useState(false);

  // Apenas Sidebar re-renderiza quando estado muda
  return (/* ... */);
}
```

**M√©trica de Melhoria:**

- **Antes:** 3 estados √ó 100 componentes filhos = 300 re-renders por mudan√ßa
- **Depois:** 1 componente re-renderiza por mudan√ßa
- **Melhoria:** 99.7% de redu√ß√£o!

#### Quando Elevar Estado vs Manter Local

**Elevar estado quando:**
- M√∫ltiplos componentes precisam do mesmo estado
- Estado deve sincronizar entre componentes
- Estado √© parte de "business logic" global

**Manter local quando:**
- Estado √© UI-only (menus abertos, tabs selecionadas)
- Apenas um componente usa
- Estado n√£o precisa persistir (pode resetar ao desmontar)

**Regra de Ouro:** Mantenha local por padr√£o. Eleve apenas quando necess√°rio.

### Pattern: Lifting Content Up

#### Sintaxe Detalhada

**Problema a Resolver:**

```javascript
// Componente com estado que re-renderiza conte√∫do pesado
function ExpensiveApp() {
  const [theme, setTheme] = useState('light');

  return (
    <div className={theme}>
      <VeryExpensiveComponent /> {/* Re-renderiza quando theme muda */}
      <AnotherExpensiveComponent />
      <ThemeSwitcher value={theme} onChange={setTheme} />
    </div>
  );
}
```

**Solu√ß√£o - Wrapper com Children:**

```javascript
// Conte√∫do "elevado" para fora do componente com estado
function ExpensiveApp() {
  return (
    <ThemedContainer>
      <VeryExpensiveComponent /> {/* N√ÉO re-renderiza quando theme muda */}
      <AnotherExpensiveComponent />
    </ThemedContainer>
  );
}

function ThemedContainer({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <div className={theme}>
      {children} {/* Prop est√°vel, React faz bailout */}
      <ThemeSwitcher value={theme} onChange={setTheme} />
    </div>
  );
}
```

**Por qu√™ funciona - Explica√ß√£o T√©cnica:**

1. `<VeryExpensiveComponent />` √© criado em `ExpensiveApp`
2. Passado como `children` prop para `ThemedContainer`
3. Quando `theme` muda, `ThemedContainer` re-renderiza
4. React compara `children` prop (refer√™ncia)
5. Refer√™ncia √© igual (mesmos elementos criados em `ExpensiveApp`)
6. React faz **bailout** - n√£o re-renderiza children

**Conceito Chave:** Children √© **prop**, e props com mesma refer√™ncia n√£o causam re-render.

#### Varia√ß√£o: Render Props

```javascript
function ThemedContainer({ header, content, footer }) {
  const [theme, setTheme] = useState('light');

  return (
    <div className={theme}>
      {header} {/* Est√°vel */}
      {content} {/* Est√°vel */}
      {footer} {/* Est√°vel */}
      <ThemeSwitcher value={theme} onChange={setTheme} />
    </div>
  );
}

// Uso
<ThemedContainer
  header={<Header />}
  content={<MainContent />}
  footer={<Footer />}
/>
```

**Benef√≠cio:** M√∫ltiplos "slots" para conte√∫do est√°vel.

### Pattern: Component Splitting

#### Dividir Componentes Estrategicamente

**Princ√≠pio:** Componente grande com estado ‚Üí dividir em componente pequeno (com estado) + componentes est√°ticos.

**Exemplo Antes:**

```javascript
function ProductPage({ productId }) {
  const [quantity, setQuantity] = useState(1);
  const [selectedColor, setSelectedColor] = useState('blue');
  const [reviewsExpanded, setReviewsExpanded] = useState(false);

  return (
    <div>
      <ProductImages productId={productId} /> {/* Re-renderiza */}
      <ProductTitle productId={productId} /> {/* Re-renderiza */}
      <ProductDescription productId={productId} /> {/* Re-renderiza */}

      <QuantitySelector value={quantity} onChange={setQuantity} />
      <ColorPicker value={selectedColor} onChange={setSelectedColor} />

      <Reviews
        productId={productId}
        expanded={reviewsExpanded}
        onToggle={setReviewsExpanded}
      />
    </div>
  );
}
```

**Problema:** Mudar `quantity` re-renderiza TUDO (ProductImages, Title, Description, Reviews).

**Solu√ß√£o - Dividir:**

```javascript
function ProductPage({ productId }) {
  return (
    <div>
      <StaticProductInfo productId={productId} />
      <DynamicPurchaseOptions />
      <ReviewsSection productId={productId} />
    </div>
  );
}

// Componentes est√°ticos (s√≥ dependem de productId)
const StaticProductInfo = React.memo(function StaticProductInfo({ productId }) {
  return (
    <>
      <ProductImages productId={productId} />
      <ProductTitle productId={productId} />
      <ProductDescription productId={productId} />
    </>
  );
});

// Componente com estado (isolado)
function DynamicPurchaseOptions() {
  const [quantity, setQuantity] = useState(1);
  const [selectedColor, setSelectedColor] = useState('blue');

  return (
    <>
      <QuantitySelector value={quantity} onChange={setQuantity} />
      <ColorPicker value={selectedColor} onChange={setSelectedColor} />
    </>
  );
}

// Outro componente com estado pr√≥prio
function ReviewsSection({ productId }) {
  const [expanded, setExpanded] = useState(false);

  return (
    <Reviews
      productId={productId}
      expanded={expanded}
      onToggle={setExpanded}
    />
  );
}
```

**Resultado:**
- Mudar `quantity` ‚Üí apenas `DynamicPurchaseOptions` re-renderiza
- Mudar `expanded` ‚Üí apenas `ReviewsSection` re-renderiza
- `StaticProductInfo` nunca re-renderiza (memoizado, productId est√°vel)

#### Quando Dividir

**Divida quando:**
- Componente tem m√∫ltiplos estados independentes
- Parte do componente √© est√°tica, parte din√¢mica
- Re-renders frequentes afetam partes n√£o relacionadas

**N√£o divida quando:**
- Componente j√° √© pequeno/simples
- Estados s√£o fortemente acoplados
- Dividir cria complexidade sem benef√≠cio mensur√°vel

### Pattern: Evitar Inline Objects/Functions

#### Problema de Inline Objects

```javascript
const UserCard = React.memo(function UserCard({ user, style }) {
  console.log('UserCard renderizou');
  return <div style={style}>{user.name}</div>;
});

function App() {
  const [count, setCount] = useState(0);
  const user = { name: 'Ana' };

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>+</button>
      <UserCard
        user={user}
        style={{ color: 'blue' }} // ‚ùå Novo objeto cada render!
      />
    </div>
  );
}
```

**Problema:** Mesmo com React.memo, `UserCard` re-renderiza a cada click porque `style` √© novo objeto cada vez.

**Solu√ß√£o 1 - Mover para Fora:**

```javascript
const userStyle = { color: 'blue' }; // Fora do componente

function App() {
  // ...
  return <UserCard user={user} style={userStyle} />; // Mesma refer√™ncia
}
```

**Solu√ß√£o 2 - useMemo:**

```javascript
function App() {
  const style = useMemo(() => ({ color: 'blue' }), []); // Memorizado
  return <UserCard user={user} style={style} />;
}
```

#### Problema de Inline Functions

```javascript
const Button = React.memo(function Button({ onClick }) {
  console.log('Button renderizou');
  return <button onClick={onClick}>Clique</button>;
});

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <Button onClick={() => console.log('clicked')} /> {/* ‚ùå Nova fun√ß√£o */}
    </div>
  );
}
```

**Solu√ß√£o - useCallback:**

```javascript
function App() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []); // Memorizado

  return <Button onClick={handleClick} />;
}
```

### Pattern: Slot Pattern (Named Children)

#### M√∫ltiplos Children Nomeados

```javascript
function Layout({ header, sidebar, content, footer }) {
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);

  return (
    <div className="layout">
      <div className="header">{header}</div>
      <div className={sidebarCollapsed ? 'sidebar collapsed' : 'sidebar'}>
        {sidebar}
        <button onClick={() => setSidebarCollapsed(!sidebarCollapsed)}>
          Toggle
        </button>
      </div>
      <div className="content">{content}</div>
      <div className="footer">{footer}</div>
    </div>
  );
}

// Uso
<Layout
  header={<Header />}
  sidebar={<Sidebar />}
  content={<MainContent />}
  footer={<Footer />}
/>
```

**Benef√≠cio:** Quando `sidebarCollapsed` muda, apenas `Layout` re-renderiza. Header, Sidebar, MainContent, Footer n√£o re-renderizam (props est√°veis).

### Pattern: Composition with Context

#### Combinar Context + Children

```javascript
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const contextValue = useMemo(() => ({
    theme,
    toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light')
  }), [theme]);

  return (
    <ThemeContext.Provider value={contextValue}>
      {children} {/* N√£o re-renderizam quando theme muda */}
    </ThemeContext.Provider>
  );
}
```

**Conceito:** Children n√£o re-renderizam quando context value muda. Apenas **consumidores** de context re-renderizam.

```javascript
function App() {
  return (
    <ThemeProvider>
      <Header /> {/* N√£o re-renderiza (n√£o consome context) */}
      <ThemedContent /> {/* Re-renderiza (consome context) */}
      <Footer /> {/* N√£o re-renderiza */}
    </ThemeProvider>
  );
}

function ThemedContent() {
  const { theme } = useContext(ThemeContext); // Consumidor
  return <div className={theme}>Conte√∫do</div>;
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Aplicar Cada Pattern

#### State Colocation

**Use quando:**
- Estado √© usado apenas por um componente
- Mudan√ßas de estado causam re-renders amplos desnecess√°rios
- Estado √© "detalhe de implementa√ß√£o" do componente (n√£o business logic global)

**Exemplo ideal:** Estado de UI (menus abertos, tabs selecionadas, formul√°rios locais).

#### Lifting Content Up

**Use quando:**
- Componente pai tem estado que muda frequentemente
- Filhos n√£o dependem desse estado
- Filhos s√£o pesados (render caro)

**Exemplo ideal:** Tema, configura√ß√µes visuais que afetam wrapper mas n√£o conte√∫do.

#### Component Splitting

**Use quando:**
- Componente grande tem m√∫ltiplos estados independentes
- Profile mostra que componente re-renderiza muito
- Parte do componente √© est√°tica, parte din√¢mica

**Exemplo ideal:** P√°ginas complexas com se√ß√µes independentes.

### Cen√°rios Pr√°ticos

#### Cen√°rio 1: Form com Preview

```javascript
// ‚ùå Preview re-renderiza a cada keystroke
function FormWithPreview() {
  const [formData, setFormData] = useState({ name: '', email: '' });

  return (
    <div>
      <FormInputs data={formData} onChange={setFormData} />
      <ExpensivePreview data={formData} /> {/* Re-renderiza sempre */}
    </div>
  );
}

// ‚úÖ Preview memoizado + useMemo para data
function FormWithPreview() {
  const [formData, setFormData] = useState({ name: '', email: '' });

  // S√≥ cria novo objeto quando valores mudam
  const previewData = useMemo(() => ({
    name: formData.name,
    email: formData.email
  }), [formData.name, formData.email]);

  return (
    <div>
      <FormInputs data={formData} onChange={setFormData} />
      <ExpensivePreviewMemo data={previewData} />
    </div>
  );
}

const ExpensivePreviewMemo = React.memo(ExpensivePreview);
```

#### Cen√°rio 2: Dashboard com Widgets

```javascript
// ‚ùå Todos widgets re-renderizam quando qualquer um muda
function Dashboard() {
  const [widget1Data, setWidget1Data] = useState(null);
  const [widget2Data, setWidget2Data] = useState(null);
  const [widget3Data, setWidget3Data] = useState(null);

  return (
    <div>
      <Widget1 data={widget1Data} onChange={setWidget1Data} />
      <Widget2 data={widget2Data} onChange={setWidget2Data} />
      <Widget3 data={widget3Data} onChange={setWidget3Data} />
    </div>
  );
}

// ‚úÖ Cada widget encapsula estado
function Dashboard() {
  return (
    <div>
      <Widget1 /> {/* Estado interno */}
      <Widget2 /> {/* Estado interno */}
      <Widget3 /> {/* Estado interno */}
    </div>
  );
}
```

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Trade-offs dos Patterns

#### Complexidade vs Performance

**Patterns adicionam complexidade:**
- Mais componentes (mais arquivos, mais navega√ß√£o)
- L√≥gica distribu√≠da (entender fluxo √© mais dif√≠cil)
- Overhead mental (raciocinar sobre boundaries)

**Vale a pena quando:**
- App tem problemas de performance mensur√°veis
- Patterns melhoram arquitetura al√©m de performance
- Equipe entende patterns

**N√£o vale quando:**
- App √© pequena/simples
- Performance j√° √© boa
- Complexidade adicional n√£o justifica

#### When to Optimize

**Otimize quando:**
- Profile mostra problema real (> 16ms renders)
- Usu√°rios reportam lentid√£o
- Aplica√ß√£o cresceu e performance degradou

**N√£o otimize quando:**
- "Parece" que pode ser lento (sem medi√ß√£o)
- Otimiza√ß√£o prematura antes de problema existir
- Adicionando complexidade preventivamente

**Regra de Ouro:** Profile first, optimize second.

### Limita√ß√µes dos Patterns

#### Children Pattern N√£o √© Universal

**Limita√ß√£o:** Children pattern funciona apenas se conte√∫do n√£o depende de estado do wrapper.

```javascript
// ‚ùå N√£o funciona - children precisam de `theme`
function ThemedContainer({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <div>
      {children} {/* Como children acessam theme? */}
    </div>
  );
}
```

**Solu√ß√£o:** Use Context para compartilhar `theme` com children.

#### State Colocation vs Shared State

**Conflito:** State colocation diz "mantenha estado local", mas muitas features precisam de estado compartilhado (carrinho de compras, autentica√ß√£o, etc).

**Resolu√ß√£o:**
- Estado de UI ‚Üí local
- Estado de business logic ‚Üí compartilhado (Context, Redux, etc)

### Armadilhas Comuns

#### Armadilha 1: Over-Splitting

```javascript
// ‚ùå Over-splitting - muitos componentes pequenos sem benef√≠cio
function Button() {
  return <ButtonWrapper><ButtonText>Clique</ButtonText></ButtonWrapper>;
}

function ButtonWrapper({ children }) {
  return <button>{children}</button>;
}

function ButtonText({ children }) {
  return <span>{children}</span>;
}
```

**Problema:** Complexidade sem ganho. Componentes muito pequenos dificultam leitura.

**Princ√≠pio:** Divida com prop√≥sito (performance, reusabilidade), n√£o arbitrariamente.

#### Armadilha 2: Memoizar Tudo

```javascript
// ‚ùå Memoiza√ß√£o excessiva
const Header = React.memo(Header);
const Footer = React.memo(Footer);
const Button = React.memo(Button);
// ... cada componente memoizado

// Overhead de compara√ß√£o pode ser maior que benef√≠cio
```

**Princ√≠pio:** Memoize apenas componentes caros que re-renderizam frequentemente com props est√°veis.

---

## üîó Interconex√µes Conceituais

### Patterns + Memoiza√ß√£o

Patterns **reduzem necessidade** de memoiza√ß√£o:

1. Aplicar patterns (state colocation, children, splitting)
2. Profile para ver impacto
3. Memoizar apenas onde patterns n√£o s√£o suficientes

**Sinergia:** Patterns + memoiza√ß√£o = m√°xima performance.

### Patterns + Concurrent Mode

Patterns facilitam concurrent rendering:
- Menos re-renders = menos trabalho para React gerenciar
- Boundaries claros = React pode interromper/retomar mais facilmente

### Patterns + Code Splitting

Componentes bem divididos s√£o mais f√°ceis de lazy load:

```javascript
// Componente dividido = chunks menores
const Widget1 = lazy(() => import('./Widget1'));
const Widget2 = lazy(() => import('./Widget2'));
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Desenvolvimento Natural

Ap√≥s dominar patterns b√°sicos:

1. **Advanced Composition:** Compound components, render props
2. **Performance Profiling:** Medir impacto de patterns
3. **State Management:** Context API patterns, Redux patterns
4. **Concurrent Patterns:** useTransition, useDeferredValue

### O Futuro

**React Compiler** automatizar√° muitos patterns, mas compreens√£o continua essencial:
- Debugging de otimiza√ß√µes autom√°ticas
- Casos que compiler n√£o cobre
- Arquitetura que facilita otimiza√ß√£o

**Filosofia Duradoura:** "Structure matters" √© atemporal. Boa arquitetura sempre ser√° base de performance.

---

## üìö Conclus√£o

Performance Patterns s√£o a **primeira linha de defesa** contra problemas de performance em React. Antes de adicionar memoiza√ß√£o, profiling complexo, ou otimiza√ß√µes avan√ßadas, estruture componentes corretamente.

**Princ√≠pios Chave:**
- **State Colocation:** Estado no menor escopo poss√≠vel
- **Lifting Content Up:** Elevar conte√∫do est√°tico para fora de componentes com estado
- **Children as Escape Hatch:** Usar children para isolar mudan√ßas
- **Component Splitting:** Dividir componentes grandes em pequenos focados

Dominar estes patterns resulta em aplica√ß√µes que s√£o perform√°ticas **por design**, n√£o por otimiza√ß√£o posterior. √â a diferen√ßa entre arquitetura que escala naturalmente e c√≥digo que precisa ser constantemente otimizado.
