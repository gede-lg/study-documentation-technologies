# Keyboard & Input Events no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Keyboard & Input Events** s√£o eventos especializados em **intera√ß√µes via teclado e entrada de dados** - detec√ß√£o de teclas pressionadas (onKeyDown, onKeyUp), captura de caracteres (onKeyPress - depreciado), distin√ß√£o entre element.target e currentTarget, e tratamento especial de inputs. Representam a **interface entre usu√°rio e aplica√ß√£o via teclado**, essenciais para acessibilidade, shortcuts, formul√°rios, e navega√ß√£o.

Esses eventos permitem criar **experi√™ncias ricas de teclado**: atalhos (Ctrl+S para salvar), navega√ß√£o (Tab, Enter, Esc), valida√ß√£o em tempo real, autocomplete, e muito mais. React normaliza eventos de teclado via SyntheticEvent, garantindo consist√™ncia cross-browser nas propriedades `key`, `keyCode` (depreciado), `code`, e modificadores (ctrl, shift, alt).

**Filosofia:** Keyboard events s√£o **primeira classe de acessibilidade** - usu√°rios power, pessoas com defici√™ncia, e casos onde mouse n√£o est√° dispon√≠vel dependem de teclado funcional.

### Contexto Hist√≥rico e Motiva√ß√£o

**Evolu√ß√£o dos keyboard events:**

**1990s-2000s: keyCode Era**
```javascript
// ‚ùå keyCode (n√∫meros m√°gicos, inconsistente)
if (event.keyCode === 13) { // Enter
  console.log('Enter pressed');
}
```

**Problemas:**
- N√∫meros m√°gicos (13 = Enter, 27 = Esc)
- Inconsistente entre browsers/layouts
- N√£o distingue tecla f√≠sica vs caractere

**2010s: key Property**
```javascript
// ‚úÖ key (strings leg√≠veis)
if (event.key === 'Enter') {
  console.log('Enter pressed');
}
```

**React:** Sempre usou eventos sint√©ticos, normalizando `key` e `keyCode`.

**2020s: code Property**
```javascript
// code: localiza√ß√£o f√≠sica da tecla (n√£o caractere)
if (event.code === 'KeyA') { // Tecla 'A' f√≠sica
  console.log('A key pressed (pode ser 'a', 'A', ou outro char dependendo de layout)');
}
```

**Motiva√ß√£o:** Criar interfaces que respondem a teclado de forma **intuitiva, acess√≠vel, e cross-platform**.

### Problema Fundamental que Resolve

**Sem keyboard events adequados:**

```javascript
// ‚ùå Usu√°rio n√£o pode usar teclado
function Modal({ onClose }) {
  return (
    <div className="modal">
      <button onClick={onClose}>Fechar</button>
      {/* Se usu√°rio pressionar Esc, nada acontece! */}
    </div>
  );
}

// ‚ùå Form n√£o responde a Enter
function SearchBox() {
  const [query, setQuery] = useState('');

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} />
      <button>Buscar</button>
      {/* Pressionar Enter no input n√£o busca */}
    </div>
  );
}
```

**Com keyboard events:**

```javascript
// ‚úÖ Modal fecha com Esc
function Modal({ onClose }) {
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [onClose]);

  return (
    <div className="modal">
      <button onClick={onClose}>Fechar (ou pressione Esc)</button>
    </div>
  );
}

// ‚úÖ Form responde a Enter
function SearchBox() {
  const [query, setQuery] = useState('');

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleSearch();
    }
  };

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      onKeyDown={handleKeyDown}
    />
  );
}
```

### Import√¢ncia no Ecossistema

Keyboard events s√£o **essenciais** para:

- **Acessibilidade**: Navega√ß√£o sem mouse (WCAG requirement)
- **UX**: Shortcuts (Ctrl+S, Ctrl+Z)
- **Produtividade**: Usu√°rios power preferem teclado
- **Jogos/Apps**: Controles via teclado

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **onKeyDown**: Tecla pressionada (detecta imediatamente)
2. **onKeyUp**: Tecla solta
3. **onKeyPress**: Depreciado (n√£o use)
4. **event.key**: Caractere ou nome da tecla
5. **event.code**: Localiza√ß√£o f√≠sica da tecla

### Pilares Fundamentais

- **event.key**: 'Enter', 'Escape', 'a', 'A', etc.
- **event.code**: 'KeyA', 'Enter', 'Space'
- **Modificadores**: ctrlKey, shiftKey, altKey, metaKey
- **target vs currentTarget**: Elemento que disparou vs elemento com listener
- **Accessibility**: Tab, Enter, Esc, Arrow keys

---

## üß† Fundamentos Te√≥ricos

### onKeyDown vs onKeyUp vs onKeyPress

**onKeyDown:** Dispara quando tecla √© pressionada (antes de caractere aparecer).
**onKeyUp:** Dispara quando tecla √© solta.
**onKeyPress:** Depreciado (n√£o use - substitu√≠do por onKeyDown).

```javascript
function KeyEvents() {
  const handleKeyDown = (e) => {
    console.log('Key down:', e.key);
  };

  const handleKeyUp = (e) => {
    console.log('Key up:', e.key);
  };

  return (
    <input
      onKeyDown={handleKeyDown}
      onKeyUp={handleKeyUp}
    />
  );
}

// Pressionar 'a':
// 1. onKeyDown ('a')
// 2. Caractere aparece no input
// 3. onKeyUp ('a')
```

### event.key vs event.code

**event.key:** Valor do caractere/tecla (depende de layout, Shift, etc).
**event.code:** Localiza√ß√£o f√≠sica da tecla.

```javascript
function KeyVsCode() {
  const handleKeyDown = (e) => {
    console.log('key:', e.key);     // 'a', 'A', 'Enter', 'Escape'
    console.log('code:', e.code);   // 'KeyA', 'Enter', 'Escape'
  };

  return <input onKeyDown={handleKeyDown} />;
}

// Pressionar 'A' (Shift+A):
// key: 'A' (uppercase)
// code: 'KeyA' (mesma tecla f√≠sica)

// Pressionar 'a':
// key: 'a' (lowercase)
// code: 'KeyA' (mesma tecla f√≠sica)
```

**Quando usar:**
- **key**: Atalhos l√≥gicos (Enter, Escape, caracteres)
- **code**: Jogos (WASD independente de layout)

### Modificadores

```javascript
function Modifiers() {
  const handleKeyDown = (e) => {
    console.log('Ctrl:', e.ctrlKey);
    console.log('Shift:', e.shiftKey);
    console.log('Alt:', e.altKey);
    console.log('Meta (Cmd/Win):', e.metaKey);

    // Detectar combina√ß√£o
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault(); // Previne Ctrl+S do browser
      console.log('Save shortcut!');
    }
  };

  return <input onKeyDown={handleKeyDown} />;
}
```

### target vs currentTarget

**event.target:** Elemento que **disparou** o evento (pode ser filho).
**event.currentTarget:** Elemento com **listener** (sempre o mesmo).

```javascript
function TargetExample() {
  const handleKeyDown = (e) => {
    console.log('target:', e.target);           // <input>
    console.log('currentTarget:', e.currentTarget); // <div>
  };

  return (
    <div onKeyDown={handleKeyDown}>
      <input placeholder="Digite aqui" />
    </div>
  );
}

// Digitar no input:
// target: input (filho, elemento real)
// currentTarget: div (parent, tem listener)
```

---

## üîç An√°lise Conceitual Profunda

### 9.2.1 Keyboard Shortcuts

```javascript
function KeyboardShortcuts() {
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Ctrl+S: Save
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        console.log('Salvando...');
      }

      // Ctrl+Z: Undo
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        console.log('Desfazendo...');
      }

      // Ctrl+Shift+Z: Redo
      if (e.ctrlKey && e.shiftKey && e.key === 'z') {
        e.preventDefault();
        console.log('Refazendo...');
      }

      // Escape: Fechar
      if (e.key === 'Escape') {
        console.log('Fechando...');
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);

  return <div>Pressione Ctrl+S, Ctrl+Z, Esc</div>;
}
```

**Hook reutiliz√°vel:**
```javascript
function useKeyPress(targetKey, callback, modifiers = {}) {
  useEffect(() => {
    const handleKeyDown = (e) => {
      const {
        ctrl = false,
        shift = false,
        alt = false,
        meta = false
      } = modifiers;

      if (
        e.key === targetKey &&
        e.ctrlKey === ctrl &&
        e.shiftKey === shift &&
        e.altKey === alt &&
        e.metaKey === meta
      ) {
        callback(e);
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [targetKey, callback, modifiers]);
}

// Uso
function App() {
  useKeyPress('s', (e) => {
    e.preventDefault();
    console.log('Save!');
  }, { ctrl: true });

  useKeyPress('Escape', () => {
    console.log('Close!');
  });

  return <div>App com shortcuts</div>;
}
```

### 9.2.2 Enter para Submit

```javascript
function EnterToSubmit() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleSearch = () => {
    console.log('Buscando:', query);
    // Fetch results
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleSearch();
    }
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Buscar (pressione Enter)"
      />
      <button onClick={handleSearch}>Buscar</button>
    </div>
  );
}
```

**Alternativa: Form onSubmit**
```javascript
function SearchForm() {
  const [query, setQuery] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Buscando:', query);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Buscar (Enter submits)"
      />
      <button type="submit">Buscar</button>
    </form>
  );
}
```

### 9.2.3 Escape para Fechar Modal

```javascript
function Modal({ isOpen, onClose, children }) {
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        {children}
        <button onClick={onClose}>Fechar (ou Esc)</button>
      </div>
    </div>
  );
}
```

### 9.2.4 Arrow Keys Navigation

```javascript
function ArrowKeyNavigation({ items }) {
  const [selectedIndex, setSelectedIndex] = useState(0);

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex(i => Math.min(i + 1, items.length - 1));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex(i => Math.max(i - 1, 0));
    } else if (e.key === 'Enter') {
      console.log('Selected:', items[selectedIndex]);
    }
  };

  return (
    <ul onKeyDown={handleKeyDown} tabIndex={0}>
      {items.map((item, index) => (
        <li
          key={item.id}
          style={{
            backgroundColor: index === selectedIndex ? 'lightblue' : 'white'
          }}
        >
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

### 9.2.5 Character Counter com KeyDown

```javascript
function CharacterCounter({ maxLength = 100 }) {
  const [text, setText] = useState('');

  const handleKeyDown = (e) => {
    // Previne digita√ß√£o se atingir limite (exceto backspace, delete)
    if (
      text.length >= maxLength &&
      e.key !== 'Backspace' &&
      e.key !== 'Delete' &&
      !e.ctrlKey && // Permitir Ctrl+A, Ctrl+C, etc
      !e.metaKey
    ) {
      e.preventDefault();
    }
  };

  return (
    <div>
      <textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        onKeyDown={handleKeyDown}
        rows={4}
      />
      <p>
        {text.length} / {maxLength}
      </p>
    </div>
  );
}
```

### 9.2.6 Tab Navigation Prevention

```javascript
function TabTrap() {
  const firstInputRef = useRef(null);
  const lastInputRef = useRef(null);

  const handleKeyDown = (e) => {
    if (e.key === 'Tab') {
      // Se Shift+Tab no primeiro, vai para √∫ltimo
      if (e.shiftKey && document.activeElement === firstInputRef.current) {
        e.preventDefault();
        lastInputRef.current.focus();
      }
      // Se Tab no √∫ltimo, vai para primeiro
      else if (!e.shiftKey && document.activeElement === lastInputRef.current) {
        e.preventDefault();
        firstInputRef.current.focus();
      }
    }
  };

  return (
    <div onKeyDown={handleKeyDown}>
      <input ref={firstInputRef} placeholder="Primeiro" />
      <input placeholder="Meio" />
      <input ref={lastInputRef} placeholder="√öltimo" />
    </div>
  );
}
```

### 9.2.7 Auto-complete com Arrow Keys

```javascript
function Autocomplete() {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [selectedIndex, setSelectedIndex] = useState(-1);

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex(i => Math.min(i + 1, suggestions.length - 1));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex(i => Math.max(i - 1, -1));
    } else if (e.key === 'Enter' && selectedIndex >= 0) {
      e.preventDefault();
      setQuery(suggestions[selectedIndex]);
      setSuggestions([]);
    } else if (e.key === 'Escape') {
      setSuggestions([]);
      setSelectedIndex(-1);
    }
  };

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    setSelectedIndex(-1);

    // Simular busca de sugest√µes
    if (value.length > 0) {
      setSuggestions(['Apple', 'Banana', 'Cherry'].filter(s =>
        s.toLowerCase().includes(value.toLowerCase())
      ));
    } else {
      setSuggestions([]);
    }
  };

  return (
    <div>
      <input
        value={query}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        placeholder="Digite frutas..."
      />
      {suggestions.length > 0 && (
        <ul>
          {suggestions.map((suggestion, index) => (
            <li
              key={suggestion}
              style={{
                backgroundColor: index === selectedIndex ? 'lightblue' : 'white'
              }}
              onClick={() => {
                setQuery(suggestion);
                setSuggestions([]);
              }}
            >
              {suggestion}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Teclas Comuns

**Navega√ß√£o:**
- `Enter`: Submit, selecionar
- `Escape`: Cancelar, fechar
- `Tab`: Navegar entre campos
- `ArrowUp/Down/Left/Right`: Navega√ß√£o direcional
- `Space`: Toggle, scroll

**Edi√ß√£o:**
- `Backspace`: Deletar anterior
- `Delete`: Deletar posterior
- `Home/End`: In√≠cio/fim de linha
- `PageUp/PageDown`: Scroll p√°gina

**Modificadores:**
- `Ctrl+S`: Salvar
- `Ctrl+Z`: Desfazer
- `Ctrl+C/V/X`: Copiar/colar/cortar
- `Ctrl+A`: Selecionar tudo

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Accessibility

**Sempre forne√ßa alternativas:**
```javascript
// ‚úÖ Funciona com mouse E teclado
<button onClick={handleAction} onKeyDown={(e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    handleAction();
  }
}}>
  A√ß√£o
</button>
```

### Browser Shortcuts

**Cuidado ao prevenir defaults:**
```javascript
// ‚ùå Impede Ctrl+T (nova tab), Ctrl+W (fechar)
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey) {
    e.preventDefault(); // Muito amplo!
  }
});

// ‚úÖ Previne apenas shortcuts espec√≠ficas
if (e.ctrlKey && e.key === 's') {
  e.preventDefault(); // OK
}
```

### Mobile Keyboards

**Keyboard events em mobile:**
- Nem todos eventos funcionam igual
- Virtual keyboards t√™m comportamentos diferentes
- Teste em dispositivos reais

---

## üîó Interconex√µes Conceituais

### Rela√ß√£o com Accessibility

Keyboard navigation √© requirement WCAG (acessibilidade).

### Rela√ß√£o com Forms

Enter, Tab, Escape s√£o essenciais para UX de formul√°rios.

### Rela√ß√£o com UX

Keyboard shortcuts melhoram produtividade de power users.

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Progress√£o Natural

```
Eventos b√°sicos (onClick)
    ‚Üì
Keyboard events (onKeyDown)
    ‚Üì
Shortcuts complexos (Ctrl+Key)
    ‚Üì
Accessibility completa (Tab, ARIA)
```

---

## üìö Conclus√£o

Keyboard & Input Events s√£o **essenciais** para acessibilidade e UX. Princ√≠pios:

1. **onKeyDown**: Detec√ß√£o de teclas (preferir sobre onKeyPress)
2. **event.key**: Valor l√≥gico da tecla
3. **event.code**: Posi√ß√£o f√≠sica da tecla
4. **Modificadores**: ctrlKey, shiftKey, altKey, metaKey
5. **Accessibility**: Sempre suporte teclado

**Recomenda√ß√µes:**
- Use onKeyDown (n√£o onKeyPress depreciado)
- event.key para atalhos l√≥gicos
- event.code para jogos/posi√ß√£o f√≠sica
- Sempre previna defaults apenas quando necess√°rio
- Teste com teclado (n√£o apenas mouse)
- Forne√ßa visual feedback para keyboard focus

**Dominar keyboard events = interfaces acess√≠veis e produtivas.**
