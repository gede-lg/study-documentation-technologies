# Other Events no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Other Events** engloba eventos especializados al√©m de click/keyboard: **scroll** (onScroll), **touch** (onTouchStart/Move/End), e **drag & drop** (onDrag/Drop). Representam intera√ß√µes avan√ßadas que v√£o al√©m do b√°sico - scroll infinito, gestures mobile, drag-and-drop de arquivos/elementos. S√£o eventos que criam **experi√™ncias ricas e modernas**.

Esses eventos permitem **interfaces nativas-like** - swipe gestures em mobile, drag para reordenar listas, lazy loading ao scroll, parallax effects. React normaliza esses eventos complexos via SyntheticEvent, mas preserva acesso a APIs nativas quando necess√°rio (touches, dataTransfer).

**Filosofia:** Modern UX vai al√©m de click - usu√°rios esperam scroll responsivo, touch gestures em mobile, drag-and-drop intuitivo. Esses eventos s√£o ponte para experi√™ncias **mobile-first** e **interaction-rich**.

### Import√¢ncia no Ecossistema

Other events s√£o **essenciais** para:

- **Mobile**: Touch gestures (swipe, pinch, rotate)
- **Performance**: Scroll events para lazy loading
- **UX avan√ßada**: Drag-and-drop para reordenar
- **Engagement**: Parallax, scroll-triggered animations

---

## üìã Sum√°rio Conceitual

### Eventos Cobertos

1. **onScroll**: Detec√ß√£o de rolagem
2. **Touch Events**: onTouchStart, onTouchMove, onTouchEnd
3. **Drag Events**: onDrag, onDrop, onDragOver

---

## üîç An√°lise Conceitual Profunda

### 9.3.1 onScroll: Eventos de Scroll

```javascript
function ScrollExamples() {
  const [scrollPosition, setScrollPosition] = useState(0);
  const [isAtBottom, setIsAtBottom] = useState(false);

  const handleScroll = (e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.target;

    // Posi√ß√£o do scroll
    setScrollPosition(scrollTop);

    // Detectar fim da p√°gina
    const bottom = scrollHeight - scrollTop === clientHeight;
    setIsAtBottom(bottom);
  };

  return (
    <div
      onScroll={handleScroll}
      style={{
        height: '300px',
        overflow: 'auto',
        border: '1px solid black'
      }}
    >
      <p>Scroll position: {scrollPosition}px</p>
      <p>{isAtBottom && 'Chegou ao fim!'}</p>
      <div style={{ height: '1000px' }}>
        Conte√∫do longo...
      </div>
    </div>
  );
}
```

**Infinite Scroll:**
```javascript
function InfiniteScroll() {
  const [items, setItems] = useState(Array.from({ length: 20 }, (_, i) => i));
  const [loading, setLoading] = useState(false);

  const handleScroll = (e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.target;

    // Se scroll est√° pr√≥ximo do fim (100px)
    if (scrollHeight - scrollTop - clientHeight < 100 && !loading) {
      loadMore();
    }
  };

  const loadMore = async () => {
    setLoading(true);
    // Simular API call
    await new Promise(resolve => setTimeout(resolve, 1000));
    setItems(prev => [...prev, ...Array.from({ length: 20 }, (_, i) => prev.length + i)]);
    setLoading(false);
  };

  return (
    <div
      onScroll={handleScroll}
      style={{ height: '400px', overflow: 'auto' }}
    >
      {items.map(item => (
        <div key={item} style={{ padding: '10px', borderBottom: '1px solid #ddd' }}>
          Item {item}
        </div>
      ))}
      {loading && <p>Carregando...</p>}
    </div>
  );
}
```

**Scroll Progress Bar:**
```javascript
function ScrollProgress() {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    const handleScroll = () => {
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      const scrollTop = window.scrollY;

      const totalHeight = documentHeight - windowHeight;
      const scrollProgress = (scrollTop / totalHeight) * 100;

      setProgress(scrollProgress);
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: `${progress}%`,
        height: '4px',
        backgroundColor: 'blue',
        transition: 'width 0.2s'
      }}
    />
  );
}
```

### 9.3.2 Touch Events: Gestures Mobile

```javascript
function TouchExamples() {
  const [touchStart, setTouchStart] = useState(null);
  const [touchEnd, setTouchEnd] = useState(null);
  const [swipeDirection, setSwipeDirection] = useState('');

  const minSwipeDistance = 50;

  const onTouchStart = (e) => {
    setTouchEnd(null);
    setTouchStart(e.targetTouches[0].clientX);
  };

  const onTouchMove = (e) => {
    setTouchEnd(e.targetTouches[0].clientX);
  };

  const onTouchEnd = () => {
    if (!touchStart || !touchEnd) return;

    const distance = touchStart - touchEnd;
    const isLeftSwipe = distance > minSwipeDistance;
    const isRightSwipe = distance < -minSwipeDistance;

    if (isLeftSwipe) {
      setSwipeDirection('left');
    } else if (isRightSwipe) {
      setSwipeDirection('right');
    }
  };

  return (
    <div
      onTouchStart={onTouchStart}
      onTouchMove={onTouchMove}
      onTouchEnd={onTouchEnd}
      style={{
        width: '300px',
        height: '200px',
        border: '2px solid black',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      Swipe aqui! Dire√ß√£o: {swipeDirection || 'nenhuma'}
    </div>
  );
}
```

**Swipeable Cards:**
```javascript
function SwipeableCard({ onSwipeLeft, onSwipeRight, children }) {
  const [touchStart, setTouchStart] = useState(0);
  const [touchCurrent, setTouchCurrent] = useState(0);
  const [isSwiping, setIsSwiping] = useState(false);

  const handleTouchStart = (e) => {
    setTouchStart(e.touches[0].clientX);
    setIsSwiping(true);
  };

  const handleTouchMove = (e) => {
    if (!isSwiping) return;
    setTouchCurrent(e.touches[0].clientX);
  };

  const handleTouchEnd = () => {
    const diff = touchCurrent - touchStart;

    if (diff > 100) {
      onSwipeRight?.();
    } else if (diff < -100) {
      onSwipeLeft?.();
    }

    setIsSwiping(false);
    setTouchCurrent(0);
  };

  const offset = isSwiping ? touchCurrent - touchStart : 0;

  return (
    <div
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      style={{
        transform: `translateX(${offset}px)`,
        transition: isSwiping ? 'none' : 'transform 0.3s',
        cursor: 'grab'
      }}
    >
      {children}
    </div>
  );
}
```

### 9.3.3 Drag & Drop Events

```javascript
function DragDropExample() {
  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3']);
  const [draggedItem, setDraggedItem] = useState(null);

  const handleDragStart = (e, index) => {
    setDraggedItem(index);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e, index) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    if (draggedItem === index) return;

    const newItems = [...items];
    const draggedContent = newItems[draggedItem];

    newItems.splice(draggedItem, 1);
    newItems.splice(index, 0, draggedContent);

    setDraggedItem(index);
    setItems(newItems);
  };

  const handleDrop = (e) => {
    e.preventDefault();
    setDraggedItem(null);
  };

  return (
    <div>
      {items.map((item, index) => (
        <div
          key={item}
          draggable
          onDragStart={(e) => handleDragStart(e, index)}
          onDragOver={(e) => handleDragOver(e, index)}
          onDrop={handleDrop}
          style={{
            padding: '10px',
            margin: '5px',
            backgroundColor: draggedItem === index ? 'lightblue' : 'white',
            border: '1px solid black',
            cursor: 'move'
          }}
        >
          {item}
        </div>
      ))}
    </div>
  );
}
```

**File Upload com Drag & Drop:**
```javascript
function FileDropZone() {
  const [files, setFiles] = useState([]);
  const [isDragging, setIsDragging] = useState(false);

  const handleDragEnter = (e) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };

  const handleDrop = (e) => {
    e.preventDefault();
    setIsDragging(false);

    const droppedFiles = Array.from(e.dataTransfer.files);
    setFiles(prev => [...prev, ...droppedFiles]);
  };

  return (
    <div>
      <div
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        style={{
          width: '300px',
          height: '200px',
          border: `2px dashed ${isDragging ? 'blue' : 'gray'}`,
          backgroundColor: isDragging ? 'lightblue' : 'white',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}
      >
        {isDragging ? 'Solte aqui!' : 'Arraste arquivos aqui'}
      </div>

      <ul>
        {files.map((file, index) => (
          <li key={index}>{file.name} ({file.size} bytes)</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## üìö Conclus√£o

Other Events expandem possibilidades de intera√ß√£o:

1. **onScroll**: Infinite scroll, progress bars
2. **Touch**: Swipe gestures, mobile UX
3. **Drag & Drop**: Reordenar, upload de arquivos

**Recomenda√ß√µes:**
- Debounce scroll events (performance)
- Touch events para mobile-first
- Drag & drop para interfaces ricas
- Sempre previna defaults quando necess√°rio

**Dominar outros eventos = UX moderna e engajadora.**
