# Event Handling Avan√ßado no React

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Event Handling Avan√ßado** cobre t√©cnicas sofisticadas de manipula√ß√£o de eventos: **controle de fluxo** (preventDefault, stopPropagation, bubbling/capturing), **passagem de argumentos** para handlers, **debouncing e throttling** para otimiza√ß√£o, e **patterns avan√ßados** de event delegation. Representa dom√≠nio completo do sistema de eventos React para casos complexos.

Essas t√©cnicas permitem **controle fino** sobre propaga√ß√£o de eventos, performance otimizada em listas/scroll handlers, e arquiteturas escal√°veis. S√£o ferramentas para resolver problemas reais: prevenir m√∫ltiplos submits, otimizar re-renders, criar event handlers reutiliz√°veis.

**Filosofia:** Event handling b√°sico √© suficiente para 80% dos casos. T√©cnicas avan√ßadas resolvem os 20% complexos - quando performance importa, quando eventos precisam ser coordenados, quando DRY √© cr√≠tico.

---

## üìã Sum√°rio Conceitual

### T√≥picos Cobertos

1. **preventDefault()**: Prevenir comportamento padr√£o
2. **stopPropagation()**: Parar bubbling
3. **Event Bubbling & Capturing**: Fases de eventos
4. **Passagem de Argumentos**: Currying e closures
5. **Debouncing & Throttling**: Otimiza√ß√£o de performance

---

## üîç An√°lise Conceitual Profunda

### 9.4.1 preventDefault(): Prevenir Comportamento Padr√£o

```javascript
function PreventDefaultExamples() {
  // 1. Prevenir submit de form
  const handleSubmit = (e) => {
    e.preventDefault(); // N√£o recarrega p√°gina
    console.log('Form submitted');
  };

  // 2. Prevenir navega√ß√£o de link
  const handleLinkClick = (e) => {
    e.preventDefault(); // N√£o navega
    console.log('Link clicado, mas n√£o navegou');
  };

  // 3. Prevenir context menu (right-click)
  const handleContextMenu = (e) => {
    e.preventDefault(); // N√£o abre menu padr√£o
    console.log('Custom context menu');
  };

  // 4. Prevenir shortcuts do browser
  const handleKeyDown = (e) => {
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault(); // N√£o abre "Salvar p√°gina"
      console.log('Custom save');
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input type="text" />
        <button type="submit">Submit (n√£o recarrega)</button>
      </form>

      <a href="https://google.com" onClick={handleLinkClick}>
        Link (n√£o navega)
      </a>

      <div onContextMenu={handleContextMenu}>
        Right-click aqui (custom menu)
      </div>

      <input onKeyDown={handleKeyDown} placeholder="Ctrl+S para salvar" />
    </div>
  );
}
```

**Exemplo: Prevenir Double Submit**
```javascript
function FormWithPreventDoubleSubmit() {
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (submitting) return; // Previne double submit

    setSubmitting(true);

    try {
      await fetch('/api/submit', {
        method: 'POST',
        body: new FormData(e.target)
      });
      alert('Enviado!');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="email" type="email" required />
      <button type="submit" disabled={submitting}>
        {submitting ? 'Enviando...' : 'Enviar'}
      </button>
    </form>
  );
}
```

### 9.4.2 stopPropagation(): Parar Bubbling

```javascript
function StopPropagationExample() {
  const handleDivClick = () => {
    console.log('Div clicada');
  };

  const handleButtonClick = (e) => {
    e.stopPropagation(); // Para propaga√ß√£o para div
    console.log('Bot√£o clicado (n√£o propaga)');
  };

  return (
    <div onClick={handleDivClick} style={{ padding: '20px', border: '1px solid black' }}>
      Clique na div
      <button onClick={handleButtonClick}>
        Bot√£o (n√£o propaga)
      </button>
    </div>
  );
}

// Clicar bot√£o: apenas "Bot√£o clicado"
// Clicar div: "Div clicada"
```

**Exemplo: Modal Overlay**
```javascript
function Modal({ isOpen, onClose, children }) {
  if (!isOpen) return null;

  return (
    <div
      className="modal-overlay"
      onClick={onClose} // Fechar ao clicar overlay
    >
      <div
        className="modal-content"
        onClick={(e) => e.stopPropagation()} // N√ÉO fechar ao clicar conte√∫do
      >
        {children}
        <button onClick={onClose}>Fechar</button>
      </div>
    </div>
  );
}
```

**stopImmediatePropagation():**
```javascript
function ImmediateExample() {
  const handleClick1 = (e) => {
    console.log('Handler 1');
    e.stopImmediatePropagation(); // Para TODOS handlers seguintes
  };

  const handleClick2 = () => {
    console.log('Handler 2'); // N√£o executa
  };

  return (
    <button
      onClick={(e) => {
        handleClick1(e);
        handleClick2(); // N√£o executa se stopImmediatePropagation
      }}
    >
      Click
    </button>
  );
}
```

### 9.4.3 Event Bubbling & Capturing

**Fases de eventos:**
1. **Capturing (descendo)**: De root at√© target
2. **Target**: Elemento alvo
3. **Bubbling (subindo)**: De target at√© root

```javascript
function BubblingCapturingExample() {
  const handleCapture = (name) => {
    console.log(`${name} - CAPTURING`);
  };

  const handleBubble = (name) => {
    console.log(`${name} - BUBBLING`);
  };

  return (
    <div
      onClickCapture={() => handleCapture('Div')}
      onClick={() => handleBubble('Div')}
      style={{ padding: '20px', border: '2px solid blue' }}
    >
      Div
      <button
        onClickCapture={() => handleCapture('Button')}
        onClick={() => handleBubble('Button')}
      >
        Button
      </button>
    </div>
  );
}

// Clicar bot√£o:
// 1. Div - CAPTURING (desce)
// 2. Button - CAPTURING (desce)
// 3. Button - BUBBLING (sobe)
// 4. Div - BUBBLING (sobe)
```

**Uso pr√°tico: Event Delegation**
```javascript
function EventDelegation() {
  const handleClick = (e) => {
    // Delega√ß√£o: um handler para todos bot√µes
    if (e.target.tagName === 'BUTTON') {
      const action = e.target.dataset.action;
      console.log(`A√ß√£o: ${action}`);
    }
  };

  return (
    <div onClick={handleClick}>
      <button data-action="save">Salvar</button>
      <button data-action="delete">Deletar</button>
      <button data-action="cancel">Cancelar</button>
    </div>
  );
}
```

### 9.4.4 Passagem de Argumentos

**Pattern 1: Arrow function inline**
```javascript
function PassArguments1() {
  const handleClick = (id, name) => {
    console.log(`ID: ${id}, Nome: ${name}`);
  };

  return (
    <button onClick={() => handleClick(123, 'Jo√£o')}>
      Click
    </button>
  );
}
```

**Pattern 2: Currying**
```javascript
function PassArguments2() {
  const handleClick = (id, name) => () => {
    console.log(`ID: ${id}, Nome: ${name}`);
  };

  return (
    <button onClick={handleClick(123, 'Jo√£o')}>
      Click
    </button>
  );
}
```

**Pattern 3: Data attributes**
```javascript
function PassArguments3() {
  const handleClick = (e) => {
    const id = e.currentTarget.dataset.id;
    const name = e.currentTarget.dataset.name;
    console.log(`ID: ${id}, Nome: ${name}`);
  };

  return (
    <button data-id="123" data-name="Jo√£o" onClick={handleClick}>
      Click
    </button>
  );
}
```

**Pattern 4: Event + argumentos**
```javascript
function PassArguments4() {
  const handleClick = (id, name, event) => {
    console.log(`ID: ${id}, Nome: ${name}`);
    console.log('Event:', event.target);
  };

  return (
    <button onClick={(e) => handleClick(123, 'Jo√£o', e)}>
      Click
    </button>
  );
}
```

**Exemplo em lista:**
```javascript
function List({ items }) {
  const handleDelete = useCallback((id) => {
    console.log(`Deletar item ${id}`);
  }, []);

  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {item.name}
          <button onClick={() => handleDelete(item.id)}>
            Deletar
          </button>
        </li>
      ))}
    </ul>
  );
}
```

### 9.4.5 Debouncing & Throttling

**Debounce: Aguarda pausa**
```javascript
function debounce(func, delay) {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  };
}

function DebounceExample() {
  const [query, setQuery] = useState('');

  const handleSearch = debounce((value) => {
    console.log('Buscando:', value);
    // Fetch API
  }, 500);

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    handleSearch(value);
  };

  return (
    <input
      value={query}
      onChange={handleChange}
      placeholder="Buscar (debounced)"
    />
  );
}
```

**Throttle: Limita taxa**
```javascript
function throttle(func, limit) {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

function ThrottleExample() {
  const [scrollY, setScrollY] = useState(0);

  useEffect(() => {
    const handleScroll = throttle(() => {
      setScrollY(window.scrollY);
    }, 100); // M√°ximo 10x por segundo

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return <div>Scroll Y: {scrollY}</div>;
}
```

**Debounce com useCallback:**
```javascript
function useDebouncedCallback(callback, delay) {
  const timeoutRef = useRef(null);

  return useCallback((...args) => {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]);
}

// Uso
function Component() {
  const debouncedSearch = useDebouncedCallback((query) => {
    console.log('Search:', query);
  }, 500);

  return <input onChange={(e) => debouncedSearch(e.target.value)} />;
}
```

### 9.4.6 Event Handler Optimization

**‚ùå Problema: Nova fun√ß√£o toda render**
```javascript
function List({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {/* Nova fun√ß√£o para CADA item, TODA render */}
          <button onClick={() => console.log(item.id)}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
}
```

**‚úÖ Solu√ß√£o 1: useCallback + data attribute**
```javascript
function List({ items }) {
  const handleClick = useCallback((e) => {
    const id = e.currentTarget.dataset.id;
    console.log('Delete:', id);
  }, []);

  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {/* Mesma fun√ß√£o para todos */}
          <button data-id={item.id} onClick={handleClick}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
}
```

**‚úÖ Solu√ß√£o 2: Componente separado**
```javascript
const ListItem = React.memo(({ item, onDelete }) => {
  return (
    <li>
      {item.name}
      <button onClick={() => onDelete(item.id)}>
        Delete
      </button>
    </li>
  );
});

function List({ items }) {
  const handleDelete = useCallback((id) => {
    console.log('Delete:', id);
  }, []);

  return (
    <ul>
      {items.map(item => (
        <ListItem key={item.id} item={item} onDelete={handleDelete} />
      ))}
    </ul>
  );
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada T√©cnica

**preventDefault:**
- Forms (prevenir reload)
- Links (navega√ß√£o custom)
- Context menu custom
- Keyboard shortcuts (prevenir browser defaults)

**stopPropagation:**
- Modais (n√£o fechar ao clicar conte√∫do)
- Dropdowns (n√£o fechar ao clicar dentro)
- Nested clickables (bot√£o dentro de div clic√°vel)

**Debounce:**
- Search inputs
- Window resize
- Auto-save

**Throttle:**
- Scroll handlers
- Mouse move
- Infinite scroll

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes

### Performance

**Debounce/Throttle tem custo:**
- Closure mantida em mem√≥ria
- Timer scheduling overhead

**Use apenas quando necess√°rio** (input r√°pido, scroll).

### Accessibility

**Cuidado ao prevenir defaults:**
```javascript
// ‚ùå Quebra navega√ß√£o por teclado
<a href="/page" onClick={(e) => {
  e.preventDefault(); // Impede keyboard navigation!
}}>Link</a>

// ‚úÖ Fornece alternativa
<button onClick={handleNavigate}>
  Navegar
</button>
```

---

## üìö Conclus√£o

Event Handling Avan√ßado √© essencial para apps complexos:

1. **preventDefault()**: Prevenir comportamentos padr√£o
2. **stopPropagation()**: Controlar bubbling
3. **Bubbling/Capturing**: Entender fases
4. **Passagem de argumentos**: Otimizar listas
5. **Debounce/Throttle**: Performance em eventos frequentes

**Recomenda√ß√µes:**
- Use preventDefault() conscientemente
- stopPropagation() para nested clickables
- Debounce inputs, throttle scroll
- Otimize event handlers em listas
- Sempre considere acessibilidade

**Dominar event handling avan√ßado = apps perform√°ticos e robustos.**
