# Data Fetching Libraries

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**Data Fetching Libraries** sÃ£o **ferramentas para gerenciar server state** (dados do backend) em aplicaÃ§Ãµes React, fornecendo **caching automÃ¡tico**, **sincronizaÃ§Ã£o**, **revalidaÃ§Ã£o** e **otimizaÃ§Ãµes de performance**. Conceitualmente, representam **camada inteligente entre UI e API** - abstrair complexidade de fetching, caching, error handling, loading states, transformando dezenas de linhas de useEffect em uma linha de cÃ³digo.

### Problema que Resolve

**Sem Data Fetching Library**:
```tsx
// âŒ Boilerplate manual
const [data, setData] = useState(null);
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  setIsLoading(true);
  fetch('/api/users')
    .then(res => res.json())
    .then(data => {
      setData(data);
      setIsLoading(false);
    })
    .catch(err => {
      setError(err);
      setIsLoading(false);
    });
}, []);

// Problemas:
// - Sem caching (refetch toda vez)
// - Sem revalidaÃ§Ã£o automÃ¡tica
// - DuplicaÃ§Ã£o em mÃºltiplos componentes
// - Race conditions
// - Sem dedupe (requests duplicados)
```

**Com Data Fetching Library**:
```tsx
// âœ… Uma linha
const { data, isLoading, error } = useQuery({
  queryKey: ['users'],
  queryFn: () => fetch('/api/users').then(res => res.json())
});

// BenefÃ­cios automÃ¡ticos:
// âœ… Caching inteligente
// âœ… Background revalidation
// âœ… Dedupe requests
// âœ… Retry automÃ¡tico
// âœ… Optimistic updates
// âœ… DevTools poderoso
```

---

## ğŸ”„ TanStack Query (React Query)

### Por Que TanStack Query?

```
Mais popular (2024):
âœ… Server state management (nÃ£o client state)
âœ… Caching + revalidation automÃ¡ticos
âœ… DevTools incrÃ­vel
âœ… TypeScript excelente
âœ… Framework agnostic (React, Vue, Solid)
âœ… 15KB gzipped
```

### Setup

```bash
npm install @tanstack/react-query
```

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutos
      cacheTime: 1000 * 60 * 10, // 10 minutos
      retry: 3,
      refetchOnWindowFocus: true
    }
  }
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### useQuery (Fetch Data)

```tsx
import { useQuery } from '@tanstack/react-query';

type User = {
  id: number;
  name: string;
  email: string;
};

function UserList() {
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await fetch('/api/users');
      if (!response.ok) throw new Error('Failed to fetch');
      return response.json() as Promise<User[]>;
    }
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      <ul>
        {data.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

// Cache behavior:
// 1. Primeira vez: fetch
// 2. Componente unmount: cache mantido (10 min)
// 3. Remount: usa cache imediatamente, refetch em background
// 4. Window focus: refetch automÃ¡tico
```

### Query Keys (Cache Identity)

```tsx
// Query keys sÃ£o identity do cache
useQuery({ queryKey: ['users'], queryFn: fetchUsers });
useQuery({ queryKey: ['users', 1], queryFn: () => fetchUser(1) });
useQuery({ queryKey: ['users', 2], queryFn: () => fetchUser(2) });

// Queries diferentes = caches diferentes
// ['users'] !== ['users', 1]

// Dependent queries
function UserProfile({ userId }: { userId: number }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  });

  const { data: posts } = useQuery({
    queryKey: ['posts', userId],
    queryFn: () => fetchUserPosts(userId),
    enabled: !!user // sÃ³ fetch quando user existir
  });

  return <div>{posts?.map(...)}</div>;
}
```

### useMutation (Modify Data)

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

function CreateUserForm() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: async (newUser: { name: string; email: string }) => {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      });
      return response.json();
    },
    onSuccess: () => {
      // Invalidar cache (refetch)
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    mutation.mutate({
      name: formData.get('name') as string,
      email: formData.get('email') as string
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" required />
      <input name="email" type="email" required />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Creating...' : 'Create User'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>User created!</div>}
    </form>
  );
}
```

### Optimistic Updates

```tsx
const mutation = useMutation({
  mutationFn: updateUser,

  onMutate: async (newUser) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: ['users', newUser.id] });

    // Snapshot do valor anterior
    const previousUser = queryClient.getQueryData(['users', newUser.id]);

    // Optimistic update (atualiza cache imediatamente)
    queryClient.setQueryData(['users', newUser.id], newUser);

    // Return context (usado no rollback)
    return { previousUser };
  },

  onError: (err, newUser, context) => {
    // Rollback em caso de erro
    queryClient.setQueryData(
      ['users', newUser.id],
      context?.previousUser
    );
  },

  onSettled: (data, error, variables) => {
    // Refetch para garantir sincronizaÃ§Ã£o
    queryClient.invalidateQueries({ queryKey: ['users', variables.id] });
  }
});

// UI atualiza instantaneamente, rollback se falhar!
```

### Infinite Queries (Pagination)

```tsx
import { useInfiniteQuery } from '@tanstack/react-query';

function InfiniteUserList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['users'],
    queryFn: async ({ pageParam = 1 }) => {
      const response = await fetch(`/api/users?page=${pageParam}`);
      return response.json();
    },
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.hasMore ? allPages.length + 1 : undefined;
    },
    initialPageParam: 1
  });

  return (
    <div>
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.users.map(user => (
            <div key={user.id}>{user.name}</div>
          ))}
        </div>
      ))}

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? 'Loading more...'
          : hasNextPage
          ? 'Load More'
          : 'No more users'}
      </button>
    </div>
  );
}
```

**Pros**:
- âœ… Caching + revalidation automÃ¡ticos
- âœ… DevTools poderoso
- âœ… Optimistic updates built-in
- âœ… TypeScript excelente
- âœ… Retry + deduping automÃ¡ticos

**Cons**:
- âŒ Learning curve (conceitos novos)
- âŒ Bundle size (15KB)

---

## ğŸ”¥ SWR (Stale-While-Revalidate)

### Por Que SWR?

```
Minimalista (Vercel):
âœ… API simples
âœ… Stale-while-revalidate pattern
âœ… Real-time via WebSocket/Polling
âœ… TypeScript excelente
âœ… 5KB gzipped
```

### Setup

```bash
npm install swr
```

```tsx
import { SWRConfig } from 'swr';

const fetcher = (url: string) => fetch(url).then(res => res.json());

function App() {
  return (
    <SWRConfig
      value={{
        fetcher,
        revalidateOnFocus: true,
        revalidateOnReconnect: true,
        dedupingInterval: 2000
      }}
    >
      <YourApp />
    </SWRConfig>
  );
}
```

### useSWR (Basic)

```tsx
import useSWR from 'swr';

function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading, mutate } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>{data.name}</h1>
      <button onClick={() => mutate()}>Refresh</button>
    </div>
  );
}

// Stale-While-Revalidate:
// 1. Retorna cache (stale) imediatamente
// 2. Refetch em background (revalidate)
// 3. Atualiza UI quando pronto
```

### Mutations

```tsx
import useSWR, { useSWRConfig } from 'swr';

function UpdateUserForm({ userId }: { userId: number }) {
  const { mutate } = useSWRConfig();
  const { data } = useSWR(`/api/users/${userId}`);

  const handleUpdate = async (newName: string) => {
    // Optimistic update
    await mutate(
      `/api/users/${userId}`,
      async (currentData) => {
        // Update no servidor
        const updated = await fetch(`/api/users/${userId}`, {
          method: 'PATCH',
          body: JSON.stringify({ name: newName })
        }).then(res => res.json());

        return updated;
      },
      {
        optimisticData: { ...data, name: newName }, // UI instantÃ¢nea
        rollbackOnError: true // Rollback se falhar
      }
    );
  };

  return (
    <button onClick={() => handleUpdate('New Name')}>
      Update Name
    </button>
  );
}
```

### Real-time (WebSocket)

```tsx
import useSWR from 'swr';
import { useEffect } from 'react';

function LiveData() {
  const { data, mutate } = useSWR('/api/live-data', fetcher);

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:3000');

    ws.onmessage = (event) => {
      // Update cache com dados do WebSocket
      mutate(JSON.parse(event.data), false); // false = nÃ£o revalidar
    };

    return () => ws.close();
  }, [mutate]);

  return <div>{data?.value}</div>;
}
```

**Pros**:
- âœ… API minimalista
- âœ… Bundle pequeno (5KB)
- âœ… Real-time fÃ¡cil
- âœ… TypeScript excelente

**Cons**:
- âŒ Menos features que React Query
- âŒ DevTools bÃ¡sico

---

## ğŸš€ Apollo Client (GraphQL)

### Por Que Apollo?

```
GraphQL-specific:
âœ… Cache normalizado (GraphQL schema)
âœ… Optimistic UI built-in
âœ… Local state management
âœ… Code generation (types)
âœ… DevTools poderoso
```

### Setup

```bash
npm install @apollo/client graphql
```

```tsx
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://api.example.com/graphql',
  cache: new InMemoryCache()
});

function App() {
  return (
    <ApolloProvider client={client}>
      <YourApp />
    </ApolloProvider>
  );
}
```

### useQuery

```tsx
import { gql, useQuery } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

function UserList() {
  const { data, loading, error, refetch } = useQuery(GET_USERS);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>Refresh</button>
      <ul>
        {data.users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### useMutation

```tsx
import { gql, useMutation } from '@apollo/client';

const CREATE_USER = gql`
  mutation CreateUser($name: String!, $email: String!) {
    createUser(name: $name, email: $email) {
      id
      name
      email
    }
  }
`;

function CreateUserForm() {
  const [createUser, { loading, error }] = useMutation(CREATE_USER, {
    refetchQueries: [{ query: GET_USERS }],
    // OU optimistic update:
    optimisticResponse: {
      createUser: {
        __typename: 'User',
        id: 'temp-id',
        name: variables.name,
        email: variables.email
      }
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    createUser({
      variables: {
        name: 'John Doe',
        email: 'john@example.com'
      }
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit" disabled={loading}>
        {loading ? 'Creating...' : 'Create User'}
      </button>
      {error && <div>Error: {error.message}</div>}
    </form>
  );
}
```

### Normalized Cache

```tsx
// Apollo normaliza cache automaticamente
// Query 1
const GET_USER = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      email
    }
  }
`;

// Query 2
const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

// Cache:
// {
//   'User:1': { id: 1, name: 'John', email: 'john@example.com' }
// }

// Qualquer query que retorna User:1 usa o mesmo cache!
// Update em uma query â†’ atualiza todas automaticamente
```

**Pros**:
- âœ… Cache normalizado (GraphQL)
- âœ… Optimistic updates built-in
- âœ… DevTools poderoso
- âœ… Code generation

**Cons**:
- âŒ GraphQL-only (nÃ£o funciona com REST)
- âŒ Bundle grande (30KB+)
- âŒ Complexidade alta

---

## ğŸ“Š ComparaÃ§Ã£o

```
Library         | Bundle | Use Case          | Learning Curve
----------------|--------|-------------------|----------------
TanStack Query  | 15KB   | REST + GraphQL    | ğŸŸ¡ MÃ©dia
SWR             | 5KB    | REST simples      | âœ… FÃ¡cil
Apollo Client   | 30KB   | GraphQL           | ğŸ”´ DifÃ­cil
RTK Query       | 10KB   | Redux users       | ğŸŸ¡ MÃ©dia
```

---

## ğŸ¯ Quando Usar Cada Um

```
TanStack Query:
âœ… Maioria dos casos (REST)
âœ… Precisar DevTools
âœ… Optimistic updates complexos
âœ… Infinite queries / Pagination
âŒ Bundle size crÃ­tico

SWR:
âœ… Apps simples
âœ… Bundle size crÃ­tico
âœ… Real-time (WebSocket/Polling)
âœ… Minimalismo
âŒ Features avanÃ§adas

Apollo Client:
âœ… GraphQL API
âœ… Cache normalizado
âœ… Subscriptions (real-time GraphQL)
âŒ REST API

Nenhuma:
âœ… Server Components (Next.js App Router)
âœ… SWR/React Query no RSC
```

---

## ğŸš€ ConclusÃ£o

Data Fetching Libraries incluem:
- **TanStack Query**: Mais completo, DevTools, REST/GraphQL
- **SWR**: Minimalista, stale-while-revalidate, real-time
- **Apollo Client**: GraphQL-specific, cache normalizado
- **RTK Query**: Integrado Redux Toolkit

**RecomendaÃ§Ã£o 2024**: **TanStack Query** para REST APIs - features completas, DevTools excelente, TypeScript perfeito.

**Importante**: Data fetching â‰  State management
- Server state â†’ React Query/SWR
- Client state â†’ Zustand/Context
- NÃ£o misture os dois!

NÃ£o use useState + useEffect para server data - use data fetching library!
