# State Management Libraries

## ğŸ¯ IntroduÃ§Ã£o e DefiniÃ§Ã£o

### DefiniÃ§Ã£o Conceitual

**State Management Libraries** sÃ£o **ferramentas para gerenciar estado global** em aplicaÃ§Ãµes React, facilitando **compartilhamento de dados** entre componentes distantes sem **prop drilling**. Conceitualmente, representam **banco de dados do frontend** - centralizar estado, controlar mutaÃ§Ãµes, permitir acesso de qualquer componente.

### Problema que Resolve

**Sem State Management**:
- Prop drilling (passar props 10 nÃ­veis)
- Estado duplicado em mÃºltiplos componentes
- DifÃ­cil sincronizar estado
- Context API verbosa

**Com State Management**:
- Estado global acessÃ­vel de qualquer lugar
- Single source of truth
- Mutations controladas
- DevTools para debug

---

## ğŸ”„ Zustand (Recomendado 2024)

### Por Que Zustand?

```
Simplicidade:
âœ… Menos boilerplate que Redux
âœ… API minimalista
âœ… TypeScript friendly
âœ… Bundle pequeno (1KB)
```

### Setup BÃ¡sico

```tsx
import { create } from 'zustand';

type Store = {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
};

const useStore = create<Store>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// Uso
function Counter() {
  const { count, increment, decrement } = useStore();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}
```

### Async Actions

```tsx
type UserStore = {
  users: User[];
  isLoading: boolean;
  error: string | null;
  fetchUsers: () => Promise<void>;
};

const useUserStore = create<UserStore>((set) => ({
  users: [],
  isLoading: false,
  error: null,

  fetchUsers: async () => {
    set({ isLoading: true, error: null });

    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      set({ users, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  }
}));

// Uso
function UserList() {
  const { users, isLoading, error, fetchUsers } = useUserStore();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### Slices Pattern

```tsx
// authSlice.ts
type AuthSlice = {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
};

const createAuthSlice = (set) => ({
  user: null,
  login: async (email, password) => {
    const user = await authApi.login(email, password);
    set({ user });
  },
  logout: () => set({ user: null })
});

// cartSlice.ts
type CartSlice = {
  items: CartItem[];
  addItem: (item: Product) => void;
  removeItem: (id: number) => void;
};

const createCartSlice = (set) => ({
  items: [],
  addItem: (item) =>
    set((state) => ({ items: [...state.items, item] })),
  removeItem: (id) =>
    set((state) => ({ items: state.items.filter(i => i.id !== id) }))
});

// store.ts
const useStore = create<AuthSlice & CartSlice>((...a) => ({
  ...createAuthSlice(...a),
  ...createCartSlice(...a)
}));
```

### Middlewares

```tsx
import { devtools, persist } from 'zustand/middleware';

// Persist (localStorage)
const useStore = create<Store>()(
  persist(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 }))
    }),
    {
      name: 'counter-storage' // localStorage key
    }
  )
);

// DevTools
const useStore = create<Store>()(
  devtools(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 }))
    }),
    {
      name: 'CounterStore'
    }
  )
);

// Combinar
const useStore = create<Store>()(
  devtools(
    persist(
      (set) => ({ /* ... */ }),
      { name: 'storage' }
    ),
    { name: 'Store' }
  )
);
```

**Pros**:
- âœ… Simples e minimalista
- âœ… TypeScript excelente
- âœ… Performance (fine-grained subscriptions)
- âœ… Bundle pequeno (1KB)

**Cons**:
- âŒ Sem estrutura opinada (liberdade = responsabilidade)

---

## ğŸ”´ Redux Toolkit (Tradicional)

### Setup

```bash
npm install @reduxjs/toolkit react-redux
```

### Slice

```tsx
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

type CounterState = {
  value: number;
};

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1; // Immer permite mutaÃ§Ã£o
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;
```

### Store

```tsx
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

### Hooks

```tsx
// hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// Uso
function Counter() {
  const count = useAppSelector((state) => state.counter.value);
  const dispatch = useAppDispatch();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

### Async Thunks

```tsx
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

// Thunk
export const fetchUsers = createAsyncThunk(
  'users/fetch',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

// Slice
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    status: 'idle',
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      });
  }
});
```

**Pros**:
- âœ… Estrutura opinada (escalÃ¡vel)
- âœ… DevTools poderoso
- âœ… Ecossistema maduro
- âœ… Time-travel debugging

**Cons**:
- âŒ Boilerplate (menos que Redux puro, mas ainda hÃ¡)
- âŒ Learning curve
- âŒ Bundle size maior

---

## âš›ï¸ Jotai (Atomic)

### Conceito

```
Zustand/Redux: Store global
Jotai: Atoms (pedaÃ§os independentes de estado)

Vantagem: Fine-grained reactivity
```

### Setup

```tsx
import { atom, useAtom } from 'jotai';

// Atoms
const countAtom = atom(0);
const userAtom = atom<User | null>(null);

// Uso
function Counter() {
  const [count, setCount] = useAtom(countAtom);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

### Derived Atoms

```tsx
const countAtom = atom(0);

// Atom derivado (computed)
const doubleCountAtom = atom((get) => get(countAtom) * 2);

// Read-write derivado
const incrementAtom = atom(
  (get) => get(countAtom),
  (get, set) => set(countAtom, get(countAtom) + 1)
);

// Uso
function Component() {
  const [count] = useAtom(countAtom);
  const [doubleCount] = useAtom(doubleCountAtom);
  const [, increment] = useAtom(incrementAtom);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}
```

### Async Atoms

```tsx
const usersAtom = atom(async () => {
  const response = await fetch('/api/users');
  return response.json();
});

// Uso
function UserList() {
  const [users] = useAtom(usersAtom);

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </Suspense>
  );
}
```

**Pros**:
- âœ… Fine-grained (performance)
- âœ… Minimalista
- âœ… Suspense integrado
- âœ… TypeScript excelente

**Cons**:
- âŒ Conceito diferente (atoms vs store)
- âŒ Menos estrutura

---

## ğŸ“Š ComparaÃ§Ã£o

```
Library      | Bundle | Learning Curve | Use Case
-------------|--------|----------------|------------------
Zustand      | 1KB    | âœ… FÃ¡cil       | Maioria dos apps
Redux TK     | 15KB   | ğŸŸ¡ MÃ©dia       | Apps grandes
Jotai        | 3KB    | ğŸŸ¡ MÃ©dia       | Performance critical
Recoil       | 10KB   | ğŸŸ¡ MÃ©dia       | Meta (nÃ£o popular)
MobX         | 16KB   | ğŸ”´ DifÃ­cil     | OOP preference
```

---

## ğŸ¯ Quando Usar Cada Um

```
Zustand:
âœ… Maioria dos casos
âœ… Simples e eficiente
âœ… EquilÃ­brio perfeito
âŒ Precisa estrutura opinada

Redux Toolkit:
âœ… Apps muito grandes
âœ… MÃºltiplos devs (estrutura opinada)
âœ… Time-travel debugging
âŒ Apps pequenos (overkill)

Jotai:
âœ… Performance crÃ­tica
âœ… Fine-grained updates
âœ… Suspense heavy
âŒ Precisa store centralizado

Nenhuma:
âœ… React Query (server state)
âœ… Context API (local state)
âœ… URL state (react-router)
```

---

## ğŸš€ ConclusÃ£o

State Management Libraries incluem:
- **Zustand**: Minimalista, TypeScript, 1KB
- **Redux Toolkit**: Estruturado, escalÃ¡vel, DevTools
- **Jotai**: Atomic, fine-grained, Suspense
- **Recoil**: Similar Jotai (menos popular)
- **MobX**: OOP, observables (legado)

**RecomendaÃ§Ã£o 2024**: **Zustand** para maioria dos casos - simples, eficiente, TypeScript excelente.

**Importante**: Considere se precisa de state management:
- Server state â†’ React Query/SWR
- Form state â†’ React Hook Form
- URL state â†’ React Router
- Local state â†’ useState/useContext

NÃ£o use state management global para tudo!
