# Novos Hooks React 19

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**React 19 Hooks** incluem **`use()`** (ler Promises e Context), **`useFormStatus()`** (estado de formul√°rios pendentes), **`useFormState()`** (gerenciar estado de Server Actions), e **`useOptimistic()`** (atualiza√ß√µes otimistas para UX responsiva). Conceitualmente, representam **evolu√ß√£o para full-stack React** - hooks espec√≠ficos para Server Components, formul√°rios progressivos, e padr√µes otimistas que melhoram UX durante opera√ß√µes ass√≠ncronas sem loading states manuais.

Na ess√™ncia, novos hooks React 19 transformam patterns comuns de **manual e verboso** para **declarativo e integrado** - ler promises diretamente em componentes, gerenciar formul√°rios sem estado complexo, mostrar updates otimistas antes de servidor confirmar.

### Contexto Hist√≥rico e Motiva√ß√£o

React 18 introduziu Concurrent Rendering e Suspense, mas faltavam **primitivas para patterns comuns**:

**Problemas antes React 19**:

1. **Ler Promises**: Precisava wrapping manual com Suspense
2. **Form Pending State**: `useState` + flags manuais
3. **Server Actions State**: Gerenciar loading/error/success manualmente
4. **Optimistic Updates**: C√≥digo complexo com rollback manual

**Solu√ß√µes React 19**:

```jsx
// ‚ùå React 18 - ler promise com Suspense
function Component({ promise }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    promise.then(setData);
  }, [promise]);

  if (!data) throw promise; // Suspense

  return <div>{data.value}</div>;
}

// ‚úÖ React 19 - use() hook
function Component({ promise }) {
  const data = use(promise); // Suspende automaticamente
  return <div>{data.value}</div>;
}
```

### Problema Fundamental que Resolve

**1. use() - Ler Promises Diretamente**:

```jsx
// React 19 - ler promise sem useEffect
function BlogPost({ postPromise }) {
  const post = use(postPromise); // Suspende at√© resolver

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}

// Uso
<Suspense fallback={<Loading />}>
  <BlogPost postPromise={fetchPost()} />
</Suspense>
```

**2. useFormStatus() - Estado de Form Pendente**:

```jsx
// Bot√£o mostra pending automaticamente
function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : 'Submit'}
    </button>
  );
}

<form action={serverAction}>
  <input name="email" />
  <SubmitButton /> {/* Aware de pending do form pai */}
</form>
```

**3. useOptimistic() - Updates Otimistas**:

```jsx
function TodoList({ todos }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, newTodo]
  );

  const handleAdd = async (formData) => {
    const newTodo = { id: Date.now(), text: formData.get('text') };

    // Mostra imediatamente (otimista)
    addOptimisticTodo(newTodo);

    // Envia ao servidor
    await addTodoAction(formData);
    // Se sucesso, estado real atualiza
    // Se falha, otimista reverte
  };

  return optimisticTodos.map(todo => <Todo key={todo.id} {...todo} />);
}
```

### Import√¢ncia no Ecossistema

Novos hooks React 19 s√£o **essenciais** para:

- **Server Components**: `use()` para promises em RSC
- **Forms**: `useFormStatus()`, `useFormState()` para formul√°rios progressivos
- **UX Responsiva**: `useOptimistic()` para updates instant√¢neos
- **Simplifica√ß√£o**: Menos boilerplate, mais declarativo
- **Progressive Enhancement**: Forms funcionam sem JS

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **use()**: Ler Promises e Context (pode ser condicional!)
2. **useFormStatus()**: Estado de pending de formul√°rio pai
3. **useFormState()**: Gerenciar retorno de Server Actions
4. **useOptimistic()**: Updates otimistas com rollback autom√°tico

### Pilares Fundamentais

- **use(promise)**: Suspende at√© promise resolver
- **use(context)**: Alternativa a useContext
- **useFormStatus()**: `{ pending, data, method, action }`
- **useFormState()**: `[state, formAction]`
- **useOptimistic()**: `[optimisticState, addOptimistic]`

---

## üß† Fundamentos Te√≥ricos

### use() Hook

**Diferencial √önico**: `use()` pode ser **condicional** (√∫nico hook React que permite isso).

```jsx
// ‚ùå Outros hooks - n√£o podem ser condicionais
function Component({ shouldFetch }) {
  if (shouldFetch) {
    const data = useState(null); // ERRO!
  }
}

// ‚úÖ use() - PODE ser condicional
function Component({ promise }) {
  if (promise) {
    const data = use(promise); // OK!
  }
}
```

**Como Funciona**:

1. Componente chama `use(promise)`
2. Promise ainda resolvendo? ‚Üí React suspende componente
3. Suspense boundary captura ‚Üí mostra fallback
4. Promise resolve ‚Üí React re-renderiza com dados

---

## üîç An√°lise Conceitual Profunda

### use() Hook: Ler Promises

#### Sintaxe B√°sica

```jsx
import { use } from 'react';

function Component({ dataPromise }) {
  // Suspende at√© promise resolver
  const data = use(dataPromise);

  return <div>{data.value}</div>;
}

// Uso com Suspense
<Suspense fallback={<Loading />}>
  <Component dataPromise={fetchData()} />
</Suspense>
```

#### Exemplo Completo: Blog Post

```jsx
// Fetch post (retorna promise)
function fetchPost(id) {
  return fetch(`/api/posts/${id}`).then(r => r.json());
}

// Componente l√™ promise
function BlogPost({ id }) {
  const post = use(fetchPost(id)); // Suspende durante fetch

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      <p>By {post.author}</p>
    </article>
  );
}

// App
function App() {
  return (
    <Suspense fallback={<div>Loading post...</div>}>
      <BlogPost id={1} />
    </Suspense>
  );
}
```

#### use() Condicional

```jsx
function Component({ user, fetchData }) {
  // Condicional baseado em prop
  if (!user) {
    return <Login />;
  }

  // use() dentro de condicional - OK!
  const data = use(fetchData(user.id));

  return <div>{data.value}</div>;
}
```

#### use() em Loops

```jsx
function MultiPosts({ postPromises }) {
  return (
    <div>
      {postPromises.map((promise, index) => {
        const post = use(promise); // use() em loop - OK!

        return (
          <article key={index}>
            <h2>{post.title}</h2>
          </article>
        );
      })}
    </div>
  );
}
```

### use() para Context

```jsx
import { use, createContext } from 'react';

const ThemeContext = createContext('light');

function ThemedButton() {
  // Alternativa a useContext
  const theme = use(ThemeContext);

  return (
    <button className={theme}>
      Themed Button
    </button>
  );
}
```

**Vantagem sobre useContext**: Pode ser condicional.

```jsx
function Component({ useTheme }) {
  if (useTheme) {
    const theme = use(ThemeContext); // OK!
    // vs
    // const theme = useContext(ThemeContext); // ERRO em condicional
  }
}
```

### useFormStatus() Hook

#### Sintaxe e Uso

```jsx
import { useFormStatus } from 'react-dom';

function SubmitButton() {
  const { pending, data, method, action } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : 'Submit'}
    </button>
  );
}

// Form pai
<form action={serverAction}>
  <input name="username" />
  <SubmitButton /> {/* Acessa estado do form pai */}
</form>
```

**Campos Retornados**:
- `pending`: Boolean - form est√° submetendo
- `data`: FormData - dados sendo submetidos
- `method`: String - m√©todo HTTP ('get', 'post')
- `action`: Function/String - action do form

#### Exemplo Completo

```jsx
// Server Action
async function signup(formData) {
  'use server';

  const email = formData.get('email');
  await db.users.create({ email });
  redirect('/welcome');
}

// Bot√£o submit com estado
function SignupButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? (
        <>
          <Spinner />
          Creating account...
        </>
      ) : (
        'Sign Up'
      )}
    </button>
  );
}

// Form
function SignupForm() {
  return (
    <form action={signup}>
      <input type="email" name="email" required />
      <SignupButton />
    </form>
  );
}
```

#### M√∫ltiplos Bot√µes com useFormStatus

```jsx
function SaveButton() {
  const { pending } = useFormStatus();

  return (
    <button name="action" value="save" disabled={pending}>
      {pending ? 'Saving...' : 'Save Draft'}
    </button>
  );
}

function PublishButton() {
  const { pending } = useFormStatus();

  return (
    <button name="action" value="publish" disabled={pending}>
      {pending ? 'Publishing...' : 'Publish'}
    </button>
  );
}

// Server Action identifica a√ß√£o
async function handlePost(formData) {
  'use server';

  const action = formData.get('action');

  if (action === 'save') {
    await savePost(formData);
  } else if (action === 'publish') {
    await publishPost(formData);
  }
}

// Form
<form action={handlePost}>
  <textarea name="content" />
  <SaveButton />
  <PublishButton />
</form>
```

### useFormState() Hook

#### Sintaxe B√°sica

```jsx
import { useFormState } from 'react-dom';

function Form() {
  const [state, formAction] = useFormState(serverAction, initialState);

  return (
    <form action={formAction}>
      {state.error && <p className="error">{state.error}</p>}
      <input name="email" />
      <button>Submit</button>
    </form>
  );
}
```

**Par√¢metros**:
- `serverAction`: Server Action (recebe `prevState` e `formData`)
- `initialState`: Estado inicial

**Retorno**:
- `state`: Estado atual retornado pela action
- `formAction`: Action wrapper para usar no form

#### Exemplo: Form com Valida√ß√£o

```jsx
// Server Action
async function createUser(prevState, formData) {
  'use server';

  const email = formData.get('email');
  const password = formData.get('password');

  // Valida√ß√£o
  if (!email.includes('@')) {
    return { error: 'Invalid email' };
  }

  if (password.length < 8) {
    return { error: 'Password must be at least 8 characters' };
  }

  // Criar usu√°rio
  try {
    await db.users.create({ email, password });
    return { success: true };
  } catch (error) {
    return { error: 'Email already exists' };
  }
}

// Form Component
'use client';

import { useFormState } from 'react-dom';

function SignupForm() {
  const [state, formAction] = useFormState(createUser, {
    error: null,
    success: false
  });

  return (
    <form action={formAction}>
      {state.error && (
        <div className="error-banner">{state.error}</div>
      )}

      {state.success && (
        <div className="success-banner">Account created!</div>
      )}

      <input type="email" name="email" required />
      <input type="password" name="password" required />

      <button type="submit">Sign Up</button>
    </form>
  );
}
```

#### useFormState + useFormStatus

```jsx
function Form() {
  const [state, formAction] = useFormState(serverAction, {});

  return (
    <form action={formAction}>
      {state.message && <p>{state.message}</p>}

      <input name="name" />

      <SubmitButton /> {/* Usa useFormStatus internamente */}
    </form>
  );
}

function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button disabled={pending}>
      {pending ? 'Saving...' : 'Save'}
    </button>
  );
}
```

### useOptimistic() Hook

#### Conceito

**Optimistic Update**: Mostrar resultado imediatamente (otimista), antes de servidor confirmar.

**Fluxo**:
1. Usu√°rio submete form
2. UI atualiza **imediatamente** (otimista)
3. Request enviado ao servidor
4. Se sucesso: Estado real atualiza (UI j√° mostra correto)
5. Se falha: Otimista reverte para estado anterior

#### Sintaxe B√°sica

```jsx
import { useOptimistic } from 'react';

function Component() {
  const [optimisticState, addOptimistic] = useOptimistic(
    actualState,
    (currentState, optimisticValue) => {
      // Retorna novo estado com valor otimista
      return [...currentState, optimisticValue];
    }
  );

  return (
    <div>
      {optimisticState.map(item => <Item key={item.id} {...item} />)}
    </div>
  );
}
```

**Par√¢metros**:
- `actualState`: Estado real (vem de props, estado, etc)
- `updateFn`: Fun√ß√£o que recebe estado atual e valor otimista, retorna novo estado

**Retorno**:
- `optimisticState`: Estado com updates otimistas aplicados
- `addOptimistic`: Fun√ß√£o para adicionar update otimista

#### Exemplo Completo: Todo List

```jsx
'use client';

import { useOptimistic } from 'react';

function TodoList({ todos }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, { ...newTodo, pending: true }]
  );

  async function handleAdd(formData) {
    const text = formData.get('text');
    const newTodo = {
      id: crypto.randomUUID(),
      text,
      completed: false
    };

    // Adiciona otimisticamente (UI atualiza IMEDIATAMENTE)
    addOptimisticTodo(newTodo);

    // Envia ao servidor (ass√≠ncrono)
    await addTodoAction(formData);
    // Quando completar, `todos` prop atualiza e otimista desaparece
  }

  return (
    <div>
      <form action={handleAdd}>
        <input name="text" />
        <button>Add</button>
      </form>

      <ul>
        {optimisticTodos.map(todo => (
          <li
            key={todo.id}
            style={{ opacity: todo.pending ? 0.5 : 1 }}
          >
            {todo.text}
            {todo.pending && ' (saving...)'}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Fluxo**:
1. Usu√°rio digita "Buy milk", clica Add
2. `addOptimisticTodo` ‚Üí UI mostra "Buy milk (saving...)" **instantaneamente**
3. `addTodoAction` envia ao servidor (leva 500ms)
4. Servidor retorna sucesso ‚Üí `todos` prop atualiza
5. `optimisticTodos` recalcula com `todos` real ‚Üí "(saving...)" desaparece

#### Optimistic Delete

```jsx
function TodoList({ todos }) {
  const [optimisticTodos, deleteOptimistic] = useOptimistic(
    todos,
    (state, idToDelete) => state.filter(todo => todo.id !== idToDelete)
  );

  async function handleDelete(id) {
    // Remove otimisticamente
    deleteOptimistic(id);

    // Envia ao servidor
    await deleteTodoAction(id);
  };

  return optimisticTodos.map(todo => (
    <div key={todo.id}>
      {todo.text}
      <button onClick={() => handleDelete(todo.id)}>Delete</button>
    </div>
  ));
}
```

#### Optimistic Update (Toggle)

```jsx
function TodoList({ todos }) {
  const [optimisticTodos, updateOptimistic] = useOptimistic(
    todos,
    (state, { id, completed }) => {
      return state.map(todo =>
        todo.id === id ? { ...todo, completed } : todo
      );
    }
  );

  async function handleToggle(id, completed) {
    // Toggle otimisticamente
    updateOptimistic({ id, completed: !completed });

    // Envia ao servidor
    await toggleTodoAction(id);
  };

  return optimisticTodos.map(todo => (
    <div key={todo.id}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => handleToggle(todo.id, todo.completed)}
      />
      {todo.text}
    </div>
  ));
}
```

---

## üéØ Aplicabilidade e Contextos

### Quando Usar Cada Hook

#### use()

**Use Quando**:
- Ler promises em Server/Client Components
- Ler Context condicionalmente
- Simplificar c√≥digo com Suspense

#### useFormStatus()

**Use Quando**:
- Mostrar estado de pending em bot√µes submit
- Desabilitar inputs durante submit
- Feedback visual durante form submission

#### useFormState()

**Use Quando**:
- Gerenciar estado retornado por Server Actions
- Valida√ß√£o com mensagens de erro
- Multi-step forms com estado persistente

#### useOptimistic()

**Use Quando**:
- UX precisa ser instant√¢nea (likes, follows)
- CRUD operations que devem parecer r√°pidas
- Apps com lat√™ncia de rede (mobile)

---

## ‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes Te√≥ricas

### Restri√ß√µes

#### 1. use() N√£o Substitui Todos useEffect

```jsx
// ‚ùå use() n√£o funciona para side effects
const data = use(promise); // OK - ler promise

// ‚úÖ useEffect ainda necess√°rio para side effects
useEffect(() => {
  // Side effects (logging, analytics, etc)
}, []);
```

#### 2. useFormStatus() Apenas em Children de Form

```jsx
// ‚ùå Fora de form - n√£o funciona
function Component() {
  const { pending } = useFormStatus(); // pending sempre false
  return <button>Click</button>;
}

// ‚úÖ Dentro de form
<form>
  <SubmitButton /> {/* useFormStatus funciona */}
</form>
```

#### 3. useOptimistic N√£o Persiste Ap√≥s Unmount

```jsx
// Se componente desmonta antes de servidor responder,
// update otimista √© perdido (n√£o persiste)
```

---

## üîó Interconex√µes Conceituais

### use() + Suspense

```jsx
<Suspense fallback={<Loading />}>
  <Component promise={fetchData()} />
</Suspense>

function Component({ promise }) {
  const data = use(promise); // Suspende
  return <div>{data}</div>;
}
```

### useFormState() + useFormStatus()

```jsx
function Form() {
  const [state, formAction] = useFormState(action, {});

  return (
    <form action={formAction}>
      {state.error && <Error message={state.error} />}
      <SubmitButton />
    </form>
  );
}

function SubmitButton() {
  const { pending } = useFormStatus();
  return <button disabled={pending}>Submit</button>;
}
```

---

## üöÄ Evolu√ß√£o e Pr√≥ximos Conceitos

### Prepara√ß√£o para T√≥picos Avan√ßados

Novos Hooks React 19 preparam para:

1. **Actions** (22.2): Form actions, Server Actions
2. **Server Components** (M√≥dulo 21): use() em RSC
3. **Forms** (M√≥dulo 10): Formul√°rios avan√ßados

---

## üéØ Conclus√£o

Novos Hooks React 19 **simplificam patterns comuns**:

**Principais Hooks**:
- **use()**: Ler promises/context (pode ser condicional!)
- **useFormStatus()**: Pending state de formul√°rios
- **useFormState()**: Estado de Server Actions
- **useOptimistic()**: Updates otimistas com rollback

**Quando Usar**:
- **use()**: Simplificar Suspense, context condicional
- **useFormStatus()**: Feedback em bot√µes submit
- **useFormState()**: Valida√ß√£o, multi-step forms
- **useOptimistic()**: UX instant√¢nea (likes, CRUD)

**Benef√≠cios**:
- Menos boilerplate
- UX mais responsiva
- C√≥digo mais declarativo
- Integra√ß√£o com Server Components

React 19 hooks elevam React de **client-side library** para **framework full-stack moderno** - com primitivas para formul√°rios progressivos, updates otimistas, e leitura declarativa de promises. Essenciais para aplica√ß√µes modernas com excelente UX.
