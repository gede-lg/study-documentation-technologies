# Two-Way Binding

**1. Introdução**

O *two-way binding* (ligação bidirecional) é um dos padrões de sincronização de dados mais utilizados em frameworks de front-end como o Angular. Ele permite que mudanças na **view** (interface) reflitam automaticamente no **model** (dados do componente) e vice-versa, sem necessidade de código boilerplate para escutar eventos ou atribuir valores manualmente.

- **Relevância e importância**: simplifica formulários e campos de entrada, melhora a legibilidade do template e reduz a quantidade de “plumbing code” para manter a UI e o estado do componente sincronizados.
- **Definição e conceitos fundamentais**:
    - **Tema principal**: two-way binding em Angular, ou seja, o padrão responsável pela sincronização dupla de valores entre template e componente.
    - **Subtemas**:
        1. *One-way binding* (interpolação e property binding)
        2. *Event binding* (escuta de eventos)
        3. *NgModel* e a sintaxe “banana in a box” (`[(…)]`)
        4. *ControlValueAccessor* para componentes customizados
    - **Para que servem**: cada subtema é um passo na cadeia que permite do simples bind de propriedade até o controle avançado de formulários.

---

**2. Sumário**

1. [Introdução](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#introdu%C3%A7%C3%A3o)
2. [Conceitos Básicos de Binding](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#conceitos-b%C3%A1sicos-de-binding)
3. [Sintaxe e Estrutura](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#sintaxe-e-estrutura)
4. [Componentes Principais](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#componentes-principais)
5. [Restrições de Uso](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#restri%C3%A7%C3%B5es-de-uso)
6. [Exemplos de Código Otimizados](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#exemplos-de-c%C3%B3digo-otimizados)
7. [Informações Adicionais](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#informa%C3%A7%C3%B5es-adicionais)
8. [Referências para Estudo Independente](https://chatgpt.com/g/g-p-67fc74e4e4b0819191996b70ff86754a-angular/c/685bd1e4-9d88-8013-9f64-1ff6bede9ffc#refer%C3%AAncias-para-estudo-independente)

---

## 3. Conceitos Básicos de Binding

- **One-way binding**
    - *Interpolação*: `{{ user.name }}` atualiza a view quando `user.name` muda.
    - *Property binding*: `[value]="user.age"` define o atributo `value` de um elemento a partir do componente.
- **Event binding**
    - `(input)="user.age = $event.target.value"` reage a eventos da UI e atualiza o model.
- **Two-way binding**
    - Combina os dois acima para **ler** e **escrever** no mesmo ponto, usando o banana-in-a-box: `[(ngModel)]="user.name"`.

---

## 4. Sintaxe e Estrutura

1. **Importar FormsModule**
    
    ```
    import { FormsModule } from '@angular/forms';
    @NgModule({
      imports: [ FormsModule, /* ... */ ]
    })
    export class AppModule { }
    
    ```
    
2. **Template**
    
    ```html
    <input [(ngModel)]="user.name" placeholder="Nome">
    <p>Olá, {{ user.name }}!</p>
    
    ```
    
    - `[(ngModel)]` = `[ngModel] = "user.name"` **+** `(ngModelChange)="user.name = $event"`

---

## 5. Componentes Principais

| Componente / Diretiva | Descrição |
| --- | --- |
| `NgModel` | Diretiva que faz o bind bidirecional. |
| `FormsModule` | Módulo que disponibiliza `NgModel`, controles e validações simples. |
| `ngModelChange` (evento) | Emite novo valor quando o usuário altera a view. |
| `ControlValueAccessor` | Interface para criar componentes que aceitam `[(ngModel)]`. |
- **Interação**:
    1. O Angular renderiza o valor inicial via `[ngModel]`.
    2. Quando o usuário digita, dispara `input` → `ngModelChange` → atualiza a propriedade do componente.
    3. Se o componente alterar o valor no código, a view será atualizada automaticamente.

---

## 6. Restrições de Uso

- **Somente em elementos suportados**: `<input>`, `<select>`, `<textarea>` ou componentes customizados que implementem `ControlValueAccessor`.
- **Múltiplos ngModel sem name**: em formulários template-driven dentro de `<form>`, cada `ngModel` precisa de atributo `name`.
- **Performance**: em listas grandes, melhor optar por *one-way* para reduzir ciclos de detecção de mudança desnecessários.

---

## 7. Exemplos de Código Otimizados

### 7.1. Uso Básico

```
// user.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-user',
  template: `
    <label>
      Nome:
      <input [(ngModel)]="user.name" name="userName">
    </label>
    <p>Bem-vindo, {{ user.name }}!</p>
  `
})
export class UserComponent {
  user = { name: 'Ju' };
}

```

### 7.2. Formulário Simples com Validação

```html
<form #f="ngForm" (ngSubmit)="save(f.value)" novalidate>
  <input
    [(ngModel)]="user.email"
    name="email"
    required
    email
    #emailCtrl="ngModel"
  >
  <div *ngIf="emailCtrl.invalid && emailCtrl.touched">
    <small *ngIf="emailCtrl.errors?.required">E-mail é obrigatório.</small>
    <small *ngIf="emailCtrl.errors?.email">Formato inválido.</small>
  </div>
  <button [disabled]="f.invalid">Salvar</button>
</form>

```

### 7.3. Componente Customizado

1. **Implementa ControlValueAccessor**
    
    ```
    import { Component, forwardRef } from '@angular/core';
    import { NG_VALUE_ACCESSOR, ControlValueAccessor } from '@angular/forms';
    
    @Component({
      selector: 'star-rating',
      template: `<span *ngFor="let star of stars; index as i" (click)="rate(i+1)">
                   {{ i < value ? '★' : '☆' }}
                 </span>`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => StarRatingComponent),
        multi: true
      }]
    })
    export class StarRatingComponent implements ControlValueAccessor {
      value = 0;
      stars = Array(5);
      private onChange = (v: number) => {};
      private onTouched = () => {};
    
      writeValue(obj: number): void { this.value = obj; }
      registerOnChange(fn: any): void { this.onChange = fn; }
      registerOnTouched(fn: any): void { this.onTouched = fn; }
    
      rate(v: number) {
        this.value = v;
        this.onChange(v);
        this.onTouched();
      }
    }
    
    ```
    
2. **Uso no template**
    
    ```html
    <star-rating [(ngModel)]="movie.rating" name="rating"></star-rating>
    
    ```
    

---

## 8. Informações Adicionais

- **Template-Driven vs Reactive Forms**:
    - *Template-Driven* (usa `NgModel`) é mais simples, porém menos testável e escalável.
    - *Reactive* (usa `FormControl`/`FormGroup`) oferece maior controle e recusa o two-way binding direto.
- **ChangeDetectionStrategy.OnPush**: ao usar detecção OnPush, garanta que mudanças no objeto sejam imutáveis (criar nova referência) para que a view atualize corretamente.
- **Boas práticas**:
    - Evite binds complexos em loops grandes.
    - Prefira reactive forms em aplicações corporativas com requisitos de validação complexos.

---

## 9. Referências para Estudo Independente

- **Angular – Template Syntax**
    
    [https://angular.io/guide/template-syntax](https://angular.io/guide/template-syntax)
    
- **Angular – Forms Guide**
    
    [https://angular.io/guide/forms-overview](https://angular.io/guide/forms-overview)
    
- **Tour of Heroes Tutorial** (capítulo de formulários)
    
    [https://angular.io/tutorial/toh-pt-4](https://angular.io/tutorial/toh-pt-4)
    
- **Documentação ControlValueAccessor**
    
    [https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)
    

---

> Dica: experimente alternar entre template-driven e reactive forms em pequenos projetos para internalizar diferenças de abordagem e performance.
>