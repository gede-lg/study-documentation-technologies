# Output property

Perfeito, Gedê\! Vamos entender tudo sobre a `Output property` no Angular. Como um desenvolvedor Backend Java em transição para Go, você vai achar a lógica de comunicação entre componentes no Angular bem interessante e fundamental para construir aplicações robustas.

---

## 1\. Introdução

A `Output property` no Angular é um dos pilares da comunicação entre componentes, especificamente para permitir que um **componente filho (child)** emita eventos para que um **componente pai (parent)** possa "ouvir" e reagir a eles. Imagine que você tem um botão em um componente filho e, quando esse botão é clicado, o componente pai precisa saber disso para realizar alguma ação. É aí que a `Output property` entra em jogo.

A relevância da `Output property` é imensa no desenvolvimento de aplicações Angular, pois ela promove um modelo de comunicação claro e desacoplado entre componentes. Isso facilita a reutilização de código, a manutenção e a escalabilidade das suas aplicações. Sem ela, a comunicação do filho para o pai seria muito mais complexa e menos padronizada.

### Definição e Conceitos Fundamentais

A `Output property` é uma forma de **emitir eventos customizados** de um componente filho para um componente pai. Ela é geralmente utilizada em conjunto com a classe `EventEmitter` do Angular. Pense na `Output property` como uma "tomada de saída" no componente filho, onde ele "pluga" um evento, e o componente pai tem uma "tomada de entrada" (um listener) para "conectar" e capturar esse evento.

Seu principal propósito é permitir que o componente filho notifique o componente pai sobre mudanças de estado ou ações que ocorrem dentro dele, sem que o pai precise "saber" dos detalhes internos do filho. Isso segue o princípio da responsabilidade única e da baixa acoplagem.

---

## 2\. Sumário

Neste guia detalhado, abordaremos os seguintes tópicos:

- **Sintaxe e Estrutura da `Output property`**
- **Componentes Principais e Associados:** `@Output()` Decorator e `EventEmitter`
- **Restrições de Uso e Melhores Práticas**
- **Exemplos de Código Otimizados**
- **Informações Adicionais e Nuances**
- **Referências para Estudo Independente**

---

## 3\. Conteúdo Detalhado

### Sintaxe e Estrutura

A `Output property` é declarada no componente filho usando o decorador `@Output()` e é tipada com `EventEmitter<T>`, onde `T` é o tipo de dado que o evento irá emitir (pode ser `void` se nenhum dado for emitido).

```tsx
// src/app/componente-filho/componente-filho.component.ts
import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-componente-filho',
  template: `
    <button (click)="emitirEvento()">Clique aqui</button>
    <button (click)="emitirEventoComDados()">Enviar dados</button>
  `
})
export class ComponenteFilhoComponent {
  // 1. Declaração da Output property
  @Output()
  eventoDeClique = new EventEmitter<void>(); // Emite um evento sem dados

  @Output()
  dadosEnviados = new EventEmitter<string>(); // Emite um evento com dados do tipo string

  constructor() { }

  // 2. Método para emitir o evento
  emitirEvento() {
    this.eventoDeClique.emit(); // Dispara o evento
    console.log('Evento de clique emitido pelo filho!');
  }

  emitirEventoComDados() {
    this.dadosEnviados.emit('Dados do componente filho!'); // Dispara o evento com dados
    console.log('Evento com dados emitido pelo filho!');
  }
}

```

No componente pai, você "escuta" esse evento no template HTML, usando a sintaxe de *event binding* `(nomeDoEventoEmitidoPeloFilho)`.

```html
<app-componente-filho
  (eventoDeClique)="lidarComCliqueDoFilho()"
  (dadosEnviados)="receberDadosDoFilho($event)">
</app-componente-filho>

<p>Mensagem do pai: {{ mensagemDoPai }}</p>

```

```tsx
// src/app/componente-pai/componente-pai.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-componente-pai',
  templateUrl: './componente-pai.component.html'
})
export class ComponentePaiComponent {
  mensagemDoPai: string = '';

  constructor() { }

  // Método no componente pai para reagir ao evento do filho sem dados
  lidarComCliqueDoFilho() {
    console.log('Componente pai: O botão do filho foi clicado!');
    this.mensagemDoPai = 'O pai recebeu o clique do filho!';
  }

  // Método no componente pai para reagir ao evento do filho com dados
  receberDadosDoFilho(dados: string) {
    console.log('Componente pai: Recebi os seguintes dados do filho:', dados);
    this.mensagemDoPai = `O pai recebeu os dados: "${dados}" do filho!`;
  }
}

```

### Componentes Principais e Associados

A `Output property` depende de dois elementos principais:

1. **`@Output()` Decorator:** Este decorador marca uma propriedade como uma "saída" de evento. Ele permite que o componente filho emita eventos personalizados para o seu pai.
2. **`EventEmitter` Classe:** Uma classe do Angular que atua como um "emissor" de eventos. Você cria uma nova instância de `EventEmitter` para cada `Output property`. O método `emit()` dessa instância é usado para disparar o evento, opcionalmente passando dados junto com ele.

**Interação entre eles:**
O `@Output()` decorator, ao ser aplicado a uma propriedade que é uma instância de `EventEmitter`, transforma essa propriedade em um canal de comunicação unidirecional do filho para o pai. Quando o método `.emit()` é chamado na instância de `EventEmitter` no componente filho, o evento é disparado. O componente pai, por sua vez, tem um *event binding* em seu template que "ouve" por esse evento e executa um método em resposta. O `$event` no template do pai (ex: `receberDadosDoFilho($event)`) representa os dados que foram passados pelo método `emit()` no filho.

### Restrições de Uso

- **Comunicação Unidirecional (Filho para Pai):** A `Output property` é estritamente para comunicação do componente filho para o componente pai. Para comunicação do pai para o filho, usa-se a `Input property`.
- **Nome do Evento:** É uma boa prática nomear as `Output properties` como eventos, no formato `nomeDoEvento` ou `nomeDoEventoChange` (se for para notificar uma mudança de valor que pode ser usada com `[(ngModel)]`).
- **Evitar Reutilização de Nomes:** Evite usar nomes de eventos HTML nativos (como `click`, `change`, etc.) para suas `Output properties` customizadas, para evitar confusão.

---

## 4\. Exemplos de Código Otimizados

Vamos aprofundar com alguns casos de uso comuns.

### Exemplo 1: Botão de Confirmar (Básico)

Imagine um componente `ConfirmButtonComponent` que, ao ser clicado, notifica o componente pai para prosseguir com uma ação.

```tsx
// src/app/confirm-button/confirm-button.component.ts
import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-confirm-button',
  template: `
    <button class="btn btn-primary" (click)="onConfirm()">
      Confirmar Ação
    </button>
  `,
  styles: [`
    .btn { padding: 10px 20px; border-radius: 5px; cursor: pointer; }
    .btn-primary { background-color: #007bff; color: white; border: none; }
  `]
})
export class ConfirmButtonComponent {
  // Define a saída para o evento de confirmação
  @Output() confirmed = new EventEmitter<void>();

  constructor() { }

  onConfirm(): void {
    // Emite o evento quando o botão é clicado
    this.confirmed.emit();
  }
}

```

```tsx
// src/app/app.component.ts (Componente Pai)
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h1>Exemplo de Output Property</h1>
    <app-confirm-button (confirmed)="handleConfirmation()"></app-confirm-button>
    <p *ngIf="isConfirmed">Ação confirmada pelo pai!</p>
  `
})
export class AppComponent {
  isConfirmed: boolean = false;

  handleConfirmation(): void {
    this.isConfirmed = true;
    console.log('Pai: A confirmação foi recebida!');
    // Aqui você pode adicionar a lógica de negócios real, como salvar dados, navegar, etc.
  }
}

```

### Exemplo 2: Item de Lista Editável (Avançado com Dados)

Considere um componente `ListItemComponent` que exibe um item de uma lista e permite editá-lo. Quando a edição é concluída, ele notifica o componente pai sobre o novo valor.

```tsx
// src/app/list-item/list-item.component.ts
import { Component, Input, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-list-item',
  template: `
    <div>
      <span *ngIf="!editing">{{ itemText }}</span>
      <input *ngIf="editing" [(ngModel)]="editedText" (keyup.enter)="saveChanges()" />
      <button (click)="toggleEdit()">{{ editing ? 'Salvar' : 'Editar' }}</button>
    </div>
  `,
  styles: [`
    div { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
    input { padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
    button { padding: 5px 10px; border-radius: 3px; cursor: pointer; }
  `]
})
export class ListItemComponent {
  @Input() itemText: string = ''; // Recebe o texto do item do pai
  @Output() itemEdited = new EventEmitter<string>(); // Emite o novo texto editado

  editing: boolean = false;
  editedText: string = '';

  constructor() { }

  ngOnInit(): void {
    this.editedText = this.itemText; // Inicializa com o texto original
  }

  toggleEdit(): void {
    this.editing = !this.editing;
    if (!this.editing) {
      this.saveChanges(); // Salva se estiver saindo do modo de edição
    }
  }

  saveChanges(): void {
    if (this.editedText !== this.itemText) { // Só emite se houver mudança
      this.itemEdited.emit(this.editedText); // Emite o novo valor
      this.itemText = this.editedText; // Atualiza o texto exibido localmente
    }
    this.editing = false; // Sai do modo de edição
  }
}

```

```tsx
// src/app/app.component.ts (Componente Pai)
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h2>Minha Lista de Tarefas</h2>
    <ul>
      <li *ngFor="let task of tasks; let i = index">
        <app-list-item
          [itemText]="task"
          (itemEdited)="updateTask(i, $event)">
        </app-list-item>
      </li>
    </ul>
    <p *ngIf="lastEditedTask">Última tarefa editada: {{ lastEditedTask }}</p>
  `
})
export class AppComponent {
  tasks: string[] = ['Comprar pão', 'Estudar Angular', 'Fazer exercício'];
  lastEditedTask: string | null = null;

  constructor() { }

  updateTask(index: number, newText: string): void {
    this.tasks[index] = newText; // Atualiza a tarefa na lista
    this.lastEditedTask = newText;
    console.log(`Pai: Tarefa no índice ${index} atualizada para "${newText}"`);
  }
}

```

---

## 5\. Informações Adicionais

- **Comunicação Bidirecional (`banana-in-a-box` syntax `[(ngModel)]`):** Embora a `Output property` seja unidirecional, é comum combiná-la com uma `Input property` e a convenção `nomePropriedadeChange` para criar uma sintaxe de *two-way data binding* similar ao `[(ngModel)]`. Por exemplo, se você tem um `@Input() valor: string` e um `@Output() valorChange = new EventEmitter<string>()`, o Angular permite que você use `[(valor)]="minhaVariavel"` no pai. Isso é uma convenção e não um recurso intrínseco da `Output property` em si, mas é importante para desenvolvedores que desejam criar componentes com essa capacidade.
- **Decoupling e Reusabilidade:** O uso de `Output properties` é fundamental para o *decoupling* (desacoplamento) entre componentes. O componente filho não precisa saber quem é seu pai ou como ele reagirá ao evento. Ele simplesmente emite o evento. Isso torna o componente filho altamente reutilizável em diferentes partes da aplicação ou até em outros projetos.
- **Alternativas para Comunicação entre Componentes:**
    - **Serviços (Services):** Para comunicação entre componentes não relacionados (irmãos, tios, etc.), ou para gerenciar estados globais, o uso de serviços compartilhados com `Subject` ou `BehaviorSubject` do RxJS é a abordagem preferida.
    - **ViewChild/ViewChildren:** Para acessar métodos ou propriedades públicas de um componente filho diretamente do pai, você pode usar `@ViewChild` ou `@ViewChildren`. No entanto, essa abordagem aumenta o acoplamento e deve ser usada com moderação, preferindo `Input` e `Output` sempre que possível.

---

## 6\. Referências para Estudo Independente

Para aprofundar seus conhecimentos, recomendo os seguintes recursos oficiais e confiáveis:

- **Documentação Oficial do Angular - Comunicação entre Componentes:**
    - [https://angular.io/guide/component-interaction](https://angular.io/guide/component-interaction)
    - Esta seção da documentação é a fonte mais precisa e detalhada sobre `Input` e `Output` properties.
- **Documentação Oficial do Angular - `@Output()`:**
    - [https://angular.io/api/core/Output](https://angular.io/api/core/Output)
- **Documentação Oficial do Angular - `EventEmitter`:**
    - [https://angular.io/api/core/EventEmitter](https://angular.io/api/core/EventEmitter)
- **Artigos e Tutoriais (Busca por "Angular Output Property Tutorial"):**
    - Sites como o [Thoughtram](https://www.google.com/search?q=https://blog.thoughtram.io/angular/2016/06/22/event-bus-with-rxjs-in-angular2.html) (embora alguns artigos possam ser mais antigos, a lógica fundamental persiste) e [Netanel Basal](https://www.google.com/search?q=https://netbasal.com/the-complete-guide-to-angular-decorators-d022b376d4c6) frequentemente têm ótimos tutoriais práticos. Lembre-se de verificar a data de publicação para garantir que o conteúdo está atualizado com as versões mais recentes do Angular.

---

Espero que esta explicação detalhada, A.R.I.A, seja bastante útil para você, Gedê\! Se tiver mais alguma dúvida, pode perguntar.