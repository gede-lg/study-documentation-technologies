# Ciclo de vida

Fala, Gedê\! Beleza? A.R.I.A. aqui para te ajudar a desvendar o **Ciclo de Vida de um Componente em Angular**. Como você é desenvolvedor Backend Java e está migrando para Go, entender esses fundamentos em Angular vai te dar uma base sólida para trabalhar com o frontend.

---

## Introdução

No desenvolvimento de aplicações web modernas, especialmente com frameworks como o Angular, os **componentes** são os blocos de construção fundamentais da interface do usuário. Eles encapsulam a lógica, o template HTML e os estilos CSS para uma parte específica da UI. O **ciclo de vida de um componente** refere-se à sequência de eventos que ocorrem desde o momento em que um componente é criado e inicializado até quando ele é destruído.

Entender esse ciclo é crucial para qualquer desenvolvedor Angular, pois permite que você execute código em momentos específicos, otimizando o desempenho, manipulando dados de forma eficaz e gerenciando recursos. Por exemplo, você pode querer buscar dados de uma API assim que um componente é carregado, ou limpar assinaturas de observables quando ele é removido da tela para evitar vazamentos de memória.

---

## Sumário

- **O que é o Ciclo de Vida de um Componente em Angular?**
- **Hooks do Ciclo de Vida**
    - `ngOnChanges`
    - `ngOnInit`
    - `ngDoCheck`
    - `ngAfterContentInit`
    - `ngAfterContentChecked`
    - `ngAfterViewInit`
    - `ngAfterViewChecked`
    - `ngOnDestroy`
- **Interação entre os Hooks**
- **Restrições de Uso e Melhores Práticas**
- **Exemplos de Código Otimizados**
- **Informações Adicionais**
- **Referências para Estudo Independente**

---

## Conteúdo Detalhado

### O que é o Ciclo de Vida de um Componente em Angular?

O ciclo de vida de um componente em Angular é um conjunto de "fases" pelas quais um componente passa desde a sua criação até a sua destruição. Cada fase representa um momento específico na vida do componente, e o Angular oferece "hooks" (ganchos) que são métodos que você pode implementar para executar código em resposta a esses eventos do ciclo de vida.

Os hooks do ciclo de vida servem principalmente para:

- **Inicializar o componente:** Configurar dados iniciais, buscar informações.
- **Reagir a mudanças:** Responder a alterações em propriedades de entrada (`@Input`).
- **Detectar e aplicar mudanças:** Forçar verificações de detecção de mudanças.
- **Manipular conteúdo e visão:** Acessar e manipular elementos do DOM após sua projeção ou renderização.
- **Limpar recursos:** Desinscrever de observables, liberar memória.

### Hooks do Ciclo de Vida

Para utilizar um hook, seu componente precisa implementar a interface correspondente do `@angular/core`. Por exemplo, para usar `ngOnInit`, você implementaria `OnInit`.

### `ngOnChanges`

- **Função:** Chamado sempre que uma ou mais propriedades de entrada (`@Input`) vinculadas a dados mudam. É o primeiro hook a ser chamado.
- **Método:** `ngOnChanges(changes: SimpleChanges): void`
- **Parâmetro:** `changes` é um objeto `SimpleChanges` que contém os valores atuais e anteriores das propriedades de entrada que mudaram.

### `ngOnInit`

- **Função:** Chamado uma única vez, após o `ngOnChanges` inicial e após a injeção de dependências do Angular. É o local ideal para lógica de inicialização.
- **Método:** `ngOnInit(): void`

### `ngDoCheck`

- **Função:** Chamado imediatamente após `ngOnChanges` em cada ciclo de detecção de mudanças, e também após `ngOnInit` na primeira vez. Ele permite que você implemente sua própria lógica de detecção de mudanças para propriedades que o Angular não monitora automaticamente.
- **Método:** `ngDoCheck(): void`

### `ngAfterContentInit`

- **Função:** Chamado uma única vez após o Angular projetar conteúdo externo (transcluído) na visualização do componente.
- **Método:** `ngAfterContentInit(): void`

### `ngAfterContentChecked`

- **Função:** Chamado após `ngAfterContentInit` e após cada verificação de `ngDoCheck`. É invocado sempre que o conteúdo projetado do componente foi verificado.
- **Método:** `ngAfterContentChecked(): void`

### `ngAfterViewInit`

- **Função:** Chamado uma única vez após o Angular inicializar as visualizações do componente e das visualizações filhas. É o momento para interagir com elementos do DOM filhos usando `@ViewChild` ou `@ViewChildren`.
- **Método:** `ngAfterViewInit(): void`

### `ngAfterViewChecked`

- **Função:** Chamado após `ngAfterViewInit` e após cada verificação de `ngDoCheck`. É invocado sempre que a visualização do componente e as visualizações filhas foram verificadas.
- **Método:** `ngAfterViewChecked(): void`

### `ngOnDestroy`

- **Função:** Chamado imediatamente antes do Angular destruir o componente. É o local para realizar limpeza de recursos, como desinscrever de observables, remover event listeners ou liberar memória.
- **Método:** `ngOnDestroy(): void`

### Interação entre os Hooks

A ordem de execução dos hooks é fundamental:

1. `ngOnChanges` (se houver inputs)
2. `ngOnInit`
3. `ngDoCheck`
4. `ngAfterContentInit`
5. `ngAfterContentChecked`
6. `ngAfterViewInit`
7. `ngAfterViewChecked`
8. `ngOnDestroy` (quando o componente é removido do DOM)

Os hooks `ngOnChanges`, `ngDoCheck`, `ngAfterContentChecked` e `ngAfterViewChecked` podem ser chamados múltiplas vezes ao longo da vida do componente, enquanto `ngOnInit`, `ngAfterContentInit`, `ngAfterViewInit` e `ngOnDestroy` são chamados apenas uma vez.

### Restrições de Uso e Melhores Práticas

- **`ngOnInit` vs. Construtor:** Use o construtor para injeção de dependências e inicialização mínima. Use `ngOnInit` para lógica de inicialização mais complexa, como chamadas de API, pois as propriedades de entrada (`@Input`) não estão disponíveis no construtor.
- **Evite lógica pesada em hooks frequentes:** `ngDoCheck`, `ngAfterContentChecked` e `ngAfterViewChecked` são chamados com muita frequência. Evite operações custosas nesses hooks para não impactar o desempenho da aplicação.
- **Limpeza em `ngOnDestroy`:** Sempre realize a limpeza de recursos (desinscrição de observables, timers, etc.) em `ngOnDestroy` para evitar vazamentos de memória.
- **`@ViewChild` e `@ContentChild`:** Eles só estarão disponíveis para uso em `ngAfterViewInit` e `ngAfterContentInit`, respectivamente.

---

## Exemplos de Código Otimizados

Vamos criar um componente simples de contador e usar alguns hooks para ilustrar seus usos.

```tsx
// src/app/contador/contador.component.ts

import { Component, OnInit, OnChanges, SimpleChanges, Input, OnDestroy, ViewChild, ElementRef, AfterViewInit } from '@angular/core';
import { interval, Subscription } from 'rxjs';

@Component({
  selector: 'app-contador',
  template: `
    <div style="border: 1px solid #ccc; padding: 15px; margin-bottom: 20px;">
      <h3>Contador: {{ valorAtual }}</h3>
      <p>Valor Inicial Recebido (Input): {{ valorInicialInput }}</p>
      <p #statusElement>Status do Timer: {{ timerStatus }}</p>
      <button (click)="incrementar()">Incrementar</button>
      <button (click)="reiniciar()">Reiniciar</button>
    </div>
  `,
  styles: [`
    div {
      background-color: #f0f0f0;
      border-radius: 8px;
    }
    button {
      margin-right: 10px;
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #007bff;
      color: white;
    }
    button:hover {
      opacity: 0.9;
    }
  `]
})
export class ContadorComponent implements OnInit, OnChanges, OnDestroy, AfterViewInit {
  @Input() valorInicialInput: number = 0; // Propriedade de entrada
  valorAtual: number = 0;
  timerSubscription: Subscription | undefined;
  timerStatus: string = 'Parado';

  @ViewChild('statusElement') statusElementRef!: ElementRef; // Para acessar um elemento do DOM

  constructor() {
    console.log('1. Construtor: Componente instanciado.');
    // Geralmente não colocamos muita lógica aqui, apenas injeção de dependências.
    // O valorInicialInput ainda não está disponível aqui.
  }

  // --- HOOKS ---

  ngOnChanges(changes: SimpleChanges): void {
    console.log('2. ngOnChanges: Propriedades de entrada alteradas.', changes);
    // Este hook é chamado antes de ngOnInit na primeira vez, e sempre que @Input muda.
    if (changes['valorInicialInput']) {
      this.valorAtual = this.valorInicialInput;
      console.log(`  -> valorInicialInput mudou para: ${this.valorAtual}`);
    }
  }

  ngOnInit(): void {
    console.log('3. ngOnInit: Componente inicializado.');
    // Ideal para buscar dados ou configurar subscriptions.
    // Aqui, this.valorInicialInput já está disponível.
    this.valorAtual = this.valorInicialInput;
    this.iniciarTimer();
  }

  ngAfterViewInit(): void {
    console.log('6. ngAfterViewInit: Visualização do componente e filhas inicializadas.');
    // O DOM do componente está totalmente renderizado e disponível.
    // Podemos acessar elementos usando @ViewChild aqui.
    if (this.statusElementRef) {
      console.log('  -> Texto do elemento de status: ', this.statusElementRef.nativeElement.textContent);
      this.statusElementRef.nativeElement.style.color = 'blue';
    }
  }

  ngOnDestroy(): void {
    console.log('8. ngOnDestroy: Componente sendo destruído. Realizando limpeza...');
    // Essencial para evitar vazamentos de memória.
    if (this.timerSubscription) {
      this.timerSubscription.unsubscribe(); // Desinscreve do observable do timer
      console.log('  -> Timer desinscrito.');
    }
  }

  // --- MÉTODOS AUXILIARES ---

  incrementar(): void {
    this.valorAtual++;
    console.log('Incrementando contador:', this.valorAtual);
  }

  reiniciar(): void {
    this.valorAtual = this.valorInicialInput;
    console.log('Contador reiniciado para:', this.valorAtual);
  }

  iniciarTimer(): void {
    // Exemplo de uso de um observable que precisa ser limpo em ngOnDestroy
    this.timerSubscription = interval(1000).subscribe(() => {
      this.timerStatus = `Rodando (${new Date().toLocaleTimeString()})`;
    });
    console.log('Timer iniciado.');
  }
}

```

Para ver este exemplo em ação, você precisaria de um componente pai (`app.component.ts`) chamando `app-contador`:

```tsx
// src/app/app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h1>Exemplo de Ciclo de Vida em Angular</h1>
    <button (click)="mostrarContador = !mostrarContador">
      {{ mostrarContador ? 'Esconder' : 'Mostrar' }} Contador
    </button>
    <button (click)="mudarValorInput()">Mudar Input do Contador</button>
    <hr>
    <app-contador *ngIf="mostrarContador" [valorInicialInput]="valorParaContador"></app-contador>
    <hr>
    <p>Verifique o console do navegador para ver os logs dos hooks.</p>
  `
})
export class AppComponent {
  mostrarContador: boolean = true;
  valorParaContador: number = 10;

  mudarValorInput(): void {
    this.valorParaContador = Math.floor(Math.random() * 100);
  }
}

```

E no seu `app.module.ts`, você precisaria declarar `ContadorComponent`:

```tsx
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { ContadorComponent } from './contador/contador.component'; // Importe o componente

@NgModule({
  declarations: [
    AppComponent,
    ContadorComponent // Declare o componente
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

Ao executar esta aplicação (`ng serve` no terminal), observe o console do navegador:

- Ao carregar a página, você verá a sequência `Constructor` -\> `ngOnChanges` -\> `ngOnInit` -\> `ngAfterViewInit`.
- Ao clicar em "Mudar Input do Contador", você verá `ngOnChanges` novamente.
- Ao clicar em "Esconder Contador", o componente será removido do DOM e você verá o log de `ngOnDestroy`.

---

## Informações Adicionais

- **Detecção de Mudanças:** O Angular usa um mecanismo de detecção de mudanças para verificar se os dados foram alterados e atualizar o DOM. Os hooks do ciclo de vida são intrinsecamente ligados a esse mecanismo.
- **Modos de Detecção de Mudanças:** Por padrão, o Angular usa o modo de detecção de mudanças "Default" (`ChangeDetectionStrategy.Default`). Você pode otimizar o desempenho alterando para "OnPush" (`ChangeDetectionStrategy.OnPush`), o que faz com que o componente só seja verificado se suas propriedades de entrada mudarem ou se um evento for disparado dentro do componente.
- **`ngDoCheck` e Imutabilidade:** `ngDoCheck` é útil para lidar com mutações em objetos ou arrays que não são detectadas por `ngOnChanges`. No entanto, é mais eficiente trabalhar com dados imutáveis (criando novas referências em vez de modificar as existentes) para aproveitar a detecção de mudanças otimizada do Angular.

---

## Referências para Estudo Independente

Para se aprofundar ainda mais no ciclo de vida dos componentes em Angular, A.R.I.A. recomenda os seguintes recursos:

- **Documentação Oficial do Angular - Ciclo de Vida de um Componente:**
    - [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)
    - Esta é a fonte mais confiável e completa, Gedê. Sempre consulte a documentação oficial para qualquer dúvida.
- **Artigo Medium - Angular Component Lifecycle Hooks Explained:**
    - [https://medium.com/@devangdpatel/angular-component-lifecycle-hooks-explained-f1f3e580e5e0](https://medium.com/@devangdpatel/angular-component-lifecycle-hooks-explained-f1f3e580e5e0)
    - Um artigo que oferece uma boa visão geral e exemplos práticos.
- **Vídeo YouTube - Angular Lifecycle Hooks Tutorial:**
    - Procure por "Angular Lifecycle Hooks" em canais como "Academind" ou "Fireship" para explicações visuais e exemplos de código.
- **Livros sobre Angular:**
    - "Angular Development with TypeScript" (por Yakov Fain e Anton Moiseev)
    - "Ng-Book: The Complete Guide to Angular" (por Ari Lerner et al.)
    - Esses livros oferecem uma cobertura aprofundada de todos os aspectos do Angular, incluindo o ciclo de vida.

Espero que esta explicação detalhada te ajude a entender melhor o ciclo de vida dos componentes em Angular, Gedê\! Se tiver mais alguma dúvida, é só chamar a A.R.I.A.\!