# TemplateRef

Olá, Gedê\! Entendido. Vou te ajudar com uma explicação detalhada sobre `TemplateRef<>` no Angular, um tema bem relevante para quem trabalha com desenvolvimento frontend.

---

# Entendendo `TemplateRef<>` no Angular

No desenvolvimento com Angular, muitas vezes precisamos de controle preciso sobre a renderização do DOM. É nesse cenário que o `TemplateRef<>` se torna uma ferramenta poderosa. Ele é fundamental para a criação de **diretivas estruturais** personalizadas e para a manipulação dinâmica de templates, permitindo um alto nível de flexibilidade na forma como seus componentes são exibidos.

Como desenvolvedor, principalmente buscando uma transição para Go, entender os fundamentos do Angular, como este, mostra a profundidade do seu conhecimento em sistemas, Gedê. Saber como o Angular gerencia a renderização de forma mais granular é crucial para otimizar aplicações e criar componentes reutilizáveis.

## Sumário

- **O que é `TemplateRef<>`?**
- **Como `TemplateRef<>` funciona?**
- **Interação com `ViewContainerRef` e `@ViewChild`**
- **Sintaxe e Estrutura**
- **Casos de Uso e Exemplos de Código**
- **Informações Adicionais**
    - Prós e Contras
    - Quando utilizar e quando evitar
- **Referências para Estudo Independente**

---

## Conteúdo Detalhado

### O que é `TemplateRef<>`?

Em termos simples, `TemplateRef<>` é uma **referência a um template HTML** (ou a um bloco de HTML) que não foi renderizado no DOM. Ele representa o conteúdo de um elemento `<ng-template>` ou de qualquer outro elemento ao qual uma diretiva estrutural (como `*ngIf`, `*ngFor`) é aplicada.

Pense assim: quando você usa `*ngIf="false"`, o conteúdo dentro desse `*ngIf` não é adicionado ao DOM imediatamente. Ele existe como um `TemplateRef` esperando o momento certo (quando `*ngIf` se tornar `true`) para ser renderizado.

### Como `TemplateRef<>` funciona?

O Angular não renderiza todo o seu template de uma vez. Quando encontra uma diretiva estrutural, ele extrai o conteúdo dessa diretiva e o encapsula em um `TemplateRef`. Esse `TemplateRef` é então passado para a diretiva, que decide quando e como esse template deve ser renderizado no DOM.

### Interação com `ViewContainerRef` e `@ViewChild`

Para realmente fazer uso do `TemplateRef`, precisamos de outros elementos chave:

- **`ViewContainerRef`**: Este é o "container" onde um `TemplateRef` pode ser anexado para ser renderizado. Ele representa um local específico no DOM onde você pode adicionar ou remover views (instâncias de templates). O `ViewContainerRef` possui métodos como `createEmbeddedView()` para instanciar e anexar um template.
- **`@ViewChild`**: É um decorador que permite injetar uma referência a um elemento do template (como um `TemplateRef` ou um componente) em sua classe TypeScript. Você o usa para obter a referência do `TemplateRef` que você definiu no seu template HTML.

Juntos, `TemplateRef`, `ViewContainerRef` e `@ViewChild` formam a espinha dorsal para a criação de conteúdo dinâmico e flexível no Angular, especialmente útil para a construção de bibliotecas de componentes ou para a manipulação avançada da interface do usuário.

### Sintaxe e Estrutura

A sintaxe principal para definir um `TemplateRef` é através da tag `<ng-template>`. Essa tag é especial no Angular porque ela não renderiza nada diretamente no DOM. Ela serve apenas como um contêiner para o template que você deseja manipular programaticamente.

```html
<ng-template #meuTemplate>
  <p>Este é o conteúdo do meu template.</p>
  <p>Ele só será renderizado se eu o anexar programaticamente.</p>
</ng-template>

```

No exemplo acima, `#meuTemplate` cria uma variável de template que pode ser acessada em seu componente TypeScript.

### Componentes Principais e Associados

- **`TemplateRef<C>`**:
    - **Propriedades/Métodos:**
        - `elementRef: ElementRef`: Retorna a `ElementRef` nativa para o elemento HTML que contém este template.
        - `createEmbeddedView(context?: C): EmbeddedViewRef<C>`: Cria uma *view* a partir deste template e a retorna. Opcionalmente, você pode passar um objeto `context` para a view, permitindo que o template acesse dados dinamicamente. O tipo `C` representa a interface do contexto que o template espera receber.
- **`ViewContainerRef`**:
    - **Propriedades/Métodos:**
        - `createEmbeddedView(templateRef: TemplateRef<any>, context?: C, index?: number): EmbeddedViewRef<C>`: Cria uma *view* embutida a partir de um `TemplateRef` e a insere no container.
        - `createComponent(componentType: Type<C>, options?: { ... }): ComponentRef<C>`: Cria e anexa um componente dinamicamente.
        - `clear(): void`: Remove todas as views do container.
        - `remove(index?: number): void`: Remove uma view em um índice específico.
        - `insert(viewRef: ViewRef, index?: number): ViewRef`: Insere uma view existente no container.
        - `get(index: number): ViewRef | null`: Retorna a view em um índice específico.

A interação entre eles ocorre da seguinte forma: você obtém um `TemplateRef` (geralmente via `@ViewChild` de um `<ng-template>`). Em seguida, você injeta um `ViewContainerRef` (normalmente em um elemento host ou em um local específico no DOM). Com essas duas referências, você usa o `ViewContainerRef.createEmbeddedView(templateRef)` para renderizar o conteúdo do `TemplateRef` no local desejado.

### Restrições de uso

- **`ng-template` não é renderizado diretamente**: Lembre-se que o conteúdo de `<ng-template>` não aparece no DOM a menos que você o renderize explicitamente via `ViewContainerRef`.
- **Escopo de contexto**: Ao criar uma `EmbeddedView`, o contexto passado para `createEmbeddedView` é o único contexto que o template tem acesso, além de qualquer contexto herdado do componente pai.

---

## Exemplos de Código Otimizados

### Exemplo Básico: Renderizando um `ng-template` condicionalmente

Vamos criar um componente simples que renderiza um template com base em um `boolean`.

```tsx
// app.component.ts
import { Component, ViewChild, TemplateRef, ViewContainerRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h2>Exemplo Básico de TemplateRef</h2>

    <button (click)="toggleContent()">Alternar Conteúdo</button>

    <ng-template #myDynamicTemplate>
      <p>Conteúdo dinâmico renderizado!</p>
      <p>Data e Hora: {{ currentDateTime | date:'medium' }}</p>
    </ng-template>

    <div #container></div>
  `
})
export class AppComponent implements AfterViewInit {
  @ViewChild('myDynamicTemplate') myDynamicTemplateRef!: TemplateRef<any>;
  @ViewChild('container', { read: ViewContainerRef }) containerRef!: ViewContainerRef;

  showContent: boolean = false;
  currentDateTime: Date = new Date();

  ngAfterViewInit() {
    // Inicialmente, não renderiza nada
    this.renderContent();
  }

  toggleContent() {
    this.showContent = !this.showContent;
    this.renderContent();
  }

  private renderContent() {
    // Limpa o container para evitar duplicações ao alternar
    this.containerRef.clear();

    if (this.showContent) {
      // Cria e anexa a view do template no container
      this.containerRef.createEmbeddedView(this.myDynamicTemplateRef, {
        currentDateTime: new Date() // Passando um contexto para o template
      });
    }
  }
}

```

### Exemplo Avançado: Criando uma Diretiva Estrutural Personalizada (`ngRepeat`)

Este é o uso mais poderoso do `TemplateRef`: criar sua própria diretiva que se comporta como `*ngIf` ou `*ngFor`. Vamos criar uma diretiva `*ngRepeat` que renderiza um bloco de template um número especificado de vezes.

```tsx
// ng-repeat.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[ngRepeat]'
})
export class NgRepeatDirective {
  // Recebe o número de vezes para repetir
  @Input() set ngRepeatOf(count: number) {
    this.viewContainer.clear(); // Limpa views existentes

    for (let i = 0; i < count; i++) {
      // Cria uma view para cada repetição
      // $implicit é a variável padrão para iteradores em templates (como 'item' em *ngFor)
      // index é uma variável adicional que pode ser acessada no template
      this.viewContainer.createEmbeddedView(this.templateRef, {
        $implicit: i, // O item atual da iteração
        index: i,     // O índice da iteração
        isFirst: i === 0,
        isLast: i === count - 1,
        isEven: i % 2 === 0,
        isOdd: i % 2 !== 0
      });
    }
  }

  constructor(
    private templateRef: TemplateRef<any>, // O template que a diretiva está aplicada
    private viewContainer: ViewContainerRef // Onde o template será renderizado
  ) {}
}

```

```tsx
// app.module.ts (para declarar a diretiva)
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { NgRepeatDirective } from './ng-repeat.directive'; // Importe sua diretiva

@NgModule({
  declarations: [
    AppComponent,
    NgRepeatDirective // Declare a diretiva aqui
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

```html
<hr>
<h2>Exemplo de Diretiva Estrutural Personalizada (*ngRepeat)</h2>

<div *ngRepeat="let i of 5; let idx = index; let first = isFirst">
  <p>Repetição {{ idx + 1 }}. Valor: {{ i }}. Primeira? {{ first }}</p>
</div>

<div *ngRepeat="let num of 3">
  <p>Item número: {{ num }}</p>
</div>

```

Neste exemplo, a diretiva `*ngRepeat` injeta o `TemplateRef` e o `ViewContainerRef` para controlar a renderização do conteúdo.

---

## Informações Adicionais

### Prós e Contras

| Característica | Prós | Contras |
| --- | --- | --- |
| **Flexibilidade** | Permite controle total sobre a renderização do DOM e criação de diretivas complexas. | Maior complexidade para casos de uso simples. |
| **Reusabilidade** | Facilita a criação de componentes e diretivas altamente reutilizáveis e genéricas. | Curva de aprendizado inicial pode ser mais íngreme para iniciantes. |
| **Desempenho** | Otimiza a renderização ao adiar a criação de elementos até que sejam necessários. | Uso incorreto pode levar a vazamento de memória se as views não forem devidamente limpas. |
| **Abstração** | Ajuda a abstrair a lógica de renderização do template do componente principal. | Pode dificultar a depuração se a lógica de renderização estiver muito distribuída. |

### Quando utilizar `TemplateRef<>`

- **Criação de Diretivas Estruturais Personalizadas**: Esse é o caso de uso mais comum e poderoso. Se você precisa de uma lógica de exibição condicional ou repetitiva que não é coberta por `ngIf` ou `ngFor`, você precisará de `TemplateRef`.
- **Componentes de Conteúdo Dinâmico/Slotting**: Quando você quer que um componente hospede conteúdo fornecido pelo componente pai de forma flexível (sem usar `ng-content` simples, que é mais limitado). Pense em componentes de modal, painéis de abas, etc., onde o conteúdo interno pode ser um template inteiro.
- **Performance (Deferir Renderização)**: Para renderizar partes da UI apenas quando elas são realmente necessárias, otimizando o carregamento inicial da aplicação.
- **Bibliotecas de Componentes**: Essencial para construir bibliotecas onde você precisa fornecer APIs para os usuários customizarem a renderização de partes do componente.

### Quando evitar o uso de `TemplateRef<>`

- **Renderização Condicional Simples**: Para `if/else` básicos, `ngIf` é muito mais simples e direto.
- **Iteração Simples**: Para iterar sobre coleções, `ngFor` é a ferramenta ideal.
- **Injeção de Conteúdo Estático**: Para injetar um bloco de HTML estático em um componente filho, `ng-content` é a solução mais fácil.
- **Over-engenharia**: Não o use se uma solução mais simples e legível já existir para o seu problema. Aumenta a complexidade sem necessidade.

---

## Referências para Estudo Independente

Para aprofundar seus conhecimentos, Gedê, sugiro os seguintes recursos:

- **Documentação Oficial do Angular - Structural Directives**: O ponto de partida essencial para entender como as diretivas estruturais (que usam `TemplateRef` internamente) funcionam.
    - [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
- **Documentação Oficial do Angular - TemplateRef**: Detalhes sobre a classe `TemplateRef` na API do Angular.
    - [https://angular.io/api/core/TemplateRef](https://angular.io/api/core/TemplateRef)
- **Documentação Oficial do Angular - ViewContainerRef**: Detalhes sobre a classe `ViewContainerRef` na API do Angular.
    - [https://angular.io/api/core/ViewContainerRef](https://angular.io/api/core/ViewContainerRef)
- **Artigos e Tutoriais no Medium/dev.to**: Procure por artigos que abordam a criação de diretivas estruturais personalizadas. Alguns autores como Netanel Basal e Todd Motto têm ótimos conteúdos sobre tópicos avançados do Angular.
    - Pesquise por "Angular custom structural directive tutorial" ou "Angular TemplateRef ViewContainerRef example".

Com esses recursos, Gedê, você terá uma base sólida para explorar ainda mais as capacidades do `TemplateRef` no Angular. Se tiver mais alguma dúvida, é só chamar\!