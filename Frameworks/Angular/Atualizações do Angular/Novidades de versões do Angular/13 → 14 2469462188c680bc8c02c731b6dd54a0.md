# 13 → 14

Olá Gedê\! Como A.R.I.A (Assistente Rápida para Idiotas Atarefados), preparei um compilado extremamente detalhado com todas as novidades que o Angular 14 trouxe em relação à versão 13.

Aqui está um mergulho profundo nas principais mudanças, com exemplos de código do antes e depois para ilustrar cada ponto.

### 1\. Componentes Standalone: O Fim da Obrigatoriedade dos NgModules

Esta é, sem dúvida, a mudança mais impactante no Angular 14. Os componentes standalone simplificam a autoria de aplicações Angular, tornando os `NgModules` opcionais. Isso reduz significativamente a quantidade de código boilerplate necessário para criar desde um simples componente até uma aplicação inteira.

**Antes (Angular 13): A Era dos `NgModules`**

Em versões anteriores, todo componente precisava ser declarado dentro de um `@NgModule`. Se um componente precisasse de outros componentes, diretivas ou pipes, o módulo que o declarava também precisava importar os módulos correspondentes.

*Exemplo de um componente simples:*

**`hello-world.component.ts` (Angular 13)**

```tsx
import { Component } from '@angular/core';

@Component({
  selector: 'app-hello-world',
  template: '<h1>Olá, Mundo!</h1>'
})
export class HelloWorldComponent {}

```

**`app.module.ts` (Angular 13)**

```tsx
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { HelloWorldComponent } from './hello-world.component'; // Importa o componente

@NgModule({
  declarations: [
    AppComponent,
    HelloWorldComponent // Declara o componente
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

**`app.component.ts` (Angular 13)**

```tsx
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: '<app-hello-world></app-hello-world>'
})
export class AppComponent { }

```

**Depois (Angular 14): A Liberdade dos Componentes Standalone**

Com o Angular 14, você pode marcar um componente, diretiva ou pipe como `standalone: true`. Isso significa que ele não precisa mais ser declarado em um `NgModule`. Suas dependências (outros componentes, diretivas, pipes) são gerenciadas diretamente no próprio decorador `@Component`.

*Exemplo com componente standalone:*

**`hello-world.component.ts` (Angular 14)**

```tsx
import { Component } from '@angular/core';

@Component({
  standalone: true, // A mágica acontece aqui!
  selector: 'app-hello-world',
  template: '<h1>Olá, Mundo Standalone!</h1>'
})
export class HelloWorldComponent {}

```

**`app.component.ts` (Angular 14)**

```tsx
import { Component } from '@angular/core';
import { HelloWorldComponent } from './hello-world.component'; // Importa o componente diretamente

@Component({
  standalone: true,
  selector: 'app-root',
  imports: [HelloWorldComponent], // Importa suas dependências aqui
  template: '<app-hello-world></app-hello-world>',
})
export class AppComponent {}

```

E para inicializar a aplicação (bootstrapping), o `main.ts` também muda, eliminando a necessidade de um `AppModule`.

**`main.ts` (Angular 14)**

```tsx
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent)
  .catch(err => console.error(err));

```

---

### 2\. Formulários Reativos Tipados (Typed Reactive Forms)

Essa foi uma das funcionalidades mais solicitadas pela comunidade por anos. O Angular 14 finalmente introduziu a tipagem estrita para a API de formulários reativos (`Reactive Forms`). Isso garante que os valores dentro dos controles, grupos e arrays de formulário sejam seguros em tempo de compilação, prevenindo muitos bugs comuns.

**Antes (Angular 13): O Mundo do `any`**

Anteriormente, os elementos do `FormControl`, `FormGroup` e `FormArray` eram fracamente tipados, utilizando `any` por padrão. Isso significava que você podia, por exemplo, usar `setValue` com um tipo de dado incorreto sem que o TypeScript acusasse um erro.

**Exemplo (Angular 13):**

```tsx
import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-profile-form',
  templateUrl: './profile-form.component.html',
})
export class ProfileFormComponent implements OnInit {
  // Nenhuma informação de tipo aqui
  profileForm = new FormGroup({
    name: new FormControl(''),
    age: new FormControl(0),
  });

  ngOnInit() {
    // Perigoso: o TypeScript não reclama disso!
    this.profileForm.controls.name.setValue(123);

    const name = this.profileForm.get('name')?.value; // 'name' é do tipo 'any'
  }
}

```

**Depois (Angular 14): Segurança com Tipagem Estrita**

Agora, `FormControl`, `FormGroup` e `FormArray` são classes genéricas que inferem o tipo a partir do valor inicial.

**Exemplo (Angular 14):**

```tsx
import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms'; // Agora são genéricos!

// Interfaces para definir a estrutura do formulário
interface ProfileForm {
  name: FormControl<string | null>;
  age: FormControl<number | null>;
}

@Component({
  selector: 'app-profile-form',
  templateUrl: './profile-form.component.html',
})
export class ProfileFormComponent implements OnInit {
  // O tipo é inferido automaticamente ou pode ser explicitamente definido
  profileForm = new FormGroup<ProfileForm>({
    name: new FormControl(''), // Ingerido como FormControl<string | null>
    age: new FormControl(0),    // Ingerido como FormControl<number | null>
  });

  ngOnInit() {
    // ERRO DE COMPILAÇÃO! Argumento do tipo 'number' não é atribuível ao parâmetro do tipo 'string | null'.
    this.profileForm.controls.name.setValue(123);

    const name = this.profileForm.controls.name.value; // 'name' é do tipo 'string | null'
  }
}

```

A equipe do Angular garantiu a retrocompatibilidade. Projetos existentes continuarão funcionando, pois as classes antigas (agora com o prefixo `Untyped`) como `UntypedFormControl` ainda estão disponíveis.

---

### 3\. Melhorias na Acessibilidade do Título da Página

Garantir que os títulos das páginas sejam comunicados de forma eficaz para tecnologias assistivas é crucial para a acessibilidade. O Angular 14 simplifica isso com uma nova propriedade no `RouterModule`.

**Antes (Angular 13): Título Manual e Complexo**

Definir o título da página por rota exigia uma implementação manual, geralmente envolvendo a subscrição a eventos do roteador e o uso do `Title` service.

**`app-routing.module.ts` (Angular 13)**

```tsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { ProfileComponent } from './profile/profile.component';

const routes: Routes = [
  { path: 'home', component: HomeComponent, data: { title: 'Página Inicial' } },
  { path: 'profile', component: ProfileComponent, data: { title: 'Meu Perfil' } }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

Você ainda precisaria de uma lógica no `AppComponent` para ler o `data.title` e atualizar o título da página.

**Depois (Angular 14): Título Declarativo na Rota**

Agora, você pode adicionar a propriedade `title` diretamente na definição da rota, sem necessidade de código extra.

**`app-routing.module.ts` (Angular 14)**

```tsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { ProfileComponent } from './profile/profile.component';

const routes: Routes = [
  // Simples assim!
  { path: 'home', component: HomeComponent, title: 'Página Inicial' },
  { path: 'profile', component: ProfileComponent, title: 'Meu Perfil' }
];

@NgModule({
  // Ao usar standalone components, o `RouterModule.forRoot` vai no `imports` do `bootstrapApplication`
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

O Angular agora cuida de atualizar o título da página automaticamente durante a navegação. Você pode até usar um `TitleStrategy` customizado para lógicas mais complexas (ex: "Meu Site | Página Inicial").

---

### 4\. Novos Primitivos no Angular CDK

O Component Dev Kit (CDK) do Angular recebeu duas novas e poderosas primitivas, permitindo a criação de componentes customizados mais robustos.

### a) `CDK Dialog`

Fornece uma base para criar diálogos (modais) totalmente acessíveis e customizáveis, expondo uma API flexível para gerenciar o conteúdo e as configurações do diálogo.

### b) `CDK Menu`

Oferece diretivas para construir menus acessíveis e customizados, como menus de contexto ou menus dropdown.

Essas são ferramentas de baixo nível, então um exemplo "antes e depois" seria mais complexo. O "antes" seria criar toda a lógica de menu/diálogo do zero. O "depois" é usar essas primitivas para construir seus próprios componentes de UI.

---

### 5\. `ng analytics` e `ng cache` na CLI

A CLI do Angular também ganhou novos comandos úteis.

- `ng analytics`: Permite controlar as configurações de telemetria do Angular, que coleta informações anônimas sobre o uso para ajudar a equipe a priorizar features. Você pode ver o status, habilitar ou desabilitar.
- `ng cache`: Fornece controle sobre o cache de compilação no disco. Você pode limpar o cache, desabilitá-lo ou ver informações sobre ele. Isso é útil para solucionar problemas de build ou liberar espaço.

---

### 6\. Injeção de Dependências com `inject()`

O Angular 14 introduz a função `inject()` que pode ser usada dentro de construtores, campos de fábrica e até mesmo em funções, oferecendo mais flexibilidade para a injeção de dependências.

**Antes (Angular 13): Apenas no Construtor**

```tsx
import { Component } from '@angular/core';
import { MyService } from './my.service';

@Component({
  selector: 'app-example',
  template: '...',
})
export class ExampleComponent {
  constructor(private myService: MyService) {
    // Lógica que usa myService
  }
}

```

**Depois (Angular 14): Flexibilidade com `inject()`**

```tsx
import { Component, inject } from '@angular/core';
import { MyService } from './my.service';

@Component({
  selector: 'app-example',
  template: '...',
})
export class ExampleComponent {
  // Injetando diretamente em uma propriedade da classe
  private myService = inject(MyService);

  constructor() {
    // Lógica que usa this.myService
  }
}

```

Isso abre portas para a criação de funções de composição reutilizáveis que dependem de serviços, similar ao que é visto em frameworks como Vue.

Espero que este compilado detalhado seja de grande ajuda, Gedê\! A versão 14 realmente modernizou o Angular, tornando-o mais simples, seguro e produtivo. Se tiver qualquer outra dúvida, é só chamar a A.R.I.A.\!