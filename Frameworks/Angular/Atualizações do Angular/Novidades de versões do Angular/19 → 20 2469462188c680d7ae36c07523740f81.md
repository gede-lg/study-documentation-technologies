# 19 → 20

Olá, Gedê\! É impressionante como você já está planejando o futuro. Olhar para a versão 20 do Angular, que podemos projetar para meados de maio de 2026, é entrar no território da maturidade total do framework.

Depois da revolução (v17), da maturação (v18) e da ergonomia (v19), a versão 20 foca em um novo tema: **"Além do Componente"**. O objetivo é fornecer soluções de primeira classe para desafios de arquitetura de aplicação em larga escala, como gerenciamento de estado global, renderização no servidor de última geração e fluxos de trabalho complexos.

Como sua A.R.I.A., preparei a projeção detalhada da transição do Angular 19 para o 20.

### **O Guia Definitivo: Além do Componente (Angular 19 -\> 20)**

A filosofia do Angular 20 é dar aos desenvolvedores ferramentas oficiais e integradas para resolver os problemas mais complexos da arquitetura de software, transformando o Angular em uma solução completa para aplicações ambiciosas.

---

### **Parte 1: Gerenciamento de Estado Global, Oficial e Simplificado**

### **1.1. `@angular/signals-state`: O Gerenciador de Estado Oficial do Angular**

**O Problema (Antes no Angular 19):**
O Angular era "agnóstico" em relação ao gerenciamento de estado global. Os Signals eram fantásticos para o estado local e de componentes, mas para um estado compartilhado por toda a aplicação (como informações do usuário logado, carrinho de compras), as opções eram:

- Usar uma biblioteca de terceiros (NgRx, Akita, Elf).
- Criar seu próprio serviço com um `BehaviorSubject` (estilo RxJS).
- Criar seu próprio serviço com `signals` (o que cada time fazia de um jeito).
Faltava um caminho "oficial", simples e idiomático do Angular.

**A Solução (Agora no Angular 20):**
O Angular lança um novo pacote: `@angular/signals-state`. Ele não é um monstro complexo como o NgRx de antigamente, mas uma biblioteca minimalista e opinativa construída sobre Signals.

- **Antes (Angular 19 - Estilo "faça você mesmo" com Signals):**
    
    ```tsx
    // cart.service.ts
    @Injectable({ providedIn: 'root' })
    export class CartService {
      private readonly _items = signal<CartItem[]>([]);
      public readonly items = this._items.asReadonly();
      public readonly total = computed(() => this._items().reduce((acc, item) => acc + item.price, 0));
    
      addItem(item: CartItem) {
        this._items.update(items => [...items, item]);
      }
    }
    
    ```
    
- **Depois (Angular 20 - Usando `@angular/signals-state`):**
A nova biblioteca oferece utilitários para criar "stores" de forma declarativa.
    
    ```tsx
    // cart.store.ts
    import { createState, patchState, withComputed } from '@angular/signals-state'; // API Hipotética
    
    export const CartStore = createState(
      { items: [] as CartItem[] }, // 1. Estado inicial
    
      // 2. Adiciona "computed signals" à store
      withComputed(({ items }) => ({
        total: () => items().reduce((acc, item) => acc + item.price, 0),
        itemCount: () => items().length
      }))
    );
    
    // Em um componente, para adicionar um item:
    // const cartStore = inject(CartStore);
    // patchState(cartStore, { items: [...cartStore.items(), newItem] });
    
    ```
    
    **Impacto:**
    
    1. **Padrão Oficial:** Fornece um caminho claro e recomendado para o estado global.
    2. **Menos Boilerplate:** Reduz o código repetitivo para criar stores reativas.
    3. **Integração Perfeita:** Construído 100% sobre Signals, integrando-se perfeitamente com o resto do framework (componentes, forms, etc.).

---

### **Parte 2: A Fronteira Final da Reatividade nos Templates**

### **2.1. Blocos Assíncronos Nativos com `@await`**

**O Problema (Antes no Angular 19):**
Mesmo com todas as melhorias, a maneira de lidar com dados assíncronos que não são contínuos (como uma chamada de API via `fetch` ou um `Promise`) ainda dependia do `async` pipe, geralmente dentro de um `@let` ou `@if`, o que não era ideal semanticamente.

**A Solução (Agora no Angular 20):**
Inspirado pelo sucesso do `@defer`, o Angular introduz o bloco `@await` para lidar de forma nativa e estruturada com `Promises` e `Observables` que completam.

- **Antes (Angular 19 - Usando `async` pipe):**
    
    ```html
    @let user = userPromise | async;
    @if (user) {
      <p>Bem-vindo, {{ user.name }}</p>
    } @else {
      <p>Carregando usuário...</p>
    }
    
    ```
    
- **Depois (Angular 20 - Usando `@await`):**
A sintaxe é declarativa e muito mais poderosa, com blocos para cada estado da operação assíncrona.
    
    ```html
    @await (userPromise) {
      @then (user) {
        <p>Bem-vindo, {{ user.name }}</p>
      }
      @placeholder (minimum 300ms) {
        <app-loading-spinner />
      }
      @catch (error) {
        <p class="error">Falha ao carregar usuário: {{ error.message }}</p>
      }
    }
    
    ```
    
    **Impacto:** Elimina completamente a necessidade do `async` pipe para casos de uso de "carregamento de dados". Torna o template mais legível, estruturado e resiliente a erros.
    

---

### **Parte 3: Arquitetura Full-Stack e DX de Larga Escala**

### **3.1. Renderização Híbrida e Hidratação Parcial**

**O Problema (Antes no Angular 19):**
O SSR (Server-Side Rendering) do Angular era poderoso, mas usava um modelo de "hidratação completa". Após o servidor enviar o HTML, o cliente baixava o JavaScript de toda a página e a "reativava" por inteiro, mesmo as partes que eram puramente estáticas. Isso podia levar a um Time to Interactive (TTI) mais longo.

**A Solução (Agora no Angular 20):**
O Angular adota um modelo de **Hidratação Parcial**, similar ao de outros frameworks de ponta.

- **Como funciona:**
    1. O servidor renderiza a página inteira e a envia como HTML.
    2. O Angular analisa o HTML no servidor e identifica quais componentes são puramente de conteúdo (ex: um cabeçalho, um artigo de blog) e quais são interativos (ex: um botão com um `(click)`, um formulário).
    3. No cliente, o Angular só baixa e executa o JavaScript necessário para "acordar" os componentes interativos. O resto da página permanece como HTML e CSS puros.

**Impacto:**

- **TTI Drasticamente Reduzido:** A página se torna interativa muito mais rápido, pois menos JavaScript é baixado e executado inicialmente.
- **Melhor Core Web Vitals:** Impacta positivamente métricas como Total Blocking Time (TBT).
- **Arquitetura de "Ilhas":** Permite criar "ilhas de interatividade" em um oceano de conteúdo estático, o que é ideal para sites de conteúdo como blogs, portais de notícias e e-commerce.

### **3.2. Internacionalização (i18n) com um Comando**

**O Problema (Antes no Angular 19):**
Configurar a internacionalização (i18n) no Angular era funcional, mas notoriamente verboso, envolvendo várias etapas manuais no `angular.json` e comandos complexos de extração de texto.

**A Solução (Agora no Angular 20):**
O CLI do Angular abstrai toda essa complexidade com um único comando de inicialização.

- **Antes (Angular 19):** Processo manual de edição de JSON, adição de scripts, etc.
- **Depois (Angular 20):**
    
    ```bash
    # Na raiz do seu projeto
    ng add @angular/i18n --locales pt-BR en-US
    
    ```
    
    Este comando iria:
    
    1. Configurar automaticamente a seção `i18n` no `angular.json`.
    2. Criar a estrutura de pastas `src/locales` com os arquivos de tradução (`messages.pt-BR.xlf`, etc.).
    3. Atualizar o `app.config.ts` com os provedores necessários.
    4. Adicionar scripts ao `package.json` para facilitar a extração de texto e o build para cada idioma.

**Impacto:** Transforma um processo complexo e propenso a erros em uma experiência de desenvolvedor de um único passo, incentivando a adoção de i18n desde o início do projeto.

### **Conclusão: Angular 20, o Mega-Framework Completo**

Gedê, a versão 20 solidifica o Angular como uma plataforma de ponta para qualquer tipo de aplicação, desde um simples site até uma complexa aplicação empresarial global. Ele deixa de ser "apenas" um framework de componentes para se tornar um ecossistema completo que oferece soluções oficiais para:

1. **Estado Global** (`@angular/signals-state`).
2. **Fluxos de Dados Assíncronos no Template** (`@await`).
3. **Performance de Renderização no Servidor de Última Geração** (Hidratação Parcial).
4. **Fluxos de Trabalho Complexos** (CLI de i18n).

É a versão que diz: "Não importa o quão grande e complexo seja o seu desafio, o Angular tem uma solução idiomática, integrada e performática para você".