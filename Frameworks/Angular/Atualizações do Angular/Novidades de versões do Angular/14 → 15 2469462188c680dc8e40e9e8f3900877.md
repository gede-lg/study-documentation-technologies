# 14 → 15

Olá Gedê\! Como A.R.I.A (Assistente Rápida para Idiotas Atarefados), preparei um compilado extremamente detalhado sobre as novidades do Angular 15 em comparação com o Angular 14.

Vamos mergulhar nas mudanças que modernizaram ainda mais o framework, com foco em simplificar o desenvolvimento e melhorar a performance.

### A Revolução do Angular 15: Mais Simples e Eficiente

A versão 15 do Angular, lançada em novembro de 2022, representou um dos saltos mais significativos na história recente do framework. O foco principal foi a **experiência do desenvolvedor (DX)**, com a estabilização de APIs que eliminam a necessidade de `NgModules` em muitos cenários, tornando o código mais limpo e direto.

---

### 1\. APIs Standalone Estáveis: O Fim da Era `NgModule`

Esta é, sem dúvida, a mudança mais impactante. As APIs Standalone, que foram introduzidas como *developer preview* no Angular 14, tornaram-se estáveis na versão 15. Elas permitem que componentes, diretivas e pipes sejam declarados sem a necessidade de estarem associados a um `NgModule`.

### Antes (Angular 14 - com `NgModule`)

No Angular 14, a estrutura era modular. Cada peça da sua aplicação precisava ser declarada dentro de um módulo.

**Exemplo: Estrutura com `NgModule`**

```tsx
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: '<h1>Olá, Gedê!</h1>'
})
export class AppComponent {}

//----------------------------------------------------

// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent // Componente precisa ser declarado aqui
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}

//----------------------------------------------------

// main.ts
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));

```

### Depois (Angular 15 - com Standalone Components)

Com componentes standalone, o `NgModule` se torna opcional. Você pode inicializar a aplicação diretamente a partir de um componente.

**Exemplo: Estrutura Standalone**

```tsx
// app.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common'; // Necessário para diretivas como ngIf, ngFor

@Component({
  selector: 'app-root',
  standalone: true, // A mágica acontece aqui!
  imports: [
    CommonModule // Importa dependências diretamente no componente
  ],
  template: '<h1>Olá, Gedê! Bem-vindo ao mundo Standalone!</h1>'
})
export class AppComponent {}

//----------------------------------------------------
// app.module.ts - ESTE ARQUIVO NÃO É MAIS NECESSÁRIO!
//----------------------------------------------------

// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent) // Nova forma de inicializar
  .catch(err => console.error(err));

```

**Benefícios:**

- **Menos Boilerplate:** Redução drástica na quantidade de código de configuração.
- **Clareza:** As dependências de um componente são declaradas diretamente nele, facilitando o entendimento.
- **Lazy Loading Simplificado:** Carregar rotas ou componentes de forma preguiçosa ficou muito mais intuitivo.

---

### 2\. Roteamento e Lazy Loading com APIs Standalone

A simplificação se estende ao roteamento.

### Antes (Angular 14 - Lazy Loading com `loadChildren` e Módulos)

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  {
    path: 'admin',
    // Aponta para um arquivo de módulo que será carregado
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}

```

### Depois (Angular 15 - Lazy Loading com `loadComponent` ou `loadChildren`)

Agora você pode carregar um único componente ou um conjunto de rotas standalone.

**Carregando um único componente:**

```tsx
// app.routes.ts (não é mais um módulo)
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'dashboard',
    // Carrega diretamente o componente standalone
    loadComponent: () => import('./dashboard/dashboard.component').then(c => c.DashboardComponent)
  }
];

// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes) // Provedor de rotas funcional
  ]
});

```

**Carregando um conjunto de rotas filhas:**

```tsx
// admin.routes.ts
import { Routes } from '@angular/router';
import { AdminDashboardComponent } from './admin-dashboard/admin-dashboard.component';
import { AdminUsersComponent } from './admin-users/admin-users.component';

// Amobs os componentes são standalone
export const ADMIN_ROUTES: Routes = [
    { path: 'dashboard', component: AdminDashboardComponent },
    { path: 'users', component: AdminUsersComponent },
    { path: '', redirectTo: 'dashboard', pathMatch: 'full' }
];

// app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'admin',
    // Carrega um arquivo que exporta um array de rotas
    loadChildren: () => import('./admin/admin.routes').then(r => r.ADMIN_ROUTES)
  }
];

```

---

### 3\. Diretiva `NgOptimizedImage` Estável

A performance de carregamento de imagens é crucial, especialmente para a métrica LCP (Largest Contentful Paint) do Google. O Angular 15 estabilizou essa diretiva, que otimiza o carregamento de imagens de forma inteligente.

### Antes (Angular 14)

Você usava a tag `<img>` padrão, sem otimizações automáticas do framework.

```html
<img src="assets/logo-grande.png" alt="Logo da Empresa" width="400" height="300">

```

### Depois (Angular 15)

Ao substituir `src` por `ngSrc`, a diretiva entra em ação.

**Como usar:**

1. Importe a diretiva no seu componente standalone ou `NgModule`.
2. Use `ngSrc` em vez de `src`.
3. **É obrigatório** definir `width` e `height` para evitar *layout shifts*.

<!-- end list -->

```tsx
// app.component.ts (standalone)
import { Component } from '@angular/core';
import { NgOptimizedImage } from '@angular/common'; // Importa a diretiva

@Component({
  selector: 'app-imagem-otimizada',
  standalone: true,
  imports: [ NgOptimizedImage ], // Adiciona aos imports
  templateUrl: './imagem-otimizada.component.html'
})
export class ImagemOtimizadaComponent {}

```

```html
<img ngSrc="assets/minha-imagem.jpg" width="800" height="600" alt="Descrição da Imagem">

<img ngSrc="assets/imagem-principal.webp" width="1200" height="700" priority alt="Imagem Principal do Site">

```

**O que ela faz por baixo dos panos?**

- **Lazy Loading automático:** Imagens fora da viewport não são carregadas até que o usuário role a página para perto delas.
- **Priorização:** A diretiva `priority` remove o lazy loading e adiciona um `link rel="preload"` no `<head>` do HTML, instruindo o navegador a carregar aquela imagem o mais rápido possível.
- **Geração de `srcset` (em breve):** Futuramente, a diretiva poderá gerar automaticamente diferentes tamanhos de imagem para diferentes telas.

---

### 4\. Interceptadores HTTP Funcionais (`Functional Interceptors`)

Outra grande melhoria na DX. A forma de escrever interceptadores HTTP, que era baseada em classes, tornou-se mais simples com funções.

### Antes (Angular 14 - Interceptadores baseados em Classe)

Você precisava criar uma classe que implementasse `HttpInterceptor`, o que adicionava bastante código boilerplate.

```tsx
// auth.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const authToken = 'meu-token-secreto';
    const authReq = req.clone({
      headers: req.headers.set('Authorization', `Bearer ${authToken}`)
    });
    return next.handle(authReq);
  }
}

// app.module.ts
import { HTTP_INTERCEPTORS } from '@angular/common/http';
@NgModule({
  // ...
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ],
})
export class AppModule {}

```

### Depois (Angular 15 - Interceptadores Funcionais)

Agora, um interceptador é apenas uma função, o que torna o código muito mais conciso e fácil de compor.

```tsx
// auth.interceptor.ts
import { HttpHandlerFn, HttpInterceptorFn, HttpRequest } from '@angular/common/http';

// É apenas uma função, não precisa de @Injectable ou classe!
export const authInterceptor: HttpInterceptorFn = (req: HttpRequest<any>, next: HttpHandlerFn) => {
  const authToken = 'meu-token-secreto';
  const authReq = req.clone({
    headers: req.headers.set('Authorization', `Bearer ${authToken}`)
  });
  return next.handle(authReq);
};

//----------------------------------------------------

// app.config.ts (ou nos providers do bootstrapApplication)
import { ApplicationConfig } from '@angular/core';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { authInterceptor } from './auth.interceptor';
import { loggingInterceptor } from './logging.interceptor'; // Outro interceptador

export const appConfig: ApplicationConfig = {
  providers: [
    // Nova forma de prover o HttpClient e registrar os interceptadores
    provideHttpClient(
      withInterceptors([authInterceptor, loggingInterceptor]) // A ordem no array define a execução
    )
  ]
};

// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { appConfig } from './app/app.config';

bootstrapApplication(AppComponent, appConfig);

```

---

### 5\. API de Composição de Diretivas (`Directive Composition API`)

Essa API permite que você "aplique" o comportamento de diretivas diretamente na `host` de um componente, melhorando a reutilização de código.

### Antes (Angular 14)

Se você quisesse que seu componente personalizado tivesse o comportamento de outra diretiva (ex: `MatMenuTrigger`), você teria que recriar as `Inputs` e `Outputs` e delegar a lógica, o que era repetitivo e propenso a erros.

```tsx
// meu-menu.component.ts (simulação sem a API)
import { Component, Input } from '@angular/core';
import { MatMenu } from '@angular/material/menu';

@Component({
    selector: 'meu-menu',
    template: `<button [matMenuTriggerFor]="menu">Abrir</button>`
})
export class MeuMenuComponent {
    @Input() menu: MatMenu; // Teria que recriar e passar cada input da diretiva original
    // ... e os outputs também
}

```

### Depois (Angular 15)

Com a propriedade `hostDirectives`, você pode "herdar" todo o comportamento, incluindo inputs, outputs e a lógica associada.

```tsx
// meu-botao-customizado.component.ts
import { Component, Input } from '@angular/core';
import { CdkMenuTrigger } from '@angular/cdk/menu';

@Component({
  selector: 'app-meu-botao-customizado',
  standalone: true,
  // Aplica a diretiva CdkMenuTrigger diretamente no host do nosso componente
  hostDirectives: [{
    directive: CdkMenuTrigger,
    // Mapeia os inputs da diretiva para os inputs do nosso componente
    inputs: ['menu: cdkMenuTriggerFor'],
  }],
  template: `
    <button>
      <ng-content></ng-content>
    </button>
  `,
})
export class MeuBotaoCustomizadoComponent {
  // Você pode adicionar lógicas próprias aqui também
}

```

**Como usar no template:**

```html
<app-meu-botao-customizado [menu]="meuMenu">Meu Menu</app-meu-botao-customizado>

<ng-template #meuMenu>
  <div class="menu-content" cdkMenu>
    <button cdkMenuItem>Item 1</button>
    <button cdkMenuItem>Item 2</button>
  </div>
</ng-template>

```

O `app-meu-botao-customizado` agora se comporta exatamente como um botão com `cdkMenuTriggerFor`, sem precisar reescrever a lógica.

---

### 6\. Refatoração do Angular Material com MDC for Web

O time do Angular finalizou a refatoração dos componentes do Angular Material para usar o **MDC (Material Design Components for Web)** do Google. Isso garante que os componentes fiquem mais alinhados à especificação do Material Design e melhora a acessibilidade.

Para a maioria dos usuários, essa mudança é transparente, mas cada componente agora tem um estilo um pouco diferente e uma estrutura de DOM mais robusta. Para projetos existentes, o Angular oferece schematics (`ng update`) para migrar os estilos CSS.

**Exemplo de mudança no DOM (Botão):**

### Antes (Angular 14 - `mat-button`)

```html
<button mat-button>
  <span class="mat-button-wrapper">
    Texto do Botão
  </span>
  <div class="mat-button-ripple mat-ripple"></div>
  <div class="mat-button-focus-overlay"></div>
</button>

```

### Depois (Angular 15 - `mat-button` com MDC)

A estrutura interna do DOM do componente foi alterada para seguir o padrão do MDC.

```html
<button class="mdc-button mat-mdc-button">
  <span class="mdc-button__ripple"></span>
  <span class="mdc-button__focus-ring"></span>
  <span class="mdc-button__label">
    Texto do Botão
  </span>
</button>

```

**Impacto Prático:** Se você tinha seletores CSS muito específicos (`.mat-button-wrapper`, por exemplo), eles podem ter quebrado. A migração automática do `ng update` ajuda a ajustar a maioria desses casos.

---

### Resumo das Principais Mudanças (Angular 14 vs 15)

| Característica | Angular 14 (Antes) | Angular 15 (Depois) |
| --- | --- | --- |
| **Estrutura Principal** | Baseada em `NgModule` | **`Standalone APIs` estáveis**. `NgModule` é opcional. |
| **Inicialização (Bootstrap)** | `platformBrowserDynamic().bootstrapModule(AppModule)` | `bootstrapApplication(AppComponent, { providers: [...] })` |
| **Dependências** | Declaradas no array `imports` do `NgModule` | Declaradas no array `imports` do próprio componente. |
| **Lazy Loading de Rotas** | `loadChildren` apontando para um `NgModule` | `loadComponent` para um componente ou `loadChildren` para rotas. |
| **Otimização de Imagens** | Manual, usando a tag `<img>` padrão. | **Diretiva `NgOptimizedImage`** (`ngSrc`) com lazy loading e priorização. |
| **Interceptadores HTTP** | Baseados em classes (`implements HttpInterceptor`). | **Funcionais** (`HttpInterceptorFn`) e registrados com `withInterceptors`. |
| **Reuso de Diretivas** | Complexo, exigia delegação manual de I/O. | **`Directive Composition API`** com `hostDirectives`. |
| **Angular Material** | Componentes com implementação legada. | Componentes refatorados para usar **MDC for Web**. |

Espero que este guia detalhado seja de grande ajuda, Gedê\! A versão 15 realmente marcou um ponto de virada, tornando o Angular mais moderno e agradável de trabalhar, especialmente para quem está vindo de outros ecossistemas.

Se tiver qualquer outra dúvida, pode perguntar\!