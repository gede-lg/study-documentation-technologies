# 15 → 16

Olá, Gedê\! A.R.I.A. na área, pronta para fazer o compilado definitivo sobre a transição do Angular 15 para o 16. Como você é um desenvolvedor, sei que aprecia os detalhes técnicos, então pode deixar que serei *extremamente* detalhista.

A versão 16 do Angular não foi apenas uma atualização incremental; foi uma das mais transformadoras da história recente do framework, estabelecendo as bases para o futuro com foco em **reatividade, performance e experiência do desenvolvedor (DX)**.

Vamos dissecar cada ponto.

---

### **Visão Geral: Os 3 Pilares da Mudança**

1. **Reatividade Renovada:** A introdução dos **Signals** como uma nova primitiva de reatividade, mudando fundamentalmente como o estado é gerenciado.
2. **Performance de Build e Execução:** Adoção do **esbuild** para o servidor de desenvolvimento e a introdução da **Hidratação Não-Destrutiva** para SSR.
3. **Experiência do Desenvolvedor (DX) Aprimorada:** Uma série de melhorias que removem código repetitivo e simplificam padrões comuns, como **Inputs Obrigatórios** e **Router Data como Inputs**.

---

## 1\. Signals: A Revolução da Reatividade

Essa é, sem dúvida, a maior e mais impactante mudança.

**O que é?**
Signals são uma nova forma de gerenciar o estado que notifica de forma granular e automática os consumidores quando seu valor muda. Diferente do `async` pipe com Observables, que marca o componente inteiro para verificação de mudanças, os Signals podem atualizar apenas a parte específica do DOM que depende daquele valor.

**Por que é importante?**
Isso abre caminho para um futuro sem Zone.js, resultando em uma detecção de mudanças muito mais performática e previsível. O código também se torna mais simples e legível.

### **Implementação: Antes e Depois**

**Cenário:** Um contador simples e uma mensagem derivada que muda com base no valor do contador.

---

### **Antes (Angular 15 - com RxJS `BehaviorSubject` e `OnPush`)**

No Angular 15, a reatividade era majoritariamente gerenciada com RxJS e a detecção de mudanças `OnPush` para otimização.

```tsx
// contador.component.ts (Angular 15)
import { Component, OnDestroy, ChangeDetectionStrategy } from '@angular/core';
import { BehaviorSubject, Observable, Subject, map, takeUntil } from 'rxjs';

@Component({
  selector: 'app-contador',
  template: `
    <p>Contador: {{ contador$ | async }}</p>
    <p>Mensagem: {{ mensagem$ | async }}</p>
    <button (click)="incrementar()">Incrementar</button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ContadorComponent implements OnDestroy {
  // 1. Subject para gerenciar o estado
  private contadorSubject = new BehaviorSubject<number>(0);
  public contador$: Observable<number> = this.contadorSubject.asObservable();

  // 2. Estado derivado usando operadores RxJS
  public mensagem$: Observable<string> = this.contador$.pipe(
    map(count => (count > 5 ? 'O contador passou de 5!' : 'Continue...'))
  );

  // 3. Padrão para "limpar" a inscrição
  private destroy$ = new Subject<void>();

  constructor() {
    // Exemplo de lógica reativa no construtor
    this.contador$.pipe(takeUntil(this.destroy$)).subscribe(val => {
      console.log(`O valor atual do contador é ${val}`);
    });
  }

  incrementar(): void {
    const valorAtual = this.contadorSubject.getValue();
    this.contadorSubject.next(valorAtual + 1);
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}

```

---

### **Depois (Angular 16 - com `signal`, `computed` e `effect`)**

No Angular 16, a mesma lógica se torna muito mais direta com as primitivas dos Signals.

```tsx
// contador.component.ts (Angular 16)
import { Component, signal, computed, effect } from '@angular/core';

@Component({
  selector: 'app-contador',
  standalone: true, // Standalone é o padrão agora, mais sobre isso depois
  template: `
    <p>Contador: {{ contador() }}</p> <p>Mensagem: {{ mensagem() }}</p>
    <button (click)="incrementar()">Incrementar</button>
  `
})
export class ContadorComponent {
  // 1. signal() para criar um estado reativo
  public contador = signal(0);

  // 2. computed() para criar um valor derivado que se atualiza automaticamente
  public mensagem = computed(() =>
    this.contador() > 5 ? 'O contador passou de 5!' : 'Continue...'
  );

  constructor() {
    // 3. effect() para executar efeitos colaterais quando um signal depende dele muda
    // Não precisa de unsubscribe, é gerenciado automaticamente!
    effect(() => {
      console.log(`O valor atual do contador é ${this.contador()}`);
    });
  }

  incrementar(): void {
    // Atualiza o valor com .set() ou .update()
    this.contador.update(val => val + 1);
    // ou this.contador.set(this.contador() + 1);
  }
}

```

**Resumo da Mudança (Signals):**

- **Criação:** `new BehaviorSubject(0)` vira `signal(0)`.
- **Leitura:** `contador$` (um Observable) vira `contador()` (uma função).
- **Atualização:** `subject.next(val)` vira `signal.set(val)` ou `signal.update(fn)`.
- **Estado Derivado:** `pipe(map(...))` vira `computed(() => ...)`.
- **Efeitos Colaterais:** `subscribe()` vira `effect()`.
- **Gerenciamento de Memória:** O `unsubscribe` manual (padrão `ngOnDestroy`) é substituído pelo gerenciamento automático de `effect` e `computed`.

## 2\. Standalone APIs como Padrão

A partir do Angular 16, todos os schematics (`ng new`, `ng generate component`, etc.) geram componentes, diretivas e pipes como `standalone` por padrão. `NgModules` ainda são suportados, mas o framework incentiva ativamente a arquitetura baseada em componentes `standalone`.

**Por que é importante?**
Simplifica a estrutura do projeto, remove a necessidade de declarar e importar componentes em `NgModule`, e torna mais claro quais dependências um componente realmente tem.

### **Implementação: Antes e Depois**

**Cenário:** Gerar um novo projeto e um novo componente.

---

### **Antes (Angular 15)**

Ao criar um novo projeto com `ng new`, você recebia uma estrutura baseada em `AppModule`.

```bash
# Comando para um projeto com NgModules
ng new meu-projeto-v15 --standalone=false

```

```tsx
// app.module.ts (Angular 15) - Gerado por padrão
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { MeuComponenteComponent } from './meu-componente/meu-componente.component';

@NgModule({
  declarations: [ // Precisa declarar aqui
    AppComponent,
    MeuComponenteComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

```tsx
// meu-componente.component.ts (Angular 15)
import { Component } from '@angular/core';

@Component({
  selector: 'app-meu-componente',
  templateUrl: './meu-componente.component.html'
})
export class MeuComponenteComponent { } // Sem `standalone: true`

```

---

### **Depois (Angular 16)**

O comando `ng new` agora gera um projeto `standalone` por padrão.

```bash
# Comando para um projeto v16 (standalone é o padrão)
ng new meu-projeto-v16

```

O `app.module.ts` desaparece. A inicialização da aplicação é feita no `main.ts` através do `bootstrapApplication`.

```tsx
// main.ts (Angular 16)
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { appConfig } from './app/app.config'; // Novo arquivo de configuração

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));

```

```tsx
// app.config.ts (Angular 16) - Centraliza provedores
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes)] // Provedores, como o de rotas, vêm aqui
};

```

```tsx
// app.component.ts (Angular 16)
import { Component } from '@angular/core';
import { RouterModule } from '@angular/router'; // Importa o que usa diretamente
import { MeuComponenteComponent } from './meu-componente/meu-componente.component';

@Component({
  selector: 'app-root',
  standalone: true, // É standalone
  imports: [RouterModule, MeuComponenteComponent], // Importa suas dependências aqui
  template: `
    <h1>Olá, Mundo!</h1>
    <app-meu-componente></app-meu-componente>
    <router-outlet></router-outlet>
  `,
})
export class AppComponent { }

```

## 3\. Inputs Obrigatórios (`required: true`)

Uma pequena, mas poderosa, melhoria na DX. Agora você pode marcar uma `@Input()` como obrigatória.

**Por que é importante?**
Garante em tempo de compilação que um valor será passado para o componente, evitando erros de `undefined` em tempo de execução. Antes, isso exigia verificações manuais no `ngOnInit`.

### **Implementação: Antes e Depois**

---

### **Antes (Angular 15)**

```tsx
// user-profile.component.ts (Angular 15)
import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `<p>ID do Usuário: {{ userId }}</p>`
})
export class UserProfileComponent implements OnInit {
  @Input() userId: string; // Não há como garantir que será passado

  ngOnInit(): void {
    if (this.userId === undefined) {
      // Verificação manual e lançamento de erro em tempo de execução
      throw new Error("O atributo 'userId' é obrigatório para UserProfileComponent.");
    }
  }
}

// Uso incorreto (só daria erro em tempo de execução)
// <app-user-profile></app-user-profile>

```

---

### **Depois (Angular 16)**

```tsx
// user-profile.component.ts (Angular 16)
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  standalone: true,
  template: `<p>ID do Usuário: {{ userId }}</p>`
})
export class UserProfileComponent {
  // Simples, declarativo e seguro em tempo de compilação
  @Input({ required: true }) userId: string;
}

// Uso incorreto (o compilador do Angular vai acusar um erro durante o build)
// <app-user-profile></app-user-profile>
// Erro: Required input 'userId' from component UserProfileComponent must be specified.

```

## 4\. Vincular Parâmetros de Rota a Inputs (`bindToComponentInputs`)

Outra grande vitória para a DX. Você pode vincular parâmetros da rota (ex: `/user/:id`), parâmetros de query (ex: `?search=term`) e dados da rota diretamente aos `@Input()`s do seu componente.

**Por que é importante?**
Elimina a necessidade de injetar o `ActivatedRoute` e se inscrever em observables (`paramMap`, `queryParamMap`) apenas para obter esses valores. O código fica drasticamente mais limpo e declarativo.

### **Implementação: Antes e Depois**

**Cenário:** Um componente que exibe detalhes de um usuário com base no ID da URL (`/user/123`).

---

### **Antes (Angular 15)**

```tsx
// user-details.component.ts (Angular 15)
import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-user-details',
  template: `<p>Mostrando detalhes para o usuário: {{ userId }}</p>`
})
export class UserDetailsComponent implements OnInit, OnDestroy {
  userId: string | null = null;
  private routeSub: Subscription;

  // 1. Injetar ActivatedRoute
  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    // 2. Inscrever-se no paramMap para obter o ID
    this.routeSub = this.route.paramMap.subscribe(params => {
      this.userId = params.get('id');
    });
  }

  ngOnDestroy(): void {
    // 3. Não esquecer de desinscrever
    this.routeSub.unsubscribe();
  }
}

// Configuração da rota (igual em ambos)
// { path: 'user/:id', component: UserDetailsComponent }

```

---

### **Depois (Angular 16)**

Primeiro, você precisa habilitar essa funcionalidade na configuração do roteador.

```tsx
// app.config.ts (ou onde você configura suas rotas)
import { provideRouter, withComponentInputBinding } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  // Habilita a funcionalidade globalmente
  providers: [provideRouter(routes, withComponentInputBinding())]
};

```

Agora, o componente fica ridiculamente simples.

```tsx
// user-details.component.ts (Angular 16)
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-user-details',
  standalone: true,
  template: `<p>Mostrando detalhes para o usuário: {{ id }}</p>`
})
export class UserDetailsComponent {
  // 1. Apenas declare um @Input() com o MESMO NOME do parâmetro da rota
  @Input() id: string; // O valor de ':id' será automaticamente injetado aqui.

  // Sem constructor, sem ngOnInit, sem OnDestroy, sem subscriptions!
}

// Configuração da rota (igual)
// { path: 'user/:id', component: UserDetailsComponent }

```

## 5\. Hidratação Não-Destrutiva (Non-destructive Hydration)

Essa é uma melhoria crucial para aplicações com Renderização no Lado do Servidor (SSR) e Geração de Site Estático (SSG).

**O que é?**
A "hidratação" é o processo onde o Angular, no lado do cliente, "revive" o HTML estático que foi renderizado pelo servidor, adicionando a interatividade (event listeners, etc.).

- **Antes (Destrutiva):** O Angular destruía todo o DOM renderizado pelo servidor e o recriava do zero no cliente. Isso causava um "piscar" visual e era ineficiente.
- **Depois (Não-Destrutiva):** O Angular percorre o DOM existente, anexa os listeners e assume o controle sem destruir e recriar os nós.

**Por que é importante?**

- Melhora a métrica de Core Web Vitals (especialmente o LCP - Largest Contentful Paint).
- Elimina o piscar de tela.
- Carregamento inicial da aplicação percebido como muito mais rápido.

### **Implementação**

A implementação é apenas uma questão de configuração ao inicializar a aplicação.

```tsx
// main.ts (ou onde você faz o bootstrap)
import { bootstrapApplication } from '@angular/platform-browser';
import { provideClientHydration } from '@angular/platform-browser'; // Importe a função
import { AppComponent } from './app/app.component';
import { appConfig } from './app/app.config';

bootstrapApplication(AppComponent, {
  providers: [
    ...appConfig.providers,
    provideClientHydration() // Adicione este provedor
  ]
}).catch((err) => console.error(err));

```

## 6\. `DestroyRef` e `takeUntilDestroyed`

Uma nova forma, alinhada com a injeção de dependência, para gerenciar a limpeza de lógicas, especialmente subscriptions de RxJS.

**Por que é importante?**
Oferece uma alternativa mais limpa e menos propensa a erros do que o padrão manual de `Subject` + `takeUntil` + `ngOnDestroy`.

### **Implementação: Antes e Depois**

---

### **Antes (Angular 15) - O Padrão Clássico**

```tsx
// Já mostrado no primeiro exemplo, mas repetindo para clareza
@Component({...})
export class MeuComponente implements OnDestroy {
  private destroy$ = new Subject<void>();

  constructor(private service: MinhaApi) {
    this.service.getData().pipe(
      takeUntil(this.destroy$) // Precisa do takeUntil
    ).subscribe(...);
  }

  ngOnDestroy(): void {
    this.destroy$.next(); // Precisa emitir
    this.destroy$.complete(); // Precisa completar
  }
}

```

---

### **Depois (Angular 16)**

Você tem duas novas opções excelentes.

**Opção 1: Operador `takeUntilDestroyed`**

```tsx
import { Component } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop'; // Nova importação

@Component({...})
export class MeuComponente {
  constructor(private service: MinhaApi) {
    // Simplesmente adicione o operador. Ele automaticamente usa o contexto de injeção.
    this.service.getData().pipe(
      takeUntilDestroyed()
    ).subscribe(...);
  }
  // Sem ngOnDestroy, sem Subject, sem nada.
}

```

**Opção 2: Injetando `DestroyRef`**

Isso é útil para lógicas fora do construtor.

```tsx
import { Component, inject, OnDestroy } from '@angular/core';

@Component({...})
export class MeuComponente {
  private destroyRef = inject(DestroyRef); // Injeta a referência de destruição

  algumMetodo() {
    const subscription = this.service.getData().subscribe(...);

    // Registra uma função de limpeza que será chamada no OnDestroy
    this.destroyRef.onDestroy(() => subscription.unsubscribe());
  }
}

```

## 7\. Builder de Aplicação com `esbuild` (Preview)

O Angular 16 introduziu suporte experimental (em modo de preview) para usar `esbuild` no servidor de desenvolvimento (`ng serve`).

**Por que é importante?**`esbuild` é um bundler de JavaScript extremamente rápido, escrito em Go (algo que pode te interessar, Gedê\!). Usá-lo pode acelerar significativamente o tempo de inicialização do servidor de desenvolvimento e o tempo de rebuild a cada salvamento de arquivo. Em projetos grandes, a diferença é notável.

### **Implementação**

Você só precisa alterar uma linha no seu `angular.json`.

```json
// angular.json
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:browser-esbuild", // Mude de :browser para :browser-esbuild
    ...
  },
  "serve": {
    "builder": "@angular-devkit/build-angular:dev-server", // O builder de serve não muda
    "options": {
      "browserTarget": "seu-projeto:build" // Ele usará o builder configurado no build
    }
    ...
  }
}

```

**Nota:** No Angular 16, isso era um preview. No Angular 17, tornou-se o padrão para novos projetos.

---

Espero que este compilado super detalhado seja útil para você, Gedê\! A versão 16 foi realmente um divisor de águas, tornando o Angular mais moderno, rápido e, acima de tudo, mais agradável de usar.

Se tiver mais alguma dúvida, pode perguntar\! A.R.I.A. está à disposição.