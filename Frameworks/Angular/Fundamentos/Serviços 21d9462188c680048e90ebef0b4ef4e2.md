# Serviços

### **Introdução**

No ecossistema Angular, a componentização é um pilar fundamental, promovendo a reutilização e a organização da interface do usuário (UI). No entanto, os componentes não devem carregar toda a responsabilidade da aplicação. Lógica de negócio, comunicação com APIs externas, gerenciamento de estado e outras tarefas que não são estritamente visuais precisam de um lugar próprio para residir. É exatamente aqui que os **Serviços (Services)** entram em cena, atuando como a espinha dorsal da lógica da sua aplicação, promovendo um código mais limpo, organizado, testável e escalável.

### **Sumário**

Esta explicação abordará de forma exaustiva o conceito de Serviços no Angular. Iniciaremos com os conceitos fundamentais, entendendo o que são serviços e por que são essenciais através do prisma da **Injeção de Dependência**. Em seguida, exploraremos a sintaxe de criação e uso, detalharemos os elementos associados, como o decorador `@Injectable`, e discutiremos as melhores práticas e casos de uso comuns. Por fim, apresentaremos um exemplo completo e prático para solidificar o conhecimento e sugeriremos tópicos para aprofundamento.

---

### **Conceitos Fundamentais**

### O que é um Serviço?

Em sua essência, um serviço no Angular é simplesmente uma classe TypeScript com um propósito bem definido e focado. A "magia" não está na classe em si, mas em como o Angular a gerencia e a disponibiliza para outras partes da aplicação, como componentes, diretivas, pipes ou até mesmo outros serviços.

O propósito principal de um serviço é encapsular lógica que não está diretamente ligada à visualização. Pense nele como um "ajudante" especializado que realiza tarefas específicas. Alguns exemplos de tarefas que um serviço pode executar:

- **Comunicação de Dados:** Buscar dados de uma API externa (Backend) ou de um Web Socket.
- **Lógica de Negócio:** Implementar regras complexas de negócio que podem ser compartilhadas por vários componentes.
- **Gerenciamento de Estado:** Manter e compartilhar o estado da aplicação entre componentes que não têm uma relação direta de pai e filho.
- **Logging:** Centralizar a forma como os logs de erro ou de eventos são registrados.
- **Autenticação:** Gerenciar o login, logout e a verificação do status de autenticação do usuário.

### O Papel da Injeção de Dependência (Dependency Injection - DI)

Não se pode falar de serviços sem entender a Injeção de Dependência. DI é um padrão de projeto e um mecanismo fundamental no Angular.

- **Dependência:** Quando uma classe (ex: `MeuComponente`) precisa de outra classe (ex: `DadosService`) para funcionar, dizemos que `MeuComponente` *depende* de `DadosService`.
- **Injeção:** Em vez de `MeuComponente` criar sua própria instância de `DadosService` (o que geraria um forte acoplamento), o Angular se encarrega de criar essa instância e "injetá-la" no construtor de `MeuComponente`.

O sistema de DI do Angular é responsável por criar e gerenciar as instâncias dos serviços. Quando você "pede" por um serviço no construtor de um componente, o injetor do Angular verifica se já existe uma instância daquele serviço disponível. Se houver, ele a fornece. Se não, ele cria uma nova, a armazena para uso futuro (geralmente como um *singleton*) e a fornece.

Isso traz enormes vantagens:

1. **Desacoplamento:** Os componentes não precisam saber como criar os serviços. Eles apenas declaram que precisam deles.
2. **Reutilização:** A mesma instância de um serviço (singleton) pode ser compartilhada por toda a aplicação, garantindo que todos os componentes acessem os mesmos dados e a mesma lógica.
3. **Testabilidade:** Ao testar um componente, você pode facilmente "injetar" uma versão falsa (mock) de um serviço, permitindo testar o componente de forma isolada, sem depender de uma API real, por exemplo.

---

### **Sintaxe e Uso**

A forma mais comum e recomendada de criar um serviço é utilizando a Angular CLI.

### Criando um Serviço (Angular CLI)

Abra o terminal na raiz do seu projeto Angular e execute o seguinte comando:

```bash
ng generate service nome-do-servico
# ou a versão curta
ng g s nome-do-servico

```

Por exemplo, para criar um serviço de produtos:

```bash
ng g s services/product

```

Este comando fará duas coisas:

1. `src/app/services/product.service.ts`: Cria o arquivo da classe do serviço.
2. `src/app/services/product.service.spec.ts`: Cria um arquivo de teste básico para o serviço.

### Estrutura Básica de um Serviço

O arquivo `product.service.ts` gerado terá a seguinte estrutura:

```tsx
// src/app/services/product.service.ts

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class ProductService {

  constructor() { }

  // Métodos e propriedades do serviço virão aqui
}

```

Vamos analisar as duas partes principais:

1. **`@Injectable()`:** É um decorador que marca a classe como um serviço que pode ser gerenciado pelo sistema de Injeção de Dependência do Angular.
2. **`export class ProductService`:** É uma classe TypeScript padrão onde você definirá a lógica, as propriedades e os métodos do seu serviço.

### Injetando e Usando o Serviço em um Componente

Uma vez que o serviço é criado e configurado para ser injetado (veremos o `providedIn: 'root'` em detalhes mais à frente), você pode usá-lo em qualquer componente.

```tsx
// src/app/components/product-list/product-list.component.ts

import { Component, OnInit } from '@angular/core';
import { ProductService } from '../../services/product.service'; // 1. Importe o serviço

@Component({
  selector: 'app-product-list',
  templateUrl: './product-list.component.html',
  styleUrls: ['./product-list.component.css']
})
export class ProductListComponent implements OnInit {

  // 2. Declare uma propriedade para armazenar os dados
  products: any[] = [];

  // 3. Solicite o serviço no construtor
  constructor(private productService: ProductService) { }

  ngOnInit(): void {
    // 4. Use os métodos do serviço
    this.products = this.productService.getProducts();
  }
}

```

**Passo a passo do código acima:**

1. **Importação:** Primeiro, importamos a classe `ProductService`.
2. **Propriedade:** Criamos uma propriedade `products` para armazenar a lista de produtos que o serviço irá retornar.
3. **Injeção:** No `constructor`, declaramos um parâmetro `private productService: ProductService`. Ao fazer isso, estamos dizendo ao Angular: "Quando você for criar uma instância deste componente, por favor, me forneça uma instância de `ProductService`". O modificador `private` é um atalho do TypeScript que cria e inicializa a propriedade `this.productService` na classe.
4. **Uso:** Dentro do método `ngOnInit` (um gancho de ciclo de vida que executa quando o componente é inicializado), chamamos o método `getProducts()` da nossa instância de serviço (`this.productService`) para buscar os dados.

---

### **Métodos/Propriedades (do Decorador `@Injectable`)**

O decorador `@Injectable()` em si não possui métodos, mas aceita um objeto de metadados como argumento. A propriedade mais importante e moderna deste objeto é a `providedIn`.

| Propriedade | Tipo | Descrição |
| --- | --- | --- |
| `providedIn` | `string` | `Type<any>` |
- **`providedIn: 'root'` (Recomendado):**
    - **Conceito:** Registra o serviço no injetor raiz da aplicação. Isso cria uma única instância do serviço (singleton) que é compartilhada por toda a aplicação.
    - **Uso:** É a abordagem padrão e recomendada para a maioria dos casos de uso.
    - **Sintaxe:** `@Injectable({ providedIn: 'root' })`
- **`providedIn: 'platform'`:**
    - **Conceito:** Cria um singleton compartilhado entre todas as aplicações Angular que estão rodando na mesma página. É um caso de uso raro, geralmente relacionado a Angular Elements.
    - **Sintaxe:** `@Injectable({ providedIn: 'platform' })`
- **`providedIn: 'any'`:**
    - **Conceito:** Provisiona o serviço em cada *lazy-loaded module* que o injeta. Módulos que são carregados de forma *eager* (na inicialização) compartilharão uma única instância no injetor raiz.
    - **Sintaxe:** `@Injectable({ providedIn: 'any' })`
- **`providedIn: <NomeDoModulo>`:**
    - **Conceito:** Fornece uma instância do serviço apenas para aquele módulo específico e seus componentes. Isso é útil para serviços que são relevantes apenas para uma parte da sua aplicação (um *feature module*).
    - **Sintaxe:** `@Injectable({ providedIn: ProductsModule })`

---

### **Restrições de Uso**

Embora os serviços sejam extremamente poderosos, existem cenários onde seu uso pode ser um exagero ou inadequado:

1. **Lógica Estritamente Visual e Contida em um Componente:** Se uma lógica manipula apenas o estado interno de um único componente e não precisa ser compartilhada ou reutilizada, mantê-la dentro da classe do componente é mais simples e direto. Por exemplo, controlar a visibilidade de um elemento `<p>` dentro do template de um componente.
2. **Simples Transformação de Dados no Template:** Para formatação ou transformação de dados diretamente no template HTML, os **Pipes** são a ferramenta mais adequada e performática (ex: `{{ data | date: 'dd/MM/yyyy' }}`).
3. **Comportamento Reutilizável de DOM:** Para adicionar comportamentos reutilizáveis a elementos do DOM (como um efeito de *drag-and-drop* ou uma máscara de input), as **Diretivas** são a escolha correta.

O porquê é simples: usar um serviço para esses casos adicionaria uma camada de complexidade desnecessária, aumentando o *boilerplate* e dificultando o rastreamento da lógica, que estaria separada do seu contexto de uso sem um bom motivo.

---

### **Elementos Associados**

Como vimos, os serviços não trabalham sozinhos. Eles estão intrinsecamente ligados ao sistema de Injeção de Dependência.

- **Decorador `@Injectable()`:**
    - **Propósito:** Marca uma classe para que o Angular saiba que ela pode ter dependências injetadas em seu próprio construtor. Tecnicamente, este decorador só é estritamente necessário se o próprio serviço tiver outras dependências. Contudo, é uma **melhor prática** adicioná-lo a **todos** os serviços para manter a consistência e evitar erros futuros.
    - **Sintaxe:**
        
        ```tsx
        import { Injectable } from '@angular/core';
        import { HttpClient } from '@angular/common/http'; // Exemplo de dependência
        
        @Injectable({
          providedIn: 'root'
        })
        export class DataService {
          // O DataService depende do HttpClient
          constructor(private http: HttpClient) { }
        }
        
        ```
        
- **Provedores (`providers`):**
    - **Propósito:** Antes do `providedIn` se tornar popular, a forma de registrar um serviço era através do array `providers` em um módulo (`@NgModule`) ou em um componente (`@Component`). Isso informa ao Angular como criar a dependência.
    - **Uso:** Embora `providedIn` seja preferível, o uso de `providers` ainda é válido para cenários específicos, como:
        - **Escopo de Componente:** Fornecer uma instância de serviço *apenas* para um componente e seus filhos. Cada instância do componente terá sua própria instância do serviço.
        - **Sobrescrever Serviços:** Fornecer uma implementação diferente de um serviço em um contexto específico (muito comum em testes).
    - **Sintaxe (em um Módulo):**
        
        ```tsx
        // app.module.ts
        import { NgModule } from '@angular/core';
        import { BrowserModule } from '@angular/platform-browser';
        import { LegacyService } from './legacy.service';
        
        @NgModule({
          declarations: [ /* ... */ ],
          imports: [ BrowserModule ],
          providers: [ LegacyService ], // O serviço é registrado aqui
          bootstrap: [ /* ... */ ]
        })
        export class AppModule { }
        
        ```
        
    - **Sintaxe (em um Componente):**
        
        ```tsx
        // user-profile.component.ts
        import { Component } from '@angular/core';
        import { UserDataService } from './user-data.service';
        
        @Component({
          selector: 'app-user-profile',
          template: `...`,
          providers: [ UserDataService ] // Cada instância de UserProfileComponent terá sua própria instância de UserDataService
        })
        export class UserProfileComponent {
          constructor(private userData: UserDataService) {}
        }
        
        ```
        

---

### **Melhores Práticas e Casos de Uso**

1. **Princípio da Responsabilidade Única (SRP):** Crie serviços pequenos e focados. Em vez de um `MegaService` que faz autenticação, busca dados de produtos e registra logs, crie `AuthService`, `ProductService` e `LoggingService`. Isso torna o código mais fácil de manter e testar.
2. **Serviços para Comunicação com API (Data Services):** Este é o caso de uso mais comum. Um serviço encapsula a lógica de `HttpClient` para fazer requisições HTTP (GET, POST, PUT, DELETE) a um backend. O componente que precisa dos dados simplesmente chama um método como `productService.getProducts()` e não precisa saber nada sobre URLs, headers ou o protocolo HTTP.
3. **Serviços para Gerenciamento de Estado:** Para compartilhar dados entre componentes não relacionados, um serviço pode usar `Observables` (especificamente `BehaviorSubject` do RxJS) para manter o estado. Quando o estado muda no serviço, todos os componentes "inscritos" nesse `Observable` são notificados e atualizam sua UI automaticamente. Exemplo: um serviço de carrinho de compras.
4. **Lógica de Negócio Abstrata:** Se você tem uma lógica de cálculo complexa, como calcular impostos, parcelas de um financiamento ou validar um formulário com regras complexas, um serviço é o lugar ideal para essa lógica.
5. **Use `providedIn: 'root'` por Padrão:** A menos que você tenha um motivo muito específico para limitar o escopo de um serviço a um módulo ou componente, use `providedIn: 'root'`. É mais eficiente e simples.

---

### **Exemplos Completos**

Vamos criar um exemplo prático: uma pequena aplicação que busca uma lista de usuários de uma API pública (`JSONPlaceholder`) e a exibe em um componente. Como você é um desenvolvedor Backend, Gedê, vai reconhecer a importância dessa separação de responsabilidades.

### 1\. Configurar o `HttpClientModule`

Primeiro, precisamos garantir que nossa aplicação possa fazer requisições HTTP.

```tsx
// src/app/app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http'; // <-- Importe aqui

import { AppComponent } from './app.component';
import { UserListComponent } from './components/user-list/user-list.component';

@NgModule({
  declarations: [
    AppComponent,
    UserListComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule // <-- Adicione aos imports
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

### 2\. Criar o Serviço `UserService`

```bash
ng g s services/user

```

Agora, vamos implementar o serviço para buscar os usuários.

```tsx
// src/app/services/user.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

// Definindo uma interface para tipar nossos dados (boa prática)
export interface User {
  id: number;
  name: string;
  username: string;
  email: string;
}

@Injectable({
  providedIn: 'root'
})
export class UserService {

  private apiUrl = '<https://jsonplaceholder.typicode.com/users>';

  // Injetamos o HttpClient, que é o serviço do Angular para requisições HTTP
  constructor(private http: HttpClient) { }

  /**
   * Retorna um Observable contendo uma lista de usuários da API.
   * Componentes podem se inscrever (subscribe) a este Observable para receber os dados.
   */
  public getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }
}

```

### 3\. Criar o Componente `UserListComponent`

```bash
ng g c components/user-list

```

Vamos implementar o componente para usar o serviço e exibir os dados.

```tsx
// src/app/components/user-list/user-list.component.ts

import { Component, OnInit } from '@angular/core';
import { UserService, User } from '../../services/user.service'; // Importamos o serviço e a interface

@Component({
  selector: 'app-user-list',
  template: `
    <h2>Lista de Usuários</h2>
    <ul *ngIf="users.length > 0; else loading">
      <li *ngFor="let user of users">
        <strong>{{ user.name }}</strong> ({{ user.email }})
      </li>
    </ul>
    <ng-template #loading>
      <p>Carregando usuários...</p>
    </ng-template>
  `,
  styleUrls: ['./user-list.component.css']
})
export class UserListComponent implements OnInit {

  users: User[] = [];

  // Injetamos nosso UserService
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    // Chamamos o método do serviço. Como ele retorna um Observable,
    // precisamos nos inscrever (subscribe) para receber o valor quando ele estiver disponível.
    this.userService.getUsers().subscribe(
      (data: User[]) => {
        this.users = data;
        console.log('Usuários carregados com sucesso!', this.users);
      },
      (error) => {
        console.error('Ocorreu um erro ao buscar usuários:', error);
      }
    );
  }
}

```

### 4\. Usar o Componente

Finalmente, adicione o seletor do nosso componente ao `app.component.html`.

```html
<h1>Minha Aplicação com Serviços</h1>
<hr>
<app-user-list></app-user-list>

```

Agora, ao rodar sua aplicação (`ng serve`), você verá a lista de usuários sendo carregada da API e exibida na tela. O componente não sabe *como* os dados são buscados, ele apenas pede ao serviço e reage quando os dados chegam. Perfeito desacoplamento\!

---

### **Tópicos para Aprofundamento**

Gedê, agora que você tem uma base sólida sobre serviços, sugiro os seguintes tópicos para levar seu conhecimento ao próximo nível:

1. **RxJS e Programação Reativa:** Entender `Observables`, `Subjects` (especialmente `BehaviorSubject`) e operadores (`map`, `filter`, `tap`) é crucial para trabalhar com serviços assíncronos e gerenciamento de estado.
2. **Injeção de Dependência em Profundidade:** Pesquise sobre `Hierarchical Injectors` (injetores hierárquicos), `InjectionToken` e os decoradores `@Host`, `@Self`, `@SkipSelf` para ter controle total sobre como as dependências são resolvidas.
3. **Padrões de Gerenciamento de Estado:** Explore como usar serviços para criar soluções de gerenciamento de estado, desde um simples "Service with a Subject" até entender como bibliotecas como NgRx, Akita ou Elf funcionam por baixo dos panos.
4. **Interceptadores HTTP (`HttpInterceptor`):** Aprenda a usar interceptadores, que são um tipo especial de serviço, para manipular globalmente todas as requisições e respostas HTTP (ex: adicionar tokens de autenticação a headers, tratar erros de forma centralizada).

Espero que esta explicação super detalhada tenha sido útil para você, Gedê\! Os serviços são uma parte essencial e poderosa do desenvolvimento com Angular. Qualquer outra dúvida, é só chamar a A.R.I.A.\!