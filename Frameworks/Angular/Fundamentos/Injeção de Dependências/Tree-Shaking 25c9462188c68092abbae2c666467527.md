# Tree-Shaking

### **Introdução**

No ecossistema de desenvolvimento web moderno, a performance é um fator crítico para o sucesso de qualquer aplicação. O tamanho final do *bundle* (o pacote de código que é enviado ao navegador do usuário) tem um impacto direto nos tempos de carregamento e, consequentemente, na experiência do usuário. É nesse cenário que o **Tree-Shaking** se torna uma técnica indispensável, especialmente em frameworks robustos como o Angular. Ele atua como um "jardineiro" do seu código, podando galhos (códigos) mortos ou não utilizados para garantir que apenas o essencial seja entregue ao cliente.

### **Sumário**

Esta explicação detalhada abordará o conceito de Tree-Shaking no Angular, desde seus fundamentos teóricos até sua aplicação prática. Exploraremos como o Angular, em conjunto com ferramentas de *build* como o Webpack, analisa seu código-fonte, identifica partes não utilizadas e as elimina do *bundle* final. Veremos a sintaxe correta para garantir que seu código seja "tree-shakable", as configurações do projeto que influenciam esse processo, e as melhores práticas para criar aplicações mais leves, rápidas e eficientes. Ao final, você terá uma compreensão completa de como essa otimização funciona e como aplicá-la efetivamente em seus projetos.

### **Conceitos Fundamentais**

### O que é Tree-Shaking?

Tree-Shaking é um processo de eliminação de código morto (*dead code elimination*). O termo foi popularizado por Rollup, um empacotador de módulos JavaScript, e a metáfora é bastante intuitiva: imagine sua aplicação como uma árvore, onde cada módulo, função ou classe é um galho. O Tree-Shaking sacode essa árvore para que as folhas e galhos secos (código não utilizado) caiam, restando apenas a estrutura viva e necessária.

O propósito fundamental do Tree-Shaking é **reduzir o tamanho do *bundle* final da aplicação**. Isso é alcançado através de uma análise estática do código-fonte.

### Como funciona a Análise Estática?

A "mágica" do Tree-Shaking acontece durante o processo de *build* da aplicação e depende fundamentalmente do uso de **módulos ES2015 (ESM)**, com suas declarações `import` e `export`. Diferente de outros sistemas de módulos (como CommonJS, usado no Node.js com `require`), a estrutura do ESM é estática. Isso significa que é possível determinar, em tempo de compilação, quais partes de um módulo são importadas e quais não são, sem precisar executar o código.

O processo pode ser simplificado em duas etapas:

1. **Marcação:** O empacotador (como o Webpack, usado pelo Angular CLI) percorre todo o grafo de dependências da sua aplicação a partir do ponto de entrada (o arquivo `main.ts`). Ele marca todas as funções, classes e variáveis que são explicitamente importadas e utilizadas como "vivas".
2. **Varredura (Sweeping):** Após a marcação, qualquer código que não foi marcado como "vivo" é considerado "morto" e é removido do *bundle* final.

No contexto do Angular, o compilador **AOT (Ahead-of-Time)** desempenha um papel crucial. Ele compila seus templates HTML e componentes TypeScript em código JavaScript otimizado durante o *build*, o que facilita ainda mais a análise estática e a identificação de código não utilizado.

### **Sintaxe e Uso: Tornando seu Código "Tree-Shakable"**

Para que o Tree-Shaking funcione, você precisa escrever seu código de uma maneira que permita a análise estática. A regra de ouro é: **use sempre a sintaxe `import` e `export` do ES2015.**

### Exemplo Prático e Comentado

Vamos imaginar um arquivo de utilitários (`src/app/utils.ts`):

```tsx
// src/app/utils.ts

// Função que será utilizada
export function formatarData(data: Date): string {
  console.log('Formatando data...');
  return data.toLocaleDateString('pt-BR');
}

// Função que NÃO será utilizada em nosso exemplo
export function calcularJuros(valor: number, taxa: number): number {
  console.log('Calculando juros...');
  return valor * (1 + taxa);
}

// Uma constante que também NÃO será utilizada
export const VERSAO_API = 'v2.1';

```

Agora, em um componente (`src/app/app.component.ts`), vamos usar apenas a função `formatarData`:

```tsx
// src/app/app.component.ts
import { Component, OnInit } from '@angular/core';
// Importamos especificamente o que precisamos
import { formatarData } from './utils';

@Component({
  selector: 'app-root',
  template: `<p>Data de hoje: {{ dataFormatada }}</p>`,
})
export class AppComponent implements OnInit {
  dataFormatada: string;

  ngOnInit() {
    // Usamos a função importada
    this.dataFormatada = formatarData(new Date());
  }
}

```

**O que acontece no *build* de produção (`ng build`)?**

1. O Webpack analisa o `app.component.ts`.
2. Ele vê a declaração `import { formatarData } from './utils';`.
3. Ele marca `formatarData` como "código vivo".
4. Ao analisar o arquivo `utils.ts`, ele percebe que `calcularJuros` e `VERSAO_API` nunca foram importados em nenhum lugar da aplicação.
5. **Resultado:** As funções `calcularJuros` e `VERSAO_API` serão completamente removidas do *bundle* final. A instrução `console.log('Calculando juros...');` nunca será incluída no código que vai para o navegador.

### **Elementos Associados ao Tree-Shaking no Angular**

O ecossistema Angular possui elementos específicos que são projetados para otimizar e facilitar o Tree-Shaking.

### 1\. Serviços e `providedIn: 'root'`

Esta é a maneira moderna e preferencial de registrar serviços no Angular, introduzida na versão 6.

- **Propósito:** Registrar um serviço diretamente em seu decorador `@Injectable`, tornando-o "tree-shakable".
- **Sintaxe e Uso:**
    
    ```tsx
    import { Injectable } from '@angular/core';
    
    @Injectable({
      providedIn: 'root' // <-- A mágica acontece aqui
    })
    export class LogService {
      log(mensagem: string) {
        console.log(`[LOG]: ${mensagem}`);
      }
    }
    
    ```
    
- **Como funciona?**
    - Quando você usa `providedIn: 'root'`, você não precisa mais adicionar o serviço ao array `providers` de nenhum `NgModule` (como o `AppModule`).
    - O compilador do Angular sabe que este serviço existe, mas só o incluirá no *bundle* final se algum componente, diretiva ou outro serviço o injetar em seu construtor.
    - **Se o `LogService` nunca for injetado em nenhum lugar da sua aplicação, ele será completamente removido do *bundle* final.** Isso é extremamente poderoso para bibliotecas de componentes e serviços compartilhados.

### 2\. Compilação AOT (Ahead-of-Time)

- **Propósito:** A compilação AOT é essencial para um Tree-Shaking eficaz no Angular. Ela converte seu código TypeScript e templates HTML em JavaScript otimizado durante o processo de *build*, antes de ser enviado ao navegador.
- **Como ajuda o Tree-Shaking?**
    - O compilador AOT analisa os templates e entende exatamente quais componentes, diretivas e pipes são realmente utilizados. Se você tem um componente declarado em um módulo, mas nunca o usa em nenhum template, o AOT pode ajudar o processo de Tree-Shaking a removê-lo.
    - Ele remove metadados do Angular que só são necessários para a compilação JIT (Just-in-Time), reduzindo ainda mais o tamanho do *bundle*.
    - **Observação:** A compilação AOT é o padrão para *builds* de produção (`ng build`) no Angular CLI.

### 3\. Otimizador de Build (`angular.json`)

O Angular CLI gerencia as configurações do Webpack e do Terser (o minificador que efetivamente remove o código morto) para você. As configurações relevantes estão no arquivo `angular.json`.

- **Propósito:** Controlar as otimizações do processo de *build*.
- **Sintaxe e Uso (em `angular.json`):**
    
    ```json
    {
      ...
      "projects": {
        "seu-projeto": {
          ...
          "architect": {
            "build": {
              "builder": "@angular-devkit/build-angular:browser",
              ...
              "configurations": {
                "production": {
                  ...
                  "optimization": true, // <-- Nível geral de otimização
                  "buildOptimizer": true, // <-- Ativa otimizações específicas do Angular
                  ...
                }
              }
            }
          }
        }
      }
    }
    
    ```
    
- **Propriedades Chave:**
    - `"optimization": true`: Habilita um conjunto de otimizações, incluindo minificação e Tree-Shaking.
    - `"buildOptimizer": true`: Aplica uma transformação adicional ao código TypeScript que o torna mais fácil de ser "tree-shaken" pelo minificador. Ele remove decoradores do Angular do código de tempo de execução e realiza outras dobras de código estático.
    
    **Essas configurações são `true` por padrão em *builds* de produção.**
    

### **Restrições de Uso e Pontos de Atenção**

O Tree-Shaking é poderoso, mas não é infalível. Existem cenários onde ele pode falhar em remover código, principalmente devido a **efeitos colaterais (side effects)**.

- **O que é um Efeito Colateral?**
Um efeito colateral ocorre quando a simples importação de um módulo modifica o estado global da aplicação, sem que nada do módulo seja explicitamente utilizado.
- **Cenários onde o Tree-Shaking pode falhar:**
    1. **Imports com Efeitos Colaterais:**
        
        ```tsx
        // a.ts
        window.minhaVariavelGlobal = 'Olá, mundo!';
        console.log('Módulo A foi carregado');
        
        // b.ts
        import './a'; // Apenas importa, não usa nada do módulo 'a'
        
        // O Tree-Shaker não pode remover 'a.ts', pois ele não sabe
        // se a modificação em 'window' ou o 'console.log' são importantes
        // para o funcionamento da aplicação.
        
        ```
        
        Um exemplo prático disso são os *polyfills* ou bibliotecas que estendem protótipos nativos (ex: `import 'core-js/es/array/find';`).
        
    2. **Código Dinâmico e "Mágico":**
    Código que depende de nomes de strings para acessar propriedades ou módulos (como `import(variavelComNomeDoModulo)`) pode ser impossível de analisar estaticamente.
    3. **Bibliotecas Mal Estruturadas:**
    Algumas bibliotecas de terceiros podem não ser escritas com Tree-Shaking em mente (ex: não usam módulos ES2015 ou possuem muitos efeitos colaterais). Nesse caso, mesmo que você importe apenas uma função, a biblioteca inteira pode ser incluída no seu *bundle*.
- **Como Mitigar?**
    - **`sideEffects: false`:** A comunidade JavaScript criou uma solução para isso. Bibliotecas podem adicionar uma propriedade `"sideEffects": false` em seu arquivo `package.json`. Isso é uma dica para o Webpack de que nenhum arquivo no pacote tem efeitos colaterais, e ele pode remover com segurança qualquer módulo que não seja diretamente importado.
    - **Escolha Bibliotecas Modernas:** Prefira bibliotecas que explicitamente suportem Tree-Shaking.

### **Melhores Práticas e Casos de Uso**

1. **Sempre Use `providedIn: 'root'` para Serviços:** Evite declarar serviços no array `providers` de módulos, a menos que você precise limitar o escopo da instância do serviço a um módulo específico (geralmente em módulos carregados por *lazy loading*).
2. **Importe Apenas o Necessário:** Seja específico em seus imports. Em vez de `import * as RxJs from 'rxjs';`, prefira importar apenas os operadores e funções que você realmente usa: `import { Observable, fromEvent } from 'rxjs';` e `import { map, filter } from 'rxjs/operators';`.
3. **Use Módulos com *Lazy Loading*:** Embora não seja Tree-Shaking *per se*, o carregamento tardio (*lazy loading*) é a técnica de otimização mais impactante em grandes aplicações Angular. Ele divide sua aplicação em pedaços (*chunks*) menores que são carregados sob demanda. O Tree-Shaking será aplicado em cada um desses *chunks* individualmente.
4. **Estruture Bibliotecas Internas com Cuidado:** Se você, Gedê, criar bibliotecas de componentes ou utilitários para sua equipe, certifique-se de que elas sejam "tree-shakable". Exporte cada componente, serviço e função de forma isolada e adicione `"sideEffects": false` ao `package.json` da biblioteca.
5. **Analise seu Bundle:** Use ferramentas como o `webpack-bundle-analyzer` para visualizar o que está dentro do seu *bundle* final. Isso ajuda a identificar bibliotecas grandes ou código que não foi removido como esperado. Você pode adicioná-lo ao seu projeto Angular com o comando `ng add webpack-bundle-analyzer`.

### **Exemplo Completo: Biblioteca de UI "Tree-Shakable"**

Vamos simular um cenário onde temos uma pequena biblioteca de componentes e queremos garantir que apenas os componentes usados sejam incluídos no *bundle* final.

**1. Estrutura da Biblioteca (`my-ui-lib`)**

- \`my-ui-lib/
    - \`src/
        - \`button/
            - `button.component.ts`
            - `button.module.ts`
        - \`card/
            - `card.component.ts`
            - `card.module.ts`
        - `public-api.ts` (Ponto de entrada da biblioteca)
    - `package.json`

**`package.json` da biblioteca:**

```json
{
  "name": "my-ui-lib",
  "version": "1.0.0",
  "sideEffects": false // <-- Informando que a lib é segura para Tree-Shaking
}

```

**`public-api.ts`:**

```tsx
// Exporta os módulos de cada componente
export * from './src/button/button.module';
export * from './src/button/button.component';
export * from './src/card/card.module';
export * from './src/card/card.component';

```

**2. Aplicação Consumidora**

Agora, na sua aplicação Angular principal:

**`app.module.ts`:**

```tsx
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

// Importamos APENAS o módulo do botão da nossa biblioteca
import { ButtonModule } from 'my-ui-lib';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    ButtonModule // <-- Usando o módulo do botão
    // CardModule não é importado aqui!
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

**`app.component.html`:**

```html
<h1>Bem-vindo à minha aplicação!</h1>
<my-button label="Clique Aqui"></my-button>

```

**Resultado do *Build* de Produção:**

- O compilador do Angular e o Webpack analisarão as importações.
- Eles verão que `ButtonModule` foi importado e `my-button` foi usado no template.
- Todo o código relacionado ao `ButtonComponent` e `ButtonModule` será incluído no *bundle*.
- Como `CardModule` e `CardComponent` nunca foram importados ou usados, **eles serão completamente eliminados do *bundle* final**, mesmo que existam na biblioteca instalada em `node_modules`.

Este é o poder do Tree-Shaking aplicado a um ecossistema modular como o do Angular.

### **Tópicos Relacionados para Aprofundamento**

1. **Lazy Loading vs. Eager Loading:** Entender a fundo como o carregamento de módulos sob demanda complementa o Tree-Shaking para otimizações ainda mais drásticas.
2. **Webpack e Terser:** Estudar como essas ferramentas funcionam sob o capô para entender melhor o processo de empacotamento e minificação.
3. **Ivy Engine:** Pesquisar como o motor de renderização Ivy, padrão no Angular desde a versão 9, foi projetado com a "localidade de referência" em mente, o que o torna ainda mais amigável ao Tree-Shaking. Com o Ivy, cada componente é compilado de forma mais isolada, permitindo que partes não utilizadas do próprio framework Angular sejam removidas.
4. **Análise de Bundle com `webpack-bundle-analyzer`:** Aprender a usar essa ferramenta na prática para inspecionar e otimizar os *bundles* de suas aplicações Angular.

Espero que esta explicação detalhada tenha sido clara e útil para você, Gedê\! Se tiver mais alguma dúvida, pode perguntar.