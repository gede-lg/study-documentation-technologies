# Introdução

Beleza, Gedê\! Entendido. A.R.I.A vai te ajudar com uma explicação detalhada sobre Formulários em Angular, focando nos conceitos, uso prático e melhores práticas. Como você é desenvolvedor Backend Java buscando GO, mas já tem experiência em desenvolvimento, vou focar em uma explicação que seja completa, mas sem te entediar com o básico do básico, tá?

---

## Formulários em Angular: Gerenciando a Interação do Usuário

### Introdução

Os formulários são a espinha dorsal da interação do usuário em qualquer aplicação web. Eles permitem coletar dados, realizar pesquisas, processar pedidos e muito mais. No **Angular**, o gerenciamento de formulários é uma das áreas mais robustas e flexíveis, oferecendo duas abordagens principais para lidar com a entrada de dados do usuário e a validação: **Formulários Orientados a Template (Template-Driven Forms)** e **Formulários Reativos (Reactive Forms)**. Entender essas abordagens é crucial para construir aplicações Angular eficientes e escaláveis.

### Sumário

Nesta explicação detalhada, abordaremos os seguintes tópicos:

- **Conceitos Fundamentais:** A importância dos formulários e as duas abordagens principais no Angular.
- **Formulários Orientados a Template:** Como funcionam, sua sintaxe e uso prático.
- **Formulários Reativos:** A base de dados, a sintaxe e o poder dos Reactive Forms.
- **Validação de Formulários:** Como validar a entrada do usuário em ambas as abordagens.
- **Cenários de Restrição ou Não Aplicação:** Quando usar cada tipo de formulário.
- **Componentes Chave Associados:** `FormControl`, `FormGroup`, `FormArray`, `FormBuilder` e diretivas.
- **Melhores Práticas e Padrões de Uso:** Dicas para construir formulários robustos.
- **Exemplo Prático Completo:** Um exemplo para visualizar os conceitos.

---

### Conceitos Fundamentais

No cerne dos formulários Angular está a capacidade de **rastrear o estado** das entradas de usuário, como elas mudam e se são válidas. As duas filosofias para alcançar isso são:

1. **Formulários Orientados a Template (Template-Driven Forms):**
    - São mais simples para casos de uso básicos.
    - A lógica é principalmente declarada diretamente no **template HTML**, usando diretivas.
    - O Angular cria automaticamente os objetos do modelo de formulário internamente.
    - São ideais para formulários simples com poucos campos e validação menos complexa.
2. **Formulários Reativos (Reactive Forms):**
    - São mais robustos e flexíveis, ideais para formulários complexos e dinâmicos.
    - A lógica é definida **programaticamente no componente TypeScript**.
    - Oferecem maior controle sobre o estado do formulário, validação assíncrona e testes unitários.
    - Utilizam **observáveis** para rastrear mudanças de valor e estado, o que os torna reativos por natureza.

A escolha entre um e outro depende da complexidade do formulário e da necessidade de controle programático.

---

### Sintaxe Detalhada e Uso Prático

Vamos mergulhar na sintaxe e no uso prático de cada tipo.

### Formulários Orientados a Template (Template-Driven Forms)

Para usar Formulários Orientados a Template, você precisa importar o `FormsModule` no seu `app.module.ts`:

```tsx
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms'; // Importe FormsModule

import { AppComponent } from './app.component';
import { UserFormComponent } from './user-form/user-form.component';

@NgModule({
  declarations: [
    AppComponent,
    UserFormComponent
  ],
  imports: [
    BrowserModule,
    FormsModule // Adicione FormsModule aos imports
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

**Sintaxe e Uso:**

A diretiva central é `ngModel`, que cria uma ligação bidirecional (`[(ngModel)]`) entre a propriedade do componente e o valor do campo do formulário.

```html
<form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)">
  <div>
    <label for="name">Nome:</label>
    <input type="text" id="name" name="name" [(ngModel)]="user.name" required minlength="3">
    <div *ngIf="userForm.controls['name']?.invalid && userForm.controls['name']?.touched">
      <span *ngIf="userForm.controls['name']?.errors?.['required']">Nome é obrigatório.</span>
      <span *ngIf="userForm.controls['name']?.errors?.['minlength']">Nome deve ter no mínimo 3 caracteres.</span>
    </div>
  </div>

  <div>
    <label for="email">Email:</label>
    <input type="email" id="email" name="email" [(ngModel)]="user.email" required email>
    <div *ngIf="userForm.controls['email']?.invalid && userForm.controls['email']?.touched">
      <span *ngIf="userForm.controls['email']?.errors?.['required']">Email é obrigatório.</span>
      <span *ngIf="userForm.controls['email']?.errors?.['email']">Email inválido.</span>
    </div>
  </div>

  <button type="submit" [disabled]="userForm.invalid">Salvar</button>
</form>

```

```tsx
// user-form.component.ts
import { Component } from '@angular/core';
import { NgForm } from '@angular/forms'; // Importe NgForm para tipagem

@Component({
  selector: 'app-user-form',
  templateUrl: './user-form.component.html',
  styleUrls: ['./user-form.component.css']
})
export class UserFormComponent {
  user = {
    name: '',
    email: ''
  };

  onSubmit(form: NgForm) {
    if (form.valid) {
      console.log('Formulário enviado!', this.user);
      // Aqui você enviaria os dados para o seu backend
    } else {
      console.log('Formulário inválido.');
    }
  }
}

```

- `#userForm="ngForm"`: Cria uma variável de template que referencia a instância da diretiva `NgForm` no `<form>`. Isso nos dá acesso ao estado geral do formulário (válido, inválido, sujo, etc.).
- `name="name"` e `name="email"`: São **obrigatórios** em campos com `ngModel` em formulários orientados a template para que o Angular possa rastrear os controles individualmente.
- `required`, `minlength`, `email`: São validadores HTML5 que o Angular reconhece e usa para validar o campo.

---

### Formulários Reativos (Reactive Forms)

Para usar Formulários Reativos, você precisa importar o `ReactiveFormsModule` no seu `app.module.ts`:

```tsx
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { ReactiveFormsModule } from '@angular/forms'; // Importe ReactiveFormsModule

import { AppComponent } from './app.component';
import { UserReactiveFormComponent } from './user-reactive-form/user-reactive-form.component';

@NgModule({
  declarations: [
    AppComponent,
    UserReactiveFormComponent
  ],
  imports: [
    BrowserModule,
    ReactiveFormsModule // Adicione ReactiveFormsModule aos imports
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

**Sintaxe e Uso:**

A base dos Formulários Reativos são as classes `FormControl`, `FormGroup` e `FormArray`.

```html
<form [formGroup]="userForm" (ngSubmit)="onSubmit()">
  <div>
    <label for="nameReactive">Nome:</label>
    <input type="text" id="nameReactive" formControlName="name">
    <div *ngIf="userForm.get('name')?.invalid && userForm.get('name')?.touched">
      <span *ngIf="userForm.get('name')?.errors?.['required']">Nome é obrigatório.</span>
      <span *ngIf="userForm.get('name')?.errors?.['minlength']">Nome deve ter no mínimo 3 caracteres.</span>
    </div>
  </div>

  <div>
    <label for="emailReactive">Email:</label>
    <input type="email" id="emailReactive" formControlName="email">
    <div *ngIf="userForm.get('email')?.invalid && userForm.get('email')?.touched">
      <span *ngIf="userForm.get('email')?.errors?.['required']">Email é obrigatório.</span>
      <span *ngIf="userForm.get('email')?.errors?.['email']">Email inválido.</span>
    </div>
  </div>

  <button type="submit" [disabled]="userForm.invalid">Salvar</button>
</form>

```

```tsx
// user-reactive-form.component.ts
import { Component, OnInit } from '@angular/core';
import { FormGroup, FormControl, Validators, FormBuilder } from '@angular/forms'; // Importe as classes necessárias

@Component({
  selector: 'app-user-reactive-form',
  templateUrl: './user-reactive-form.component.html',
  styleUrls: ['./user-reactive-form.component.css']
})
export class UserReactiveFormComponent implements OnInit {
  userForm!: FormGroup; // Usamos ! para indicar que será inicializado no ngOnInit

  constructor(private fb: FormBuilder) { } // Injetamos FormBuilder

  ngOnInit(): void {
    // Usando FormBuilder para criar o FormGroup de forma concisa
    this.userForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3)]], // Valor inicial e validadores
      email: ['', [Validators.required, Validators.email]]
    });

    // Você também pode criar manualmente sem FormBuilder, assim:
    /*
    this.userForm = new FormGroup({
      name: new FormControl('', [Validators.required, Validators.minLength(3)]),
      email: new FormControl('', [Validators.required, Validators.email]),
    });
    */

    // Exemplo de como reagir a mudanças de valor de um controle
    this.userForm.get('name')?.valueChanges.subscribe(value => {
      console.log('Nome alterado para:', value);
    });

    // Exemplo de como reagir a mudanças de estado de um controle
    this.userForm.get('name')?.statusChanges.subscribe(status => {
      console.log('Status do nome:', status); // 'VALID', 'INVALID', 'PENDING', 'DISABLED'
    });
  }

  onSubmit() {
    if (this.userForm.valid) {
      console.log('Formulário reativo enviado!', this.userForm.value);
      // Aqui você enviaria os dados para o seu backend
      // this.userForm.reset(); // Para resetar o formulário
    } else {
      console.log('Formulário reativo inválido.');
      // Pode marcar todos os campos como 'touched' para exibir as mensagens de erro
      this.userForm.markAllAsTouched();
    }
  }
}

```

- `[formGroup]="userForm"`: Liga o `FormGroup` definido no componente TypeScript ao `<form>` no template.
- `formControlName="name"`: Liga um elemento de formulário HTML a um `FormControl` específico dentro do `FormGroup`. **Não é necessário o atributo `name`** aqui, pois a ligação é feita pelo `formControlName`.
- `Validators.required`, `Validators.minLength`, `Validators.email`: São validadores internos do Angular, usados programaticamente no componente TypeScript.

---

### Cenários de Restrição ou Não Aplicação

- **Formulários Orientados a Template:**
    - **Melhor escolha para:** Formulários simples, com poucos campos e validação básica. Ideal para prototipagem rápida ou formulários que não mudam muito.
    - **Não é a melhor escolha para:** Formulários complexos, dinâmicos (onde campos aparecem/desaparecem), validação assíncrona ou quando você precisa testar a lógica do formulário de forma isolada. A lógica de validação misturada com o template pode dificultar a manutenção.
- **Formulários Reativos:**
    - **Melhor escolha para:** Formulários complexos, formulários dinâmicos, formulários com validação personalizada ou assíncrona, e quando você precisa de controle programático total sobre o formulário. É o padrão recomendado para a maioria das aplicações Angular modernas.
    - **Não é a melhor escolha para:** Formulários extremamente simples, onde a sobrecarga de criar um `FormGroup` no TypeScript pode parecer desnecessária para apenas um ou dois campos. Embora funcione perfeitamente, pode ser um "overkill".

---

### Componentes Chave Associados

Aqui estão os pilares dos Formulários Reativos:

- **`FormControl`:**
    - **Propósito:** Representa um controle de formulário individual (como um `<input>`, `<select>`, `<textarea>`). Ele rastreia o valor do campo e seu estado de validação (válido, inválido, intocado, tocado, sujo, limpo).
    - **Sintaxe e Uso:**
    Você pode acessar suas propriedades como `nameControl.value`, `nameControl.valid`, `nameControl.invalid`, `nameControl.touched`, `nameControl.dirty`, etc.
    Métodos importantes: `setValue()`, `patchValue()`, `reset()`, `disable()`, `enable()`.
        
        ```tsx
        const nameControl = new FormControl('Valor Inicial', [Validators.required, MyCustomValidator]);
        
        ```
        
- **`FormGroup`:**
    - **Propósito:** Agrupa uma coleção de instâncias de `FormControl` (ou outros `FormGroup`s e `FormArray`s) em um único formulário. Ele rastreia o estado de validação de todo o grupo. Se qualquer `FormControl` dentro dele for inválido, o `FormGroup` inteiro também será inválido.
    - **Sintaxe e Uso:**
    Você pode acessá-lo no template com `[formGroup]="userProfile"` e usar `formControlName` para ligar os campos.
        
        ```tsx
        const userProfile = new FormGroup({
          firstName: new FormControl(''),
          lastName: new FormControl(''),
          address: new FormGroup({ // FormGroup aninhado
            street: new FormControl(''),
            city: new FormControl('')
          })
        });
        
        ```
        
- **`FormArray`:**
    - **Propósito:** Gerencia uma coleção de `FormControl`s, `FormGroup`s ou até mesmo outros `FormArray`s dinamicamente. É perfeito para cenários onde você tem um número variável de campos repetíveis (ex: múltiplos números de telefone, itens de um pedido).
    - **Sintaxe e Uso:**
    No template, você usaria `formArrayName` e `ngFor` para iterar sobre os controles.
        
        ```tsx
        const hobbies = new FormArray([
          new FormControl('Leitura'),
          new FormControl('Caminhada')
        ]);
        
        const userForm = new FormGroup({
          name: new FormControl(''),
          contactInfo: hobbies // Adicionando o FormArray ao FormGroup
        });
        
        // Adicionando um novo hobby dinamicamente
        (userForm.get('contactInfo') as FormArray).push(new FormControl('Programação'));
        
        ```
        
- **`FormBuilder`:**
    - **Propósito:** Um serviço injetável que fornece métodos auxiliares para gerar instâncias de `FormControl`, `FormGroup` e `FormArray` de forma mais concisa e legível, especialmente útil para formulários maiores.
    - **Sintaxe e Uso:**
        
        ```tsx
        import { FormBuilder, FormGroup, Validators } from '@angular/forms';
        
        // No constructor do seu componente:
        constructor(private fb: FormBuilder) {}
        
        // No ngOnInit:
        this.userForm = this.fb.group({
          name: ['', Validators.required],
          email: ['', [Validators.required, Validators.email]],
          phones: this.fb.array([this.fb.control('')]) // Exemplo com FormArray
        });
        
        ```
        

---

### Melhores Práticas e Padrões de Uso

1. **Escolha a Abordagem Certa:** Para formulários mais simples ou para aprender, comece com Template-Driven. Para qualquer coisa que vá além do trivial, especialmente em aplicações de médio a grande porte, **prefira Formulários Reativos**.
2. **Modularize seus Formulários Reativos:** Para formulários complexos, crie `FormGroup`s e `FormArray`s aninhados para organizar a lógica.
3. **Validação Personalizada:** Crie validadores personalizados como funções para lógica de validação complexa ou específica do negócio. Eles podem ser síncronos ou assíncronos.
4. **Exibição de Erros:** Exiba mensagens de erro apenas quando o campo estiver `invalid` e `touched` (o usuário interagiu com ele) ou `dirty` (o usuário modificou o valor). Isso evita que o formulário pareça inválido antes mesmo do usuário começar a preencher.
5. **Reatividade com `valueChanges` e `statusChanges`:** Utilize os Observables `valueChanges` e `statusChanges` dos `FormControl`s, `FormGroup`s e `FormArray`s para reagir a mudanças nos dados ou no estado do formulário. Isso é ótimo para habilitar/desabilitar campos dinamicamente, cálculos em tempo real ou feedback ao usuário.
6. **Desabilitar o Botão de Submit:** Mantenha o botão de submit desabilitado enquanto o formulário for `invalid`. `[disabled]="myReactiveForm.invalid"` é uma maneira simples e eficaz.
7. **Testes Unitários:** Formulários Reativos são significativamente mais fáceis de testar unitariamente, pois a lógica de validação está desacoplada do template e é definida em TypeScript.
8. **Tipagem Forte:** Embora o Angular não imponha tipagem forte nos objetos `FormGroup.value`, você pode criar interfaces para tipar os valores do seu formulário, tornando o código mais seguro e legível.

---

### Exemplo Prático Completo: Cadastro de Usuário com Endereço e Telefones (Reactive Forms)

Este exemplo demonstra um formulário mais complexo com um `FormGroup` aninhado para o endereço e um `FormArray` para múltiplos números de telefone.

```tsx
// app.module.ts (Certifique-se de ter ReactiveFormsModule importado)
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { ReactiveFormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
import { ComplexUserFormComponent } from './complex-user-form/complex-user-form.component';

@NgModule({
  declarations: [
    AppComponent,
    ComplexUserFormComponent
  ],
  imports: [
    BrowserModule,
    ReactiveFormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

```tsx
// complex-user-form.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';

@Component({
  selector: 'app-complex-user-form',
  templateUrl: './complex-user-form.component.html',
  styleUrls: ['./complex-user-form.component.css']
})
export class ComplexUserFormComponent implements OnInit {
  userRegistrationForm!: FormGroup;

  constructor(private fb: FormBuilder) { }

  ngOnInit(): void {
    this.userRegistrationForm = this.fb.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      age: [null, [Validators.required, Validators.min(18), Validators.max(99)]],
      // FormGroup aninhado para endereço
      address: this.fb.group({
        street: ['', Validators.required],
        city: ['', Validators.required],
        state: ['', Validators.required],
        zipCode: ['', [Validators.required, Validators.pattern(/^\\d{5}-\\d{3}$|^\\d{8}$/)]] // Ex: 12345-678 ou 12345678
      }),
      // FormArray para múltiplos telefones
      phones: this.fb.array([
        this.createPhoneGroup() // Inicia com um campo de telefone
      ])
    });

    // Exemplo de como pré-preencher o formulário (patchValue vs setValue)
    // this.userRegistrationForm.patchValue({
    //   firstName: 'Gedê',
    //   email: 'gededev@example.com'
    // });
  }

  // Getter para facilitar o acesso aos controles no template
  get phones() {
    return this.userRegistrationForm.get('phones') as FormArray;
  }

  createPhoneGroup(): FormGroup {
    return this.fb.group({
      type: ['Celular', Validators.required], // Ex: 'Celular', 'Comercial', 'Residencial'
      number: ['', [Validators.required, Validators.pattern(/^\\(?\\d{2}\\)?\\s?\\d{4,5}-?\\d{4}$/)]] // Ex: (XX) XXXX-XXXX ou XXXXXXXXX
    });
  }

  addPhone(): void {
    this.phones.push(this.createPhoneGroup());
  }

  removePhone(index: number): void {
    this.phones.removeAt(index);
  }

  onSubmit(): void {
    if (this.userRegistrationForm.valid) {
      console.log('Formulário de Registro Enviado:', this.userRegistrationForm.value);
      // Aqui você enviaria os dados para o seu backend.
      // Pode também resetar o formulário após o envio
      // this.userRegistrationForm.reset();
    } else {
      console.log('Formulário de Registro Inválido!');
      this.markAllControlsAsTouched(this.userRegistrationForm); // Função auxiliar para exibir todos os erros
    }
  }

  // Função auxiliar para marcar todos os controles como 'touched' recursivamente
  markAllControlsAsTouched(formGroup: FormGroup | FormArray): void {
    Object.values(formGroup.controls).forEach(control => {
      control.markAsTouched();
      if (control instanceof FormGroup || control instanceof FormArray) {
        this.markAllControlsAsTouched(control);
      }
    });
  }
}

```

```html
<form [formGroup]="userRegistrationForm" (ngSubmit)="onSubmit()">
  <h2>Registro de Usuário</h2>

  <div class="form-section">
    <h3>Dados Pessoais</h3>
    <div>
      <label for="firstName">Primeiro Nome:</label>
      <input type="text" id="firstName" formControlName="firstName">
      <div *ngIf="userRegistrationForm.get('firstName')?.invalid && userRegistrationForm.get('firstName')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('firstName')?.errors?.['required']">Nome é obrigatório.</span>
        <span *ngIf="userRegistrationForm.get('firstName')?.errors?.['minlength']">Nome deve ter no mínimo 2 caracteres.</span>
      </div>
    </div>

    <div>
      <label for="lastName">Sobrenome:</label>
      <input type="text" id="lastName" formControlName="lastName">
      <div *ngIf="userRegistrationForm.get('lastName')?.invalid && userRegistrationForm.get('lastName')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('lastName')?.errors?.['required']">Sobrenome é obrigatório.</span>
      </div>
    </div>

    <div>
      <label for="email">Email:</label>
      <input type="email" id="email" formControlName="email">
      <div *ngIf="userRegistrationForm.get('email')?.invalid && userRegistrationForm.get('email')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('email')?.errors?.['required']">Email é obrigatório.</span>
        <span *ngIf="userRegistrationForm.get('email')?.errors?.['email']">Email inválido.</span>
      </div>
    </div>

    <div>
      <label for="age">Idade:</label>
      <input type="number" id="age" formControlName="age">
      <div *ngIf="userRegistrationForm.get('age')?.invalid && userRegistrationForm.get('age')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('age')?.errors?.['required']">Idade é obrigatória.</span>
        <span *ngIf="userRegistrationForm.get('age')?.errors?.['min']">Idade mínima de 18 anos.</span>
        <span *ngIf="userRegistrationForm.get('age')?.errors?.['max']">Idade máxima de 99 anos.</span>
      </div>
    </div>
  </div>

  <div class="form-section" formGroupName="address">
    <h3>Endereço</h3>
    <div>
      <label for="street">Rua:</label>
      <input type="text" id="street" formControlName="street">
      <div *ngIf="userRegistrationForm.get('address.street')?.invalid && userRegistrationForm.get('address.street')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('address.street')?.errors?.['required']">Rua é obrigatória.</span>
      </div>
    </div>

    <div>
      <label for="city">Cidade:</label>
      <input type="text" id="city" formControlName="city">
      <div *ngIf="userRegistrationForm.get('address.city')?.invalid && userRegistrationForm.get('address.city')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('address.city')?.errors?.['required']">Cidade é obrigatória.</span>
      </div>
    </div>

    <div>
      <label for="state">Estado:</label>
      <input type="text" id="state" formControlName="state">
      <div *ngIf="userRegistrationForm.get('address.state')?.invalid && userRegistrationForm.get('address.state')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('address.state')?.errors?.['required']">Estado é obrigatório.</span>
      </div>
    </div>

    <div>
      <label for="zipCode">CEP:</label>
      <input type="text" id="zipCode" formControlName="zipCode" placeholder="Ex: 12345-678 ou 12345678">
      <div *ngIf="userRegistrationForm.get('address.zipCode')?.invalid && userRegistrationForm.get('address.zipCode')?.touched" class="error-message">
        <span *ngIf="userRegistrationForm.get('address.zipCode')?.errors?.['required']">CEP é obrigatório.</span>
        <span *ngIf="userRegistrationForm.get('address.zipCode')?.errors?.['pattern']">CEP inválido (Ex: 12345-678 ou 12345678).</span>
      </div>
    </div>
  </div>

  <div class="form-section">
    <h3>Telefones</h3>
    <div formArrayName="phones">
      <div *ngFor="let phoneGroup of phones.controls; let i = index" [formGroupName]="i" class="phone-group">
        <label for="phoneType-{{i}}">Tipo:</label>
        <select id="phoneType-{{i}}" formControlName="type">
          <option value="Celular">Celular</option>
          <option value="Comercial">Comercial</option>
          <option value="Residencial">Residencial</option>
        </select>

        <label for="phoneNumber-{{i}}">Número:</label>
        <input type="text" id="phoneNumber-{{i}}" formControlName="number" placeholder="Ex: (XX) XXXX-XXXX">
        <div *ngIf="phoneGroup.get('number')?.invalid && phoneGroup.get('number')?.touched" class="error-message">
          <span *ngIf="phoneGroup.get('number')?.errors?.['required']">Número é obrigatório.</span>
          <span *ngIf="phoneGroup.get('number')?.errors?.['pattern']">Número de telefone inválido.</span>
        </div>

        <button type="button" (click)="removePhone(i)">Remover</button>
      </div>
    </div>
    <button type="button" (click)="addPhone()">Adicionar Telefone</button>
  </div>

  <button type="submit" [disabled]="userRegistrationForm.invalid">Cadastrar</button>
</form>

<style>
  .form-section {
    border: 1px solid #ccc;
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 8px;
  }
  .form-section h3 {
    margin-top: 0;
    color: #333;
  }
  div {
    margin-bottom: 10px;
  }
  label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
  }
  input[type="text"], input[type="email"], input[type="number"], select {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box; /* Para padding não aumentar a largura */
  }
  button {
    padding: 10px 15px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 10px;
  }
  button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }
  .error-message {
    color: red;
    font-size: 0.85em;
    margin-top: 5px;
  }
  .phone-group {
    border: 1px dashed #eee;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 4px;
    display: grid;
    grid-template-columns: 1fr 2fr 0.5fr;
    gap: 10px;
    align-items: center;
  }
  .phone-group button {
    margin-top: 0;
    background-color: #dc3545;
  }
</style>

```

---

Espero que essa explicação detalhada, A.R.I.A, seja super útil para você, Gedê\! Se tiver alguma dúvida ou quiser que eu aprofunde em algum ponto, é só chamar.