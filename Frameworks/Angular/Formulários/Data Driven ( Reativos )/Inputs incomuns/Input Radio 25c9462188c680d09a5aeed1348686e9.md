# Input Radio

Olá Gedê\! Como A.R.I.A (Assistente Rápida para Idiotas Atarefados), preparei um guia completo e extremamente detalhado sobre como trabalhar com Radio Buttons em Formulários Reativos no Angular. Vamos mergulhar fundo neste tópico para que você domine todos os aspectos.

---

### **Título: Dominando Radio Buttons com Formulários Reativos em Angular: Um Guia Detalhado**

---

### **Introdução**

Os Radio Buttons (botões de opção) são um elemento de interface de usuário (UI) fundamental em formulários web, permitindo que o usuário selecione uma única opção de um conjunto predefinido. No ecossistema Angular, a abordagem de Formulários Reativos (Reactive Forms) oferece um modelo poderoso e escalável para gerenciar o estado desses inputs de forma explícita e previsível. Este guia detalha o processo de integração e gerenciamento de radio buttons em formulários reativos, desde os conceitos básicos até as práticas mais avançadas, garantindo um controle robusto sobre os dados do seu formulário.

---

### **Sumário**

Este artigo aborda de forma exaustiva o uso de radio buttons no contexto dos Formulários Reativos do Angular. Iniciaremos com os **Conceitos Fundamentais**, explicando o que são Formulários Reativos e o papel do `FormControl`. Em seguida, detalharemos a **Sintaxe e Uso**, mostrando como conectar o template HTML ao componente TypeScript. Exploraremos todos os **Métodos e Propriedades** relevantes para a manipulação dos dados. Discutiremos as **Restrições de Uso**, os **Elementos Associados** como diretivas e classes essenciais, as **Melhores Práticas e Casos de Uso**, e finalizaremos com um **Exemplo Completo** e sugestões de tópicos para aprofundamento.

---

### **Conceitos Fundamentais**

### O que são Formulários Reativos?

Diferente dos Formulários baseados em Template (Template-driven Forms), onde a lógica reside principalmente no template HTML, os Formulários Reativos adotam uma abordagem "model-first". A fonte da verdade (o modelo do formulário) é definida e gerenciada de forma explícita no código do componente (TypeScript).

As principais características são:

- **Explícito e Imutável:** O estado do formulário é imutável. Cada mudança no estado retorna um novo estado, o que facilita o rastreamento e o teste.
- **Modelo de Objeto Síncrono:** O modelo do formulário (`FormGroup`, `FormControl`, `FormArray`) é criado e gerenciado no componente, fornecendo acesso síncrono e imediato ao estado e valor dos inputs.
- **Escalabilidade e Testabilidade:** A separação clara entre a lógica do formulário e o template torna o código mais organizado, escalável e muito mais fácil de ser testado unitariamente.

### O Papel do `FormControl` para Radio Buttons

No coração dos Formulários Reativos está a classe `FormControl`. Cada input em seu formulário (seja um campo de texto, um checkbox ou um conjunto de radio buttons) é representado por uma instância de `FormControl`.

Para um grupo de radio buttons, acontece algo interessante: **todo o grupo de opções representa um único `FormControl`**. Isso ocorre porque o objetivo de um grupo de radio buttons é permitir a seleção de apenas *um* valor. Portanto, embora existam múltiplos elementos `<input type="radio">` no HTML, todos eles se vinculam e manipulam o valor de um único `FormControl` no seu modelo reativo. O valor deste `FormControl` será o valor (`value`) do radio button que estiver selecionado.

---

### **Sintaxe e Uso**

Para integrar um grupo de radio buttons em um formulário reativo, precisamos conectar o modelo de formulário definido no componente (TypeScript) com o template (HTML).

### Passo 1: Configurando o Módulo

Primeiramente, certifique-se de que o `ReactiveFormsModule` está importado no seu módulo Angular (geralmente `app.module.ts` ou um módulo de funcionalidade específico).

```tsx
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { ReactiveFormsModule } from '@angular/forms'; // Importação essencial

import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    ReactiveFormsModule // Adicione aos imports
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

### Passo 2: Definindo o Formulário no Componente (TypeScript)

No seu componente, você criará uma instância de `FormGroup` que conterá o `FormControl` para o grupo de radio buttons.

```tsx
// meu-formulario.component.ts
import { Component, OnInit } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';

@Component({
  selector: 'app-meu-formulario',
  templateUrl: './meu-formulario.component.html',
})
export class MeuFormularioComponent implements OnInit {

  // Declaração da propriedade que vai conter nosso formulário
  perfilForm: FormGroup;

  ngOnInit(): void {
    // Instanciação do FormGroup no ciclo de vida ngOnInit
    this.perfilForm = new FormGroup({
      // Criando um FormControl para o grupo de radio buttons chamado 'genero'
      // O primeiro argumento é o valor inicial. Pode ser null, '', ou um valor padrão.
      // O segundo argumento é um array de validadores síncronos.
      'genero': new FormControl(null, Validators.required)
    });
  }

  onSubmit(): void {
    // Acessando o valor do radio button selecionado
    console.log('Formulário submetido!');
    console.log('Valor do formulário:', this.perfilForm.value);
    console.log('Gênero selecionado:', this.perfilForm.get('genero').value);
  }
}

```

### Passo 3: Conectando o Template (HTML)

No template, usamos as diretivas `formGroup`, `formControlName` e o atributo `value` para fazer a ligação.

```html
<form [formGroup]="perfilForm" (ngSubmit)="onSubmit()">

  <h3>Selecione o Gênero:</h3>

  <div>
    <label>
      <input type="radio" formControlName="genero" name="genero" value="masculino">
      Masculino
    </label>
  </div>

  <div>
    <label>
      <input type="radio" formControlName="genero" name="genero" value="feminino">
      Feminino
    </label>
  </div>

  <div>
    <label>
      <input type="radio" formControlName="genero" name="genero" value="nao_informar">
      Prefiro não informar
    </label>
  </div>

  <div *ngIf="perfilForm.get('genero').invalid && perfilForm.get('genero').touched">
    Por favor, selecione uma opção.
  </div>

  <button type="submit" [disabled]="perfilForm.invalid">Enviar</button>
</form>

```

---

### **Métodos e Propriedades**

Ao trabalhar com o `FormControl` associado a um grupo de radio buttons, você tem acesso a um vasto conjunto de métodos e propriedades para ler e manipular seu estado. Vamos explorar os mais importantes, sem exceção.

### Propriedades do `FormControl`

| Propriedade | Tipo | Descrição Detalhada | Exemplo de Uso (no componente) |
| --- | --- | --- | --- |
| `value` | `any` | Retorna o valor atual do controle. Para radio buttons, será o valor do atributo `value` do input selecionado. | `const genero = this.perfilForm.get('genero').value;` |
| `status` | `string` ('VALID', 'INVALID', 'PENDING') | Retorna o estado de validação do controle. `PENDING` é usado para validações assíncronas. | `if (this.perfilForm.get('genero').status === 'INVALID') { ... }` |
| `valid` | `boolean` | Retorna `true` se o controle for válido (passou em todas as validações), `false` caso contrário. É um atalho para `status === 'VALID'`. | `<button [disabled]="!perfilForm.get('genero').valid">...` |
| `invalid` | `boolean` | Retorna `true` se o controle for inválido, `false` caso contrário. É um atalho para `status === 'INVALID'`. | `<div *ngIf="perfilForm.get('genero').invalid">Erro!</div>` |
| `pending` | `boolean` | Retorna `true` se o controle estiver com validações assíncronas em andamento, `false` caso contrário. Atalho para `status === 'PENDING'`. | `<div *ngIf="perfilForm.get('genero').pending">Validando...</div>` |
| `errors` | `ValidationErrors \| null` | Retorna um objeto contendo os erros de validação, ou `null` se não houver erros. A chave do objeto é o nome do erro (ex: `required`) e o valor são os detalhes do erro. | `this.perfilForm.get('genero').hasError('required')` |
| `pristine` | `boolean` | Retorna `true` se o valor do controle não foi alterado pelo usuário desde sua inicialização. | `// Útil para saber se o usuário interagiu` |
| `dirty` | `boolean` | O oposto de `pristine`. Retorna `true` se o valor do controle foi alterado. | `<div *ngIf="perfilForm.get('genero').dirty">Alterado</div>` |
| `touched` | `boolean` | Retorna `true` se o usuário tocou no controle (acionou o evento `blur`). Útil para exibir mensagens de erro apenas após o usuário sair do campo. | `*ngIf="perfilForm.get('genero').touched && ..."` |
| `untouched` | `boolean` | O oposto de `touched`. Retorna `true` se o usuário ainda não interagiu com o controle. | `// Estado inicial do controle` |
| `disabled` | `boolean` | Retorna `true` se o controle estiver desabilitado. | `if (this.perfilForm.get('genero').disabled) { ... }` |
| `enabled` | `boolean` | O oposto de `disabled`. Retorna `true` se o controle estiver habilitado para interação. | `// Estado padrão do controle` |
| `parent` | `FormGroup \| FormArray` | Fornece uma referência ao `FormGroup` ou `FormArray` pai que contém este controle. | `const form = this.perfilForm.get('genero').parent;` |
| `root` | `AbstractControl` | Fornece uma referência ao controle de nível mais alto na árvore de formulários. | `const rootForm = this.perfilForm.get('genero').root;` |
| `valueChanges` | `Observable<any>` | Um `Observable` que emite o novo valor do controle toda vez que ele muda. Extremamente poderoso para reagir a mudanças em tempo real. | `this.perfilForm.get('genero').valueChanges.subscribe(val => ...);` |
| `statusChanges` | `Observable<string>` | Um `Observable` que emite o novo status de validação (`VALID`, `INVALID`, etc.) toda vez que ele muda. | `this.perfilForm.get('genero').statusChanges.subscribe(st => ...);` |

### Métodos do `FormControl`

| Método | Parâmetros | Descrição Detalhada | Exemplo de Uso (no componente) |
| --- | --- | --- | --- |
| `setValue(value, options?)` | `value`: O novo valor.\<br/\>`options`: Objeto de configuração. | Define o valor do controle. Para radio buttons, você deve passar um valor que corresponda exatamente a um dos atributos `value` dos inputs. Se o valor não corresponder a nenhum radio, nenhum será selecionado. Gera um erro se usado em um `FormGroup` e você não fornecer valor para todos os controles filhos. | `this.perfilForm.get('genero').setValue('feminino');` |
| `patchValue(value, options?)` | `value`: O novo valor.\<br/\>`options`: Objeto de configuração. | Similar ao `setValue`, mas mais flexível. Em um `FormGroup`, permite atualizar apenas um subconjunto dos controles. Para um `FormControl` isolado, seu comportamento é idêntico ao `setValue`. | `this.perfilForm.get('genero').patchValue('masculino');` |
| `reset(value?, options?)` | `value`: Valor para resetar.\<br/\>`options`: Objeto de configuração. | Reseta o controle para seu valor inicial (ou para o valor fornecido) e redefine seu estado (`pristine`, `untouched`). | `this.perfilForm.get('genero').reset(); // Volta para null` |
| `markAsTouched()` | `(options?)` | Marca o controle (e seus pais) como `touched`. Útil para acionar a exibição de mensagens de erro programaticamente. | `this.perfilForm.get('genero').markAsTouched();` |
| `markAsUntouched()` | `(options?)` | Marca o controle como `untouched`. | `this.perfilForm.get('genero').markAsUntouched();` |
| `markAsDirty()` | `(options?)` | Marca o controle como `dirty`. | `this.perfilForm.get('genero').markAsDirty();` |
| `markAsPristine()` | `(options?)` | Marca o controle como `pristine`. | `this.perfilForm.get('genero').markAsPristine();` |
| `disable(options?)` | `(options?)` | Desabilita o controle, impedindo a interação do usuário. Por padrão, o valor de um controle desabilitado é excluído do objeto `value` do `FormGroup` pai. | `this.perfilForm.get('genero').disable();` |
| `enable(options?)` | `(options?)` | Habilita o controle, permitindo a interação. | `this.perfilForm.get('genero').enable();` |
| `setErrors(errors, opts?)` | `errors`: Objeto de erros.\<br/\>`opts`: Opções. | Define erros de validação manualmente no controle. | `this.perfilForm.get('genero').setErrors({ 'customError': true });` |
| `getError(errorCode)` | `errorCode`: string | Retorna o valor de um erro específico, se existir. | `const err = this.perfilForm.get('genero').getError('required');` |
| `hasError(errorCode)` | `errorCode`: string | Retorna `true` se o controle possui um erro de validação específico. | `*ngIf="perfilForm.get('genero').hasError('required')"` |

---

### **Restrições de Uso**

Embora os radio buttons sejam ideais para seleção única, existem cenários onde eles não são a melhor escolha:

1. **Seleção Múltipla:** Se o usuário precisa selecionar mais de uma opção de uma lista, os radio buttons são fundamentalmente inadequados. Nesse caso, **Checkboxes** (`<input type="checkbox">`), gerenciados individualmente por `FormControl`s ou coletivamente por um `FormArray`, são a solução correta.
2. **Grande Quantidade de Opções:** Para listas muito longas (mais de 5-7 opções), um grupo de radio buttons pode poluir a interface. Uma caixa de seleção (`<select>`) é geralmente uma alternativa mais limpa e compacta para esses casos.
3. **Nenhuma Seleção é uma Opção Válida (e o formulário não deve começar com um padrão):** Se não selecionar nada for uma opção válida e distinta, pode ser confuso para o usuário, pois uma vez que um radio button é selecionado, ele não pode ser "desselecionado" (apenas trocado por outro). Uma alternativa seria incluir explicitamente uma opção "Nenhum" ou usar um componente diferente.

---

### **Elementos Associados**

Para que os radio buttons funcionem em Formulários Reativos, várias peças do framework Angular trabalham juntas.

| Elemento | Tipo | Propósito e Uso | Sintaxe Específica |
| --- | --- | --- | --- |
| `ReactiveFormsModule` | `NgModule` | Módulo que fornece as diretivas e classes necessárias para trabalhar com Formulários Reativos. **Sua importação é obrigatória.** | `import { ReactiveFormsModule } from '@angular/forms';` |
| `FormGroup` | `Class` | Representa uma coleção de `FormControl`s. É o contêiner principal do nosso formulário, rastreando o valor e o estado de validação de seus controles filhos. | `new FormGroup({ nome: new FormControl('') });` |
| `FormControl` | `Class` | Representa um único controle de formulário. Para radio buttons, uma única instância representa todo o grupo. | `new FormControl(valorInicial, validadores);` |
| `[formGroup]` | `Directive` | Liga um elemento `<form>` no template a uma instância de `FormGroup` no componente. | `<form [formGroup]="meuForm">` |
| `formControlName` | `Directive` | Liga um elemento de input (`<input>`, `<select>`, etc.) a um `FormControl` específico dentro do `FormGroup` pai. **Esta é a cola que conecta o HTML ao TypeScript.** | `<input type="radio" formControlName="meuControle">` |
| `Validators` | `Class` | Fornece um conjunto de funções de validação estáticas e prontas para uso, como `required`, `minLength`, `maxLength`, `pattern`, etc. | `new FormControl('', [Validators.required, Validators.minLength(3)]);` |

---

### **Melhores Práticas e Casos de Uso**

- **Agrupamento Visual e Lógico:** Sempre agrupe os radio buttons relacionados dentro de um elemento como `<fieldset>` com uma legenda `<legend>`. Isso melhora a semântica do HTML e a acessibilidade para leitores de tela.
- **Valores Significativos:** Use valores (`value`) descritivos e significativos para os radio buttons. Evite usar `1`, `2`, `3` se você pode usar `'ativo'`, `'inativo'`, `'pendente'`. Isso torna o valor do formulário mais legível.
- **Definir um Valor Padrão:** É uma boa prática definir um valor inicial para o `FormControl` dos radio buttons. Isso garante que o formulário comece em um estado previsível, com uma opção já selecionada, evitando que o controle comece como `null` (a menos que isso seja intencional).
- **Uso de `valueChanges`:** Utilize o `Observable` `valueChanges` para criar formulários dinâmicos. Por exemplo, a seleção de um radio button pode mostrar ou ocultar outras partes do formulário.
    
    ```tsx
    ngOnInit() {
      // ... inicialização do form
      this.perfilForm.get('tipoUsuario').valueChanges.subscribe(tipo => {
        if (tipo === 'admin') {
          this.mostrarCamposAdmin = true;
        } else {
          this.mostrarCamposAdmin = false;
        }
      });
    }
    
    ```
    
- **Acessibilidade (`label`):** Sempre associe um `<label>` a cada `<input type="radio">`. A maneira mais robusta é aninhar o input dentro do label, pois isso aumenta a área de clique e é semanticamente correto.

---

### **Exemplo Completo: Formulário de Inscrição**

Vamos criar um formulário mais completo que utiliza radio buttons para selecionar um plano de assinatura, e a seleção do plano afeta a exibição de outros campos.

### Componente (TypeScript)

```tsx
// inscricao.component.ts
import { Component, OnInit } from '@angular/core';
import { FormGroup, FormBuilder, Validators } from '@angular/forms';

@Component({
  selector: 'app-inscricao',
  templateUrl: './inscricao.component.html',
})
export class InscricaoComponent implements OnInit {
  inscricaoForm: FormGroup;
  planos = [
    { id: 'basico', nome: 'Plano Básico', preco: 'R$ 19,90' },
    { id: 'premium', nome: 'Plano Premium', preco: 'R$ 49,90' },
    { id: 'familia', nome: 'Plano Família', preco: 'R$ 79,90' },
  ];

  // Usando FormBuilder para uma sintaxe mais limpa
  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.inscricaoForm = this.fb.group({
      nomeCompleto: ['', [Validators.required, Validators.minLength(3)]],
      email: ['', [Validators.required, Validators.email]],
      // FormControl para o plano, com valor inicial 'premium' e validador required
      planoEscolhido: ['premium', Validators.required],
      dependentes: [null] // Campo para o plano família
    });

    // Reagindo a mudanças no radio button
    this.planoControl.valueChanges.subscribe(planoId => {
      const dependentesControl = this.inscricaoForm.get('dependentes');
      if (planoId === 'familia') {
        dependentesControl.setValidators([Validators.required, Validators.min(1)]);
        dependentesControl.enable();
      } else {
        dependentesControl.clearValidators();
        dependentesControl.disable();
        dependentesControl.reset();
      }
      dependentesControl.updateValueAndValidity(); // Atualiza o estado de validação
    });

    // Dispara a lógica inicial para o valor padrão
    this.planoControl.updateValueAndValidity();
  }

  // Atalhos (getters) para facilitar o acesso aos controles no template
  get planoControl() {
    return this.inscricaoForm.get('planoEscolhido');
  }

  get dependentesControl() {
    return this.inscricaoForm.get('dependentes');
  }

  onSubmit(): void {
    if (this.inscricaoForm.valid) {
      console.log('Formulário Válido!', this.inscricaoForm.value);
      // O valor de controles desabilitados não é incluído por padrão.
      // Para obtê-lo, use getRawValue().
      console.log('Valor Bruto (com desabilitados):', this.inscricaoForm.getRawValue());
    } else {
      console.log('Formulário Inválido!');
      // Marca todos os campos como tocados para exibir os erros
      this.inscricaoForm.markAllAsTouched();
    }
  }
}

```

### Template (HTML)

```html
<form [formGroup]="inscricaoForm" (ngSubmit)="onSubmit()">

  <div>
    <label for="nome">Nome Completo:</label>
    <input id="nome" type="text" formControlName="nomeCompleto">
  </div>

  <div>
    <label for="email">Email:</label>
    <input id="email" type="email" formControlName="email">
  </div>

  <fieldset>
    <legend>Escolha seu Plano:</legend>
    <div *ngFor="let plano of planos">
      <label>
        <input type="radio" formControlName="planoEscolhido" name="plano" [value]="plano.id">
        {{ plano.nome }} ({{ plano.preco }})
      </label>
    </div>
    <div *ngIf="planoControl.invalid && planoControl.touched" style="color: red;">
      Por favor, selecione um plano.
    </div>
  </fieldset>

  <div *ngIf="planoControl.value === 'familia'">
    <label for="dependentes">Número de Dependentes:</label>
    <input id="dependentes" type="number" formControlName="dependentes">
    <div *ngIf="dependentesControl.invalid && dependentesControl.touched" style="color: red;">
      Informe o número de dependentes.
    </div>
  </div>

  <button type="submit" [disabled]="inscricaoForm.invalid">Inscrever-se</button>
</form>

```

---

### **Tópicos Relacionados para Aprofundamento**

1. **Validadores Customizados (Custom Validators):** Aprenda a criar suas próprias funções de validação para cenários mais complexos que não são cobertos pelos validadores padrão.
2. **Validadores Assíncronos (Async Validators):** Explore como criar validadores que dependem de operações assíncronas, como uma chamada HTTP para verificar se um nome de usuário já existe no banco de dados.
3. **FormArray:** Aprofunde-se no `FormArray` para gerenciar listas dinâmicas de controles, como adicionar múltiplos telefones ou endereços a um formulário.
4. **Agrupamento com `FormGroupName`:** Entenda como aninhar `FormGroup`s dentro de outros `FormGroup`s para criar estruturas de dados mais complexas e organizadas, utilizando a diretiva `formGroupName`.
5. **Componentes de Formulário Customizados (ControlValueAccessor):** Descubra como criar seus próprios componentes de formulário que se integram perfeitamente com os Formulários Reativos do Angular, implementando a interface `ControlValueAccessor`.

Espero que esta explicação super detalhada seja de grande ajuda nos seus projetos com Angular, Gedê\! Se tiver qualquer outra dúvida, pode perguntar.