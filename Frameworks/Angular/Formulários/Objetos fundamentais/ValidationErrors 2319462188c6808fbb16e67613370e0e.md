# ValidationErrors

Olá, Gedê\!

A.R.I.A. está pronta para te ajudar com uma explicação detalhada sobre `ValidationErrors` no Angular. Preparei um material bem completo para você, seguindo todas as suas instruções.

---

# Desvendando o `ValidationErrors` no Angular: Validação de Formulários a Fundo

## Sumário

Este guia detalhado explora o `ValidationErrors` no Angular, um tipo essencial para o tratamento de erros de validação em formulários. Abordaremos desde os conceitos fundamentais até exemplos práticos e melhores práticas, passando pela sintaxe, propriedades e métodos.

## Conceitos Fundamentais

No Angular, a validação de formulários é uma parte crucial do desenvolvimento de aplicações robustas. Quando um formulário ou um controle de formulário (como um `FormControl`) falha em passar por um ou mais validadores, o Angular armazena informações sobre essas falhas. O `ValidationErrors` é a estrutura de dados que guarda esses erros.

Em essência, o `ValidationErrors` é um objeto do tipo `{[key: string]: any}`, onde a **chave** é o nome do validador que falhou e o **valor** é o erro específico retornado por esse validador. Por exemplo, um validador `required` pode retornar `{ 'required': true }`, enquanto um validador `minlength` pode retornar `{ 'minlength': { 'requiredLength': 5, 'actualLength': 3 } }`.

O propósito principal do `ValidationErrors` é oferecer uma forma padronizada e acessível de inspecionar quais validações falharam em um controle de formulário. Ele é a espinha dorsal para a exibição de mensagens de erro dinâmicas e contextuais na interface do usuário.

## Propriedades, Sintaxe e Uso

Quando um `FormControl` falha na validação, ele tem uma propriedade chamada `errors` que contém o objeto `ValidationErrors`. A sintaxe para acessar é bem direta: `formControl.errors`.

Vamos explorar como acessar e utilizar essas informações com alguns validadores comuns.

```tsx
import { FormControl, Validators } from '@angular/forms';

// Criação de um FormControl com dois validadores
const emailControl = new FormControl('', [
  Validators.required,
  Validators.email
]);

// Se o campo estiver vazio e o usuário tentar interagir
emailControl.setValue('');
emailControl.markAsDirty(); // Marca o controle como "sujo" para que os erros sejam exibidos

// O objeto 'errors' do FormControl agora contém as falhas
console.log(emailControl.errors);

// O resultado no console seria:
// { 'required': true }

// Se o usuário digitar 'teste' (formato inválido)
emailControl.setValue('teste');

// O objeto 'errors' agora conterá o erro de email
console.log(emailControl.errors);

// O resultado no console seria:
// { 'email': true }

// Para verificar a existência de um erro específico, você pode usar a propriedade 'hasError'
// que é um método de conveniência que vamos ver mais a frente
console.log(emailControl.hasError('required')); // false
console.log(emailControl.hasError('email'));    // true

```

---

## Métodos (e Propriedades Úteis) Relacionadas

Embora o `ValidationErrors` em si não tenha métodos, o `AbstractControl` (classe base para `FormControl`, `FormGroup` e `FormArray`) oferece métodos e propriedades que facilitam a interação com os erros de validação.

### **1. `errors` (Propriedade)**

Como vimos, esta é a propriedade central que contém o objeto `ValidationErrors` quando a validação falha. Se o controle for válido, `errors` será `null`.

```tsx
// Exemplo: Checando se o controle tem erros
if (meuForm.controls['nome'].errors) {
  // O controle de 'nome' tem erros de validação
}

```

### **2. `hasError(errorCode: string, path?: string | (string | number)[]): boolean` (Método)**

Este é o método mais comum e prático para verificar se um erro específico existe. Ele retorna `true` se o erro com o `errorCode` especificado estiver presente no objeto `ValidationErrors`, e `false` caso contrário.

- `errorCode`: A chave do validador (ex: `'required'`, `'email'`, `'minlength'`).
- `path`: Opcional, usado para verificar erros em controles aninhados dentro de um `FormGroup` ou `FormArray`.

<!-- end list -->

```tsx
// Exemplo de uso
if (meuForm.controls['email'].hasError('required')) {
  // Mostrar mensagem "O campo email é obrigatório."
}

```

### **3. `getError(errorCode: string, path?: string | (string | number)[]): any` (Método)**

Este método é similar a `hasError`, mas em vez de retornar um booleano, ele retorna o valor do erro específico. Se o erro não existir, ele retorna `null`.

```tsx
// Exemplo com o validador 'minlength'
const nomeControl = new FormControl('', Validators.minlength(5));

nomeControl.setValue('João'); // 4 caracteres

if (nomeControl.hasError('minlength')) {
  const minlengthError = nomeControl.getError('minlength');
  console.log(`Tamanho mínimo requerido: ${minlengthError.requiredLength}`);
  console.log(`Tamanho atual: ${minlengthError.actualLength}`);
}

```

## Restrições de Uso e Casos Especiais

O `ValidationErrors` é a forma padrão de lidar com validações no Angular e não tem grandes "restrições de uso" no sentido de não dever ser usado. No entanto, é crucial entender que:

- **Não lide com erros de validação no `ValidationErrors` diretamente no template.** Embora seja possível, isso pode se tornar verboso e difícil de manter. A melhor prática é usar o método `hasError` nos templates ou criar *getters* na sua classe de componente para simplificar a lógica.
- **A propriedade `errors` é `null` quando o controle é válido.** Isso é uma fonte comum de erros `TypeError` se você tentar acessá-la sem uma verificação. Sempre verifique se `errors` não é `null` antes de tentar acessá-lo no template (ex: `ngIf="formControl.errors"`).

## Melhores Práticas e Casos de Uso

### **1. Exibição de Mensagens de Erro no Template**

Use `*ngIf` e `hasError` para exibir mensagens de erro condicionais.

```html
<form [formGroup]="loginForm">
  <div>
    <label>Email</label>
    <input type="email" formControlName="email">

    <div *ngIf="loginForm.controls['email'].invalid && loginForm.controls['email'].touched">
      <small class="text-danger" *ngIf="loginForm.controls['email'].hasError('required')">
        O email é obrigatório.
      </small>
      <small class="text-danger" *ngIf="loginForm.controls['email'].hasError('email')">
        Por favor, insira um email válido.
      </small>
    </div>
  </div>
</form>

```

### **2. Criação de `getters` no Componente**

Para simplificar o template, crie *getters* na sua classe de componente.

```tsx
// meu-componente.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';

@Component({ ... })
export class MeuComponente implements OnInit {
  loginForm: FormGroup;

  constructor(private fb: FormBuilder) { }

  ngOnInit() {
    this.loginForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]]
    });
  }

  get email() {
    return this.loginForm.get('email');
  }
}

// Em seu template, o código fica muito mais limpo:
<div *ngIf="email.invalid && email.touched">
  <small *ngIf="email.hasError('required')">O email é obrigatório.</small>
  <small *ngIf="email.hasError('email')">Email inválido.</small>
</div>

```

---

## Exemplo Completo

Vamos criar um componente de cadastro com um formulário reativo para demonstrar o uso do `ValidationErrors` em um cenário mais amplo.

### **`cadastro.component.ts`**

```tsx
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';

@Component({
  selector: 'app-cadastro',
  templateUrl: './cadastro.component.html',
  styleUrls: ['./cadastro.component.css']
})
export class CadastroComponent implements OnInit {
  cadastroForm: FormGroup;

  constructor(private fb: FormBuilder) { }

  ngOnInit() {
    this.cadastroForm = this.fb.group({
      nome: ['', [Validators.required, Validators.minLength(3)]],
      email: ['', [Validators.required, Validators.email]],
      idade: ['', [Validators.required, Validators.min(18), Validators.max(99)]],
      senha: ['', [Validators.required, Validators.minLength(6)]],
      confirmarSenha: ['', [Validators.required]]
    }, { validators: this.passwordMatchValidator });
  }

  // Getter para acesso facilitado no template
  get nomeControl(): AbstractControl {
    return this.cadastroForm.get('nome');
  }

  get emailControl(): AbstractControl {
    return this.cadastroForm.get('email');
  }

  get idadeControl(): AbstractControl {
    return this.cadastroForm.get('idade');
  }

  get senhaControl(): AbstractControl {
    return this.cadastroForm.get('senha');
  }

  get confirmarSenhaControl(): AbstractControl {
    return this.cadastroForm.get('confirmarSenha');
  }

  // Validador personalizado para checar se as senhas são iguais
  passwordMatchValidator(control: AbstractControl): ValidationErrors | null {
    const senha = control.get('senha');
    const confirmarSenha = control.get('confirmarSenha');

    return senha && confirmarSenha && senha.value !== confirmarSenha.value
      ? { 'mismatch': true }
      : null;
  }

  onSubmit() {
    if (this.cadastroForm.valid) {
      console.log('Formulário enviado com sucesso!', this.cadastroForm.value);
      // Aqui você faria a chamada para a sua API backend
    } else {
      console.log('Formulário inválido. Verifique os campos.');
      // O `ValidationErrors` está disponível em `this.cadastroForm.errors`
      // ou em cada controle individualmente.
      console.log('Erros do formulário:', this.cadastroForm.errors);
      console.log('Erros do nome:', this.nomeControl.errors);
    }
  }
}

```

### **`cadastro.component.html`**

```html
<form [formGroup]="cadastroForm" (ngSubmit)="onSubmit()">

  <div>
    <label>Nome:</label>
    <input type="text" formControlName="nome">

    <div *ngIf="nomeControl.invalid && nomeControl.touched">
      <small class="error-msg" *ngIf="nomeControl.hasError('required')">O nome é obrigatório.</small>
      <small class="error-msg" *ngIf="nomeControl.hasError('minlength')">
        O nome deve ter no mínimo {{ nomeControl.getError('minlength').requiredLength }} caracteres.
      </small>
    </div>
  </div>

  <div>
    <label>Email:</label>
    <input type="email" formControlName="email">
    <div *ngIf="emailControl.invalid && emailControl.touched">
      <small class="error-msg" *ngIf="emailControl.hasError('required')">O email é obrigatório.</small>
      <small class="error-msg" *ngIf="emailControl.hasError('email')">Email inválido.</small>
    </div>
  </div>

  <div>
    <label>Idade:</label>
    <input type="number" formControlName="idade">
    <div *ngIf="idadeControl.invalid && idadeControl.touched">
      <small class="error-msg" *ngIf="idadeControl.hasError('required')">A idade é obrigatória.</small>
      <small class="error-msg" *ngIf="idadeControl.hasError('min')">Você deve ter no mínimo 18 anos.</small>
      <small class="error-msg" *ngIf="idadeControl.hasError('max')">Você deve ter no máximo 99 anos.</small>
    </div>
  </div>

  <div>
    <label>Senha:</label>
    <input type="password" formControlName="senha">
    <div *ngIf="senhaControl.invalid && senhaControl.touched">
      <small class="error-msg" *ngIf="senhaControl.hasError('required')">A senha é obrigatória.</small>
      <small class="error-msg" *ngIf="senhaControl.hasError('minlength')">A senha deve ter no mínimo 6 caracteres.</small>
    </div>
  </div>

  <div>
    <label>Confirmar Senha:</label>
    <input type="password" formControlName="confirmarSenha">
    <div *ngIf="confirmarSenhaControl.invalid && confirmarSenhaControl.touched">
      <small class="error-msg" *ngIf="confirmarSenhaControl.hasError('required')">Confirmação de senha é obrigatória.</small>
    </div>
  </div>

  <div *ngIf="cadastroForm.errors?.['mismatch'] && cadastroForm.touched">
    <small class="error-msg">As senhas não coincidem.</small>
  </div>

  <button type="submit" [disabled]="cadastroForm.invalid">Cadastrar</button>

</form>

```

---

## Tópicos Relacionados para Aprofundamento

- **Validação Assíncrona no Angular:** Como usar validadores que dependem de chamadas de API (por exemplo, para verificar se um email já existe).
- **Validação Cruzada (Cross-field Validation):** Validação que depende de múltiplos campos de um formulário (como o nosso exemplo de `passwordMatchValidator`).
- **Validação de Formulários Reativos vs. Baseados em Template:** Aprofundar as diferenças e os prós e contras de cada abordagem.
- **Custom Validators (Validadores Personalizados):** Aprenda a criar seus próprios validadores para cenários específicos, como validação de CPF ou CNPJ.

Espero que esta explicação tenha sido útil, Gedê. Se tiver mais alguma dúvida ou precisar de algo, é só chamar\!