# NgModel

Olá, Gedê\! Aqui é a A.R.I.A. (Assistente Rápida para Idiotas Atarefados), pronta para te ajudar a dominar a diretiva `NgModel` do Angular.

Preparei uma explicação extremamente detalhada, como você pediu, para que não reste nenhuma dúvida sobre essa ferramenta fundamental para a criação de formulários com a abordagem *Template-Driven*.

---

### **Título: Guia Completo da Diretiva NgModel em Angular: Dominando Formulários Template-Driven**

### **Introdução**

A diretiva `NgModel` é uma das peças centrais do módulo de formulários do Angular, especificamente na abordagem conhecida como *Template-Driven Forms*. Ela atua como uma ponte, criando um vínculo bidirecional (two-way data binding) entre um elemento de formulário na sua view (HTML) e uma propriedade no seu componente (TypeScript). Isso significa que qualquer alteração no campo do formulário atualiza a propriedade no componente e, vice-versa, qualquer alteração na propriedade do componente reflete imediatamente no campo do formulário.

### **Sumário**

Este guia completo irá desmistificar a diretiva `NgModel`, abordando desde seus conceitos mais básicos até as melhores práticas de uso. Exploraremos:

- O que é o `NgModel` e seu papel no two-way data binding.
- A sintaxe fundamental e suas variações.
- Todas as propriedades e métodos associados para rastreamento de estado e validação.
- Quando utilizar (e quando não utilizar) essa abordagem.
- Os elementos essenciais do ecossistema de formulários que trabalham em conjunto com o `NgModel`.
- Um exemplo prático e completo para solidificar o conhecimento.

### **Conceitos Fundamentais**

O propósito principal do `NgModel` é simplificar a sincronização de dados entre a lógica do seu componente e a interface do usuário. Para que ele funcione, três conceitos são essenciais:

1. **FormsModule**: `NgModel` não é uma diretiva nativa do Angular Core. Ela pertence ao `FormsModule`. Portanto, o primeiro passo para usá-la é importar este módulo no seu `app.module.ts` (ou em qualquer outro módulo onde você precise de formulários).
    
    ```tsx
    // app.module.ts
    import { NgModule } from '@angular/core';
    import { BrowserModule } from '@angular/platform-browser';
    import { FormsModule } from '@angular/forms'; // <-- IMPORTAÇÃO ESSENCIAL
    
    import { AppComponent } from './app.component';
    
    @NgModule({
      declarations: [
        AppComponent
      ],
      imports: [
        BrowserModule,
        FormsModule // <-- ADICIONAR AOS IMPORTS
      ],
      providers: [],
      bootstrap: [AppComponent]
    })
    export class AppModule { }
    
    ```
    
2. **Two-Way Data Binding**: A famosa sintaxe `[(ngModel)]` é na verdade um "açúcar sintático" para duas ligações de dados separadas:
    - **Property Binding `[ngModel]`**: Envia dados do componente para a view. (Componente -\> Template)
    - **Event Binding `(ngModelChange)`**: Envia dados da view (quando o usuário digita algo) para o componente. (Template -\> Componente)
    
    Juntas, `[ngModel]` e `(ngModelChange)` criam a ligação de dados bidirecional.
    
3. **Rastreamento de Estado**: Além de sincronizar valores, `NgModel` rastreia o estado do controle do formulário. Ele nos informa se o campo foi tocado (`touched`), se seu valor foi alterado (`dirty`), se é válido (`valid`) de acordo com as regras de validação, e quais erros de validação possui (`errors`).

### **Sintaxe e Uso**

A forma mais comum de usar o `NgModel` é através da sintaxe de "banana in a box" `[()]`.

### Sintaxe Básica (Two-Way Binding)

```html
<label for="nome">Nome:</label>
<input
    type="text"
    id="nome"
    name="nome"
    [(ngModel)]="propriedadeDoComponente"
>

<p>Valor atual: {{ propriedadeDoComponente }}</p>

```

```tsx
// no-seu-componente.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent {
  propriedadeDoComponente: string = 'Valor Inicial';
}

```

**Observação Importante**: Para que o `NgModel` funcione corretamente dentro de um `<form>`, cada elemento com `[(ngModel)]` **deve** possuir o atributo `name`. O Angular usa esse atributo para registrar o controle no formulário.

### Sintaxe Detalhada (One-Way Binding)

Para entender o que acontece por baixo dos panos, podemos reescrever o exemplo acima sem o açúcar sintático:

```html
<input
    type="text"
    name="nome"
    [ngModel]="propriedadeDoComponente"

    (ngModelChange)="propriedadeDoComponente = $event"
>

```

O `$event` aqui contém o novo valor do input.

### **Métodos e Propriedades**

Para acessar o rico conjunto de propriedades de estado e validação do `NgModel`, utilizamos uma **variável de referência de template**.

**Como criar uma variável de referência:**`#nomeInput="ngModel"`

Agora, `nomeInput` nos dá acesso a todas as propriedades do controle.

| Propriedade | Tipo | Descrição | Exemplo de Uso no Template |
| --- | --- | --- | --- |
| `valid` | `boolean` | `true` se o controle passar em todas as validações. `false` caso contrário. | `<div *ngIf="nomeInput.valid">Campo válido!</div>` |
| `invalid` | `boolean` | O oposto de `valid`. `true` se o controle falhar em alguma validação. | `[class.is-invalid]="nomeInput.invalid"` |
| `pending` | `boolean` | `true` se houver validações assíncronas em andamento. | `<div *ngIf="nomeInput.pending">Validando...</div>` |
| `disabled` | `boolean` | `true` se o controle estiver desabilitado (ex: `[disabled]="true"`). | `[disabled]="!form.valid"` |
| `enabled` | `boolean` | O oposto de `disabled`. | `[class.active]="nomeInput.enabled"` |
| `pristine` | `boolean` | `true` se o usuário ainda não alterou o valor do campo. | `[class.untouched-field]="nomeInput.pristine"` |
| `dirty` | `boolean` | O oposto de `pristine`. `true` se o valor do campo foi alterado pelo usuário. | `<div *ngIf="nomeInput.dirty">Campo foi modificado.</div>` |
| `touched` | `boolean` | `true` se o usuário "tocou" no campo (entrou e saiu, via `blur` event). | `[class.is-invalid]="nomeInput.invalid && nomeInput.touched"` |
| `untouched` | `boolean` | O oposto de `touched`. `true` se o campo ainda não recebeu e perdeu o foco. | `<div *ngIf="nomeInput.untouched">Por favor, preencha.</div>` |
| `errors` | `object` | Um objeto contendo os erros de validação. `null` se não houver erros. As chaves são os nomes das regras. | `<div *ngIf="nomeInput.errors?.['required']">Campo obrigatório.</div>` |
| `value` | `any` | O valor atual do controle. | `<span>Valor: {{ nomeInput.value }}</span>` |
| `status` | `string` | O status de validação como uma string: 'VALID', 'INVALID', 'PENDING' ou 'DISABLED'. | `<div [ngSwitch]="nomeInput.status"> ... </div>` |
| `control` | `AbstractControl` | A instância da classe de controle de formulário (`FormControl`) que o Angular cria internamente. | Usado principalmente para acesso programático no componente. |

### **Restrições de Uso**

A abordagem *Template-Driven* com `NgModel` é excelente para formulários simples, como login, cadastro ou formulários de contato. No entanto, existem cenários onde ela se torna menos ideal:

- **Formulários Complexos e Dinâmicos**: Se você precisa adicionar ou remover campos de formulário dinamicamente com base na interação do usuário, a abordagem **Reactive Forms** é muito mais poderosa e flexível.
- **Validações Customizadas Complexas**: Embora seja possível criar validadores customizados para *Template-Driven Forms*, o processo é mais verboso do que em *Reactive Forms*, onde a lógica de validação reside no componente, facilitando testes e reutilização.
- **Testes Unitários da Lógica do Formulário**: Como a maior parte da configuração do formulário (validações, estrutura) está no template (HTML), testar essa lógica de forma unitária se torna mais difícil. *Reactive Forms* definem toda a estrutura no código TypeScript, o que os torna muito mais fáceis de testar.
- **Grande Volume de Dados e Performance**: Para formulários muito grandes e complexos, a abordagem reativa pode oferecer um controle mais granular e, potencialmente, melhor performance.

Em resumo: para formulários simples e rápidos, `NgModel` é perfeito. Para cenários complexos, dinâmicos e que exigem testes rigorosos, considere usar **Reactive Forms**.

### **Elementos Associados**

`NgModel` não trabalha sozinho. Ele faz parte de um ecossistema de diretivas:

1. **`ngForm`**:
    - **Propósito**: Cria uma instância de `FormGroup` para agrupar os controles de um formulário.
    - **Uso**: Angular aplica automaticamente a diretiva `ngForm` a qualquer tag `<form>` que não tenha um `formGroup` definido. Ela encapsula todos os `NgModel` internos, permitindo verificar o estado do formulário como um todo (ex: `meuForm.valid`).
    - **Sintaxe**: `<form #meuForm="ngForm"> ... </form>`
2. **`ngSubmit`**:
    - **Propósito**: Permite que você execute uma função do seu componente quando o formulário é enviado, prevenindo o comportamento padrão do navegador de recarregar a página.
    - **Uso**: Deve ser usada na tag `<form>`.
    - **Sintaxe**: `<form (ngSubmit)="onSubmitFunction()"> ... </form>`
3. **Diretivas de Validação**:
    - **Propósito**: São atributos que você pode adicionar aos seus elementos de formulário para aplicar regras de validação.
    - **Exemplos**: `required`, `minlength="X"`, `maxlength="Y"`, `pattern="regex"`, `email`.
    - **Sintaxe**: `<input type="text" [(ngModel)]="nome" name="nome" required minlength="3">`
4. **`ngModelGroup`**:
    - **Propósito**: Agrupa logicamente um subconjunto de controles dentro de um formulário maior, criando um `FormGroup` aninhado.
    - **Uso**: Útil para organizar dados complexos, como um objeto de endereço dentro de um formulário de usuário.
    - **Sintaxe**:
        
        ```html
        <div ngModelGroup="endereco" #enderecoGroup="ngModelGroup">
            <input type="text" [(ngModel)]="meuObjeto.rua" name="rua">
            <input type="text" [(ngModel)]="meuObjeto.cidade" name="cidade">
        </div>
        <p>Status do grupo Endereço: {{ enderecoGroup.valid ? 'Válido' : 'Inválido' }}</p>
        
        ```
        

### **Melhores Práticas e Casos de Uso**

- **Feedback Visual Imediato**: Use as propriedades de estado (`touched`, `dirty`, `invalid`) para aplicar classes CSS que informem ao usuário o que está acontecendo. Por exemplo, mostre uma mensagem de erro apenas se o campo for inválido E já tiver sido tocado (`invalid && touched`).
- **Desabilitar o Botão de Envio**: Sempre desabilite o botão de `submit` enquanto o formulário for inválido para prevenir envios incorretos. Ex: `<button type="submit" [disabled]="!meuForm.valid">Enviar</button>`.
- **Organize com `ngModelGroup`**: Para formulários que representam objetos aninhados, use `ngModelGroup` para manter a estrutura do seu modelo de dados e do seu template limpa e organizada.
- **Inicialize os Dados**: Sempre inicialize as propriedades que serão vinculadas com o `NgModel` no seu componente para evitar que os campos comecem com o valor `undefined`.

### **Exemplo Completo: Formulário de Cadastro**

Vamos aplicar tudo o que aprendemos em um formulário de cadastro simples para você e a Ju.

**1. `user.model.ts` (Interface do nosso modelo)**

```tsx
export interface User {
  nomeCompleto: string;
  email: string;
  frameworkFavorito: string;
}

```

**2. `app.component.ts` (Lógica do Componente)**

```tsx
import { Component } from '@angular/core';
import { User } from './user.model';
import { NgForm } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  // Inicializando o modelo do usuário para o formulário
  user: User = {
    nomeCompleto: '',
    email: '',
    frameworkFavorito: '' // Valor inicial para o select
  };

  // Função chamada na submissão do formulário
  onSubmit(form: NgForm) {
    if (form.invalid) {
      console.log('Formulário inválido!');
      return;
    }

    console.log('Formulário enviado com sucesso!');
    console.log('Dados do usuário:', this.user);

    // Aqui você enviaria os dados para um backend, por exemplo.
  }
}

```

**3. `app.component.html` (O Template do Formulário)**

```html
<div class="container">
  <h1>Formulário de Cadastro</h1>

  <form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)" novalidate>

    <div class="form-group">
      <label for="nomeCompleto">Nome Completo</label>
      <input
        type="text"
        id="nomeCompleto"
        name="nomeCompleto"
        class="form-control"
        [(ngModel)]="user.nomeCompleto"
        required
        minlength="5"
        #nomeInput="ngModel"
        [class.is-invalid]="nomeInput.invalid && nomeInput.touched"
      >
      <div *ngIf="nomeInput.invalid && nomeInput.touched" class="invalid-feedback">
        <div *ngIf="nomeInput.errors?.['required']">Nome é obrigatório.</div>
        <div *ngIf="nomeInput.errors?.['minlength']">O nome deve ter no mínimo 5 caracteres.</div>
      </div>
    </div>

    <div class="form-group">
      <label for="email">Email</label>
      <input
        type="email"
        id="email"
        name="email"
        class="form-control"
        [(ngModel)]="user.email"
        required
        email
        #emailInput="ngModel"
        [class.is-invalid]="emailInput.invalid && emailInput.touched"
      >
       <div *ngIf="emailInput.invalid && emailInput.touched" class="invalid-feedback">
        <div *ngIf="emailInput.errors?.['required']">Email é obrigatório.</div>
        <div *ngIf="emailInput.errors?.['email']">Por favor, insira um email válido.</div>
      </div>
    </div>

    <div class="form-group">
      <label for="framework">Framework Favorito</label>
      <select
        id="framework"
        name="framework"
        class="form-control"
        [(ngModel)]="user.frameworkFavorito"
        required
        #frameworkInput="ngModel"
        [class.is-invalid]="frameworkInput.invalid && frameworkInput.touched"
      >
        <option value="" disabled>Selecione uma opção</option>
        <option value="Angular">Angular</option>
        <option value="React">React</option>
        <option value="Vue">Vue</option>
      </select>
      <div *ngIf="frameworkInput.invalid && frameworkInput.touched" class="invalid-feedback">
        Selecione um framework.
      </div>
    </div>

    <button type="submit" class="btn-submit" [disabled]="userForm.invalid">Cadastrar</button>

  </form>

  <hr>
  <h3>Estado do Formulário (Debug)</h3>
  <pre>
    Form Válido: {{ userForm.valid }}
    Valores do Formulário: {{ userForm.value | json }}
    Valores do Modelo: {{ user | json }}
  </pre>
</div>

```

**4. `app.component.css` (Estilos para feedback visual)**

```css
.form-group { margin-bottom: 15px; }
.form-control.is-invalid { border-color: red; }
.invalid-feedback { color: red; font-size: 0.8em; margin-top: 5px; }
.btn-submit:disabled { background-color: #ccc; cursor: not-allowed; }

```

---

### **Tópicos Relacionados para Aprofundamento**

1. **Reactive Forms**: O próximo passo natural. Estude sobre `FormControl`, `FormGroup`, `FormArray` e `FormBuilder`. Eles oferecem um controle mais granular e são a abordagem preferida para formulários complexos.
2. **Validadores Customizados**: Aprenda a criar suas próprias diretivas de validação para regras de negócio específicas que não são cobertas pelos validadores padrão.
3. **ControlValueAccessor**: Um tópico avançado que permite que seus próprios componentes customizados se integrem perfeitamente com os formulários do Angular, funcionando com `ngModel` e `formControlName`.

Espero que esta explicação detalhada tenha sido extremamente útil, Gedê\! Se tiver mais alguma dúvida, pode perguntar.