# Validator

Peço desculpas pelo meu erro, Gedê. Você está absolutamente correto. A explicação anterior focou na função `ValidatorFn`, que é a forma mais comum de se criar validadores personalizados, mas não na implementação direta da **interface `Validator`**.

Vamos refazer a explicação, agora focando especificamente na implementação da classe que usa a interface `Validator`.

---

## O Uso da Interface `Validator` do Angular para Validação de Formulários

### Sumário

Esta explicação detalhada se aprofundará na interface `Validator` do Angular, mostrando como implementá-la em uma classe para criar validadores personalizados. Cobriremos a estrutura, os métodos, o uso e as melhores práticas, distinguindo-a da abordagem `ValidatorFn`.

---

### Conceitos Fundamentais

A interface `Validator` é um contrato que exige que uma classe implemente um único método: `validate`. Essa abordagem, embora menos comum que o uso de `ValidatorFn`, é particularmente útil quando o validador precisa de **estado** ou de **serviços injetáveis**.

Ao encapsular a lógica de validação em uma classe, você pode:

- Injetar dependências (como um serviço HTTP para validação assíncrona).
- Manter o estado interno (como configurações ou parâmetros de validação).
- Criar validadores mais complexos e com maior organização de código.

A interface `Validator` é o alicerce por trás dos validadores embutidos que você usa no Angular. Por exemplo, a classe `RequiredValidator` implementa essa interface para fornecer a funcionalidade de campo obrigatório.

### Sintaxe e Uso

A sintaxe para implementar a interface `Validator` é a de uma classe comum que usa a palavra-chave `implements`.

Vamos criar um validador para verificar se o valor de um campo de texto é maior que um determinado número, configurável através do construtor da classe.

### 1\. Implementando a Interface `Validator`

```tsx
import { Validator, AbstractControl, ValidationErrors } from '@angular/forms';

/**
 * Validador que verifica se um valor numérico é maior que um limite específico.
 */
export class MinValueValidator implements Validator {
  constructor(private min: number) {}

  /**
   * Método principal da interface Validator.
   * Recebe o AbstractControl e retorna os erros ou null.
   */
  validate(control: AbstractControl): ValidationErrors | null {
    // Pega o valor do controle
    const value = control.value;

    // Se o valor for nulo, a validação é bem-sucedida (a regra de required deve ser separada)
    if (value === null || value === '') {
      return null;
    }

    // Verifica a condição de validação
    const isInvalid = value < this.min;

    // Retorna o objeto de erro se a validação falhar, ou null se for bem-sucedida
    return isInvalid ? { 'minValue': { min: this.min, actual: value } } : null;
  }
}

```

Neste exemplo, o validador tem um **estado** (`this.min`) que é definido no construtor. Isso mostra uma das principais vantagens de usar a interface.

### 2\. Usando o Validador no `FormControl`

Para usar uma classe validadora, você precisa criar uma instância dela e passá-la para o `FormControl`.

```tsx
import { FormControl, Validators } from '@angular/forms';
import { MinValueValidator } from './min-value.validator';

// ...

// Cria um FormControl e instancia o validador diretamente
const myControl = new FormControl(
  10, // valor inicial
  [
    Validators.required, // Validador embutido
    new MinValueValidator(15) // Instância da classe validadora
  ]
);

// myControl.valid será false, pois 10 é menor que 15
console.log(myControl.valid);

```

Perceba que você precisa usar a palavra-chave `new` para criar uma nova instância da classe validadora.

### Propriedades e Métodos

A interface `Validator` possui apenas um método obrigatório:

| Método | Conceito |
| --- | --- |
| `validate(control: AbstractControl): ValidationErrors \| null` | Este é o único método que você precisa implementar. Ele contém a lógica de validação. O `control` é a referência para o `FormControl`, `FormGroup` ou `FormArray` que está sendo validado. O método deve retornar um objeto de erro (`ValidationErrors`) em caso de falha ou `null` em caso de sucesso. |

A interface `Validator` não possui propriedades próprias, mas a classe que a implementa pode ter quantas propriedades e métodos auxiliares forem necessários para sua lógica, como a propriedade `min` no exemplo acima.

Como na explicação anterior, dentro do método `validate`, você terá acesso a todas as propriedades e métodos do `AbstractControl` (`value`, `pristine`, `parent`, `setErrors()`, etc.) para criar a lógica de validação.

### Restrições de Uso

A implementação da interface `Validator` tem suas peculiaridades:

- **Validações simples e sem estado:** Para validações que não precisam de estado ou dependências, o uso de `ValidatorFn` é mais direto e preferível, pois evita a criação de uma classe inteira. A `ValidatorFn` é apenas uma função e é mais leve.
- **Custo de desenvolvimento:** Implementar uma classe pode ser mais verboso do que criar uma função simples. Use essa abordagem quando a complexidade justificar.

### Melhores Práticas e Casos de Uso

### Melhores Práticas:

1. **Use `implements Validator`:** Embora não seja estritamente necessário para o compilador (já que ele se baseia no duck typing), declarar que sua classe `implements Validator` melhora a clareza do código e a segurança de tipos.
2. **Separação de Preocupações:** Mantenha a lógica de validação dentro do método `validate`. Se precisar de lógica auxiliar, crie outros métodos privados na classe.
3. **Use `DI` para Dependências:** Se seu validador precisar de um serviço (como um `HttpClient`), use a Injeção de Dependências do Angular no construtor.

### Casos de Uso Comuns:

- **Validação Assíncrona (com serviços):** Quando você precisa de um validador assíncrono que use um serviço para, por exemplo, verificar a disponibilidade de um nome de usuário em um banco de dados. Nesse caso, a classe implementaria a interface `AsyncValidator`.
- **Validadores Complexos e Reutilizáveis:** Quando a lógica de validação é complexa e precisa de parâmetros de configuração ou de estado interno que justifiquem a criação de uma classe.

### Exemplo Completo: Validador com Injeção de Dependência (Assíncrono)

Um dos melhores exemplos para a interface `Validator` é um validador assíncrono que injeta um serviço. Para isso, usamos a interface `AsyncValidator`.

### 1\. Criando o Serviço de Validação

```tsx
// user.service.ts
import { Injectable } from '@angular/core';
import { of } from 'rxjs';
import { delay } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  // Simula uma requisição de verificação de nome de usuário
  checkUsername(username: string) {
    const isTaken = ['gedê', 'ju'].includes(username.toLowerCase());
    return of(isTaken).pipe(delay(500)); // Simula um delay de 500ms
  }
}

```

### 2\. Implementando a Interface `AsyncValidator`

```tsx
// unique-username.validator.ts
import { Injectable } from '@angular/core';
import { AsyncValidator, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { UserService } from './user.service';

// O decorator @Injectable é necessário para injetar o serviço no construtor
@Injectable({ providedIn: 'root' })
export class UniqueUsernameValidator implements AsyncValidator {
  constructor(private userService: UserService) {}

  validate(control: AbstractControl): Observable<ValidationErrors | null> {
    // Se o campo estiver vazio, retorna null imediatamente
    if (!control.value) {
      return of(null);
    }

    // Chama o serviço para verificar o nome de usuário
    return this.userService.checkUsername(control.value).pipe(
      map(isTaken => (isTaken ? { uniqueUsername: true } : null)),
      catchError(() => of(null)) // Em caso de erro na requisição, não bloqueia o formulário
    );
  }
}

```

### 3\. Usando o Validador no `FormControl`

No seu componente, você injeta o validador e o passa para o `FormControl`.

```tsx
// my-component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { UniqueUsernameValidator } from './unique-username.validator';

@Component({
  selector: 'app-my-component',
  templateUrl: './my-component.html'
})
export class MyComponent implements OnInit {
  myForm: FormGroup;

  constructor(
    private fb: FormBuilder,
    private uniqueUsernameValidator: UniqueUsernameValidator // Injeta o validador
  ) {}

  ngOnInit(): void {
    this.myForm = this.fb.group({
      username: [
        '',
        [Validators.required], // Validação síncrona
        [this.uniqueUsernameValidator.validate] // Validação assíncrona
      ]
    });
  }

  onSubmit(): void {
    if (this.myForm.valid) {
      console.log('Formulário válido!');
    } else {
      console.log('Formulário inválido!');
    }
  }
}

```

### Tópicos Relacionados para Aprofundamento

- **`AsyncValidator` e `AsyncValidatorFn`:** Entenda as diferenças entre as interfaces assíncronas e suas contrapartes de função.
- **Injeção de Dependências em Validadores:** Aprofunde-se no mecanismo de Injeção de Dependências (DI) do Angular para criar validadores mais poderosos.
- **Estratégias de Validação:** Aprenda sobre as diferentes formas de disparar a validação (`on blur`, `on submit`, `on change`) e como elas interagem com a lógica de validação.

Espero que esta nova explicação tenha abordado exatamente o que você precisava, Gedê. Agradeço por me corrigir e por me dar a oportunidade de aprofundar o tópico. Se tiver mais perguntas, pode contar comigo\!