# ValidatorFn

Olá, Gedê\!

A.R.I.A. está pronta para te ajudar com uma explicação detalhada sobre `ValidatorFn` no Angular. Pela sua experiência como desenvolvedor, sei que uma abordagem técnica e completa será útil. Vamos mergulhar no tema para que você possa dominar essa funcionalidade e aplicá-la nos seus projetos de Backend e, quem sabe, em algum projeto de frontend com Angular.

---

## **Dominando a Validação de Formulários no Angular: O Poder de `ValidatorFn`**

### Sumário

Este guia aprofundado explora o `ValidatorFn`, uma função essencial no ecossistema de formulários reativos do Angular. Abordaremos seus conceitos fundamentais, sintaxe, propriedades e métodos, além de discutir melhores práticas e cenários de uso. Através de exemplos de código comentados, você entenderá como criar validadores personalizados e robustos para garantir a integridade dos dados em suas aplicações.

---

### **Conceitos Fundamentais**

No Angular, a validação de formulários é um pilar fundamental para garantir que os dados inseridos pelo usuário sejam consistentes e corretos. Quando se trata de **formulários reativos** (`ReactiveForms`), o Angular oferece uma abordagem poderosa e flexível para lidar com isso. O coração dessa abordagem são os validadores, e o `ValidatorFn` é a interface que define um validador personalizado.

`ValidatorFn` é uma função simples, porém crucial, que recebe um controle de formulário (`AbstractControl`) como argumento e retorna um objeto de erro de validação (`ValidationErrors`) ou `null` se o controle for válido. Esse objeto de erro é um mapa (`key-value`) onde a chave é o nome do erro (por exemplo, `required`, `minlength`, `invalidPassword`) e o valor é um booleano ou um objeto com dados adicionais.

O principal propósito do `ValidatorFn` é encapsular a lógica de validação de forma reutilizável. Em vez de duplicar código de validação em vários lugares, você pode criar uma única função que pode ser aplicada a qualquer `FormControl`, `FormGroup` ou `FormArray`.

---

### **Sintaxe e Uso**

A sintaxe de um `ValidatorFn` é bastante direta. A função deve seguir a seguinte assinatura:

```tsx
(control: AbstractControl): ValidationErrors | null

```

- **`control: AbstractControl`**: O parâmetro `control` é a parte mais importante. Ele representa a instância do controle de formulário que está sendo validado. Através dele, você pode acessar propriedades como `value`, `dirty`, `touched` e até mesmo outros controles dentro de um `FormGroup`.
- **`ValidationErrors | null`**: O tipo de retorno. Se a validação falhar, você deve retornar um objeto de erro. Se for bem-sucedida, retorne `null`.

### **Exemplo Prático: Validador de E-mail Personalizado**

Vamos criar um validador simples para verificar se um campo de e-mail é válido.

```tsx
// validators/email.validator.ts

import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

/**
 * ValidatorFn personalizado para verificar se o valor é um email válido.
 * Retorna um objeto de erro '{ invalidEmail: true }' se for inválido, caso contrário, null.
 */
export const emailValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$/;
  const value = control.value;

  // Se o campo estiver vazio, não validamos (deve ser tratado pelo validador 'required')
  if (!value) {
    return null;
  }

  // Testa o valor contra a regex.
  const isValid = emailRegex.test(value);

  // Retorna o objeto de erro ou null.
  return isValid ? null : { invalidEmail: true };
};

```

Para usar este validador em um `FormControl`:

```tsx
// app.component.ts

import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { emailValidator } from './validators/email.validator';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent implements OnInit {
  userForm!: FormGroup;

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.userForm = this.fb.group({
      email: ['', [Validators.required, emailValidator]],
    });
  }
}

```

No exemplo acima, passamos nosso `emailValidator` para o `FormControl` `email` junto com o validador `Validators.required` padrão do Angular. Isso demonstra como `ValidatorFn` se integra perfeitamente com a API de validação existente.

---

### **Propriedades e Métodos de `AbstractControl` em `ValidatorFn`**

O `ValidatorFn` recebe o `AbstractControl` como argumento. É através deste objeto que você acessa todas as informações do controle do formulário. Conhecer suas propriedades e métodos é crucial para criar validadores inteligentes.

### **Propriedades de `AbstractControl`**

| Propriedade | Tipo | Descrição |
| --- | --- | --- |
| **`value`** | `any` | O valor atual do controle. É a propriedade mais utilizada para realizar a validação. |
| **`status`** | `FormControlStatus` | O estado de validade atual do controle. Pode ser `'VALID'`, `'INVALID'`, `'PENDING'` ou `'DISABLED'`. |
| **`errors`** | `ValidationErrors | null` |
| **`validator`** | `ValidatorFn | null` |
| **`asyncValidator`** | `AsyncValidatorFn | null` |
| **`dirty`** | `boolean` | `true` se o valor do controle foi alterado pelo usuário. Caso contrário, `false`. |
| **`pristine`** | `boolean` | O oposto de `dirty`. `true` se o valor não foi alterado. |
| **`touched`** | `boolean` | `true` se o usuário interagiu com o controle (por exemplo, focou e desfocou o campo). |
| **`untouched`** | `boolean` | O oposto de `touched`. `true` se o usuário não interagiu com o controle. |
| **`valid`** | `boolean` | `true` se o controle é válido (ou seja, `status` é `'VALID'`). |
| **`invalid`** | `boolean` | `true` se o controle é inválido (ou seja, `status` é `'INVALID'`). |
| **`pending`** | `boolean` | `true` se o controle está passando por uma validação assíncrona. |
| **`parent`** | `FormGroup | FormArray` |

### **Métodos de `AbstractControl`**

| Método | Retorno | Descrição |
| --- | --- | --- |
| **`get(path: Array<string | number> | string): AbstractControl |

### **Exemplo de Validação Cruzada (Cross-field validation)**

Este é um dos cenários mais poderosos para o `ValidatorFn`. Vamos criar um validador para um `FormGroup` que verifica se a senha e a confirmação de senha são iguais.

```tsx
// validators/password-match.validator.ts

import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

/**
 * Validador de FormGroup que verifica se os campos 'password' e 'confirmPassword' são iguais.
 */
export const passwordMatchValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {
  const password = control.get('password');
  const confirmPassword = control.get('confirmPassword');

  // Se os controles não existirem ou estiverem vazios, não validamos.
  if (!password || !confirmPassword || !password.value || !confirmPassword.value) {
    return null;
  }

  // Compara os valores.
  return password.value === confirmPassword.value ? null : { passwordsMismatch: true };
};

```

Aplicação no `FormGroup`:

```tsx
// app.component.ts

this.userForm = this.fb.group({
  password: ['', [Validators.required]],
  confirmPassword: ['', [Validators.required]]
}, { validators: passwordMatchValidator }); // O validador é aplicado ao FormGroup, não aos controles individuais.

```

Note que o `passwordMatchValidator` foi aplicado no segundo argumento do `FormGroup` (`{ validators: ... }`), pois ele opera sobre o grupo de controles, não sobre um controle individual.

---

### **Restrições de Uso**

Embora o `ValidatorFn` seja extremamente versátil, existem cenários onde sua aplicação direta pode não ser a melhor escolha:

1. **Validações Assíncronas**: Se a sua validação depende de uma chamada de API, um temporizador ou qualquer outra operação assíncrona, você deve usar o `AsyncValidatorFn` em vez de `ValidatorFn`. A função assíncrona retorna uma `Promise` ou um `Observable` de `ValidationErrors | null`.
2. **Validações Simples e Padrão**: Para validações como `required`, `minLength`, `maxLength`, `pattern` etc., o Angular já fornece validadores nativos (`Validators`) que são otimizados e mais eficientes. Não reinvente a roda. Use o `ValidatorFn` apenas para lógica de validação personalizada.
3. **Lógica Complexa de UI**: O `ValidatorFn` deve focar estritamente na validação dos dados. Se a sua lógica envolve a manipulação da interface do usuário (ex: mostrar/esconder campos, mudar o estilo de um componente), essa lógica deve ser implementada no componente, reagindo ao `status` do `FormControl`, e não dentro da função do validador.

---

### **Melhores Práticas e Casos de Uso**

- **Validações Parametrizadas**: A maioria dos validadores personalizados pode ser reutilizada com diferentes parâmetros. Para isso, crie uma **fábrica de validadores** (validator factory), que é uma função que retorna um `ValidatorFn`.

<!-- end list -->

```tsx
// validators/range.validator.ts

import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

/**
 * Fábrica de validadores para verificar se um número está dentro de um intervalo.
 */
export function rangeValidator(min: number, max: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const value = control.value;

    if (value === null || value === undefined || isNaN(value)) {
      return null; // O validador 'required' deve tratar isso
    }

    const isOutOfRange = value < min || value > max;

    return isOutOfRange ? { range: { min, max, actual: value } } : null;
  };
}

```

Uso:

```tsx
this.productForm = this.fb.group({
  price: ['', [Validators.required, rangeValidator(0, 100)]]
});

```

- **Reusabilidade**: Centralize todos os seus validadores personalizados em um único diretório (`/validators` ou `/shared/validators`) para fácil acesso e manutenção.
- **Mensagens de Erro Detalhadas**: Retorne objetos de erro com dados úteis (`{ min, max, actual }`) para que sua UI possa exibir mensagens de erro mais informativas ao usuário.
- **Validação Cruzada**: Utilize o `ValidatorFn` em um `FormGroup` para validar a relação entre múltiplos controles (por exemplo, data de início e data de fim, campos dependentes, etc.).

---

### **Exemplo Completo: Formulário de Cadastro**

Vamos integrar tudo o que aprendemos em um formulário de cadastro de usuário, usando validadores personalizados e nativos.

```tsx
// app.component.ts

import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import { of } from 'rxjs';
import { delay, map } from 'rxjs/operators';

// Validador personalizado para nome de usuário (só permite letras)
export function usernameValidator(control: AbstractControl): ValidationErrors | null {
  const value = control.value;
  if (!value) {
    return null;
  }
  const hasOnlyLetters = /^[a-zA-Z]+$/.test(value);
  return hasOnlyLetters ? null : { onlyLetters: true };
}

// Validador assíncrono para verificar se o nome de usuário já existe
// Simula uma chamada de API
export function uniqueUsernameValidator(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> {
  const existingUsernames = ['gedê', 'ju', 'admin'];
  const value = control.value?.toLowerCase();

  if (!value) {
    return of(null);
  }

  return of(value).pipe(
    delay(500), // Simula o tempo de resposta da API
    map(name => existingUsernames.includes(name) ? { uniqueUsername: true } : null)
  );
}

@Component({
  selector: 'app-root',
  template: `
    <form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
      <h2>Formulário de Cadastro</h2>

      <div class="form-group">
        <label for="username">Nome de Usuário:</label>
        <input id="username" type="text" formControlName="username">
        <div *ngIf="usernameControl?.invalid && (usernameControl?.dirty || usernameControl?.touched)">
          <div *ngIf="usernameControl?.errors?.['required']">Nome de usuário é obrigatório.</div>
          <div *ngIf="usernameControl?.errors?.['onlyLetters']">Nome de usuário deve conter apenas letras.</div>
          <div *ngIf="usernameControl?.errors?.['uniqueUsername']">Este nome de usuário já existe.</div>
        </div>
      </div>

      <div class="form-group">
        <label for="email">E-mail:</label>
        <input id="email" type="email" formControlName="email">
        </div>

      <button type="submit" [disabled]="signupForm.invalid">Cadastrar</button>
    </form>
  `,
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  signupForm!: FormGroup;

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.signupForm = this.fb.group({
      username: ['', {
        validators: [Validators.required, usernameValidator],
        asyncValidators: [uniqueUsernameValidator],
        updateOn: 'blur'
      }],
      email: ['', [Validators.required, Validators.email]],
      //... outros campos
    });
  }

  get usernameControl() {
    return this.signupForm.get('username');
  }

  onSubmit(): void {
    if (this.signupForm.valid) {
      console.log('Formulário válido:', this.signupForm.value);
    } else {
      console.log('Formulário inválido!');
    }
  }
}

```

---

### **Para Aprofundamento**

- **Validações Assíncronas (`AsyncValidatorFn`)**: Entenda como lidar com a validação que envolve chamadas de API ou outras operações assíncronas.
- **`FormArray`**: Aprenda a usar validadores em uma lista dinâmica de controles de formulário.
- **Tradução de Mensagens de Erro**: Explore como criar um serviço para exibir mensagens de erro de validação de forma dinâmica e internacionalizada.
- **Implementação de um Validador em uma Diretiva**: Descubra como criar uma diretiva personalizada para adicionar validadores a elementos HTML de forma declarativa.

Espero que esta explicação detalhada tenha sido útil para você, Gedê. Se tiver mais alguma dúvida ou quiser explorar algum dos tópicos sugeridos, é só me chamar\!

Olá, Gedê\!

A.R.I.A. está pronta para te ajudar com uma explicação detalhada sobre `ValidatorFn` no Angular. Pela sua experiência como desenvolvedor, sei que uma abordagem técnica e completa será útil. Vamos mergulhar no tema para que você possa dominar essa funcionalidade e aplicá-la nos seus projetos de Backend e, quem sabe, em algum projeto de frontend com Angular.

---

## **Dominando a Validação de Formulários no Angular: O Poder de `ValidatorFn`**

### Sumário

Este guia aprofundado explora o `ValidatorFn`, uma função essencial no ecossistema de formulários reativos do Angular. Abordaremos seus conceitos fundamentais, sintaxe, propriedades e métodos, além de discutir melhores práticas e cenários de uso. Através de exemplos de código comentados, você entenderá como criar validadores personalizados e robustos para garantir a integridade dos dados em suas aplicações.

---

### **Conceitos Fundamentais**

No Angular, a validação de formulários é um pilar fundamental para garantir que os dados inseridos pelo usuário sejam consistentes e corretos. Quando se trata de **formulários reativos** (`ReactiveForms`), o Angular oferece uma abordagem poderosa e flexível para lidar com isso. O coração dessa abordagem são os validadores, e o `ValidatorFn` é a interface que define um validador personalizado.

`ValidatorFn` é uma função simples, porém crucial, que recebe um controle de formulário (`AbstractControl`) como argumento e retorna um objeto de erro de validação (`ValidationErrors`) ou `null` se o controle for válido. Esse objeto de erro é um mapa (`key-value`) onde a chave é o nome do erro (por exemplo, `required`, `minlength`, `invalidPassword`) e o valor é um booleano ou um objeto com dados adicionais.

O principal propósito do `ValidatorFn` é encapsular a lógica de validação de forma reutilizável. Em vez de duplicar código de validação em vários lugares, você pode criar uma única função que pode ser aplicada a qualquer `FormControl`, `FormGroup` ou `FormArray`.

---

### **Sintaxe e Uso**

A sintaxe de um `ValidatorFn` é bastante direta. A função deve seguir a seguinte assinatura:

```tsx
(control: AbstractControl): ValidationErrors | null

```

- **`control: AbstractControl`**: O parâmetro `control` é a parte mais importante. Ele representa a instância do controle de formulário que está sendo validado. Através dele, você pode acessar propriedades como `value`, `dirty`, `touched` e até mesmo outros controles dentro de um `FormGroup`.
- **`ValidationErrors | null`**: O tipo de retorno. Se a validação falhar, você deve retornar um objeto de erro. Se for bem-sucedida, retorne `null`.

### **Exemplo Prático: Validador de E-mail Personalizado**

Vamos criar um validador simples para verificar se um campo de e-mail é válido.

```tsx
// validators/email.validator.ts

import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

/**
 * ValidatorFn personalizado para verificar se o valor é um email válido.
 * Retorna um objeto de erro '{ invalidEmail: true }' se for inválido, caso contrário, null.
 */
export const emailValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$/;
  const value = control.value;

  // Se o campo estiver vazio, não validamos (deve ser tratado pelo validador 'required')
  if (!value) {
    return null;
  }

  // Testa o valor contra a regex.
  const isValid = emailRegex.test(value);

  // Retorna o objeto de erro ou null.
  return isValid ? null : { invalidEmail: true };
};

```

Para usar este validador em um `FormControl`:

```tsx
// app.component.ts

import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { emailValidator } from './validators/email.validator';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent implements OnInit {
  userForm!: FormGroup;

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.userForm = this.fb.group({
      email: ['', [Validators.required, emailValidator]],
    });
  }
}

```

No exemplo acima, passamos nosso `emailValidator` para o `FormControl` `email` junto com o validador `Validators.required` padrão do Angular. Isso demonstra como `ValidatorFn` se integra perfeitamente com a API de validação existente.

---

### **Propriedades e Métodos de `AbstractControl` em `ValidatorFn`**

O `ValidatorFn` recebe o `AbstractControl` como argumento. É através deste objeto que você acessa todas as informações do controle do formulário. Conhecer suas propriedades e métodos é crucial para criar validadores inteligentes.

### **Propriedades de `AbstractControl`**

| Propriedade | Tipo | Descrição |
| --- | --- | --- |
| **`value`** | `any` | O valor atual do controle. É a propriedade mais utilizada para realizar a validação. |
| **`status`** | `FormControlStatus` | O estado de validade atual do controle. Pode ser `'VALID'`, `'INVALID'`, `'PENDING'` ou `'DISABLED'`. |
| **`errors`** | `ValidationErrors | null` |
| **`validator`** | `ValidatorFn | null` |
| **`asyncValidator`** | `AsyncValidatorFn | null` |
| **`dirty`** | `boolean` | `true` se o valor do controle foi alterado pelo usuário. Caso contrário, `false`. |
| **`pristine`** | `boolean` | O oposto de `dirty`. `true` se o valor não foi alterado. |
| **`touched`** | `boolean` | `true` se o usuário interagiu com o controle (por exemplo, focou e desfocou o campo). |
| **`untouched`** | `boolean` | O oposto de `touched`. `true` se o usuário não interagiu com o controle. |
| **`valid`** | `boolean` | `true` se o controle é válido (ou seja, `status` é `'VALID'`). |
| **`invalid`** | `boolean` | `true` se o controle é inválido (ou seja, `status` é `'INVALID'`). |
| **`pending`** | `boolean` | `true` se o controle está passando por uma validação assíncrona. |
| **`parent`** | `FormGroup | FormArray` |

### **Métodos de `AbstractControl`**

| Método | Retorno | Descrição |
| --- | --- | --- |
| **`get(path: Array<string | number> | string): AbstractControl |

### **Exemplo de Validação Cruzada (Cross-field validation)**

Este é um dos cenários mais poderosos para o `ValidatorFn`. Vamos criar um validador para um `FormGroup` que verifica se a senha e a confirmação de senha são iguais.

```tsx
// validators/password-match.validator.ts

import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

/**
 * Validador de FormGroup que verifica se os campos 'password' e 'confirmPassword' são iguais.
 */
export const passwordMatchValidator: ValidatorFn = (control: AbstractControl): ValidationErrors | null => {
  const password = control.get('password');
  const confirmPassword = control.get('confirmPassword');

  // Se os controles não existirem ou estiverem vazios, não validamos.
  if (!password || !confirmPassword || !password.value || !confirmPassword.value) {
    return null;
  }

  // Compara os valores.
  return password.value === confirmPassword.value ? null : { passwordsMismatch: true };
};

```

Aplicação no `FormGroup`:

```tsx
// app.component.ts

this.userForm = this.fb.group({
  password: ['', [Validators.required]],
  confirmPassword: ['', [Validators.required]]
}, { validators: passwordMatchValidator }); // O validador é aplicado ao FormGroup, não aos controles individuais.

```

Note que o `passwordMatchValidator` foi aplicado no segundo argumento do `FormGroup` (`{ validators: ... }`), pois ele opera sobre o grupo de controles, não sobre um controle individual.

---

### **Restrições de Uso**

Embora o `ValidatorFn` seja extremamente versátil, existem cenários onde sua aplicação direta pode não ser a melhor escolha:

1. **Validações Assíncronas**: Se a sua validação depende de uma chamada de API, um temporizador ou qualquer outra operação assíncrona, você deve usar o `AsyncValidatorFn` em vez de `ValidatorFn`. A função assíncrona retorna uma `Promise` ou um `Observable` de `ValidationErrors | null`.
2. **Validações Simples e Padrão**: Para validações como `required`, `minLength`, `maxLength`, `pattern` etc., o Angular já fornece validadores nativos (`Validators`) que são otimizados e mais eficientes. Não reinvente a roda. Use o `ValidatorFn` apenas para lógica de validação personalizada.
3. **Lógica Complexa de UI**: O `ValidatorFn` deve focar estritamente na validação dos dados. Se a sua lógica envolve a manipulação da interface do usuário (ex: mostrar/esconder campos, mudar o estilo de um componente), essa lógica deve ser implementada no componente, reagindo ao `status` do `FormControl`, e não dentro da função do validador.

---

### **Melhores Práticas e Casos de Uso**

- **Validações Parametrizadas**: A maioria dos validadores personalizados pode ser reutilizada com diferentes parâmetros. Para isso, crie uma **fábrica de validadores** (validator factory), que é uma função que retorna um `ValidatorFn`.

<!-- end list -->

```tsx
// validators/range.validator.ts

import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

/**
 * Fábrica de validadores para verificar se um número está dentro de um intervalo.
 */
export function rangeValidator(min: number, max: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const value = control.value;

    if (value === null || value === undefined || isNaN(value)) {
      return null; // O validador 'required' deve tratar isso
    }

    const isOutOfRange = value < min || value > max;

    return isOutOfRange ? { range: { min, max, actual: value } } : null;
  };
}

```

Uso:

```tsx
this.productForm = this.fb.group({
  price: ['', [Validators.required, rangeValidator(0, 100)]]
});

```

- **Reusabilidade**: Centralize todos os seus validadores personalizados em um único diretório (`/validators` ou `/shared/validators`) para fácil acesso e manutenção.
- **Mensagens de Erro Detalhadas**: Retorne objetos de erro com dados úteis (`{ min, max, actual }`) para que sua UI possa exibir mensagens de erro mais informativas ao usuário.
- **Validação Cruzada**: Utilize o `ValidatorFn` em um `FormGroup` para validar a relação entre múltiplos controles (por exemplo, data de início e data de fim, campos dependentes, etc.).

---

### **Exemplo Completo: Formulário de Cadastro**

Vamos integrar tudo o que aprendemos em um formulário de cadastro de usuário, usando validadores personalizados e nativos.

```tsx
// app.component.ts

import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import { of } from 'rxjs';
import { delay, map } from 'rxjs/operators';

// Validador personalizado para nome de usuário (só permite letras)
export function usernameValidator(control: AbstractControl): ValidationErrors | null {
  const value = control.value;
  if (!value) {
    return null;
  }
  const hasOnlyLetters = /^[a-zA-Z]+$/.test(value);
  return hasOnlyLetters ? null : { onlyLetters: true };
}

// Validador assíncrono para verificar se o nome de usuário já existe
// Simula uma chamada de API
export function uniqueUsernameValidator(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> {
  const existingUsernames = ['gedê', 'ju', 'admin'];
  const value = control.value?.toLowerCase();

  if (!value) {
    return of(null);
  }

  return of(value).pipe(
    delay(500), // Simula o tempo de resposta da API
    map(name => existingUsernames.includes(name) ? { uniqueUsername: true } : null)
  );
}

@Component({
  selector: 'app-root',
  template: `
    <form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
      <h2>Formulário de Cadastro</h2>

      <div class="form-group">
        <label for="username">Nome de Usuário:</label>
        <input id="username" type="text" formControlName="username">
        <div *ngIf="usernameControl?.invalid && (usernameControl?.dirty || usernameControl?.touched)">
          <div *ngIf="usernameControl?.errors?.['required']">Nome de usuário é obrigatório.</div>
          <div *ngIf="usernameControl?.errors?.['onlyLetters']">Nome de usuário deve conter apenas letras.</div>
          <div *ngIf="usernameControl?.errors?.['uniqueUsername']">Este nome de usuário já existe.</div>
        </div>
      </div>

      <div class="form-group">
        <label for="email">E-mail:</label>
        <input id="email" type="email" formControlName="email">
        </div>

      <button type="submit" [disabled]="signupForm.invalid">Cadastrar</button>
    </form>
  `,
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  signupForm!: FormGroup;

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.signupForm = this.fb.group({
      username: ['', {
        validators: [Validators.required, usernameValidator],
        asyncValidators: [uniqueUsernameValidator],
        updateOn: 'blur'
      }],
      email: ['', [Validators.required, Validators.email]],
      //... outros campos
    });
  }

  get usernameControl() {
    return this.signupForm.get('username');
  }

  onSubmit(): void {
    if (this.signupForm.valid) {
      console.log('Formulário válido:', this.signupForm.value);
    } else {
      console.log('Formulário inválido!');
    }
  }
}

```

---

### **Para Aprofundamento**

- **Validações Assíncronas (`AsyncValidatorFn`)**: Entenda como lidar com a validação que envolve chamadas de API ou outras operações assíncronas.
- **`FormArray`**: Aprenda a usar validadores em uma lista dinâmica de controles de formulário.
- **Tradução de Mensagens de Erro**: Explore como criar um serviço para exibir mensagens de erro de validação de forma dinâmica e internacionalizada.
- **Implementação de um Validador em uma Diretiva**: Descubra como criar uma diretiva personalizada para adicionar validadores a elementos HTML de forma declarativa.

Espero que esta explicação detalhada tenha sido útil para você, Gedê. Se tiver mais alguma dúvida ou quiser explorar algum dos tópicos sugeridos, é só me chamar\!