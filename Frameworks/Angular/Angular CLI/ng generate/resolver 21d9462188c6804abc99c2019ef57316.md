# resolver

**Título da Explicação:** Desvendando o comando `ng generate resolver` no Angular CLI

---

## Introdução

O comando `ng generate resolver` (ou seu atalho `ng g r`) faz parte do Angular CLI e serve para criar de forma automática os artefatos necessários para um *resolver* no contexto de rotas do Angular. Um *resolver* permite pré-carregar dados antes da ativação de uma rota, garantindo que o componente associado tenha todas as informações disponíveis assim que for exibido ([angular.dev](https://angular.dev/cli/generate?utm_source=chatgpt.com)).

---

## Sumário

1. **Conceitos Fundamentais**
2. **Sintaxe e Uso**
3. **Restrições de Uso**
4. **Argumentos**
5. **Opções**
    - 5.1. Específicas do *schematic*
    - 5.2. Globais do Angular CLI
6. **Melhores Práticas e Casos de Uso**
7. **Exemplos Completos**
8. **Tópicos Adicionais**
9. **Tópicos Relacionados para Aprofundamento**

---

## 1. Conceitos Fundamentais

- **O que é um *Resolver*?**
    
    Um *resolver* é uma classe ou função que implementa a interface `Resolve<T>` ou o tipo `ResolveFn<T>`. Sua função principal é buscar dados necessários (por exemplo, via HTTP) **antes** de carregar o componente da rota. Isso evita telas “vazias” ou estados de carregamento exibidos após a rota já ter sido ativada ([angular.dev](https://angular.dev/cli/generate/resolver?utm_source=chatgpt.com), [v17.angular.io](https://v17.angular.io/guide/router-tutorial-toh?utm_source=chatgpt.com)).
    
- **Fluxo de execução:**
    1. Navegação iniciada.
    2. Antes de ativar o componente, o Angular executa o *resolver*.
    3. Se o *resolver* retornar um `Observable`/`Promise`, a navegação aguarda até sua resolução.
    4. Injeção dos dados resolvidos no `ActivatedRoute.data`.
- **Vantagens:**
    - Garante que todos os dados estejam prontos ao exibir a rota.
    - Centraliza a lógica de pré-carregamento fora do componente.
- **Desvantagens potenciais:**
    - Atrasos na navegação se o *resolver* demorar ou falhar.
    - Sobrecarga de chamadas HTTP se usado em excesso.

---

## 2. Sintaxe e Uso

```bash
# Comando completo
ng generate resolver <nome> [options]

# Alias curto
ng g r <nome> [options]

```

- `<nome>`: nome do *resolver*, podendo incluir caminho, por ex.:
    
    ```bash
    ng g resolver services/user-profile --module=app
    
    ```
    
- O comando gera dois arquivos por padrão:
    - `<nome>.resolver.ts`
    - `<nome>.resolver.spec.ts`
- Exemplo comentado:
    
    ```bash
    # Gera um resolver de função (functional) no diretório current/path
    ng g r user-data \
      --flat=false \        # cria pasta 'user-data'
      --functional=true \   # gera ResolveFn em vez de classe
      --module=app.module.ts
    
    ```
    

---

## 3. Restrições de Uso

- **Não utilizar para:**
    - Dados que podem ser carregados de forma assíncrona dentro do próprio componente sem impactar negativamente a UX.
    - Operações muito pesadas (várias requisições sequenciais), pois atrasam a renderização da rota.
    - Cenários onde o usuário precisa interagir antes do carregamento completo dos dados.
- **Quando evitar:** páginas com conteúdo parcial graduais (infinite scroll, por exemplo), pois *resolvers* bloqueiam totalmente o carregamento.

---

## 4. Argumentos

| Argumento | Tipo | Descrição |
| --- | --- | --- |
| `name` | string | **Obrigatório.** Nome do resolver. Pode incluir subpastas (`folder/name`). Gera arquivos `.ts`. |

> Exemplo:
> 
> 
> `ng g r auth/token` → cria `src/app/auth/token.resolver.ts` e `token.resolver.spec.ts` ([angular.dev](https://angular.dev/cli/generate/resolver?utm_source=chatgpt.com))
> 

---

## 5. Opções

### 5.1. Específicas do *schematic* `resolver`

| Opção | Tipo | Padrão | Descrição |
| --- | --- | --- | --- |
| `--flat` | boolean | true | Se `true`, gera arquivos no diretório atual; se `false`, cria subpasta com o nome do *resolver*. |
| `--functional` | boolean | true | Se `true`, gera um `ResolveFn<T>` (função) em vez de classe que implementa `Resolve<T>`. |
| `--project` | string | default | Nome do projeto no *workspace* onde será gerado. |
| `--path` | string | default | Caminho onde os arquivos serão criados (normalmente `src/app`). |
| `--module` | string | — | Arquivo de módulo para importar o *resolver* (ex.: `app.module.ts`). |
| `--skip-import` | boolean | false | Se `true`, não importa o *resolver* no módulo especificado. |
| `--spec` | boolean | true | Se `true`, gera o arquivo de teste `.spec.ts`. |

> Fonte: Angular CLI Docs (angular.dev)
> 

### 5.2. Globais do Angular CLI

| Opção | Tipo | Descrição |
| --- | --- | --- |
| `--dry-run` (`-d`) | boolean | Simula a geração de arquivos, sem alterar nada. |
| `--force` (`-f`) | boolean | Sobrescreve arquivos existentes sem perguntar. |
| `--collection` | string | Coleção de *schematics* a usar (ex.: `@schematics/angular`). |
| `--defaults` | boolean | Usa valores padrão sem prompt interativo. |
| `--verbose` | boolean | Exibe logs detalhados durante a execução. |
| `--help` | boolean | Exibe ajuda do comando. |

> Dica: consulte ng generate --help para sua versão instalada (sitepoint.com)
> 

---

## 6. Melhores Práticas e Casos de Uso

- **Pré-carregamento de dados críticos:**
    
    Use *resolvers* para dados necessários à renderização completa do componente (ex.: perfil de usuário, configurações).
    
- **Manutenção de consistência de navegação:**
    
    Evita duplicação de lógica de carregamento em vários componentes.
    
- **Combine com Guardas (`CanActivate`):**
    
    Assegure autenticação com um *guard* antes de pré-carregar dados sensíveis com um *resolver*.
    
- **Evite para dados incrementais:**
    
    Se o componente pode apresentar partes da interface antes de todos os dados, carregue-os no `ngOnInit` em vez de bloquear a rota ([v17.angular.io](https://v17.angular.io/guide/router-tutorial-toh?utm_source=chatgpt.com)).
    

---

## 7. Exemplos Completos

**1. Geração via CLI**

```bash
ng g resolver orders/order-detail \
  --flat=false \
  --module=app-routing.module.ts \
  --functional=false

```

**2. Conteúdo de `order-detail.resolver.ts`**

```
import { Injectable } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { OrderService } from '../services/order.service';
import { Order } from '../models/order.model';

@Injectable({ providedIn: 'root' })
export class OrderDetailResolver implements Resolve<Order> {
  constructor(private service: OrderService) {}

  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<Order> {
    const id = route.paramMap.get('id')!;
    return this.service.getById(+id);
  }
}

```

**3. Registro no `app-routing.module.ts`**

```
const routes: Routes = [
  {
    path: 'orders/:id',
    component: OrderDetailComponent,
    resolve: { order: OrderDetailResolver }
  }
];

```

Este fluxo garante que `ActivatedRoute.data.order` já contenha o objeto `Order` antes de `OrderDetailComponent` ser inicializado ([v17.angular.io](https://v17.angular.io/guide/router-tutorial-toh?utm_source=chatgpt.com)).

---

## 8. Tópicos Adicionais

- Implementação de *resolvers* funcionais com `ResolveFn<T>`.
- Testes unitários para *resolvers*.
- Criação de coleções personalizadas de *schematics* envolvendo *resolvers*.
- Tratamento de erros dentro de *resolvers* (ex.: redirecionamento em caso de 404).

---

## 9. Tópicos Relacionados para Aprofundamento

- **Guards (`CanActivate`, `CanLoad`)**
- **Interceptors HTTP**
- **Customização de *schematics***
- **Lazy Loading de Módulos**
- **Estratégias de Cache no Router**

---

*Espero que esta explicação detalhada auxilie na compreensão e aplicação do `ng generate resolver` em seus projetos Angular!*