# Navegação programática

Beleza, Gedê\! Entendido. A.R.I.A. vai te ajudar a desvendar a **Navegação Programática em Rotas do Angular** de forma bem detalhada. Você pediu para cobrir tudo e focar nos exemplos práticos, então vamos lá\!

---

## Navegação Programática em Angular: Dominando o Fluxo de Rotas

### Introdução

No desenvolvimento de aplicações web modernas, a navegação entre diferentes partes da aplicação é um pilar fundamental da experiência do usuário. O Angular, com seu poderoso módulo de roteamento, oferece várias maneiras de gerenciar essa navegação. Além dos links declarativos (`routerLink`), existe a **navegação programática**, que permite controlar o fluxo da aplicação através de código. Isso é essencial para cenários onde a navegação depende de lógica de negócio, interações do usuário, ou respostas de APIs, dando a você um controle preciso sobre quando e para onde o usuário será redirecionado.

### Sumário

Nesta explicação detalhada, vamos cobrir os seguintes pontos:

- **Conceitos Fundamentais:** Entender o propósito e a importância da navegação programática.
- **Serviço `Router`:** O coração da navegação programática.
- **Sintaxe Detalhada e Uso Prático:**
    - Exemplo de Navegação Básica (`Maps` e `MapsByUrl`).
    - Navegando com Path Parameters.
    - Navegando com Extras: `queryParams`, `fragment`, `queryParamsHandling`, `preserveFragment`, `relativeTo`, `skipLocationChange`, `replaceUrl`, `state`.
- **Cenários de Restrição ou Não Aplicação:** Quando evitar a navegação programática.
- **Melhores Práticas e Padrões de Uso:** Dicas e recomendações para usar a navegação programática de forma eficaz.

---

### Conceitos Fundamentais

A navegação programática em Angular refere-se à capacidade de disparar uma navegação para uma rota específica a partir do seu código TypeScript, em vez de usar um link HTML (`<a routerLink="...">`). O coração dessa funcionalidade é o serviço `Router`, que é injetado nos seus componentes ou serviços.

**Propósito e Importância:**

- **Lógica Condicional:** Redirecionar o usuário com base em condições (e.g., após um login bem-sucedido, se um formulário for inválido, permissões do usuário).
- **Fluxos de Trabalho Complexos:** Guiar o usuário através de um fluxo de várias etapas (e.g., um wizard de compra).
- **Respostas de Servidor:** Navegar após o recebimento de dados de uma API.
- **Interatividade:** Reagir a eventos do usuário que não são apenas cliques em links estáticos.

---

### Serviço `Router`

O serviço `Router` é o principal ponto de entrada para a navegação programática. Você o injeta no seu construtor e utiliza seus métodos para disparar as navegações. Os dois métodos mais comuns são `Maps` e `MapsByUrl`.

```tsx
import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-my-component',
  template: `
    <button (click)="goToDashboard()">Ir para Dashboard</button>
  `
})
export class MyComponent {
  constructor(private router: Router) {} // Injetando o serviço Router

  goToDashboard() {
    // Exemplo de uso
  }
}

```

---

### Sintaxe Detalhada e Uso Prático

Vamos explorar os principais métodos e opções para a navegação programática.

### Exemplo de Navegação Básica

Existem duas formas principais de iniciar uma navegação programática:

1. **`router.navigate(['/path', param1, param2])`**:
    - Recebe um array de segmentos de URL. É a forma **preferida** para rotas mais complexas, especialmente quando você tem parâmetros, query parameters ou fragmentos. O Angular compõe a URL para você.
    - É ideal para navegação relativa.
    
    <!-- end list -->
    
    ```tsx
    // app-routing.module.ts
    const routes: Routes = [
      { path: 'home', component: HomeComponent },
      { path: 'dashboard', component: DashboardComponent },
      { path: 'products/:id', component: ProductDetailComponent },
      { path: '', redirectTo: '/home', pathMatch: 'full' }
    ];
    
    // my-component.ts
    import { Component } from '@angular/core';
    import { Router } from '@angular/router';
    
    @Component({
      selector: 'app-my-component',
      template: `
        <button (click)="goToHome()">Ir para Home (navigate)</button>
        <button (click)="goToDashboard()">Ir para Dashboard (navigateByUrl)</button>
      `
    })
    export class MyComponent {
      constructor(private router: Router) {}
    
      goToHome() {
        // Navega para a rota '/home'
        this.router.navigate(['/home']);
        console.log('Navegou para /home usando navigate');
      }
    
      goToDashboard() {
        // Navega para a rota '/dashboard' (string literal)
        // Equivalente a this.router.navigate(['/dashboard']);
        this.router.navigateByUrl('/dashboard');
        console.log('Navegou para /dashboard usando navigateByUrl');
      }
    }
    
    ```
    
2. **`router.navigateByUrl('/full/url?param=value#fragment')`**:
    - Recebe uma string contendo a URL completa.
    - Útil quando você já tem a URL completa em mãos (e.g., vinda de uma API) ou quando a URL é estática e não envolve parâmetros dinâmicos complexos.
    - Não suporta navegação relativa.
    
    *Exemplo incluído acima para comparação.*
    

---

### Navegando com Path Parameters

Quando suas rotas possuem parâmetros dinâmicos (e.g., `/products/:id`), você os passa como parte do array no método `Maps`.

```tsx
// app-routing.module.ts
const routes: Routes = [
  { path: 'product/:id', component: ProductDetailComponent }
];

// product-detail.component.ts (para pegar o ID)
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-product-detail',
  template: `
    <h2>Detalhes do Produto {{ productId }}</h2>
    <button (click)="goBack()">Voltar</button>
  `
})
export class ProductDetailComponent implements OnInit {
  productId: string | null = null;

  constructor(private route: ActivatedRoute, private router: Router) {}

  ngOnInit() {
    // Captura o parâmetro 'id' da URL
    this.route.paramMap.subscribe(params => {
      this.productId = params.get('id');
    });
  }

  goBack() {
    this.router.navigate(['/products']); // Exemplo de voltar para uma lista
  }
}

// my-component.ts (para navegar com path parameter)
import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-my-component',
  template: `
    <button (click)="viewProduct(123)">Ver Produto 123</button>
    <button (click)="viewProduct(456)">Ver Produto 456</button>
  `
})
export class MyComponent {
  constructor(private router: Router) {}

  viewProduct(id: number) {
    // Navega para '/product/123' ou '/product/456'
    this.router.navigate(['/product', id]);
    console.log(`Navegou para /product/${id}`);
  }
}

```

---

### Navegando com Extras (Opções Adicionais)

O segundo argumento do método `Maps` é um objeto de configuração que permite passar opções adicionais para a navegação. Essas opções são essenciais para cenários mais complexos.

```tsx
this.router.navigate(['/path'], {
  queryParams: { key: 'value' },
  fragment: 'anchor',
  // ...outras opções
});

```

Vamos detalhar cada uma:

- **`queryParams`**: Permite adicionar parâmetros de consulta (query parameters) à URL. São usados para filtrar dados, passar estado que não faz parte da rota em si, etc. A URL final terá `?key=value&another=value`.
    
    ```tsx
    // URL final: /search?query=angular&category=frontend
    this.router.navigate(['/search'], {
      queryParams: { query: 'angular', category: 'frontend' }
    });
    
    ```
    
- **`fragment`**: Permite adicionar um fragmento de URL (hash `#`) para rolar a página até um elemento com o ID correspondente.
    
    ```tsx
    // URL final: /about#section-details
    this.router.navigate(['/about'], { fragment: 'section-details' });
    
    ```
    
- **`queryParamsHandling`**: Define como os *query parameters* existentes na URL atual devem ser tratados ao navegar.
    - `'merge'`: Mescla os novos `queryParams` com os existentes. Se houver chaves duplicadas, as novas sobrescrevem as antigas.
    - `'preserve'`: Preserva todos os `queryParams` existentes e ignora os `queryParams` passados no `Maps`.
    - `'false'` (ou omitido): Não transfere nenhum `queryParams` existente, apenas os que são passados na navegação atual.
    
    <!-- end list -->
    
    ```tsx
    // Exemplo: Suponha que a URL atual seja /products?page=1&sort=asc
    
    // 1. merge: Adiciona 'filter=new' e mantém 'page' e 'sort'
    // URL final: /products?page=1&sort=asc&filter=new
    this.router.navigate(['/products'], {
      queryParams: { filter: 'new' },
      queryParamsHandling: 'merge'
    });
    
    // 2. preserve: Ignora o 'filter=new' e mantém 'page' e 'sort'
    // URL final: /products?page=1&sort=asc
    this.router.navigate(['/products'], {
      queryParams: { filter: 'new' },
      queryParamsHandling: 'preserve'
    });
    
    // 3. false (default): Apenas o novo queryParam é considerado
    // URL final: /products?filter=new
    this.router.navigate(['/products'], {
      queryParams: { filter: 'new' } // queryParamsHandling é 'false' por padrão
    });
    
    ```
    
- **`preserveFragment`**: Se definido como `true`, preserva o fragmento da URL atual na nova navegação. Útil para manter a rolagem da página quando você navega para uma rota diferente.
    
    ```tsx
    // Suponha que a URL atual seja /dashboard#notifications
    // E você está navegando para /settings
    this.router.navigate(['/settings'], { preserveFragment: true });
    // URL final: /settings#notifications
    
    ```
    
- **`relativeTo`**: Permite que você faça navegações relativas a uma rota ativada específica. Isso é extremamente útil em componentes aninhados ou quando você quer navegar sem precisar saber o caminho absoluto completo. Você passa uma instância de `ActivatedRoute`.
    
    ```tsx
    import { Component } from '@angular/core';
    import { ActivatedRoute, Router } from '@angular/router';
    
    @Component({
      selector: 'app-user-profile',
      template: `
        <h2>Perfil do Usuário</h2>
        <button (click)="editProfile()">Editar Perfil</button>
      `
    })
    export class UserProfileComponent {
      constructor(
        private route: ActivatedRoute, // Rota ativa atual (e.g., /users/123)
        private router: Router
      ) {}
    
      editProfile() {
        // Supondo que a rota atual seja '/users/123'
        // E existe uma rota filha 'edit' configurada em /users/:id/edit
        // Navega para '/users/123/edit'
        this.router.navigate(['edit'], { relativeTo: this.route });
      }
    }
    
    ```
    
- **`skipLocationChange`**: Se definido como `true`, a navegação ocorre, mas a URL no navegador **não é atualizada**. O histórico do navegador também não é afetado. Isso pode ser útil para navegações internas que não precisam ser refletidas na URL ou no histórico, por exemplo, ao abrir um modal que tem uma "rota" interna, mas você não quer que o usuário possa voltar para o estado do modal usando o botão "voltar" do navegador.
    
    ```tsx
    // Navega para /hidden-state, mas a URL no navegador permanece a mesma
    this.router.navigate(['/hidden-state'], { skipLocationChange: true });
    
    ```
    
- **`replaceUrl`**: Se definido como `true`, a nova URL **substitui** a URL atual no histórico do navegador em vez de adicioná-la. Isso significa que, se o usuário clicar no botão "voltar", ele voltará para a URL *anterior à atual*, ignorando a navegação que usou `replaceUrl`. Útil após um login/logout ou redirecionamentos que não devem ser "voltáveis".
    
    ```tsx
    // Após o login, navega para o dashboard e substitui a página de login no histórico
    this.router.navigate(['/dashboard'], { replaceUrl: true });
    
    ```
    
- **`state`**: Permite passar dados de estado arbitrários para a rota de destino, que não são visíveis na URL. Esses dados ficam armazenados no objeto `History.state` do navegador e podem ser acessados pela rota de destino através do `Router.getCurrentNavigation()?.extras.state` ou `History.state`. É útil para passar objetos complexos ou sensíveis que não devem ser expostos na URL.
    
    ```tsx
    // No componente de origem
    this.router.navigate(['/order-summary'], {
      state: { orderId: 123, customerName: 'Gedê', products: ['itemA', 'itemB'] }
    });
    
    // No componente de destino (OrderSummaryComponent)
    import { Component, OnInit } from '@angular/core';
    import { Router } from '@angular/router';
    
    @Component({
      selector: 'app-order-summary',
      template: `
        <h2>Resumo do Pedido</h2>
        <p>ID do Pedido: {{ order?.orderId }}</p>
        <p>Cliente: {{ order?.customerName }}</p>
        <ul>
          <li *ngFor="let product of order?.products">{{ product }}</li>
        </ul>
      `
    })
    export class OrderSummaryComponent implements OnInit {
      order: any;
    
      constructor(private router: Router) {}
    
      ngOnInit() {
        // Verifica se há dados de estado na navegação atual
        if (this.router.getCurrentNavigation()?.extras.state) {
          this.order = this.router.getCurrentNavigation()?.extras.state;
          console.log('Dados do estado recebidos:', this.order);
        } else {
          // Também é possível acessar diretamente via history.state (menos recomendado para Angular)
          // this.order = history.state;
          console.log('Nenhum dado de estado encontrado ou navegação direta.');
        }
      }
    }
    
    ```
    
    **Atenção:** Os dados do `state` **não são persistentes** após um refresh da página ou se o usuário navegar para fora da aplicação. Eles são apenas para a navegação **atual**.
    

---

### Cenários de Restrição ou Não Aplicação

A navegação programática, embora poderosa, não é sempre a melhor escolha.

- **Links Estáticos Simples:** Para navegação direta e estática (e.g., um menu de navegação), usar `routerLink` no HTML é mais declarativo, legível e geralmente mais performático, pois o Angular pode pré-carregar os módulos e componentes.
- **SEO:** Se a URL é importante para indexação por motores de busca, garanta que ela seja semanticamente significativa. `skipLocationChange` e `state` podem esconder informações importantes dos crawlers.
- **Acessibilidade:** Certifique-se de que a navegação programática não prejudique a acessibilidade. Use `routerLink` sempre que possível para que leitores de tela e outros auxílios possam interpretar a navegação.
- **Complexidade Desnecessária:** Evite a navegação programática se um `routerLink` simples resolver o problema. Adicionar lógica de TypeScript para uma navegação básica só aumenta a complexidade sem benefício.

---

### Melhores Práticas e Padrões de Uso

- **Use `routerLink` por Padrão:** Sempre comece considerando se um `routerLink` pode atender à sua necessidade.
- **Injete o `Router` e o `ActivatedRoute`:** Sempre que precisar de navegação programática, injete o `Router`. Se precisar de navegação relativa ou de acesso a parâmetros da rota atual, injete também o `ActivatedRoute`.
- **Trate Parâmetros de Rota no `ngOnInit`:** Para capturar `paramMap`, `queryParamMap` ou `fragment` da rota atual, sempre se inscreva nos observables no `ngOnInit` do seu componente e desinscreva-se no `ngOnDestroy` para evitar vazamentos de memória.
    
    ```tsx
    import { Component, OnInit, OnDestroy } from '@angular/core';
    import { ActivatedRoute } from '@angular/router';
    import { Subscription } from 'rxjs';
    
    @Component({
      selector: 'app-my-component',
      template: `...`
    })
    export class MyComponent implements OnInit, OnDestroy {
      private routeSubscription!: Subscription;
    
      constructor(private route: ActivatedRoute) {}
    
      ngOnInit() {
        this.routeSubscription = this.route.paramMap.subscribe(params => {
          const id = params.get('id');
          // Faça algo com o ID
        });
      }
    
      ngOnDestroy() {
        if (this.routeSubscription) {
          this.routeSubscription.unsubscribe();
        }
      }
    }
    
    ```
    
- **Use `Maps` para Rotas Complexas e `MapsByUrl` para Rotas Simples/Constantes:** Escolha o método mais adequado para a situação. `Maps` é mais flexível para construção de URLs dinâmicas.
- **Gerencie o Estado de Navegação com Cuidado:** Se você precisa passar dados entre rotas, considere usar:
    - **Path Parameters:** Para identificadores de recursos (`/users/123`).
    - **Query Parameters:** Para filtros, ordenação, paginação (`/products?category=eletronics`).
    - **Serviços Compartilhados:** Para dados mais complexos ou que precisam ser persistidos em várias navegações ou em diferentes partes da aplicação. Essa é frequentemente a melhor abordagem para gerenciar estado global.
    - **`state` (History API):** Para dados efêmeros que não precisam ser visíveis na URL e não devem persistir após um refresh.
- **Trate Erros de Navegação:** O método `Maps` retorna uma `Promise<boolean>` que resolve para `true` se a navegação foi bem-sucedida e `false` se foi cancelada (por um guarda de rota, por exemplo). Você pode usar isso para adicionar lógica de tratamento de erros ou feedback ao usuário.
    
    ```tsx
    this.router.navigate(['/admin'])
      .then(success => {
        if (success) {
          console.log('Navegação bem-sucedida para /admin');
        } else {
          console.log('Navegação para /admin foi cancelada');
          // Exibir mensagem de erro ou redirecionar para página de acesso negado
        }
      })
      .catch(error => {
        console.error('Erro na navegação:', error);
      });
    
    ```
    

A navegação programática é uma ferramenta poderosa no arsenal de um desenvolvedor Angular, Gedê. Ao dominá-la, você terá controle total sobre o fluxo da sua aplicação, podendo criar experiências de usuário dinâmicas e responsivas.

---

### Sugestões para Aprofundamento

Para continuar aprofundando seus conhecimentos, sugiro os seguintes tópicos:

- **Guards de Rota (Guards):** Aprenda a proteger suas rotas e controlar o acesso a elas (CanActivate, CanDeactivate, Resolve, etc.). Eles são frequentemente usados em conjunto com a navegação programática para controlar permissões.
- **Estratégias de Carregamento de Módulos (Lazy Loading):** Entenda como o carregamento sob demanda pode melhorar a performance da sua aplicação.
- **Router Events:** Explore os eventos do `Router` para reagir a diferentes estágios do ciclo de vida da navegação.
- **`RouterOutlet` e Rotas Aninhadas:** Aprofunde-se em como o `RouterOutlet` funciona com rotas filhas para criar layouts complexos.

Espero que esta explicação detalhada tenha sido útil, Gedê\! Se tiver mais alguma dúvida, A.R.I.A. está à disposição.