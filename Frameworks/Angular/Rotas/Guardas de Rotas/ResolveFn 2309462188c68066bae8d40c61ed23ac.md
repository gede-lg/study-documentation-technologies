# ResolveFn

Olá, Gedê\! Aqui é a A.R.I.A. (Assistente Rápida para Idiotas Atarefados).

Preparei uma explicação extremamente detalhada sobre o `resolveFn` no contexto de rotas do Angular, exatamente como você pediu. Vamos mergulhar fundo neste conceito essencial para criar aplicações robustas e com ótima experiência de usuário.

---

### **Título: Desvendando o `resolveFn` no Roteamento Angular: Guia Completo de Pré-carregamento de Dados**

---

### **Introdução**

No desenvolvimento de aplicações Single-Page Application (SPA) com Angular, um desafio comum é garantir que os dados necessários para uma tela estejam disponíveis no momento em que ela é exibida. Frequentemente, um componente é renderizado e, em seu `ngOnInit`, dispara uma chamada HTTP para buscar dados, resultando em uma tela vazia ou com "spinners" de carregamento, o que pode prejudicar a experiência do usuário.

O `resolveFn`, também conhecido como "Functional Route Resolver", é a solução moderna e elegante do Angular para este problema. Ele atua como um intermediário no processo de navegação, permitindo que você busque dados de forma assíncrona *antes* que a rota seja ativada e o componente correspondente seja renderizado.

---

### **Sumário**

Este guia completo abordará os seguintes pontos:

- **O que é o `resolveFn`**: Seu propósito fundamental de pré-carregamento de dados.
- **Vantagens**: Por que usar a abordagem funcional em vez da antiga baseada em classes.
- **Sintaxe e Anatomia**: Como declarar e o que cada parâmetro da função representa.
- **Registro e Acesso**: Como associar um resolver a uma rota e como o componente acessa os dados resolvidos.
- **Tratamento de Erros**: O que acontece quando a busca de dados falha e como lidar com isso.
- **Casos de Uso e Restrições**: Quando usar e, igualmente importante, quando *não* usar um resolver.
- **Exemplo Prático Completo**: Uma mini-aplicação para ilustrar todos os conceitos em ação.

---

### **Conceitos Fundamentais**

### **Base Teórica e Propósito**

O propósito central de um `resolveFn` é atuar como um "guardião de dados" para uma rota. Quando um usuário tenta navegar para uma rota que possui um resolver associado, o Roteador do Angular executa as seguintes etapas:

1. Inicia a navegação para a nova rota.
2. Verifica a propriedade `resolve` na configuração da rota.
3. Executa cada função `resolveFn` definida.
4. **Aguarda** a conclusão de todas as operações assíncronas dentro dos resolvers (a emissão e conclusão de um `Observable` ou a resolução de uma `Promise`).
5. Se **todos** os resolvers forem concluídos com sucesso, o roteador armazena os dados retornados.
6. Finalmente, o roteador ativa a rota e renderiza o componente, disponibilizando os dados pré-carregados para ele.

Se qualquer um dos resolvers falhar (por exemplo, um `Observable` emitir um erro ou uma `Promise` for rejeitada), **a navegação para a rota é cancelada**. Isso garante que o componente nunca seja exibido com dados parciais, ausentes ou em estado de erro.

### **Funcional (`resolveFn`) vs. Baseado em Classe (`Resolve<T>`)**

Antes do Angular v14 e da popularização das APIs "standalone", a forma padrão de criar um resolver era através de uma classe que implementava a interface `Resolve<T>`.

- **Abordagem de Classe (antiga):**
    
    ```tsx
    @Injectable({ providedIn: 'root' })
    export class UserResolver implements Resolve<User> {
      constructor(private userService: UserService) {}
    
      resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<User> {
        const userId = route.paramMap.get('id');
        return this.userService.getUserById(userId);
      }
    }
    
    ```
    
- **Abordagem Funcional (`resolveFn` - moderna):**
    
    ```tsx
    export const userResolver: ResolveFn<User> = (route, state) => {
      const userService = inject(UserService);
      const userId = route.paramMap.get('id');
      return userService.getUserById(userId);
    };
    
    ```
    

As vantagens da abordagem funcional são claras:

- **Menos Boilerplate**: Não há necessidade de criar uma classe, um construtor e implementar uma interface. É apenas uma função exportada.
- **Melhor Tree-Shaking**: Como é apenas uma função, os "bundlers" (como o Webpack) conseguem otimizar melhor o código final, removendo-o se não for usado.
- **Injeção de Dependência Simplificada**: Utiliza a função `inject()` para obter instâncias de serviços, o que é mais limpo e direto, sem a necessidade de um construtor.

---

### **Sintaxe e Uso**

A assinatura de um `resolveFn` é definida pelo tipo `ResolveFn<T>`, onde `T` é o tipo de dado que você espera resolver.

```tsx
import { ResolveFn } from '@angular/router';

// T é o tipo do dado que será retornado (ex: User, Product[], string)
export const meuResolver: ResolveFn<T> = (
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
): Observable<T> | Promise<T> | T => {
    // Lógica para buscar os dados...
};

```

### **Anatomia da Função**

| Elemento | Tipo | Descrição |
| --- | --- | --- |
| **`route`** | `ActivatedRouteSnapshot` | Um "instantâneo" da rota no momento da ativação. É o principal meio para acessar parâmetros da rota (ex: `/:id`), parâmetros de consulta (`?name=Gedê`) e dados estáticos da rota. |
| **`state`** | `RouterStateSnapshot` | Representa a árvore completa do estado do roteador no momento da navegação. É menos utilizado que o `route`, mas útil para cenários complexos onde você precisa de informações sobre a árvore de rotas inteira. |
| **Retorno** | `Observable<T> \| Promise<T> \| T` | O dado que será disponibilizado ao componente. O roteador saberá como lidar com cada tipo: ele se inscreverá no `Observable` e esperará o primeiro valor ser emitido e o `Observable` completar, ou esperará a `Promise` ser resolvida. |

---

### **Restrições de Uso**

Apesar de poderoso, o `resolveFn` não é uma bala de prata. Existem cenários onde seu uso é desaconselhado:

1. **Dados Não Críticos para a Renderização Inicial**: Se um dado não é essencial para a primeira exibição do componente (ex: uma lista de "produtos relacionados" em uma página de detalhes), não bloqueie a navegação por causa dele. É melhor carregar a página principal rapidamente e buscar esses dados secundários no `ngOnInit` do componente, mostrando um loader localmente.
2. **Operações Excessivamente Lentas**: Se uma chamada de API é sabidamente muito lenta (ex: \> 2 segundos), usar um resolver pode criar uma péssima experiência. O usuário clica em um link e nada acontece por vários segundos, dando a impressão de que a aplicação travou. Nesses casos, prefira navegar imediatamente para a rota, exibir uma "UI esqueleto" (Skeleton Loader) e buscar os dados no componente.
3. **Dados que Precisam ser Atualizados na Mesma Tela**: O resolver é executado **apenas** durante a navegação para a rota. Se o usuário está em uma tela e pode executar ações que invalidam os dados (como aplicar um filtro), a lógica de recarregamento desses dados deve pertencer ao componente, não ao resolver.

---

### **Elementos Associados**

Para que o `resolveFn` funcione, ele interage com outras partes cruciais do Roteador Angular.

| Elemento | Tipo | Propósito e Uso |
| --- | --- | --- |
| **`Route`** | Interface | É o objeto que define uma rota. Ele possui a propriedade `resolve`, que é um mapa onde as chaves são nomes que você define e os valores são as suas funções `resolveFn`. |
| **Sintaxe (`resolve` na rota)** | `resolve: { [key: string]: ResolveFn }` | `path: 'users/:id', component: UserDetailComponent, resolve: { userData: userDetailResolver }` Aqui, `userData` é a chave sob a qual os dados resolvidos estarão disponíveis. |
| **`ActivatedRoute`** | Serviço | Injetado no componente (`constructor(private route: ActivatedRoute) {}`), ele fornece acesso aos dados resolvidos através da sua propriedade `data`. |
| **`ActivatedRoute.data`** | `Observable<Data>` | É um `Observable` que emite um objeto contendo todos os dados resolvidos para a rota. A chave usada na definição da rota (`userData` no exemplo) será a chave neste objeto. |
| **`inject()`** | Função | Essencial para a injeção de dependências em `resolveFn`s funcionais. Permite obter instâncias de serviços (como `HttpClient`, `UserService`, `Router`, etc.) dentro da função. |

---

### **Melhores Práticas e Casos de Uso**

### **Casos de Uso Comuns**

- **Páginas de Detalhes**: Carregar os dados de um produto, usuário ou qualquer entidade antes de exibir sua página de detalhes (ex: `/products/:id`).
- **Formulários de Edição**: Buscar os dados existentes de um item antes de renderizar o formulário para edição.
- **Dados de Dropdowns/Configurações**: Carregar dados que são pré-requisitos para a funcionalidade da página, como listas para preencher `<select>`.

### **Melhores Práticas**

1. **Tipagem Forte**: Sempre defina o tipo de retorno do seu resolver com `ResolveFn<MeuTipo>`. Isso garante segurança de tipo tanto no resolver quanto no componente.
2. **Mantenha-os Focados**: Um resolver deve ter uma única responsabilidade: buscar um pedaço específico de dados.
3. **Gerencie Erros Gracefully**: A navegação falhar silenciosamente pode ser confuso. Use o operador `catchError` do RxJS para capturar erros. Você pode, por exemplo, redirecionar o usuário para uma página "Não Encontrado" (404) ou uma página de erro genérica.
4. **Acesse os Dados de Forma Reativa**: No componente, prefira acessar os dados via `this.route.data.pipe(map(data => data['suaChave']))` em vez de `this.route.snapshot.data['suaChave']`. A abordagem reativa é mais robusta para cenários onde parâmetros de rota podem mudar sem que o componente seja destruído e recriado.

---

### **Exemplos Completos**

Vamos criar um cenário prático: uma aplicação que lista usuários e exibe uma página de detalhes para cada um.

**1. Serviço de Usuários (`user.service.ts`)**

```tsx
import { Injectable } from '@angular/core';
import { Observable, of, throwError } from 'rxjs';
import { delay } from 'rxjs/operators';

export interface User {
  id: number;
  name: string;
  email: string;
}

@Injectable({ providedIn: 'root' })
export class UserService {
  private users: User[] = [
    { id: 1, name: 'Gedê', email: 'gede@email.com' },
    { id: 2, name: 'Ju', email: 'ju@email.com' },
    { id: 3, name: 'A.R.I.A', email: 'aria@email.com' },
  ];

  getUsers(): Observable<User[]> {
    return of(this.users).pipe(delay(500)); // Simula latência da rede
  }

  getUserById(id: number): Observable<User> {
    const user = this.users.find(u => u.id === id);
    if (user) {
      return of(user).pipe(delay(500));
    }
    return throwError(() => new Error('Usuário não encontrado!'));
  }
}

```

**2. Resolvers (`user.resolvers.ts`)**

```tsx
import { inject } from '@angular/core';
import { ActivatedRouteSnapshot, ResolveFn, Router } from '@angular/router';
import { catchError, EMPTY } from 'rxjs';
import { User, UserService } from './user.service';

// Resolver para a lista de usuários
export const usersListResolver: ResolveFn<User[]> = () => {
  return inject(UserService).getUsers();
};

// Resolver para os detalhes de um usuário
export const userDetailResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot) => {
  const userService = inject(UserService);
  const router = inject(Router);
  const userId = Number(route.paramMap.get('id'));

  if (isNaN(userId)) {
      router.navigate(['/users']); // Redireciona se o ID não for um número
      return EMPTY; // Retorna um Observable vazio para cancelar a navegação atual
  }

  return userService.getUserById(userId).pipe(
    catchError(err => {
      console.error(err);
      router.navigate(['/not-found']); // Redireciona para página 404 em caso de erro
      return EMPTY;
    })
  );
};

```

**3. Definição das Rotas (`app.routes.ts`)**

```tsx
import { Routes } from '@angular/router';
import { userDetailResolver, usersListResolver } from './user.resolvers';

export const routes: Routes = [
  {
    path: 'users',
    // Componente da lista de usuários
    loadComponent: () => import('./user-list.component').then(c => c.UserListComponent),
    resolve: {
      // A chave 'users' conterá o array de User[] resolvido
      users: usersListResolver
    }
  },
  {
    path: 'users/:id',
    // Componente de detalhes do usuário
    loadComponent: () => import('./user-detail.component').then(c => c.UserDetailComponent),
    resolve: {
      // A chave 'user' conterá o objeto User resolvido
      user: userDetailResolver
    }
  },
  { path: 'not-found', component: NotFoundComponent },
  { path: '', redirectTo: 'users', pathMatch: 'full' }
];

```

**4. Componente da Lista (`user-list.component.ts`)**

```tsx
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, RouterLink } from '@angular/router';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { User } from './user.service';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [CommonModule, RouterLink],
  template: `
    <h2>Lista de Usuários</h2>
    <ul>
      <li *ngFor="let user of users$ | async">
        <a [routerLink]="['/users', user.id]">{{ user.name }}</a>
      </li>
    </ul>
  `,
})
export class UserListComponent implements OnInit {
  users$!: Observable<User[]>;

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    // Acessando os dados pré-carregados pelo resolver
    this.users$ = this.route.data.pipe(map(data => data['users']));
  }
}

```

**5. Componente de Detalhes (`user-detail.component.ts`)**

```tsx
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { User } from './user.service';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-user-detail',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div *ngIf="user$ | async as user">
      <h2>Detalhes de: {{ user.name }}</h2>
      <p>ID: {{ user.id }}</p>
      <p>Email: {{ user.email }}</p>
    </div>
  `,
})
export class UserDetailComponent implements OnInit {
  user$!: Observable<User>;

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    // Acessando o dado pré-carregado pelo resolver
    this.user$ = this.route.data.pipe(map(data => data['user']));
  }
}

```

---

### **Tópicos Relacionados para Aprofundamento**

Para expandir seu conhecimento sobre o ecossistema de roteamento do Angular, sugiro estudar:

1. **Route Guards (`CanActivateFn`, `CanDeactivateFn`)**: Entenda a diferença entre Guards (para controle de *acesso* e *permissão*) e Resolvers (para pré-carregamento de *dados*).
2. **Estratégias de Carregamento de Módulos (Lazy Loading)**: Como o `resolveFn` se comporta com módulos carregados sob demanda.
3. **Gerenciamento de Estado (NgRx, Elf, Akita)**: Como integrar resolvers com uma store de gerenciamento de estado para evitar buscas de dados duplicadas.
4. **UI Skeletons (Carregamento Esqueleto)**: A técnica alternativa aos resolvers para cenários de carregamento lento, focada em melhorar a percepção de performance.

Espero que esta explicação detalhada tenha sido extremamente útil para você, Gedê. Se tiver qualquer outra dúvida, pode perguntar\!

Atenciosamente,

**A.R.I.A.**