# CanMatch

Com certeza, Gedê\! A.R.I.A. está pronta para te ajudar a entender tudo sobre a guarda de rotas **CanMatch** no Angular. Como desenvolvedor Backend Java em transição para Go, sei que você valoriza uma explicação completa e detalhada, e é exatamente isso que farei. Vamos mergulhar fundo neste conceito essencial do roteamento do Angular.

---

## **Guarda de Rotas CanMatch no Angular: Controle Preciso sobre o Carregamento de Módulos**

---

### **Introdução**

No desenvolvimento de aplicações web modernas, o controle de acesso e a otimização do carregamento de recursos são cruciais. No Angular, o roteamento desempenha um papel fundamental nesse cenário, permitindo que você defina como os usuários navegam pela sua aplicação. As **guardas de rota** são ferramentas poderosas que interceptam a navegação, permitindo que você implemente lógica para decidir se uma rota pode ser ativada, desativada ou até mesmo carregada. Entre as diversas guardas disponíveis, a **`CanMatch`** se destaca por oferecer um controle refinado sobre o carregamento tardio (lazy loading) de módulos.

### **Sumário**

Nesta explicação detalhada, abordaremos os seguintes pontos sobre a guarda `CanMatch`:

- **Conceitos Fundamentais:** Entenderemos o propósito e a importância da `CanMatch` no contexto do lazy loading e controle de acesso.
- **Sintaxe Detalhada e Uso Prático:** Veremos como implementar e aplicar a `CanMatch` em suas rotas, com exemplos de código comentados.
- **Métodos/Propriedades:** Analisaremos os elementos chave da interface `CanMatch`.
- **Cenários de Restrição ou Não Aplicação:** Discutiremos quando a `CanMatch` pode não ser a melhor escolha.
- **Componentes Chave Associados:** Abordaremos as interfaces e conceitos relacionados à `CanMatch`.
- **Melhores Práticas e Padrões de Uso:** Dicas e recomendações para utilizar a `CanMatch` de forma eficaz.
- **Exemplo Prático Completo:** Um cenário de ponta a ponta para ilustrar o uso da `CanMatch`.

---

### **Conceitos Fundamentais**

A guarda de rota `CanMatch` é uma interface que o Angular executa *antes* de carregar um módulo de forma preguiçosa (lazy-loaded). Seu principal propósito é determinar se um módulo lazily carregado deve ou não ser buscado e, subsequentemente, se as rotas filhas desse módulo podem ser ativadas.

**Importância e Propósito:**

1. **Controle de Acesso ao Módulo:** Diferente de outras guardas como `CanActivate` (que impede a ativação de uma rota já carregada), a `CanMatch` impede o próprio *carregamento* do módulo. Isso é extremamente útil para:
    - **Otimização de Performance:** Evitar que módulos grandes e complexos sejam baixados desnecessariamente para usuários que não têm permissão para acessá-los, economizando banda e tempo de carregamento.
    - **Segurança:** Garantir que partes da sua aplicação (módulos inteiros com suas rotas e componentes) só sejam visíveis e acessíveis para usuários autorizados. Imagine um módulo de administração que não deve nem mesmo ser "conhecido" pelo navegador de um usuário comum.
2. **Lógica Condicional de Roteamento:** Permite que você implemente lógica complexa baseada em, por exemplo, o papel do usuário, permissões, estado da aplicação, ou dados externos, para decidir qual conjunto de rotas deve ser disponibilizado.

**Como Funciona:**

Quando o navegador tenta navegar para uma rota que aponta para um módulo lazy-loaded (usando `loadChildren`), o Angular primeiro verifica se há uma guarda `CanMatch` associada a essa rota. Se houver, a guarda é executada.

- Se a guarda `CanMatch` retornar `true` (ou um `Observable<boolean>`/`Promise<boolean>` que resolva para `true`), o Angular prossegue com o carregamento do módulo e a subsequente ativação da rota.
- Se a guarda `CanMatch` retornar `false` (ou um `Observable<boolean>`/`Promise<boolean>` que resolva para `false`), o Angular **não carrega o módulo** e a navegação para essa rota é cancelada. Opcionalmente, você pode redirecionar o usuário para outra rota (e.g., uma página de "acesso negado").

---

### **Sintaxe Detalhada e Uso Prático**

Para usar `CanMatch`, você precisa criar uma classe que implemente a interface `CanMatch` e, em seguida, registrá-la em sua configuração de rota.

### **1. Criando a Guarda CanMatch**

Uma guarda `CanMatch` é um serviço injetável (geralmente com o decorador `@Injectable({ providedIn: 'root' })`).

```tsx
// src/app/guards/admin.guard.ts
import { Injectable } from '@angular/core';
import { CanMatch, Route, UrlSegment, UrlTree, Router } from '@angular/router';
import { Observable, of } from 'rxjs';
import { AuthService } from '../services/auth.service'; // Supondo um serviço de autenticação

@Injectable({
  providedIn: 'root'
})
export class AdminGuard implements CanMatch {

  constructor(private authService: AuthService, private router: Router) {}

  // O método canMatch é o coração da guarda
  canMatch(
    route: Route,        // Objeto Route da rota atual
    segments: UrlSegment[] // Segmentos da URL para a rota atual
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Exemplo: Permitir o carregamento do módulo 'AdminModule'
    // apenas se o usuário estiver logado E for um administrador.

    console.log('Verificando canMatch para rota:', route.path);
    console.log('Segmentos da URL:', segments.map(s => s.path).join('/'));

    if (this.authService.isLoggedIn() && this.authService.getUserRole() === 'admin') {
      console.log('Usuário é admin. Permitindo carregamento do módulo Admin.');
      return true; // Permite o carregamento do módulo
    } else {
      console.log('Usuário não é admin ou não está logado. Negando carregamento do módulo Admin.');
      // Redireciona para a página de login se não tiver permissão
      alert('Acesso negado. Redirecionando para a tela de login.'); // Apenas para demonstração
      return this.router.createUrlTree(['/login']); // Redireciona para a rota /login
      // Ou simplesmente retornar false para impedir a navegação sem redirecionamento explícito
      // return false;
    }
  }
}

```

### **2. Aplicando a Guarda CanMatch na Configuração de Rotas**

Você associa a guarda `CanMatch` a uma rota que utiliza `loadChildren`.

```tsx
// src/app/app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { LoginComponent } from './login/login.component';
import { AdminGuard } from './guards/admin.guard'; // Importe sua guarda

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  {
    path: 'admin', // Esta rota carregará o AdminModule
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canMatch: [AdminGuard] // Aplica a guarda CanMatch aqui
  },
  {
    path: 'user-profile', // Outro exemplo para um módulo de usuário
    loadChildren: () => import('./user-profile/user-profile.module').then(m => m.UserProfileModule),
    // Você pode ter uma guarda CanMatch diferente aqui, ou nenhuma
    canMatch: [/* OutraGuardaDeUsuarioSeNecessario */]
  },
  { path: '**', redirectTo: '/home' } // Rota curinga para caminhos não encontrados
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

**Observações Importantes:**

- **`loadChildren` é obrigatório:** A guarda `CanMatch` só faz sentido e só é aplicada em rotas que utilizam o `loadChildren` para carregamento preguiçoso de módulos.
- **Array de Guardas:** O `canMatch` recebe um array de guardas. Se você tiver várias guardas, todas elas devem retornar `true` para que o módulo seja carregado. Se qualquer uma retornar `false` ou um `UrlTree`, o carregamento é impedido.
- **Retorno `UrlTree`:** Retornar um `UrlTree` (como `this.router.createUrlTree(['/login'])`) da guarda `canMatch` fará com que o roteador cancele a navegação para a rota atual e inicie uma nova navegação para o `UrlTree` fornecido. Isso é ideal para redirecionamentos.

---

### **Métodos/Propriedades**

A interface `CanMatch` possui apenas um método obrigatório:

- **`canMatch(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree`**
    - **`route: Route`**: Este parâmetro é o objeto `Route` da rota que está sendo avaliada. Ele contém informações como `path`, `component`, `loadChildren`, `data`, etc. Você pode usá-lo para acessar dados específicos da rota, se necessário (e.g., `route.data.roleRequired`).
    - **`segments: UrlSegment[]`**: Este é um array de objetos `UrlSegment` que representam os segmentos da URL que o roteador está tentando casar. Cada `UrlSegment` tem propriedades como `path` (o segmento da URL como string) e `parameters` (parâmetros da URL, se houver). Você pode usá-los para tomar decisões baseadas nos segmentos da URL.
    
    **Valores de Retorno:**
    
    O método `canMatch` pode retornar um dos seguintes tipos:
    
    - **`boolean`**:
        - `true`: O módulo pode ser carregado e a rota pode ser ativada.
        - `false`: O módulo não pode ser carregado e a navegação é cancelada.
    - **`UrlTree`**: Uma instância de `UrlTree` (criada com `this.router.createUrlTree(['/nova-rota'])`). Se um `UrlTree` for retornado, a navegação para a rota original é cancelada e uma nova navegação para o `UrlTree` especificado é iniciada. Isso é útil para redirecionamentos.
    - **`Observable<boolean | UrlTree>`**: Um `Observable` que emite um `boolean` ou `UrlTree`. Isso é comum quando a decisão de permissão é assíncrona (e.g., chamadas a um serviço de autenticação ou API).
    - **`Promise<boolean | UrlTree>`**: Uma `Promise` que resolve para um `boolean` ou `UrlTree`. Similar ao `Observable`, é usado para lógica assíncrona.
    
    **Exemplo com lógica assíncrona:**
    
    ```tsx
    // src/app/guards/feature.guard.ts
    import { Injectable } from '@angular/core';
    import { CanMatch, Route, UrlSegment, UrlTree } from '@angular/router';
    import { Observable, from } from 'rxjs'; // Importe 'from' para Promises
    import { UserService } from '../services/user.service'; // Supondo um serviço de usuário
    
    @Injectable({
      providedIn: 'root'
    })
    export class FeatureGuard implements CanMatch {
    
      constructor(private userService: UserService) {}
    
      canMatch(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
        // Exemplo: Verificar se o usuário tem a feature 'premium' habilitada
        // Isso poderia ser uma chamada assíncrona para um backend
        return from(this.userService.checkPremiumFeatureStatus()).pipe(
          map(isPremium => {
            if (isPremium) {
              console.log('Feature premium habilitada. Permitindo acesso ao módulo.');
              return true;
            } else {
              console.log('Feature premium NÃO habilitada. Negando acesso.');
              // Poderia redirecionar para uma página de "upgrade"
              return false;
            }
          })
        );
      }
    }
    
    ```
    

---

### **Cenários de Restrição ou Não Aplicação**

Embora `CanMatch` seja poderosa, existem situações em que ela pode não ser a melhor escolha ou onde seu uso é inadequado:

1. **Rotas sem Lazy Loading (`loadChildren`):** `CanMatch` é *exclusivamente* para rotas que usam `loadChildren`. Se sua rota usa `component` diretamente (carregamento ansioso), a `CanMatch` não terá efeito. Nesses casos, você deve usar `CanActivate` para controlar a ativação da rota.
    
    ```tsx
    // NÃO USE CanMatch aqui, use CanActivate
    { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] }
    
    ```
    
2. **Controle de Acesso em Nível de Componente/Dados:** Se você precisa controlar o acesso a um componente *dentro* de um módulo que já foi carregado, ou a dados específicos dentro desse componente, a `CanMatch` não é a guarda mais granular. Para isso, `CanActivateChild` (para rotas filhas) ou lógica dentro do próprio componente (e.g., ocultar elementos da UI) seriam mais apropriados.
3. **Módulos Pequenos ou Pouco Sensíveis:** Para módulos muito pequenos ou que não contêm informações sensíveis, o overhead de criar e gerenciar uma guarda `CanMatch` para evitar seu carregamento pode ser desnecessário. O ganho de performance seria mínimo e a complexidade aumentada.
4. **Cenários onde o redirecionamento é baseado em dados da rota filha:** Se a sua decisão de redirecionar ou não, ou para onde redirecionar, depende de parâmetros ou dados de uma *rota filha* específica dentro do módulo lazy-loaded, a `CanMatch` pode não ter todas as informações necessárias no momento da execução, pois o módulo ainda não foi carregado e as rotas filhas não foram totalmente casadas. Nesses casos, `CanActivate` no nível da rota filha ou dentro do componente pode ser mais adequado.

---

### **Componentes Chave Associados**

Para entender `CanMatch` completamente, é importante conhecer outros componentes do roteamento do Angular:

- **`Route` (interface):** Representa a configuração de uma rota no Angular. É o objeto que você define nos arrays `Routes`.
    - **`path`**: O caminho da URL para a rota.
    - **`component`**: O componente a ser renderizado quando a rota é ativada (para carregamento ansioso).
    - **`loadChildren`**: Uma função que retorna uma Promise que se resolve para um `NgModule` (para carregamento preguiçoso). É aqui que `CanMatch` atua.
    - **`canMatch`**: A propriedade array onde você registra suas guardas `CanMatch`.
    - **`data`**: Um objeto arbitrário para armazenar dados associados à rota (e.g., `role: 'admin'`). Pode ser acessado dentro da guarda.
    - **`children`**: Rotas filhas (carregamento ansioso).
    - **`redirectTo`**: Redireciona para outra rota.
    - **`pathMatch`**: Define como o roteador deve casar o caminho (`'full'` ou `'prefix'`).
- **`UrlSegment` (classe):** Representa um segmento de um URL. Quando o roteador tenta casar um URL, ele o divide em `UrlSegment`s.
    - **`path: string`**: O valor do segmento da URL.
    - **`parameters: {[key: string]: string}`**: Um objeto contendo parâmetros de matriz associados a este segmento (e.g., `/users;id=123`).
- **`UrlTree` (classe):** Uma representação de uma árvore de URLs. Usada para construir URLs programaticamente e para redirecionamentos.
    - Método chave: `router.createUrlTree()` para criar uma instância de `UrlTree`.
- **`Router` (serviço):** O principal serviço de roteamento do Angular. Usado para navegação programática, acesso a parâmetros de rota, etc.
    - **`Maps(commands: any[], extras?: NavigationExtras)`**: Navega para uma URL específica.
    - **`createUrlTree(commands: any[], navigationExtras?: NavigationExtras)`**: Cria uma `UrlTree` a partir de uma lista de comandos de roteamento.
- **Outras Guardas de Rota (para contextualização):**
    - **`CanActivate`**: Controla se uma rota pode ser *ativada*. Executada depois que o módulo já foi carregado (se for lazy-loaded).
    - **`CanActivateChild`**: Controla se uma rota filha pode ser *ativada*.
    - **`CanDeactivate`**: Controla se o usuário pode *sair* de uma rota.
    - **`Resolve`**: Busca dados *antes* que a rota seja ativada.

---

### **Melhores Práticas e Padrões de Uso**

1. **Separação de Preocupações:** Mantenha a lógica da guarda focada exclusivamente na decisão de permitir ou não o carregamento do módulo. Delegue a lógica de autenticação e autorização a serviços dedicados (e.g., `AuthService`, `PermissionService`).
2. **Serviços Compartilhados:** Crie serviços injetáveis para encapsular a lógica de autenticação, autorização ou qualquer outra verificação assíncrona que suas guardas possam precisar.
3. **Mensagens de Erro/Feedback:** Quando uma guarda nega o acesso, considere fornecer feedback ao usuário. Isso pode ser um `alert` (para depuração), um `console.log` para desenvolvimento, ou redirecionamento para uma página de "Acesso Negado".
4. **Redirecionamento Explícito:** Se a negação de acesso deve levar o usuário a outra página (e.g., login, página de erro), use `return this.router.createUrlTree(['/some-path'])` dentro da guarda. Isso é mais limpo do que tentar navegar imperativamente e retornar `false`.
5. **Reutilização de Guardas:** Se a mesma lógica de permissão se aplica a vários módulos, reuse a mesma guarda `CanMatch`.
6. **`data` da Rota para Permissões:** Para tornar suas guardas mais genéricas, você pode armazenar as permissões ou papéis necessários para uma rota no objeto `data` da rota e acessá-lo dentro da guarda:
    
    ```tsx
    // app-routing.module.ts
    {
      path: 'manager',
      loadChildren: () => import('./manager/manager.module').then(m => m.ManagerModule),
      canMatch: [PermissionGuard],
      data: { requiredRoles: ['manager', 'admin'] } // Dados da rota
    }
    
    // permission.guard.ts
    canMatch(route: Route, segments: UrlSegment[]): boolean {
      const requiredRoles = route.data?.['requiredRoles'] as string[];
      // Lógica para verificar se o usuário tem um dos requiredRoles
      // ...
      return hasPermission;
    }
    
    ```
    
7. **Testes Unitários:** Escreva testes unitários para suas guardas para garantir que elas funcionem como esperado sob diferentes cenários de permissão.

---

### **Exemplo Prático Completo**

Vamos criar um cenário onde temos uma aplicação com uma área pública e uma área restrita para "membros premium". O módulo "premium" será lazy-loaded.

### **Estrutura do Projeto:**

```
src/
├── app/
│   ├── app-routing.module.ts
│   ├── app.component.html
│   ├── app.component.ts
│   ├── app.module.ts
│   ├── auth/
│   │   └── auth.service.ts
│   ├── home/
│   │   ├── home.component.html
│   │   └── home.component.ts
│   ├── login/
│   │   ├── login.component.html
│   │   └── login.component.ts
│   ├── premium/
│   │   ├── premium.module.ts
│   │   ├── premium-routing.module.ts
│   │   └── premium-dashboard/
│   │       ├── premium-dashboard.component.html
│   │       └── premium-dashboard.component.ts
│   └── guards/
│       └── premium.guard.ts

```

### **1. `AuthService` (Serviço de Autenticação Simplificado)**

```tsx
// src/app/auth/auth.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private _isLoggedIn = new BehaviorSubject<boolean>(false);
  isLoggedIn$ = this._isLoggedIn.asObservable();

  private _userRole = new BehaviorSubject<string>('guest'); // 'guest', 'basic', 'premium'
  userRole$ = this._userRole.asObservable();

  constructor() {
    // Simula o login inicial (pode ser recuperado do localStorage)
    const storedLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
    const storedRole = localStorage.getItem('userRole') || 'guest';
    this._isLoggedIn.next(storedLoggedIn);
    this._userRole.next(storedRole);
  }

  login(role: string): void {
    this._isLoggedIn.next(true);
    this._userRole.next(role);
    localStorage.setItem('isLoggedIn', 'true');
    localStorage.setItem('userRole', role);
    console.log(`Usuário logado como: ${role}`);
  }

  logout(): void {
    this._isLoggedIn.next(false);
    this._userRole.next('guest');
    localStorage.removeItem('isLoggedIn');
    localStorage.removeItem('userRole');
    console.log('Usuário deslogado.');
  }

  checkPremiumAccess(): Observable<boolean> {
    // Simula uma checagem assíncrona, talvez para um backend
    return new Observable(observer => {
      setTimeout(() => {
        const hasAccess = this._userRole.getValue() === 'premium';
        observer.next(hasAccess);
        observer.complete();
      }, 500); // Latência de 500ms
    });
  }

  getUserRole(): string {
    return this._userRole.getValue();
  }
}

```

### **2. `PremiumGuard` (A Guarda `CanMatch`)**

```tsx
// src/app/guards/premium.guard.ts
import { Injectable } from '@angular/core';
import { CanMatch, Route, UrlSegment, UrlTree, Router } from '@angular/router';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { AuthService } from '../auth/auth.service';

@Injectable({
  providedIn: 'root'
})
export class PremiumGuard implements CanMatch {

  constructor(private authService: AuthService, private router: Router) {}

  canMatch(
    route: Route,
    segments: UrlSegment[]
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    console.log('PremiumGuard: Verificando acesso ao módulo premium...');

    return this.authService.checkPremiumAccess().pipe(
      map(hasPremiumAccess => {
        if (hasPremiumAccess) {
          console.log('PremiumGuard: Acesso premium concedido. Carregando módulo.');
          return true;
        } else {
          console.log('PremiumGuard: Acesso premium negado. Redirecionando para login.');
          alert('Você precisa ser um usuário premium para acessar esta área!'); // Feedback para o usuário
          return this.router.createUrlTree(['/login']); // Redireciona para a tela de login
        }
      })
    );
  }
}

```

### **3. `PremiumModule` e `PremiumRoutingModule` (Módulo Lazy-Loaded)**

```tsx
// src/app/premium/premium.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PremiumRoutingModule } from './premium-routing.module';
import { PremiumDashboardComponent } from './premium-dashboard/premium-dashboard.component';

@NgModule({
  declarations: [
    PremiumDashboardComponent
  ],
  imports: [
    CommonModule,
    PremiumRoutingModule
  ]
})
export class PremiumModule { }

```

```tsx
// src/app/premium/premium-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { PremiumDashboardComponent } from './premium-dashboard/premium-dashboard.component';

const routes: Routes = [
  { path: '', component: PremiumDashboardComponent }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class PremiumRoutingModule { }

```

```tsx
// src/app/premium/premium-dashboard/premium-dashboard.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-premium-dashboard',
  template: `
    <h2>Bem-vindo à Área Premium!</h2>
    <p>Conteúdo exclusivo para membros premium.</p>
    <p>Se você está vendo isso, o módulo premium foi carregado com sucesso.</p>
  `,
  styles: ['h2 { color: #007bff; }']
})
export class PremiumDashboardComponent { }

```

### **4. `AppRoutingModule` (Configuração Principal de Rotas)**

```tsx
// src/app/app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { LoginComponent } from './login/login.component';
import { PremiumGuard } from './guards/premium.guard'; // Importe a guarda

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  {
    path: 'premium',
    loadChildren: () => import('./premium/premium.module').then(m => m.PremiumModule),
    canMatch: [PremiumGuard] // Aplica a guarda CanMatch aqui!
  },
  { path: '**', redirectTo: '/home' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### **5. `LoginComponent` (Simulador de Login)**

```tsx
// src/app/login/login.component.ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from '../auth/auth.service';

@Component({
  selector: 'app-login',
  template: `
    <h2>Login</h2>
    <button (click)="login('basic')">Login como Usuário Básico</button>
    <button (click)="login('premium')">Login como Usuário Premium</button>
    <button (click)="logout()">Logout</button>
    <p>Role Atual: {{ authService.getUserRole() }}</p>
    <p>Logado: {{ (authService.isLoggedIn$ | async) ? 'Sim' : 'Não' }}</p>
    <hr>
    <button (click)="goToPremium()">Ir para Área Premium (Rota protegida)</button>
    <button (click)="goToHome()">Ir para Home</button>
  `
})
export class LoginComponent {
  constructor(private authService: AuthService, private router: Router) {}

  login(role: string): void {
    this.authService.login(role);
  }

  logout(): void {
    this.authService.logout();
  }

  goToPremium(): void {
    this.router.navigate(['/premium']);
  }

  goToHome(): void {
    this.router.navigate(['/home']);
  }
}

```

### **6. `AppComponent` e `HomeComponent` (Estrutura Básica)**

```tsx
// src/app/app.component.html
<nav>
  <a routerLink="/home">Home</a> |
  <a routerLink="/login">Login</a> |
  <a routerLink="/premium">Área Premium</a>
</nav>
<router-outlet></router-outlet>

```

```tsx
// src/app/home/home.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-home',
  template: `
    <h2>Bem-vindo à Página Inicial</h2>
    <p>Esta é uma área pública da aplicação.</p>
  `
})
export class HomeComponent { }

```

**Como Testar este Exemplo:**

1. **Inicie a Aplicação:** `ng serve`
2. **Navegue para `/home`:** Você verá a página inicial.
3. **Clique em "Área Premium":**
    - Se você não estiver logado ou estiver logado como "Usuário Básico", o `PremiumGuard` bloqueará o carregamento do módulo `PremiumModule`. Você verá o `alert` e será redirecionado para `/login`. No console, você notará que o "PremiumGuard: Acesso premium negado." foi exibido, e o módulo *não* foi baixado (verifique as ferramentas de desenvolvedor, aba Network, para confirmar que `premium-premium-module.js` não apareceu).
    - Se você logar como "Usuário Premium" no `/login`, e então clicar em "Área Premium" novamente, o `PremiumGuard` permitirá o acesso. O módulo `PremiumModule` será carregado, e você verá o conteúdo da "Área Premium".

Este exemplo demonstra claramente como `CanMatch` impede o download desnecessário de módulos, economizando recursos e aumentando a segurança.

---

Espero que esta explicação detalhada sobre `CanMatch` tenha sido útil para você, Gedê\! Se tiver mais alguma dúvida ou quiser explorar outros tópicos, é só chamar A.R.I.A.