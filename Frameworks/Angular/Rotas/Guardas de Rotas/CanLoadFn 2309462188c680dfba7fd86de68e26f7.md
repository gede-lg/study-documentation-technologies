# CanLoadFn

Olá Gedê\! Como A.R.I.A (Assistente Rápida para Idiotas Atarefados), preparei uma explicação extremamente detalhada sobre o `CanLoadFn` no Angular, exatamente como você pediu. Vamos mergulhar fundo neste importante conceito de rotas.

---

### **Título: Dominando o `CanLoadFn`: O Guardião do Carregamento de Módulos no Angular**

---

### **Introdução**

No ecossistema de desenvolvimento de aplicações web modernas, a otimização do desempenho é crucial. Uma das técnicas mais eficazes para alcançar uma aplicação rápida e responsiva é o *Lazy Loading* (Carregamento Preguiçoso) de módulos. O Angular oferece um suporte robusto para essa técnica, permitindo que partes da sua aplicação sejam carregadas sob demanda. Nesse contexto, surge a necessidade de controlar *se* um módulo pode ou não ser carregado. É exatamente aqui que o `CanLoadFn`, um tipo de guarda de rota (Route Guard), desempenha seu papel fundamental, atuando como um porteiro que decide se o código de um módulo pode ser baixado e carregado pelo navegador.

---

### **Sumário**

Este guia completo explora o `CanLoadFn`, um guarda de rota do Angular projetado especificamente para proteger o carregamento de módulos configurados com *Lazy Loading*. Abordaremos desde seus conceitos fundamentais e propósito, passando pela sua sintaxe e implementação prática. Detalharemos os elementos associados, como a configuração de rotas `loadChildren`, e discutiremos as melhores práticas e casos de uso comuns, como controle de acesso baseado em autenticação e perfil de usuário. Ao final, você terá uma compreensão sólida de como e quando utilizar o `CanLoadFn` para criar aplicações Angular mais seguras e eficientes.

---

### **Conceitos Fundamentais**

### **O que é um Guarda de Rota (Route Guard)?**

No Angular, um guarda de rota é uma funcionalidade que permite executar uma lógica antes que uma navegação de rota aconteça. Eles são funções que retornam `true` (permitindo a navegação), `false` (bloqueando a navegação) ou um `UrlTree` (redirecionando para outra rota). Existem diferentes tipos de guardas, cada um atuando em um momento específico do ciclo de vida da navegação.

### **O Propósito Específico do `CanLoadFn`**

Dentre os guardas de rota, o `CanLoad` (e sua forma funcional, `CanLoadFn`) é único. Seu propósito exclusivo é **impedir o carregamento do código de um módulo de *Lazy Loading***.

Isso é diferente de outros guardas como o `CanActivate`. Veja a diferença crucial:

- **`CanActivate`**: Decide se uma rota pode ser *ativada*. Se um módulo associado a essa rota ainda não foi carregado, o `CanActivate` será executado **após** o download do código do módulo. Ele protege o acesso ao componente, mas não o carregamento do código.
- **`CanLoad`**: Decide se o código de um módulo pode ser *carregado* (baixado). Ele é executado **antes** que o Angular tente fazer o download dos arquivos do módulo. Se o `CanLoadFn` retornar `false`, o código do módulo nunca chega ao navegador, economizando banda e processamento.

**Por que isso é importante?**
Imagine um painel administrativo (`AdminModule`) em sua aplicação. Este módulo pode ser grande e conter lógica de negócios sensível. Um usuário comum não precisa (e não deveria) ter acesso a ele.

1. **Sem `CanLoad`**: Se você usar apenas `CanActivate`, quando o usuário comum tentar acessar uma rota de admin, o Angular primeiro fará o download de todo o `AdminModule` e só então o `CanActivate` bloqueará o acesso. O usuário não verá a página, mas o código já foi exposto e a banda já foi consumida.
2. **Com `CanLoad`**: Se você usar `CanLoad`, quando o usuário tentar acessar a rota, o guarda será executado *primeiro*. Ao detectar que o usuário não é um administrador, ele retornará `false`. O Angular cancelará a operação e o código do `AdminModule` **nunca será baixado**. Isso é mais seguro e mais performático.

---

### **Sintaxe e Uso**

Desde o Angular 14, a preferência tem sido para a criação de guardas funcionais, que são mais simples e fáceis de testar. O `CanLoadFn` é a tipagem para um guarda `canLoad` funcional.

### **Definição da Função (`CanLoadFn`)**

A assinatura de um `CanLoadFn` é a seguinte:

```tsx
type CanLoadFn = (route: Route, segments: UrlSegment[]) =>
  Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;

```

Vamos quebrar os parâmetros e o tipo de retorno:

- **`route: Route`**: Um objeto que contém a configuração da rota que está tentando ser carregada. É útil para acessar dados estáticos (`data`), o `path`, etc.
- **`segments: UrlSegment[]`**: Um array dos segmentos de URL que correspondem a esta rota.

O retorno da função pode ser:

- `boolean`: `true` para permitir o carregamento, `false` para bloquear.
- `UrlTree`: Para redirecionar o usuário para outra rota caso o carregamento seja bloqueado.
- `Observable<boolean | UrlTree>` ou `Promise<boolean | UrlTree>`: Para cenários assíncronos, como fazer uma chamada HTTP para verificar permissões de usuário.

### **Exemplo Prático e Comentado**

Vamos criar um guarda funcional que verifica se um usuário está autenticado e tem a permissão ('role') de 'ADMIN'.

**1. Crie o arquivo do guarda (ex: `auth.guard.ts`)**

```tsx
import { inject } from '@angular/core';
import { CanLoadFn, Route, Router, UrlSegment, UrlTree } from '@angular/router';
import { Observable, of } from 'rxjs';
import { map, take } from 'rxjs/operators';
import { AuthService } from './auth.service'; // Um serviço hipotético de autenticação

export const canLoadAdmin: CanLoadFn = (
  route: Route,
  segments: UrlSegment[]
): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree => {

  // Injeta o serviço de autenticação e o roteador usando a função inject()
  const authService = inject(AuthService);
  const router = inject(Router);

  // O AuthService.user$ é um Observable que emite o usuário logado
  return authService.user$.pipe(
    take(1), // Pega apenas a primeira emissão para evitar que o guarda fique "escutando"
    map(user => {
      // Verifica se o usuário existe e se sua role é 'ADMIN'
      const isAdmin = !!user && user.role === 'ADMIN';

      if (isAdmin) {
        console.log('Acesso de Admin permitido. Carregando módulo...');
        return true; // Permite o carregamento do módulo
      } else {
        console.log('Acesso negado. Redirecionando para /login');
        // Se não for admin, cria uma UrlTree para redirecionar para a página de login
        return router.createUrlTree(['/login']);
      }
    })
  );
};

```

**2. Aplique o guarda na sua configuração de rotas (ex: `app-routing.module.ts`)**

```tsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { canLoadAdmin } from './guards/auth.guard'; // Importe o guarda funcional

const routes: Routes = [
  // ... outras rotas
  {
    path: 'admin',
    // A propriedade 'canLoad' recebe um array de guardas
    canLoad: [canLoadAdmin],
    // loadChildren aponta para o módulo a ser carregado preguiçosamente
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  },
  {
    path: 'login',
    // ... componente de login
  }
  // ... outras rotas
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

Neste exemplo, quando um usuário tentar navegar para qualquer URL que comece com `/admin`, o guarda `canLoadAdmin` será executado. Ele verificará o status de autenticação e o perfil do usuário de forma assíncrona. Somente se o usuário for um administrador, o Angular prosseguirá com o download do `admin.module.ts`. Caso contrário, o usuário será redirecionado para `/login` e o código do módulo de admin permanecerá no servidor, intocado.

---

### **Métodos/Propriedades**

O `CanLoadFn` em si é uma função, não uma classe, então não possui métodos ou propriedades intrínsecas. No entanto, ele recebe parâmetros (`route` e `segments`) que possuem suas próprias propriedades úteis.

| Objeto | Propriedade | Tipo | Descrição |
| --- | --- | --- | --- |
| `Route` | `path` | `string` | O caminho (path) da rota definido na configuração (ex: `'admin'`). |
| `Route` | `data` | `Data` (um objeto `[key: string]: any`) | Um objeto para passar dados estáticos para a rota. Útil para, por exemplo, passar a `role` esperada para o guarda, tornando-o reutilizável. Ex: `data: { expectedRole: 'ADMIN' }`. |
| `Route` | `pathMatch` | `'prefix' \| 'full'` | Estratégia de correspondência de caminho. |
| `Route` | `component` | `Type<any>` | O componente associado à rota (não aplicável em rotas com `loadChildren`). |
| `Route` | `redirectTo` | `string` | URL para redirecionamento. |
| `Route` | `children` | `Routes` | Um array de definições de rotas filhas. |
| `Route` | `loadChildren` | `LoadChildren` | A função que carrega o módulo preguiçosamente. |
| `UrlSegment` | `path` | `string` | O fragmento de URL que este segmento representa. |
| `UrlSegment` | `parameters` | `{ [name: string]: string }` | Parâmetros de matriz da URL associados a este segmento. |

**Exemplo de uso das propriedades:**

Para tornar o guarda mais genérico, podemos usar a propriedade `data` da rota.

```tsx
// Em app-routing.module.ts
{
  path: 'manager',
  canLoad: [canLoadBasedOnRole],
  data: { expectedRole: 'MANAGER' }, // Passando a role esperada
  loadChildren: () => import('./manager/manager.module').then(m => m.ManagerModule)
}

// Em auth.guard.ts
export const canLoadBasedOnRole: CanLoadFn = (route: Route, segments: UrlSegment[]) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  const expectedRole = route.data?.['expectedRole']; // Acessando a role de 'data'

  return authService.user$.pipe(
    map(user => {
      if (user && user.role === expectedRole) {
        return true;
      }
      return router.createUrlTree(['/unauthorized']);
    })
  );
};

```

---

### **Restrições de Uso**

O `CanLoadFn` é poderoso, mas deve ser usado no cenário correto.

- **Apenas para Módulos com `loadChildren`**: A restrição mais importante é que `CanLoad` **só funciona** em rotas que usam a propriedade `loadChildren` para carregamento preguiçoso. Ele não tem efeito em rotas que carregam componentes diretamente (eager loading) através da propriedade `component`. O Angular simplesmente ignora o guarda `canLoad` nessas rotas.
- **Execução Única**: O guarda `CanLoad` é executado apenas **uma vez**, na primeira vez que se tenta carregar o módulo. Depois que o módulo é carregado com sucesso, o guarda não será mais invocado para navegações subsequentes para dentro daquele módulo. Se você precisar de uma verificação a cada navegação para uma rota específica *dentro* de um módulo já carregado, você deve usar o `CanActivate`. É comum usar ambos em conjunto: `CanLoad` para proteger o carregamento inicial e `CanActivate` para proteger o acesso a rotas específicas dentro do módulo.

---

### **Elementos Associados**

| Elemento | Tipo | Propósito | Sintaxe/Uso |
| --- | --- | --- | --- |
| **`Routes`** | Interface/Array | A configuração principal das rotas da sua aplicação. É aqui que você aplica o `CanLoadFn`. | `const routes: Routes = [...];` |
| **`loadChildren`** | Propriedade de Rota | Define uma função que o roteador Angular usa para carregar um módulo de forma assíncrona (Lazy Loading). | `loadChildren: () => import('./path/to/module').then(m => m.MyModule)` |
| **`canLoad`** | Propriedade de Rota | Um array de guardas que devem ser executados antes do carregamento do módulo definido em `loadChildren`. | `canLoad: [myCanLoadGuardFn]` |
| **`UrlTree`** | Classe | Uma representação de uma URL. É retornada por um guarda para instruir o roteador a cancelar a navegação atual e navegar para a URL representada por esta árvore. | `return router.createUrlTree(['/login']);` |
| **`inject()`** | Função | Uma função do core do Angular usada para injetar dependências (como serviços ou o `Router`) dentro de contextos de injeção, como em guardas funcionais. | `const myService = inject(MyService);` |

---

### **Melhores Práticas e Casos de Uso**

1. **Controle de Acesso Baseado em Permissões (Roles)**:
    - **Caso de Uso**: O cenário mais clássico. Impedir que usuários não administradores ou sem uma permissão específica sequer façam o download do código de módulos privilegiados (Ex: Painel de Admin, Módulo de Finanças, Ferramentas de Moderação).
    - **Melhor Prática**: Combine `CanLoad` (para proteger o download do módulo) com `CanActivate` (para proteger rotas internas do módulo, caso as permissões possam mudar enquanto o usuário está na aplicação).
2. **Aplicações com Módulos Pagos (Feature Flags)**:
    - **Caso de Uso**: Sua aplicação tem funcionalidades "premium" que estão em um módulo separado. Você pode usar o `CanLoad` para verificar se o usuário tem uma assinatura ativa antes de carregar o código dessas funcionalidades.
    - **Melhor Prática**: A lógica do guarda pode consultar um serviço que verifica o plano do usuário. Isso evita que usuários do plano gratuito baixem código que nunca poderão usar.
3. **Otimização de Desempenho em Dispositivos Móveis**:
    - **Caso de Uso**: Em uma PWA (Progressive Web App), você pode querer evitar o carregamento de módulos muito pesados em conexões de dados lentas ou em dispositivos com pouca memória, a menos que o usuário explicitamente solicite.
    - **Melhor Prática**: O guarda poderia, teoricamente, verificar a API de Conexão de Rede do navegador e decidir se o carregamento deve prosseguir.
4. **Manter os Guardas Simples e Focados**:
    - **Melhor Prática**: Cada guarda deve ter uma única responsabilidade. Em vez de um guarda monolítico que verifica autenticação, permissões e status da conta, crie guardas separados (`canLoadAuthenticated`, `canLoadAdminRole`, etc.) e aplique-os em sequência no array `canLoad`. O roteador os executará na ordem.

---

### **Exemplos Completos**

Vamos montar um cenário um pouco mais complexo. Uma aplicação com um módulo de "Dashboard" para usuários logados e um módulo de "Settings" para administradores.

**`auth.service.ts` (Serviço de Autenticação Simulado)**

```tsx
import { Injectable } from '@angular/core';
import { BehaviorSubject, delay, of } from 'rxjs';

export interface User {
  name: string;
  role: 'USER' | 'ADMIN';
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  // BehaviorSubject para simular um usuário logado que pode mudar
  private userSubject = new BehaviorSubject<User | null>(null);
  user$ = this.userSubject.asObservable();

  loginAsAdmin() {
    // Simula um login de admin após 100ms
    of({ name: 'Admin Gedê', role: 'ADMIN' as const }).pipe(delay(100))
      .subscribe(user => this.userSubject.next(user));
  }

  loginAsUser() {
    // Simula um login de usuário comum
    of({ name: 'User Ju', role: 'USER' as const }).pipe(delay(100))
      .subscribe(user => this.userSubject.next(user));
  }

  logout() {
    this.userSubject.next(null);
  }
}

```

**`auth.guard.ts` (Guarda Funcional Reutilizável)**

```tsx
import { inject } from '@angular/core';
import { CanLoadFn, Route, Router, UrlTree } from '@angular/router';
import { map, take } from 'rxjs/operators';
import { AuthService } from './auth.service';

// Guarda para verificar se o usuário está apenas autenticado
export const canLoadAuthenticated: CanLoadFn = () => {
  const authService = inject(AuthService);
  const router = inject(Router);

  return authService.user$.pipe(
    take(1),
    map(user => {
      if (!!user) {
        return true; // Se existe usuário, permite carregar
      }
      return router.createUrlTree(['/login']); // Senão, redireciona
    })
  );
};

// Guarda que usa a propriedade 'data' para verificar a role
export const canLoadWithRole: CanLoadFn = (route: Route) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  const expectedRole = route.data?.['expectedRole'];

  if (!expectedRole) {
    throw new Error('A propriedade "expectedRole" não foi fornecida nos dados da rota.');
  }

  return authService.user$.pipe(
    take(1),
    map(user => {
      if (!!user && user.role === expectedRole) {
        return true; // Se o usuário tem a role esperada, permite carregar
      }
      // Se não tiver a role, redireciona para uma página de "acesso negado"
      return router.createUrlTree(['/unauthorized']);
    })
  );
};

```

**`app-routing.module.ts` (Configuração das Rotas)**

```tsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { canLoadAuthenticated, canLoadWithRole } from './auth.guard';
import { LoginComponent } from './login.component';
import { UnauthorizedComponent } from './unauthorized.component';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { path: 'unauthorized', component: UnauthorizedComponent },
  {
    path: 'dashboard',
    // O usuário só precisa estar logado para carregar este módulo
    canLoad: [canLoadAuthenticated],
    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule)
  },
  {
    path: 'settings',
    // Aqui, encadeamos os guardas. Primeiro verifica se está logado, depois se tem a role.
    canLoad: [canLoadAuthenticated, canLoadWithRole],
    data: {
      expectedRole: 'ADMIN' // Passamos a role esperada
    },
    loadChildren: () => import('./settings/settings.module').then(m => m.SettingsModule)
  },
  { path: '', redirectTo: '/dashboard', pathMatch: 'full' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

Com esta configuração:

- Um usuário não logado que tentar ir para `/dashboard` ou `/settings` será redirecionado para `/login`, e nenhum módulo será carregado.
- Um usuário comum (`role: 'USER'`) logado poderá acessar `/dashboard` (o `DashboardModule` será carregado), mas ao tentar acessar `/settings`, o `canLoadWithRole` falhará e ele será redirecionado para `/unauthorized`, e o `SettingsModule` **não** será carregado.
- Apenas um usuário com `role: 'ADMIN'` conseguirá carregar o `SettingsModule` ao navegar para `/settings`.

---

### **Tópicos Relacionados para Aprofundamento**

1. **`CanActivateFn`**: Entenda a fundo a diferença entre `CanLoad` e `CanActivate` e como eles podem ser usados em conjunto para uma estratégia de segurança em camadas.
2. **`CanDeactivateFn`**: Um guarda que controla a navegação *para fora* de uma rota, útil para prevenir que o usuário perca dados não salvos em um formulário.
3. **`ResolveFn`**: Um "guarda" que pré-busca dados necessários para uma rota antes que ela seja ativada. Pode ser usado para carregar informações de uma API antes do componente ser renderizado.
4. **Injeção de Dependência em Guardas Funcionais**: Aprofunde-se no uso da função `inject()` para prover serviços e outras dependências aos seus guardas funcionais, que é a abordagem moderna e recomendada.
5. **Estratégias de Pré-carregamento de Módulos (`PreloadingStrategy`)**: O Angular permite que você pré-carregue módulos de lazy-loading em segundo plano após o carregamento inicial da aplicação. Entenda como o `PreloadAllModules` e estratégias customizadas interagem (ou não) com os guardas `CanLoad`.

Espero que esta explicação detalhada tenha sido exatamente o que você precisava, Gedê\! Se tiver mais alguma dúvida, pode perguntar.