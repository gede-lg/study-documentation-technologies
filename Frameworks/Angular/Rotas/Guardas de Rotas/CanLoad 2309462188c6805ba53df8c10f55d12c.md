# CanLoad

Com certeza, Gedê\! A.R.I.A está aqui para te ajudar a entender a guarda de rotas com `CanLoad` no Angular de forma detalhada. Como você é desenvolvedor backend e busca uma vaga em Go, sei que gosta de entender bem os fundamentos, então vamos mergulhar fundo nisso.

---

# Guarda de Rotas no Angular: Desvendando o `CanLoad`

A segurança e o controle de acesso são aspectos cruciais em qualquer aplicação web moderna. No Angular, o roteamento desempenha um papel central na navegação do usuário, e é aqui que as **Guards de Rota** entram em cena. Elas são ferramentas poderosas que permitem controlar o acesso a determinadas rotas, seja para prevenir que um usuário navegue para uma rota não autorizada, ou para garantir que certos dados estejam carregados antes de uma rota ser ativada.

---

### Sumário

Nesta explicação detalhada, abordaremos os seguintes tópicos:

- **Introdução às Guards de Rota no Angular:** Contextualizando a importância das guards no controle de acesso e na otimização de performance.
- **Conceitos Fundamentais do `CanLoad`:** Entendendo seu propósito, como ele difere de outras guards e sua importância para o lazy loading.
- **Sintaxe Detalhada e Uso Prático do `CanLoad`:** Como implementar e aplicar o `CanLoad` em suas rotas, com exemplos de código comentados.
- **Métodos e Propriedades Essenciais:** Explorando a assinatura e os retornos possíveis do `CanLoad`.
- **Cenários de Restrição ou Não Aplicação:** Quando o `CanLoad` é a melhor escolha e quando outras guards podem ser mais adequadas.
- **Componentes Chave Associados:** Análise de interfaces e módulos cruciais para o funcionamento do `CanLoad`.
- **Melhores Práticas e Padrões de Uso:** Recomendações para utilizar o `CanLoad` de forma eficiente e segura.
- **Exemplo Prático Completo:** Um cenário de ponta a ponta demonstrando a aplicação do `CanLoad` em um módulo com lazy loading.

---

### Introdução

No universo do Angular, a **guarda de rotas** é um mecanismo essencial para proteger suas aplicações. Imagine que você tem uma área administrativa que só deve ser acessada por usuários autenticados e com permissões específicas. Sem as guards, qualquer um poderia tentar acessar essa rota, mesmo que a interface não exibisse os links para ela. As guards agem como "porteiros" para suas rotas, decidindo se um usuário pode ou não entrar.

Existem diferentes tipos de guards, cada uma com uma finalidade específica:

- `CanActivate`: Decide se uma rota pode ser **ativada**.
- `CanActivateChild`: Decide se um módulo filho pode ser **ativado**.
- `CanDeactivate`: Decide se o usuário pode **sair** de uma rota.
- `Resolve`: Realiza a **busca de dados** antes que a rota seja ativada.
- `CanLoad`: Decide se um **módulo** pode ser **carregado** de forma lazy (sob demanda).

Nosso foco principal será no `CanLoad`, que é particularmente interessante para otimizar o desempenho da sua aplicação.

---

### Conceitos Fundamentais

O **`CanLoad`** é uma guard de rota no Angular que tem um propósito muito específico e poderoso: **impedir que um módulo com lazy loading seja carregado**. Isso significa que o código JavaScript do módulo nem sequer será baixado para o navegador do usuário se a guard retornar `false`.

### Importância e Propósito do `CanLoad`

A principal importância do `CanLoad` reside na **otimização de performance e segurança**:

1. **Otimização de Performance (Lazy Loading):** Quando um módulo é carregado de forma lazy (sob demanda), seu código JavaScript só é baixado quando o usuário tenta navegar para uma rota que pertence a esse módulo. O `CanLoad` atua como um filtro *antes mesmo* do download. Se a guard determinar que o usuário não tem permissão para acessar o módulo, o Angular simplesmente não fará a requisição para buscar o bundle do módulo, economizando largura de banda e tempo de carregamento. Isso é crucial para aplicações grandes, onde módulos específicos podem conter muito código que nem todos os usuários precisarão.
2. **Segurança e Controle de Acesso:** Ao prevenir o carregamento do módulo, o `CanLoad` garante que o código relacionado a funcionalidades sensíveis ou restritas nunca chegue ao cliente, a menos que ele tenha as permissões necessárias. Isso é uma camada extra de segurança, além de simplesmente bloquear a ativação da rota (o que `CanActivate` faria).

### `CanLoad` vs. `CanActivate`

É comum confundir `CanLoad` com `CanActivate`. A diferença é sutil, mas fundamental:

- **`CanLoad`**: Impede o **carregamento** do módulo. Se a guard falhar, o módulo não é baixado, e a navegação para qualquer rota dentro dele é impedida.
- **`CanActivate`**: Permite que o módulo seja **carregado**, mas impede a **ativação** da rota específica. Se a guard falhar, o módulo já estará no navegador, mas o usuário não conseguirá acessar a rota.

Pense assim: `CanLoad` é a "catraca" que impede você de entrar na estação. `CanActivate` é o "bilheteiro" que verifica se você pode embarcar no trem, mesmo já estando na estação.

Para segurança máxima e otimização, muitas vezes você usará o `CanLoad` para evitar o download de módulos inteiros e o `CanActivate` para proteger rotas específicas dentro de módulos que já foram carregados (seja por lazy loading ou não).

---

### Sintaxe Detalhada e Uso Prático

Para usar o `CanLoad`, você precisa criar um serviço que implemente a interface `CanLoad`.

### Criação da Guard

Vamos criar uma guard de exemplo chamada `AuthLoadGuard`:

```tsx
// src/app/guards/auth-load.guard.ts
import { Injectable } from '@angular/core';
import { CanLoad, Route, UrlSegment, Router, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from '../services/auth.service'; // Suponha que você tenha um serviço de autenticação

@Injectable({
  providedIn: 'root' // Indica que o serviço pode ser injetado em qualquer lugar da aplicação
})
export class AuthLoadGuard implements CanLoad {

  constructor(private authService: AuthService, private router: Router) {}

  canLoad(
    route: Route, // Objeto de rota que está sendo carregada
    segments: UrlSegment[] // Array de segmentos da URL para a rota
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Lógica para determinar se o módulo pode ser carregado
    if (this.authService.isLoggedIn()) { // Verifica se o usuário está logado
      // Se estiver logado, o módulo pode ser carregado
      console.log('AuthLoadGuard: Usuário autenticado. Módulo permitido.');
      return true;
    } else {
      // Se não estiver logado, o módulo não pode ser carregado
      console.log('AuthLoadGuard: Usuário não autenticado. Módulo bloqueado.');
      // Opcional: Redirecionar o usuário para a página de login
      this.router.navigate(['/login']);
      // Retorna false ou um UrlTree para redirecionar
      return false; // Ou return this.router.parseUrl('/login');
    }
  }
}

```

Neste exemplo:

- `@Injectable({ providedIn: 'root' })`: Torna o serviço disponível para injeção de dependência em toda a aplicação.
- `implements CanLoad`: A classe deve implementar a interface `CanLoad`.
- `canLoad(route: Route, segments: UrlSegment[])`: Este é o método que o Angular chamará para determinar se o módulo pode ser carregado.
    - `route`: Fornece informações sobre a rota que está sendo carregada (por exemplo, `route.path`, `route.data`).
    - `segments`: Representa os segmentos da URL que estão sendo processados.

### Aplicação da Guard na Rota

Depois de criar a guard, você a aplica na configuração de rota do seu módulo principal (`app-routing.module.ts`):

```tsx
// src/app/app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AuthLoadGuard } from './guards/auth-load.guard'; // Importe sua guard

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent }, // Supondo um HomeComponent
  { path: 'login', component: LoginComponent }, // Supondo um LoginComponent
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canLoad: [AuthLoadGuard] // Aplica a guard CanLoad aqui
  },
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule),
    canLoad: [AuthLoadGuard] // Você pode aplicar a mesma guard a vários módulos
  },
  { path: '**', component: NotFoundComponent } // Rota curinga para páginas não encontradas
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

No exemplo acima, o módulo `AdminModule` e `DashboardModule` serão carregados de forma lazy. A propriedade `canLoad: [AuthLoadGuard]` garante que o Angular chame a `AuthLoadGuard` *antes* de tentar baixar o código desses módulos. Se `AuthLoadGuard` retornar `false`, o download não ocorrerá, e o usuário será redirecionado para a página de login (conforme a lógica da guard).

---

### Métodos/Propriedades

A interface `CanLoad` define apenas um método que você precisa implementar:

- `canLoad(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree`

### Parâmetros:

- **`route: Route`**: Este objeto fornece acesso à configuração da rota que está sendo avaliada.
    - **Propriedades úteis:**
        - `route.path`: O caminho da rota (ex: 'admin').
        - `route.component`: O componente associado à rota (se for uma rota direta, não lazy).
        - `route.children`: Rotas filhas.
        - `route.data`: Dados adicionais que você pode definir na configuração da rota (útil para passar permissões ou outros metadados para a guard).
        - `route.resolve`: Resolvers associados à rota.
        - `route.canActivate`, `route.canLoad`, etc.
- **`segments: UrlSegment[]`**: Este é um array de objetos `UrlSegment`. Cada `UrlSegment` representa um segmento da URL ativa. Isso pode ser útil se você precisar de informações mais granulares sobre a URL para tomar sua decisão.
    - **Propriedades úteis:**
        - `segment.path`: O valor do segmento (ex: 'admin').
        - `segment.parameters`: Parâmetros da URL para este segmento.

### Retornos Possíveis:

O método `canLoad` pode retornar um dos seguintes tipos:

- **`boolean`**:
    - `true`: O módulo pode ser carregado.
    - `false`: O módulo **não** pode ser carregado. A navegação será abortada.
- **`UrlTree`**: Se você retornar uma instância de `UrlTree`, o Angular cancelará a navegação atual e iniciará uma nova navegação para a URL representada pelo `UrlTree`. Isso é extremamente útil para redirecionar o usuário, por exemplo, para uma página de login.
    - Exemplo: `return this.router.parseUrl('/login');`
- **`Observable<boolean | UrlTree>`**: Útil para operações assíncronas, como verificar permissões em um servidor. O módulo será carregado somente quando o Observable emitir `true` ou um `UrlTree`.
- **`Promise<boolean | UrlTree>`**: Semelhante ao Observable, mas para operações assíncronas baseadas em Promises.

---

### Cenários de Restrição ou Não Aplicação

Embora o `CanLoad` seja uma ferramenta poderosa, há situações em que ele pode não ser a melhor escolha ou quando outras guards são mais apropriadas:

- **Quando a Permissão é Necessária APENAS para Ativar a Rota, não para Carregar o Módulo:** Se o seu módulo não contém informações sensíveis no seu código e a única preocupação é que o usuário não acesse certas *funcionalidades* após o carregamento (por exemplo, um painel de visualização que todos podem ver, mas apenas admins podem editar), o `CanActivate` pode ser suficiente. O `CanLoad` é mais restritivo, impedindo o download do código.
- **Quando o Módulo Não é Lazy Loaded:** O `CanLoad` é *exclusivamente* para módulos com lazy loading (`loadChildren`). Se o seu módulo é carregado de forma eager (no bundle principal da aplicação), o `CanLoad` não terá efeito. Para esses casos, você usaria `CanActivate` ou `CanActivateChild`.
- **Quando Você Precisa de Dados da Rota para Tomar a Decisão (e o `CanLoad` não fornece o suficiente):** Embora `canLoad` receba o objeto `Route` e `UrlSegment[]`, em cenários complexos onde você precisa de parâmetros de rota específicos ou dados de um `Resolve` para tomar a decisão de carregamento, o `CanLoad` pode ser limitado. O `CanActivate` tem acesso a um `ActivatedRouteSnapshot` que fornece mais detalhes sobre o estado da rota. No entanto, o `CanLoad` geralmente é suficiente para verificações de alto nível (autenticação, permissão de perfil).
- **Controle de Saída de Rota:** Se você precisa perguntar ao usuário se ele quer realmente sair de uma página (por exemplo, se há formulários não salvos), o `CanLoad` não é a guard certa. Para isso, use o `CanDeactivate`.
- **Pré-Carregamento de Dados:** Se o seu objetivo é carregar dados antes que a rota seja ativada, o `Resolve` é a guard apropriada, não o `CanLoad`.

Em resumo, use o `CanLoad` quando a segurança e/ou a otimização de performance exigem que um módulo inteiro não seja baixado para o navegador do cliente, a menos que certas condições sejam satisfeitas.

---

### Componentes Chave Associados

O `CanLoad` é uma interface que reside no módulo `@angular/router`. Vamos analisar os componentes cruciais envolvidos:

- **`CanLoad` (Interface):**
    - **Localização:** `@angular/router`
    - **Definição:**
        
        ```tsx
        export interface CanLoad {
          canLoad(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;
        }
        
        ```
        
    - **Uso:** Qualquer classe que você queira que funcione como uma guard `CanLoad` deve implementar esta interface. Isso garante que a classe tenha o método `canLoad` com a assinatura correta.
- **`Route` (Interface/Type Alias):**
    - **Localização:** `@angular/router`
    - **Definição (Simplificada):**
        
        ```tsx
        export interface Route {
          path?: string;
          pathMatch?: string;
          matcher?: UrlMatcher;
          component?: Type<any>;
          redirectTo?: string;
          outlet?: string;
          canActivate?: any[];
          canActivateChild?: any[];
          canDeactivate?: any[];
          canLoad?: any[]; // Aqui é onde você associa sua guard CanLoad
          data?: Data;
          resolve?: ResolveFn | ResolveFn[];
          children?: Routes;
          loadChildren?: LoadChildrenCallback; // Usado para lazy loading
          runGuardsAndResolvers?: "paramsChange" | "paramsOrQueryParamsChange" | "always" | "pathParamsChange" | "queryParamsChange";
          title?: string | ResolveFn<string>;
        }
        
        ```
        
    - **Uso:** Este é o objeto de configuração que você usa para definir suas rotas no Angular. A propriedade `canLoad` dentro deste objeto aceita um array de guards (`CanLoad` implementações) que serão executadas sequencialmente.
- **`UrlSegment` (Classe):**
    - **Localização:** `@angular/router`
    - **Definição (Simplificada):**
        
        ```tsx
        export class UrlSegment {
          constructor(path: string, parameters: { [name: string]: string });
          readonly path: string;
          readonly parameters: { [name: string]: string };
          // ... outros métodos
        }
        
        ```
        
    - **Uso:** Representa um único segmento de uma URL. O array de `UrlSegment` passado para o método `canLoad` permite que você inspecione os componentes individuais da URL que o usuário está tentando acessar.
- **`Router` (Classe):**
    - **Localização:** `@angular/router`
    - **Uso:** Embora não seja parte da interface `CanLoad`, o serviço `Router` é frequentemente injetado nas guards para permitir redirecionamentos programáticos (ex: `this.router.navigate(['/login'])`) ou para construir um `UrlTree` para redirecionamento.
- **`UrlTree` (Classe):**
    - **Localização:** `@angular/router`
    - **Uso:** Uma representação da árvore de segmentos de URL. Retornar um `UrlTree` de `canLoad` (ou de outras guards) faz com que o Angular cancele a navegação atual e inicie uma nova navegação para a URL representada pelo `UrlTree`. É a forma preferencial de redirecionar o usuário a partir de uma guard.

---

### Melhores Práticas e Padrões de Uso

Para usar o `CanLoad` de forma eficaz e robusta, considere as seguintes melhores práticas:

1. **Mantenha as Guards Simples e Focadas:** Uma guard `CanLoad` deve ter uma única responsabilidade clara, como verificar autenticação ou um tipo específico de permissão. Evite colocar lógica de negócios complexa dentro dela.
2. **Use Serviços para Lógica Complexa:** Se a verificação de permissão for complexa (ex: múltiplas regras de role-based access control), encapsule essa lógica em um serviço (como `AuthService` ou `PermissionsService`) e injete esse serviço na sua guard. Isso torna a guard mais limpa e a lógica de permissões reutilizável e testável.
3. **Lide com Redirecionamentos de Forma Explícita:** Se a guard retornar `false`, o Angular simplesmente aborta a navegação. Para uma melhor experiência do usuário, geralmente você quer redirecionar o usuário para uma página apropriada (login, "acesso negado", etc.). Use `this.router.navigate()` ou retorne um `UrlTree` (`this.router.parseUrl('/login')`) para isso. Retornar `UrlTree` é a abordagem mais elegante, pois o Angular lida com o redirecionamento internamente.
4. **Assincronicidade é Chave:** Muitas verificações de permissão envolvem chamadas de API para um backend. Use `Observable` ou `Promise` no retorno do `canLoad` para lidar com essa assincronicidade. Certifique-se de que o Observable ou Promise resolve para `true`, `false` ou um `UrlTree`.
5. **Use `providedIn: 'root'` para Guards Compartilhadas:** Para guards que são usadas em vários lugares da sua aplicação e não têm dependências específicas de módulos, usar `@Injectable({ providedIn: 'root' })` é a abordagem recomendada, pois garante que a guard seja um singleton e otimiza o empacotamento.
6. **Combine com Outras Guards (quando necessário):** Para segurança em profundidade, você pode usar `CanLoad` para evitar o carregamento do módulo e `CanActivate` ou `CanActivateChild` para proteger rotas específicas dentro do módulo (caso o módulo seja carregado por alguma falha ou se a permissão for granular por rota, mesmo dentro de um módulo lazy).
7. **Teste Suas Guards:** As guards são uma parte crítica da segurança da sua aplicação. Escreva testes unitários para garantir que elas se comportem como esperado em diferentes cenários (usuário logado, não logado, com permissão, sem permissão, etc.).

---

### Exemplo Prático Completo

Vamos criar um cenário onde temos um módulo `AdminModule` que deve ser carregado apenas se o usuário tiver o papel de "administrador".

### 1\. Serviço de Autenticação (Simulado)

```tsx
// src/app/services/auth.service.ts
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { delay, tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private _isLoggedIn = false;
  private _userRole = 'guest'; // Pode ser 'guest', 'user', 'admin'

  constructor() {
    // Simula um login inicial
    // this._isLoggedIn = true;
    // this._userRole = 'admin';
  }

  login(role: string): Observable<boolean> {
    console.log(`Tentando logar como: ${role}`);
    return of(true).pipe(
      delay(500), // Simula um atraso de rede
      tap(() => {
        this._isLoggedIn = true;
        this._userRole = role;
        console.log(`Logado: ${this._isLoggedIn}, Papel: ${this._userRole}`);
      })
    );
  }

  logout(): void {
    this._isLoggedIn = false;
    this._userRole = 'guest';
    console.log('Deslogado.');
  }

  isLoggedIn(): boolean {
    return this._isLoggedIn;
  }

  hasRole(role: string): boolean {
    return this._isLoggedIn && this._userRole === role;
  }
}

```

### 2\. Guarda `AdminLoadGuard`

```tsx
// src/app/guards/admin-load.guard.ts
import { Injectable } from '@angular/core';
import { CanLoad, Route, UrlSegment, Router, UrlTree } from '@angular/router';
import { Observable, of } from 'rxjs';
import { AuthService } from '../services/auth.service';
import { take, switchMap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AdminLoadGuard implements CanLoad {

  constructor(private authService: AuthService, private router: Router) {}

  canLoad(
    route: Route,
    segments: UrlSegment[]
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    console.log('AdminLoadGuard: Verificando permissão para carregar o módulo admin...');

    // Lógica assíncrona: Verifique se o usuário está logado e tem o papel de administrador
    // Suponha que a verificação de papel possa ser assíncrona (ex: buscar do backend)
    return of(this.authService.isLoggedIn()).pipe(
      switchMap(isLoggedIn => {
        if (isLoggedIn && this.authService.hasRole('admin')) {
          console.log('AdminLoadGuard: Usuário é admin. Permissão concedida.');
          return of(true); // Permite o carregamento
        } else {
          console.log('AdminLoadGuard: Usuário não é admin ou não está logado. Redirecionando...');
          // Redireciona para a página de login se não tiver permissão
          return of(this.router.parseUrl('/login')); // Redireciona
        }
      })
    );
  }
}

```

### 3\. Configuração de Rota no `AppRoutingModule`

```tsx
// src/app/app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AdminLoadGuard } from './guards/admin-load.guard';
import { HomeComponent } from './home/home.component'; // Exemplo
import { LoginComponent } from './login/login.component'; // Exemplo
import { NotFoundComponent } from './not-found/not-found.component'; // Exemplo

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canLoad: [AdminLoadGuard] // Aplica a guard aqui
  },
  { path: '**', component: NotFoundComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 4\. Módulo Admin (lazy loaded)

```tsx
// src/app/admin/admin.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminDashboardComponent } from './admin-dashboard/admin-dashboard.component';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: '', component: AdminDashboardComponent }
];

@NgModule({
  declarations: [AdminDashboardComponent],
  imports: [
    CommonModule,
    RouterModule.forChild(routes)
  ]
})
export class AdminModule { }

```

```tsx
// src/app/admin/admin-dashboard/admin-dashboard.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-admin-dashboard',
  template: `
    <h2>Painel Administrativo</h2>
    <p>Bem-vindo, administrador!</p>
  `
})
export class AdminDashboardComponent { }

```

### Como Testar:

1. **Inicialmente:** Tente navegar para `/admin`. Você deverá ser redirecionado para `/login` (ou a URL que você configurou), e o console mostrará a mensagem do `AdminLoadGuard` indicando que o módulo foi bloqueado.
2. **Simule o Login como 'admin':** No seu `AuthService` ou via algum botão/formulário na sua UI, chame `authService.login('admin')`.
3. **Tente navegar novamente:** Após o login como admin, tente acessar `/admin` novamente. Agora o `AdminModule` deverá ser carregado, e você verá o `AdminDashboardComponent`.
4. **Simule o Login como 'user':** Se você logar como 'user' (`authService.login('user')`) e tentar acessar `/admin`, você também será bloqueado, demonstrando a granularidade da permissão.

Este exemplo completo ilustra como o `CanLoad` atua como um porteiro para módulos lazy-loaded, garantindo que apenas usuários autorizados baixem e acessem o código do módulo.

---

Espero que esta explicação detalhada tenha sido clara e útil para você, Gedê\! Se tiver mais alguma dúvida ou quiser aprofundar em outro ponto, é só chamar a A.R.I.A\!