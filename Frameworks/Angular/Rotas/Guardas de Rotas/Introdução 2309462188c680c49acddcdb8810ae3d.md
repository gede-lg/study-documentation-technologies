# Introdução

Com certeza, Gedê\! Você tem toda razão. Para uma explicação completa, é essencial abordar todas as interfaces de guarda de rotas que o Angular oferece. A.R.I.A. vai refazer a explicação focando nisso, garantindo que você tenha uma visão abrangente e detalhada de cada uma.

---

# Guarda de Rotas no Angular: Protegendo Seus Caminhos Digitais (Revisado)

### Introdução

No desenvolvimento de aplicações web modernas, a **segurança** e o **controle de acesso** são cruciais. Imagine uma aplicação onde qualquer usuário pode acessar páginas administrativas ou dados sensíveis sem a devida permissão. Isso seria um caos, certo? É aqui que as **Guarda de Rotas (Route Guards)** do Angular entram em ação. Elas atuam como sentinelas, protegendo rotas específicas da sua aplicação, permitindo ou bloqueando a navegação com base em certas condições.

### Sumário

Nesta explicação detalhada, abordaremos os seguintes pontos:

- **Conceitos Fundamentais:** O que são Guardas de Rotas, sua importância e propósito.
- **Todas as Interfaces de Guardas de Rotas:** Conheça as sete interfaces disponíveis: `CanActivate`, `CanActivateChild`, `CanDeactivate`, `Resolve`, `CanLoad`, `CanMatch` e `CanActivateFn`/`CanDeactivateFn`/`CanLoadFn`/`ResolveFn`/`CanMatchFn`.
- **Sintaxe Detalhada e Uso Prático:** Exemplos de código comentados para cada tipo de guarda.
- **Cenários de Restrição ou Não Aplicação:** Onde as guardas podem não ser a melhor escolha.
- **Melhores Práticas e Padrões de Uso:** Recomendações para utilizar as guardas de forma eficaz.
- **Exemplos Práticos Otimizados:** Um cenário de ponta a ponta demonstrando o uso de múltiplas guardas.

---

### Conceitos Fundamentais

As **Guarda de Rotas** são classes ou funções em Angular que implementam interfaces ou tipos específicos para controlar o acesso a rotas. Elas são executadas antes que uma navegação para ou de uma rota seja concluída. O principal objetivo é adicionar lógica condicional ao roteamento, permitindo que você:

- **Controle o acesso:** Verifique se um usuário está autenticado, tem permissões específicas ou atende a outros critérios antes de permitir o acesso a uma rota.
- **Pré-carregue dados:** Carregue dados necessários para um componente antes que ele seja renderizado, evitando que o usuário veja uma tela vazia ou com dados ausentes.
- **Confirme a saída:** Peça confirmação ao usuário antes que ele saia de uma rota, útil para formulários não salvos.
- **Otimize o carregamento de módulos:** Impeça o carregamento de módulos lazily-loaded (carregamento sob demanda) se o usuário não tiver permissão para acessá-los, economizando recursos.

A **importância** das Guardas de Rotas reside na capacidade de construir aplicações mais seguras, robustas e com uma melhor experiência do usuário. Elas centralizam a lógica de controle de acesso e pré-carregamento, tornando seu código mais limpo e fácil de manter.

---

### Tipos de Guardas de Rotas e Sintaxe Detalhada

Angular oferece sete interfaces e tipos principais para guardas de rotas, cada uma com um propósito específico.

### 1\. `CanActivate`

Permite ou impede o acesso a uma rota. É a guarda mais comumente usada para autenticação e autorização.

**Sintaxe (Baseada em Classe):**

```tsx
// auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service'; // Exemplo de um serviço de autenticação

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot, // Informações sobre a rota que está sendo ativada
    state: RouterStateSnapshot // O estado atual do roteador
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Verifica se o usuário está logado
    if (this.authService.isLoggedIn()) {
      return true; // Permite o acesso à rota
    } else {
      // Redireciona o usuário para a página de login
      this.router.navigate(['/login']);
      return false; // Impede o acesso à rota
    }
  }
}

```

**Sintaxe (Baseada em Função - a partir do Angular 14/15, é a abordagem preferida para novas aplicações):**

```tsx
// auth.guard.ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true;
  } else {
    return router.parseUrl('/login'); // Retorna um UrlTree para redirecionar
  }
};

```

**Uso no módulo de rotas (`app-routing.module.ts` ou similar):**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { DashboardComponent } from './dashboard/dashboard.component';
import { LoginComponent } from './login/login.component';
// Importa a guarda (pode ser a classe ou a função)
import { AuthGuard } from './auth.guard'; // Para a guarda baseada em classe
// import { authGuard } from './auth.guard'; // Para a guarda baseada em função

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard] // Aplica a guarda 'AuthGuard' a esta rota (usando a classe ou a função)
  },
  { path: '', redirectTo: '/dashboard', pathMatch: 'full' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 2\. `CanActivateChild`

Controla o acesso a rotas filhas de uma rota pai. Útil para aplicar regras de acesso consistentes a um grupo de rotas.

**Sintaxe (Baseada em Classe):**

```tsx
// admin.guard.ts
import { Injectable } from '@angular/core';
import { CanActivateChild, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service'; // Exemplo de um serviço de autenticação

@Injectable({
  providedIn: 'root'
})
export class AdminGuard implements CanActivateChild {

  constructor(private authService: AuthService) {}

  canActivateChild(
    childRoute: ActivatedRouteSnapshot, // Informações sobre a rota filha que está sendo ativada
    state: RouterStateSnapshot
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Verifica se o usuário é um administrador
    if (this.authService.isAdmin()) {
      return true; // Permite o acesso à rota filha
    } else {
      alert('Você não tem permissão para acessar esta área administrativa!');
      return false; // Impede o acesso à rota filha
    }
  }
}

```

**Sintaxe (Baseada em Função):**

```tsx
// admin.guard.ts
import { CanActivateChildFn } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const adminGuard: CanActivateChildFn = (childRoute, state) => {
  const authService = inject(AuthService);
  if (authService.isAdmin()) {
    return true;
  } else {
    alert('Você não tem permissão para acessar esta área administrativa!');
    return false;
  }
};

```

**Uso no módulo de rotas:**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AdminDashboardComponent } from './admin/admin-dashboard/admin-dashboard.component';
import { UserManagementComponent } from './admin/user-management/user-management.component';
// Importa a guarda (classe ou função)
import { AdminGuard } from './admin.guard'; // Para a classe
// import { adminGuard } from './admin.guard'; // Para a função

const routes: Routes = [
  {
    path: 'admin',
    canActivateChild: [AdminGuard], // Aplica a guarda a todas as rotas filhas de 'admin'
    children: [
      { path: 'dashboard', component: AdminDashboardComponent },
      { path: 'users', component: UserManagementComponent }
    ]
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 3\. `CanDeactivate`

Permite ou impede que um usuário saia de uma rota. É ideal para prevenir perda de dados em formulários não salvos.

**Sintaxe (Baseada em Classe):**

Para usar `CanDeactivate`, você precisa definir uma interface que seus componentes possam implementar para indicar se podem desativar.

```tsx
// deactivate.guard.ts
import { Injectable } from '@angular/core';
import { CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';

// Interface que os componentes devem implementar
export interface CanComponentDeactivate {
  canDeactivate: () => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;
}

@Injectable({
  providedIn: 'root'
})
export class DeactivateGuard implements CanDeactivate<CanComponentDeactivate> {
  canDeactivate(
    component: CanComponentDeactivate, // O componente que está sendo desativado
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Chama o método canDeactivate do componente se ele existir
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}

```

**Sintaxe (Baseada em Função):**

```tsx
// deactivate.guard.ts
import { CanDeactivateFn } from '@angular/router';
import { CanComponentDeactivate } from './path/to/your/component'; // Importe a interface do seu componente

export const deactivateGuard: CanDeactivateFn<CanComponentDeactivate> = (component, currentRoute, currentState, nextState) => {
  return component.canDeactivate ? component.canDeactivate() : true;
};

```

**No componente (`edit-profile.component.ts`):**

```tsx
// edit-profile.component.ts
import { Component } from '@angular/core';
import { Observable, of } from 'rxjs';
// Importa a interface que a guarda espera
import { CanComponentDeactivate } from '../deactivate.guard'; // Se for guarda de classe
// import { CanComponentDeactivate } from '../deactivate.guard'; // Se for guarda de função

@Component({
  selector: 'app-edit-profile',
  template: `
    <h2>Editar Perfil</h2>
    <input type="text" [(ngModel)]="userName">
    <button (click)="save()">Salvar</button>
  `
})
export class EditProfileComponent implements CanComponentDeactivate {
  userName: string = 'Gedê'; // Exemplo de dado do formulário
  isSaved: boolean = false;

  save() {
    // Lógica para salvar os dados
    this.isSaved = true;
    alert('Perfil salvo com sucesso!');
  }

  canDeactivate(): Observable<boolean> | Promise<boolean> | boolean {
    if (!this.isSaved) {
      // Se o formulário não foi salvo, pergunta ao usuário
      const confirmation = confirm('Você tem alterações não salvas. Deseja realmente sair?');
      return confirmation;
    }
    return true; // Se o formulário foi salvo, permite a saída
  }
}

```

**Uso no módulo de rotas:**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { EditProfileComponent } from './edit-profile/edit-profile.component';
// Importa a guarda (classe ou função)
import { DeactivateGuard } from './deactivate.guard'; // Para a classe
// import { deactivateGuard } from './deactivate.guard'; // Para a função

const routes: Routes = [
  {
    path: 'edit-profile',
    component: EditProfileComponent,
    canDeactivate: [DeactivateGuard] // Aplica a guarda 'DeactivateGuard' (usando a classe ou a função)
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 4\. `Resolve`

Pré-carrega dados para uma rota antes que o componente seja ativado. Isso garante que os dados estejam disponíveis antes que o componente seja renderizado, melhorando a experiência do usuário.

**Sintaxe (Baseada em Classe):**

```tsx
// user.resolver.ts
import { Injectable } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable, of } from 'rxjs';
import { UserService } from './user.service'; // Exemplo de um serviço de usuário

interface User {
  id: number;
  name: string;
  email: string;
}

@Injectable({
  providedIn: 'root'
})
export class UserResolver implements Resolve<User | undefined> { // Pode retornar undefined se não encontrar
  constructor(private userService: UserService) {}

  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<User | undefined> | Promise<User | undefined> | User | undefined {
    const userId = +route.paramMap.get('id')!; // Obtém o ID do usuário da rota (o '!' afirma que não será null)
    // Retorna um Observable com os dados do usuário (simulado)
    return this.userService.getUser(userId);
  }
}

```

**Sintaxe (Baseada em Função):**

```tsx
// user.resolver.ts
import { ResolveFn } from '@angular/router';
import { inject } from '@angular/core';
import { UserService } from './user.service';
import { Observable } from 'rxjs';

interface User {
  id: number;
  name: string;
  email: string;
}

export const userResolver: ResolveFn<User | undefined> = (route, state) => {
  const userService = inject(UserService);
  const userId = +route.paramMap.get('id')!;
  return userService.getUser(userId);
};

```

**No serviço (`user.service.ts` - exemplo simulado):**

```tsx
// user.service.ts
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private users = [
    { id: 1, name: 'Gedê', email: 'gede@example.com' },
    { id: 2, name: 'Ju', email: 'ju@example.com' }
  ];

  getUser(id: number): Observable<any | undefined> {
    const user = this.users.find(u => u.id === id);
    return of(user); // Retorna um observable com o usuário encontrado (ou undefined)
  }
}

```

**No componente (`user-detail.component.ts`):**

```tsx
// user-detail.component.ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-user-detail',
  template: `
    <h2>Detalhes do Usuário</h2>
    <p>ID: {{ user?.id }}</p>
    <p>Nome: {{ user?.name }}</p>
    <p>Email: {{ user?.email }}</p>
    <div *ngIf="!user">Usuário não encontrado.</div>
  `
})
export class UserDetailComponent implements OnInit {
  user: any;

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    // Os dados já foram resolvidos e estão disponíveis no snapshot da rota
    // Você também pode se inscrever no Observable data: this.route.data.subscribe(data => this.user = data['user']);
    this.user = this.route.snapshot.data['user'];
  }
}

```

**Uso no módulo de rotas:**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { UserDetailComponent } from './user-detail/user-detail.component';
// Importa o resolver (classe ou função)
import { UserResolver } from './user.resolver'; // Para a classe
// import { userResolver } from './user.resolver'; // Para a função

const routes: Routes = [
  {
    path: 'users/:id',
    component: UserDetailComponent,
    resolve: {
      user: UserResolver // O 'user' será a chave para acessar os dados resolvidos no componente (usando a classe ou a função)
    }
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 5\. `CanLoad`

Controla se um módulo lazily-loaded (carregamento sob demanda) pode ser carregado. Isso evita que módulos grandes sejam baixados desnecessariamente se o usuário não tiver permissão para acessá-los.

**Sintaxe (Baseada em Classe):**

```tsx
// lazy-module.guard.ts
import { Injectable } from '@angular/core';
import { CanLoad, Route, UrlSegment, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class LazyModuleGuard implements CanLoad {

  constructor(private authService: AuthService) {}

  canLoad(
    route: Route, // A rota que está tentando carregar o módulo
    segments: UrlSegment[] // Os segmentos da URL
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Verifica se o usuário tem permissão para carregar o módulo administrativo
    if (this.authService.isAdmin()) {
      return true; // Permite o carregamento do módulo
    } else {
      alert('Você não tem permissão para carregar este módulo!');
      return false; // Impede o carregamento do módulo
    }
  }
}

```

**Sintaxe (Baseada em Função):**

```tsx
// lazy-module.guard.ts
import { CanLoadFn } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const lazyModuleGuard: CanLoadFn = (route, segments) => {
  const authService = inject(AuthService);
  if (authService.isAdmin()) {
    return true;
  } else {
    alert('Você não tem permissão para carregar este módulo!');
    return false;
  }
};

```

**Uso no módulo de rotas (no `app-routing.module.ts`):**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
// Importa a guarda (classe ou função)
import { LazyModuleGuard } from './lazy-module.guard'; // Para a classe
// import { lazyModuleGuard } from './lazy-module.guard'; // Para a função

const routes: Routes = [
  {
    path: 'admin-area',
    loadChildren: () => import('./admin-area/admin-area.module').then(m => m.AdminAreaModule),
    canLoad: [LazyModuleGuard] // Aplica a guarda 'LazyModuleGuard' (usando a classe ou a função)
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 6\. `CanMatch` (Introduzida no Angular 14)

Controla se uma rota pode ser "casada" (matched) pela URL. Diferente de `CanLoad`, `CanMatch` impede que o roteador sequer considere a rota, enquanto `CanLoad` permite que a rota seja casada, mas impede o carregamento do módulo. Isso é útil para quando você tem rotas com o mesmo path, mas que devem ser ativadas condicionalmente.

**Sintaxe (Baseada em Classe):**

```tsx
// feature.guard.ts
import { Injectable } from '@angular/core';
import { CanMatch, Route, UrlSegment, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { FeatureToggleService } from './feature-toggle.service'; // Simula um serviço de feature toggle

@Injectable({
  providedIn: 'root'
})
export class FeatureGuard implements CanMatch {
  constructor(private featureToggleService: FeatureToggleService) {}

  canMatch(
    route: Route,
    segments: UrlSegment[]
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    // Exemplo: Somente permite o match se a feature 'newFeature' estiver ativada
    return this.featureToggleService.isFeatureEnabled('newFeature');
  }
}

```

**Sintaxe (Baseada em Função):**

```tsx
// feature.guard.ts
import { CanMatchFn } from '@angular/router';
import { inject } from '@angular/core';
import { FeatureToggleService } from './feature-toggle.service';

export const featureGuard: CanMatchFn = (route, segments) => {
  const featureToggleService = inject(FeatureToggleService);
  return featureToggleService.isFeatureEnabled('newFeature');
};

```

**Uso no módulo de rotas:**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
// Importa a guarda
import { FeatureGuard } from './feature.guard'; // Para a classe
// import { featureGuard } from './feature.guard'; // Para a função

const routes: Routes = [
  // Rota para o módulo antigo (se a feature não estiver ativada)
  {
    path: 'my-feature',
    loadChildren: () => import('./old-feature/old-feature.module').then(m => m.OldFeatureModule),
  },
  // Nova rota para o módulo da nova feature (só é considerada se canMatch retornar true)
  {
    path: 'my-feature', // Mesmo path
    loadChildren: () => import('./new-feature/new-feature.module').then(m => m.NewFeatureModule),
    canMatch: [FeatureGuard] // Aplica a guarda 'CanMatch'
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### Funções de Guarda Tipadas (`CanActivateFn`, `CanDeactivateFn`, `CanLoadFn`, `ResolveFn`, `CanMatchFn`)

Introduzidas no Angular 14 e promovidas como a abordagem preferencial a partir do Angular 15, as funções de guarda oferecem uma sintaxe mais concisa e flexível do que as classes. Elas são mais leves, não precisam ser injetadas (podem usar `inject()` internamente) e são mais fáceis de testar.

Você já viu exemplos de cada uma delas nas seções anteriores, mas é importante reforçar que essa é a **direção que o Angular está tomando para as guardas de rotas**.

**Vantagens das Funções de Guarda:**

- **Conciseness:** Menos boilerplate code.
- **Flexibility:** Easier to compose and combine logic.
- **Tree-shakable:** Only the used parts of the code are included in the final bundle.
- **No Classes or Services Needed:** Can be pure functions, though they often use `inject()` for dependencies.
- **Better Type Safety:** Explicitly typed functions.

---

### Cenários de Restrição ou Não Aplicação

Embora as Guardas de Rotas sejam ferramentas poderosas, há situações em que podem não ser a melhor abordagem ou podem ser excessivas:

- **Lógica de Negócios Simples:** Para validações muito simples que não envolvem controle de acesso ou pré-carregamento de dados complexos, a lógica pode ser incorporada diretamente no componente. No entanto, para manter a modularidade e o princípio de responsabilidade única, mesmo validações simples de acesso podem se beneficiar de uma guarda.
- **Controle de Visibilidade de Elementos:** As guardas controlam a navegação. Se você precisa apenas ocultar ou exibir elementos na interface do usuário com base em permissões, sem impedir a navegação, é mais apropriado usar diretivas como `ngIf` ou serviços de permissão dentro dos componentes.
- **Performance em Excesso:** Usar muitas guardas complexas em uma única rota ou aninhá-las profundamente pode impactar o tempo de carregamento da rota. Monitore o desempenho e otimize a lógica das suas guardas.
- **Redirecionamento Condicional Simples:** Para redirecionamentos baseados em condições muito básicas que não exigem verificação de autenticação ou autorização, você pode usar a propriedade `redirectTo` diretamente na configuração da rota, ou lógica simples no componente `ngOnInit`. No entanto, para cenários de redirecionamento mais complexos, uma guarda é a escolha ideal.

---

### Melhores Práticas e Padrões de Uso

- **Priorize Funções de Guarda:** Para novas guardas e projetos no Angular 15+, dê preferência às funções de guarda (`CanActivateFn`, `CanDeactivateFn`, etc.) devido à sua concisão e modernidade.
- **Modularização:** Crie guardas separadas para cada tipo de lógica (autenticação, autorização, salvamento, etc.). Isso torna seu código mais limpo e fácil de manter.
- **Serviços de Apoio:** As guardas devem ser concisas. Delegue a lógica complexa (como chamadas de API para verificar autenticação) a serviços dedicados, injetando-os nas guardas (via construtor para classes ou `inject()` para funções).
- **Reutilização:** Desenvolva guardas genéricas que possam ser reutilizadas em várias rotas ou módulos, como uma `AuthGuard` global.
- **Tratamento de Erros e Feedback ao Usuário:** Se uma guarda bloquear o acesso, forneça feedback claro ao usuário (redirecionando para uma página de login, exibindo uma mensagem de erro, etc.).
- **Assincronicidade:** Utilize `Observables` ou `Promises` para lidar com operações assíncronas dentro das guardas (por exemplo, verificar a autenticação com uma API).
- **Chain de Guardas:** Você pode aplicar múltiplas guardas a uma única rota. Elas serão executadas na ordem em que são listadas. Se uma guarda retornar `false` ou uma `UrlTree`, as guardas subsequentes não serão executadas.
- **Guarda para Redirecionamento:** Em vez de retornar `false` diretamente, você pode retornar uma `UrlTree` para redirecionar o usuário para outra rota, como `this.router.parseUrl('/login')`.
- **Utilize `Resolve` para UX:** Sempre que um componente precisar de dados antes de ser renderizado, considere usar `Resolve`. Isso evita que o usuário veja uma tela sem dados ou um "flicker" de carregamento.
- **`CanLoad` e `CanMatch` para otimização:** Use `CanLoad` para módulos grandes que são carregados sob demanda e que nem todos os usuários terão acesso. Use `CanMatch` quando você tiver rotas com o mesmo `path` mas condições de ativação diferentes, evitando o carregamento desnecessário de módulos.

---

### Exemplos Práticos Otimizados

Vamos construir um cenário onde combinamos várias guardas para proteger uma área administrativa, utilizando, sempre que possível, as funções de guarda.

**Cenário:**

Temos uma área administrativa (`/admin`) que só pode ser acessada por usuários autenticados e que possuem a role de "admin". Dentro dessa área, temos uma seção de "configurações" (`/admin/settings`) que permite editar configurações sensíveis. Queremos garantir que o usuário não saia dessa página se houver alterações não salvas. Além disso, ao acessar a página de "detalhes do usuário" (`/admin/users/:id`), queremos que os dados do usuário sejam pré-carregados.

1. **`AuthGuard` (CanActivateFn):** Para garantir que apenas usuários logados possam acessar a área `/admin`.
2. **`AdminRoleGuard` (CanActivateChildFn):** Para garantir que apenas usuários com a role de "admin" possam acessar as rotas filhas da área `/admin`.
3. **`SettingsGuard` (CanDeactivateFn):** Para a rota `/admin/settings`, para confirmar a saída se houver alterações não salvas.
4. **`UserDetailResolver` (ResolveFn):** Para pré-carregar os dados do usuário na rota `/admin/users/:id`.

**(Para simplicidade, `AuthService` e `UserService` serão simulados, assim como no exemplo anterior)**

```tsx
// auth.service.ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private loggedIn = false;
  private userRole = 'user'; // Pode ser 'user' ou 'admin'

  login(username: string, password: string): boolean {
    // Simulação de login
    if (username === 'admin' && password === 'admin') {
      this.loggedIn = true;
      this.userRole = 'admin';
      return true;
    } else if (username === 'user' && password === 'user') {
      this.loggedIn = true;
      this.userRole = 'user';
      return true;
    }
    this.loggedIn = false;
    this.userRole = 'user';
    return false;
  }

  logout(): void {
    this.loggedIn = false;
    this.userRole = 'user';
  }

  isLoggedIn(): boolean {
    return this.loggedIn;
  }

  hasRole(role: string): boolean {
    return this.userRole === role;
  }
}

// user.service.ts
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { delay } from 'rxjs/operators'; // Para simular um atraso de rede

interface User {
  id: number;
  name: string;
  email: string;
  role: string;
}

@Injectable({ providedIn: 'root' })
export class UserService {
  private users: User[] = [
    { id: 1, name: 'João Silva', email: 'joao@example.com', role: 'user' },
    { id: 2, name: 'Maria Souza', email: 'maria@example.com', role: 'admin' },
    { id: 3, name: 'Pedro Alves', email: 'pedro@example.com', role: 'user' }
  ];

  getUser(id: number): Observable<User | undefined> {
    const user = this.users.find(u => u.id === id);
    return of(user).pipe(delay(500)); // Simula atraso
  }
}

```

**As Guardas (Todas Funções):**

```tsx
// auth.guard.ts (CanActivateFn)
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true;
  }
  return router.parseUrl('/login'); // Redireciona para login
};

// admin-role.guard.ts (CanActivateChildFn)
import { CanActivateChildFn } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const adminRoleGuard: CanActivateChildFn = (childRoute, state) => {
  const authService = inject(AuthService);
  if (authService.hasRole('admin')) {
    return true;
  }
  alert('Acesso negado! Você não tem permissão de administrador.');
  return false;
};

// settings.guard.ts (CanDeactivateFn)
import { CanDeactivateFn } from '@angular/router';
import { Observable, UrlTree } from 'rxjs';
import { AdminSettingsComponent } from './admin-settings/admin-settings.component'; // Importe seu componente aqui

// Você pode criar uma interface para o componente se preferir, mas também pode tipar diretamente
// export interface CanComponentDeactivate { canDeactivate: () => Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree; }

export const settingsGuard: CanDeactivateFn<AdminSettingsComponent> = (component, currentRoute, currentState, nextState) => {
  // O componente precisa ter um método 'canDeactivate'
  return component.canDeactivate ? component.canDeactivate() : true;
};

// user-detail.resolver.ts (ResolveFn)
import { ResolveFn } from '@angular/router';
import { inject } from '@angular/core';
import { UserService } from './user.service';
import { Observable } from 'rxjs';

interface User { id: number; name: string; email: string; role: string; }

export const userDetailResolver: ResolveFn<User | undefined> = (route, state) => {
  const userService = inject(UserService);
  const userId = +route.paramMap.get('id')!;
  return userService.getUser(userId);
};

```

**Componentes (Exemplos simplificados):**

```tsx
// login.component.ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from './auth.service';

@Component({
  selector: 'app-login',
  template: `
    <h2>Login</h2>
    <input type="text" [(ngModel)]="username" placeholder="Usuário">
    <input type="password" [(ngModel)]="password" placeholder="Senha">
    <button (click)="onLogin()">Login</button>
    <p>Use 'admin/admin' para administrador ou 'user/user' para usuário comum.</p>
  `
})
export class LoginComponent {
  username = '';
  password = '';

  constructor(private authService: AuthService, private router: Router) {}

  onLogin() {
    if (this.authService.login(this.username, this.password)) {
      this.router.navigate(['/admin']);
    } else {
      alert('Credenciais inválidas!');
    }
  }
}

// admin-dashboard.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-admin-dashboard',
  template: `<h2>Painel Administrativo</h2>`
})
export class AdminDashboardComponent {}

// admin-settings.component.ts (Implementa o método esperado pela guarda)
import { Component, OnInit } from '@angular/core';
import { Observable, of } from 'rxjs';

@Component({
  selector: 'app-admin-settings',
  template: `
    <h2>Configurações Administrativas</h2>
    <input type="text" [(ngModel)]="settingValue">
    <button (click)="saveSettings()">Salvar</button>
    <p *ngIf="!saved">Você tem alterações não salvas!</p>
  `
})
export class AdminSettingsComponent implements OnInit {
  settingValue: string = 'Valor inicial';
  private originalSettingValue: string = '';
  saved: boolean = true;

  ngOnInit(): void {
    this.originalSettingValue = this.settingValue;
  }

  saveSettings() {
    // Lógica para salvar as configurações
    this.originalSettingValue = this.settingValue;
    this.saved = true;
    alert('Configurações salvas!');
  }

  // Método canDeactivate que a guarda espera
  canDeactivate(): Observable<boolean> | Promise<boolean> | boolean {
    if (this.settingValue !== this.originalSettingValue && !this.saved) {
      return confirm('Você tem alterações não salvas. Deseja realmente sair?');
    }
    return true;
  }
}

// admin-user-detail.component.ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-admin-user-detail',
  template: `
    <h2>Detalhes do Usuário (Administrador)</h2>
    <div *ngIf="user">
      <p>ID: {{ user.id }}</p>
      <p>Nome: {{ user.name }}</p>
      <p>Email: {{ user.email }}</p>
      <p>Role: {{ user.role }}</p>
    </div>
    <div *ngIf="!user">
      <p>Usuário não encontrado.</p>
    </div>
  `
})
export class AdminUserDetailComponent implements OnInit {
  user: any;

  constructor(private route: ActivatedRoute) {}

  ngOnInit(): void {
    this.route.data.subscribe(data => {
      this.user = data['user']; // O 'user' vem do resolver
    });
  }
}

```

**Configuração de Rotas (`app-routing.module.ts`):**

```tsx
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

// Importa as funções de guarda e resolver
import { authGuard } from './auth.guard';
import { adminRoleGuard } from './admin-role.guard';
import { settingsGuard } from './settings.guard';
import { userDetailResolver } from './user-detail.resolver';

// Importa os componentes
import { LoginComponent } from './login/login.component';
import { AdminDashboardComponent } from './admin-dashboard/admin-dashboard.component';
import { AdminSettingsComponent } from './admin-settings/admin-settings.component';
import { AdminUserDetailComponent } from './admin-user-detail/admin-user-detail.component';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  {
    path: 'admin',
    canActivate: [authGuard], // Apenas usuários logados podem acessar /admin
    canActivateChild: [adminRoleGuard], // Apenas admins podem acessar rotas filhas de /admin
    children: [
      { path: 'dashboard', component: AdminDashboardComponent },
      {
        path: 'settings',
        component: AdminSettingsComponent,
        canDeactivate: [settingsGuard] // Aplica a guarda de desativação
      },
      {
        path: 'users/:id',
        component: AdminUserDetailComponent,
        resolve: {
          user: userDetailResolver // Pré-carrega os dados do usuário
        }
      },
      { path: '', redirectTo: 'dashboard', pathMatch: 'full' }
    ]
  },
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: '**', redirectTo: '/login' } // Rota curinga para 404/redirecionamento
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

Neste exemplo atualizado, Gedê, você pode ver a sinergia entre as diferentes guardas, agora com ênfase nas **funções de guarda**, para criar um fluxo de navegação seguro e eficiente no Angular. Essa abordagem é a mais moderna e recomendada para novas aplicações.

Ficou mais claro agora com todas as interfaces e as abordagens de classe e função?