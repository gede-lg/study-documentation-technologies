# CanActivate

Opa, Gedê\! Entendido. A.R.I.A. vai te dar uma explicação detalhada sobre `CanActivate` no Angular, com foco em todos os pontos que você pediu. Bora lá\!

---

## **Guarda de Rotas no Angular: Desvendando o CanActivate**

A navegação em aplicações web modernas é um pilar fundamental para a experiência do usuário. No entanto, nem todas as rotas devem ser acessíveis a todos os usuários em todos os momentos. É aqui que entram as **guards de rota** do Angular, e entre elas, a **`CanActivate`** se destaca como uma ferramenta essencial para controlar o acesso a determinadas partes da sua aplicação.

---

### **Sumário**

Nesta explicação abrangente, vamos cobrir os seguintes tópicos para garantir que você tenha um domínio completo sobre o `CanActivate`:

- **Introdução:** Contexto das guards de rota e a importância do `CanActivate`.
- **Conceitos Fundamentais:** Base teórica, propósito e por que o `CanActivate` é crucial para a segurança e controle de acesso em aplicações Angular.
- **Sintaxe Detalhada e Uso Prático:** Como implementar e configurar o `CanActivate` em suas rotas, com exemplos de código comentados.
- **Métodos/Propriedades:** Uma análise exaustiva de todos os métodos e propriedades associados ao `CanActivate`.
- **Cenários de Restrição ou Não Aplicação:** Quando o `CanActivate` pode não ser a melhor escolha e alternativas a considerar.
- **Componentes Chave Associados:** Exploração das interfaces, classes e módulos cruciais que trabalham em conjunto com o `CanActivate`.
- **Melhores Práticas e Padrões de Uso:** Recomendações e dicas para utilizar o `CanActivate` de forma eficiente e segura.
- **Exemplo Prático Completo:** Um cenário de ponta a ponta demonstrando a aplicação do `CanActivate` em um projeto Angular.

---

### **Introdução**

Em aplicações de página única (SPAs) como as construídas com Angular, a navegação entre diferentes visualizações é gerenciada por um roteador. Imagine que você tem uma área administrativa que só deve ser acessível a usuários autenticados, ou uma página de edição de perfil que só pode ser vista pelo proprietário do perfil. Como você garante que esses requisitos de segurança e acesso sejam respeitados?

É aí que as **guards de rota** entram em cena. Elas são classes que o roteador do Angular executa para decidir se pode ou não navegar para uma rota específica. O `CanActivate` é uma dessas guards, e seu papel é determinar se um usuário tem permissão para **ativar** uma determinada rota. Se a guard retornar `true`, a navegação é permitida; se retornar `false`, a navegação é cancelada.

---

### **Conceitos Fundamentais**

O `CanActivate` é uma interface que você implementa em uma classe para criar uma guard de rota. Seu principal objetivo é proteger rotas, impedindo que usuários não autorizados ou que não atendam a certos critérios acessem determinadas partes da sua aplicação. Isso é crucial para:

- **Segurança:** Evitar que usuários não autenticados ou não autorizados acessem dados sensíveis ou funcionalidades restritas.
- **Experiência do Usuário:** Direcionar o usuário para uma página de login, uma página de erro ou qualquer outra rota adequada quando o acesso é negado, fornecendo feedback claro.
- **Controle de Fluxo:** Gerenciar o fluxo de navegação da aplicação com base em condições dinâmicas, como o status de uma operação, a disponibilidade de dados ou o preenchimento de formulários.

A importância do `CanActivate` reside na sua capacidade de atuar como um "porteiro" antes que qualquer componente da rota seja carregado ou inicializado. Isso significa que a lógica de autorização é executada **antes** de o usuário ver qualquer conteúdo da rota protegida.

---

### **Sintaxe Detalhada e Uso Prático**

Para usar `CanActivate`, você precisa criar uma classe que implemente a interface `CanActivate` e, em seguida, registrar essa classe no seu módulo de roteamento.

### **1. Criando a Guard CanActivate**

Você pode gerar uma guard usando o Angular CLI:

```bash
ng generate guard auth

```

O CLI perguntará qual interface você deseja implementar. Selecione `CanActivate`.

Isso criará um arquivo `auth.guard.ts` (ou o nome que você deu) parecido com este:

```tsx
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  // Injeta o Router para poder redirecionar em caso de acesso negado
  constructor(private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {

    // Lógica de autorização aqui.
    // Por exemplo, verificar se o usuário está logado.
    const isAuthenticated = false; // Simula a verificação de autenticação

    if (isAuthenticated) {
      console.log('Acesso permitido para a rota:', state.url);
      return true; // Permite a navegação
    } else {
      console.log('Acesso negado para a rota:', state.url);
      // Redireciona para a página de login se o usuário não estiver autenticado
      alert('Você precisa estar logado para acessar esta página!');
      return this.router.createUrlTree(['/login']); // Redireciona para a rota '/login'
      // Ou simplesmente retorna false para cancelar a navegação e permanecer na rota atual
      // return false;
    }
  }
}

```

### **2. Aplicando a Guard na Configuração de Rotas**

No seu arquivo de configuração de rotas (`app-routing.module.ts` ou similar), você adiciona a guard à propriedade `canActivate` da rota:

```tsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AuthGuard } from './auth.guard'; // Importa a sua guard
import { DashboardComponent } from './dashboard/dashboard.component';
import { LoginComponent } from './login/login.component';
import { HomeComponent } from './home/home.component';

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard] // Aplica a guard CanActivate aqui
  },
  { path: '**', redirectTo: '/home' } // Rota curinga para caminhos não encontrados
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

Neste exemplo, a rota `/dashboard` só poderá ser ativada se a `AuthGuard` retornar `true`. Se retornar `false` ou um `UrlTree` para redirecionamento, a navegação para `/dashboard` será impedida ou o usuário será redirecionado.

Você pode ter múltiplas guards para uma única rota. Elas serão executadas na ordem em que são listadas no array `canActivate`:

```tsx
{
  path: 'admin',
  component: AdminComponent,
  canActivate: [AuthGuard, AdminRoleGuard] // Ambas as guards precisam retornar true
}

```

Se qualquer uma das guards retornar `false` ou um `UrlTree`, a navegação é interrompida imediatamente.

---

### **Métodos/Propriedades**

A interface `CanActivate` possui um único método principal que você precisa implementar:

### `canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree`

- **`route: ActivatedRouteSnapshot`**: Este parâmetro fornece uma "fotografia" da rota que está sendo ativada. Ele contém informações como:
    - `route.params`: Os parâmetros da URL (ex: `/users/:id`).
    - `route.queryParams`: Os parâmetros de consulta da URL (ex: `/users?role=admin`).
    - `route.data`: Dados arbitrários estáticos definidos na configuração da rota.
    - `route.url`: Segmentos da URL.
    - `route.parent`: A rota pai, se houver.
    - `route.root`: A rota raiz.
    - `route.fragment`: O fragmento da URL (ex: `#section1`).
    
    É útil para tomar decisões baseadas em dados específicos da rota. Por exemplo, você pode verificar se um usuário tem permissão para editar um item específico com base no `id` passado na URL.
    
- **`state: RouterStateSnapshot`**: Este parâmetro representa o estado futuro do roteador. Ele fornece uma "fotografia" da árvore de rotas que seria ativada se a navegação fosse bem-sucedida. Isso inclui:
    - `state.url`: A URL completa que o usuário tentou acessar.
    - `state.root`: O `ActivatedRouteSnapshot` da rota raiz do estado futuro.
    
    É útil para obter a URL completa que o usuário tentou acessar, o que pode ser útil para redirecionamentos ou logging.
    
- **Retorno do Método `canActivate`:** O método `canActivate` é muito flexível em termos de seu tipo de retorno, podendo ser:
    - **`boolean`**:
        - `true`: A navegação para a rota é permitida.
        - `false`: A navegação para a rota é cancelada. O roteador não ativará a rota e permanecerá na rota atual.
    - **`UrlTree`**: Um objeto `UrlTree` representa uma URL estruturada que o roteador pode usar para navegar. Se você retornar um `UrlTree`, o roteador cancelará a navegação para a rota original e navegará para a URL representada pelo `UrlTree`. Isso é extremamente útil para redirecionamentos programáticos, por exemplo, para uma página de login ou de acesso negado.
        - Exemplo: `return this.router.createUrlTree(['/login']);`
    - **`Observable<boolean | UrlTree>`**: Útil quando a sua lógica de autorização envolve operações assíncronas, como chamadas HTTP para um serviço de autenticação ou autorização. O roteador esperará que o Observable emita um valor (`true`, `false` ou `UrlTree`) antes de prosseguir com a navegação.
        - Certifique-se de que o Observable se complete (emita um valor e chame `complete()`) para que o roteador possa reagir.
    - **`Promise<boolean | UrlTree>`**: Similar ao Observable, mas para Promisses. Também útil para operações assíncronas. O roteador esperará que a Promise seja resolvida com `true`, `false` ou um `UrlTree`.

**Importante:** A guard `CanActivate` deve ser um serviço Angular injetável (`@Injectable({ providedIn: 'root' })`). Isso permite que você injete outros serviços (como serviços de autenticação, serviços de dados, o `Router` ou o `ActivatedRoute`) na sua guard para realizar a lógica de autorização.

---

### **Cenários de Restrição ou Não Aplicação**

Embora o `CanActivate` seja poderoso, existem cenários onde ele pode não ser a melhor escolha ou onde outras guards podem ser mais adequadas:

1. **Guarda de Desativação (`CanDeactivate`):** Se você precisa verificar se um usuário pode **sair** de uma rota (por exemplo, para evitar perda de dados em um formulário não salvo), o `CanDeactivate` é a guard apropriada. O `CanActivate` só lida com a entrada na rota.
2. **Pré-carregamento de Dados (`Resolve`):** Se o seu objetivo é garantir que os dados necessários para uma rota estejam disponíveis **antes** que o componente seja carregado, o `Resolve` é a guard correta. Ele permite que você busque dados assincronamente e os disponibilize para o componente da rota. O `CanActivate` foca apenas na permissão de acesso, não na disponibilidade de dados.
3. **Carregamento de Módulos Lazy-Loaded (`CanLoad`):** Se você tem módulos com carregamento preguiçoso (lazy-loaded) e quer evitar que todo o módulo seja baixado se o usuário não tiver permissão para acessá-lo, o `CanLoad` é a guard ideal. Ele verifica a permissão **antes** que o módulo seja carregado. O `CanActivate` só é executado após o módulo já ter sido carregado.
4. **Lógica Muito Complexa e Global:** Para lógicas de autorização extremamente complexas que afetam múltiplos componentes e envolvem muitas interações, pode ser mais eficiente implementar essa lógica em um serviço centralizado e injetá-lo nas guards e/ou nos próprios componentes. O `CanActivate` deve ser focado na decisão de "sim ou não" para a ativação da rota.
5. **Performance em Aplicações Pequenas:** Em aplicações muito pequenas onde a segurança não é uma preocupação primária ou o número de rotas é mínimo, a complexidade adicional de criar guards pode ser um exagero. Nesses casos, uma lógica simples dentro do próprio componente pode ser suficiente, embora não seja a prática recomendada para aplicações maiores.

---

### **Componentes Chave Associados**

Para que o `CanActivate` funcione, ele se integra a outros componentes e conceitos cruciais do Angular:

1. **`@Injectable` Decorator:**
    - **O que é:** Um decorador que marca uma classe como disponível para ser injetada em outras classes como uma dependência.
    - **Uso e Sintaxe:**
        
        ```tsx
        @Injectable({
          providedIn: 'root' // Torna o serviço disponível em toda a aplicação
        })
        export class MyService { /* ... */ }
        
        ```
        
    - **Crucial para `CanActivate`:** As guards de rota são serviços. O `@Injectable` permite que o roteador do Angular crie uma instância da sua guard e a utilize. `providedIn: 'root'` é a prática recomendada para garantir que a guard seja um singleton em toda a aplicação.
2. **`CanActivate` Interface:**
    - **O que é:** Uma interface definida no pacote `@angular/router` que sua classe de guard deve implementar.
    - **Uso e Sintaxe:**
        
        ```tsx
        import { CanActivate } from '@angular/router';
        
        export class MyGuard implements CanActivate {
          // Implementação do método canActivate
          canActivate(...) { /* ... */ }
        }
        
        ```
        
    - **Crucial para `CanActivate`:** Garante que sua classe possui o método `canActivate` com a assinatura correta, que o roteador Angular espera chamar.
3. **`ActivatedRouteSnapshot` Class:**
    - **O que é:** Uma classe que representa uma "fotografia" imutável de uma rota ativa em um ponto específico no tempo.
    - **Uso e Sintaxe:** É um dos parâmetros do método `canActivate`. Você acessa suas propriedades diretamente:
        
        ```tsx
        canActivate(route: ActivatedRouteSnapshot, ...) {
          const userId = route.params['id']; // Acessa um parâmetro da URL
          const isAdmin = route.queryParams['admin']; // Acessa um parâmetro de consulta
          const pageTitle = route.data['title']; // Acessa dados estáticos da rota
        }
        
        ```
        
    - **Crucial para `CanActivate`:** Permite que a lógica da guard tome decisões baseadas nas características específicas da rota para a qual a navegação está tentando ocorrer.
4. **`RouterStateSnapshot` Class:**
    - **O que é:** Uma classe que representa o estado futuro do roteador, incluindo a árvore completa de rotas que seriam ativadas após a navegação.
    - **Uso e Sintaxe:** É o segundo parâmetro do método `canActivate`.
        
        ```tsx
        canActivate(..., state: RouterStateSnapshot) {
          const fullUrl = state.url; // A URL completa que está sendo navegada
          // state.root.children para explorar a árvore de rotas futuras
        }
        
        ```
        
    - **Crucial para `CanActivate`:** Fornece contexto sobre o estado geral do roteador e a URL completa que está sendo solicitada, útil para logging ou redirecionamentos condicionados à URL completa.
5. **`Router` Class:**
    - **O que é:** O principal serviço de roteamento do Angular, responsável por navegar entre as rotas, gerenciar o histórico e a interação com a URL do navegador.
    - **Uso e Sintaxe:** Você injeta o `Router` no construtor da sua guard:
        
        ```tsx
        import { Router } from '@angular/router';
        
        export class AuthGuard implements CanActivate {
          constructor(private router: Router) {}
        
          canActivate(...) {
            // Redirecionar para outra rota
            return this.router.createUrlTree(['/login']);
          }
        }
        
        ```
        
    - **Crucial para `CanActivate`:** Essencial para implementar a lógica de redirecionamento quando o acesso é negado, usando `createUrlTree` ou `Maps`.
6. **`UrlTree` Class:**
    - **O que é:** Uma representação estruturada de uma URL no Angular, usada internamente pelo roteador.
    - **Uso e Sintaxe:** Não é instanciada diretamente por você, mas sim criada pelo método `router.createUrlTree()`.
        
        ```tsx
        // Exemplo de retorno no canActivate
        return this.router.createUrlTree(['/access-denied'], { queryParams: { returnUrl: state.url } });
        
        ```
        
    - **Crucial para `CanActivate`:** Permite que a guard, em vez de simplesmente bloquear a navegação, direcione o usuário para uma URL alternativa, mantendo o controle sobre o fluxo de navegação.

---

### **Melhores Práticas e Padrões de Uso**

Para usar `CanActivate` de forma eficaz e manter seu código limpo e seguro:

1. **Mantenha a Lógica Simples:** As guards devem ser leves e focadas em uma única responsabilidade. Se a lógica de autorização se tornar muito complexa, considere mover partes dela para um serviço separado e injetá-lo na guard.
2. **Use Serviços para Lógica Centralizada:** Tenha um serviço de autenticação (`AuthService`) e/ou um serviço de autorização (`AuthorizationService`) que encapsule a lógica de verificação de usuário logado, permissões de role, etc. Sua guard então injetaria e chamaria os métodos desses serviços.
    
    ```tsx
    // auth.service.ts
    @Injectable({ providedIn: 'root' })
    export class AuthService {
      isAuthenticated(): boolean {
        // Lógica real de autenticação
        return localStorage.getItem('token') !== null;
      }
      hasRole(role: string): boolean {
        // Lógica real de verificação de role
        const userRoles = ['admin', 'user']; // Exemplo
        return userRoles.includes(role);
      }
    }
    
    // auth.guard.ts
    export class AuthGuard implements CanActivate {
      constructor(private authService: AuthService, private router: Router) {}
    
      canActivate(...): boolean | UrlTree {
        if (this.authService.isAuthenticated()) {
          return true;
        }
        return this.router.createUrlTree(['/login']);
      }
    }
    
    ```
    
3. **Redirecionamento Explícito com `UrlTree`:** Em vez de retornar `false` e deixar o usuário "preso" na página anterior, use `this.router.createUrlTree()` para redirecionar o usuário para uma página de login, uma página de acesso negado ou uma rota padrão. Isso melhora a experiência do usuário, pois ele sabe o que aconteceu e o que fazer em seguida.
4. **Mensagens ao Usuário:** Se você redirecionar ou negar acesso, considere usar um serviço de notificação (como `MatSnackBar` do Angular Material ou um simples `alert()`) para informar o usuário o motivo da negação de acesso.
5. **Lógica Assíncrona com `Observable` ou `Promise`:** Sempre que a decisão de autorização depender de uma chamada a uma API externa ou de qualquer outra operação assíncrona, use `Observable` ou `Promise` como tipo de retorno. Isso garante que a navegação só ocorra após a conclusão da verificação.
6. **Teste Suas Guards:** Crie testes unitários para suas guards para garantir que a lógica de permissão está funcionando conforme o esperado em diferentes cenários (autenticado, não autenticado, com diferentes roles, etc.).
7. **Composição de Guards:** Para requisitos complexos (ex: "usuário deve ser admin OU editor, E deve estar logado"), você pode criar guards menores e combiná-las ou criar uma guard que chame outras guards internamente.

---

### **Exemplo Prático Completo**

Vamos simular um cenário onde temos uma aplicação com áreas públicas, uma área de login e uma área restrita (`/admin`) que só pode ser acessada por usuários autenticados com a role de "admin".

### **1. Estrutura do Projeto:**

```
src/
├── app/
│   ├── app-routing.module.ts
│   ├── app.component.html
│   ├── app.component.ts
│   ├── auth.guard.ts           <-- Nossa guard
│   ├── auth.service.ts         <-- Serviço de autenticação
│   ├── admin/
│   │   ├── admin.component.html
│   │   └── admin.component.ts
│   ├── home/
│   │   ├── home.component.html
│   │   └── home.component.ts
│   ├── login/
│   │   ├── login.component.html
│   │   └── login.component.ts

```

### **2. `auth.service.ts` (Serviço de Autenticação)**

```tsx
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { delay, tap } from 'rxjs/operators';

interface User {
  username: string;
  roles: string[];
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private currentUser: User | null = null; // Simula o usuário logado

  constructor() {
    // Tenta carregar um usuário simulado do localStorage ao iniciar
    const storedUser = localStorage.getItem('currentUser');
    if (storedUser) {
      this.currentUser = JSON.parse(storedUser);
    }
  }

  // Simula o login
  login(username: string, password: string): Observable<boolean> {
    // Lógica de autenticação simplificada
    if (username === 'admin' && password === 'admin123') {
      this.currentUser = { username: 'admin', roles: ['admin', 'user'] };
      localStorage.setItem('currentUser', JSON.stringify(this.currentUser));
      return of(true).pipe(delay(500), tap(() => console.log('Login bem-sucedido')));
    } else if (username === 'user' && password === 'user123') {
      this.currentUser = { username: 'user', roles: ['user'] };
      localStorage.setItem('currentUser', JSON.stringify(this.currentUser));
      return of(true).pipe(delay(500), tap(() => console.log('Login bem-sucedido')));
    }
    this.currentUser = null;
    localStorage.removeItem('currentUser');
    return of(false).pipe(delay(500), tap(() => console.log('Login falhou')));
  }

  // Simula o logout
  logout(): void {
    this.currentUser = null;
    localStorage.removeItem('currentUser');
    console.log('Logout realizado');
  }

  // Verifica se o usuário está autenticado
  isAuthenticated(): boolean {
    return this.currentUser !== null;
  }

  // Verifica se o usuário tem uma determinada role
  hasRole(role: string): boolean {
    return this.currentUser ? this.currentUser.roles.includes(role) : false;
  }
}

```

### **3. `auth.guard.ts` (Nossa Guarda de Rotas)**

```tsx
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {

    console.log('Verificando acesso para:', state.url);

    // 1. Verifica se o usuário está autenticado
    if (!this.authService.isAuthenticated()) {
      alert('Você precisa estar logado para acessar esta página.');
      // Redireciona para a página de login, passando a URL original como query param
      return this.router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
    }

    // 2. Se estiver autenticado, verifica se a rota requer uma role específica
    // A rota pode definir `data: { requiredRole: 'admin' }`
    const requiredRole = route.data['requiredRole'] as string;

    if (requiredRole && !this.authService.hasRole(requiredRole)) {
      alert(`Você não tem permissão de ${requiredRole} para acessar esta página.`);
      // Redireciona para uma página de acesso negado ou para a home
      return this.router.createUrlTree(['/access-denied']);
    }

    // Se passou por todas as verificações, permite o acesso
    console.log('Acesso permitido.');
    return true;
  }
}

```

### **4. `app-routing.module.ts` (Configuração de Rotas)**

```tsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { LoginComponent } from './login/login.component';
import { AdminComponent } from './admin/admin.component';
import { AuthGuard } from './auth.guard'; // Importe a guard

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  { path: 'access-denied', component: HomeComponent /* ou um componente de acesso negado */ },
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [AuthGuard], // Protege a rota '/admin'
    data: { requiredRole: 'admin' } // Dados da rota que a guard pode usar
  },
  { path: '**', redirectTo: '/home' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### **5. `login.component.ts` (Exemplo de Login)**

```tsx
import { Component, OnInit } from '@angular/core';
import { AuthService } from '../auth.service';
import { Router, ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-login',
  template: `
    <h2>Login</h2>
    <input [(ngModel)]="username" placeholder="Usuário">
    <input type="password" [(ngModel)]="password" placeholder="Senha">
    <button (click)="onLogin()">Entrar</button>
    <div *ngIf="errorMessage" style="color: red;">{{ errorMessage }}</div>
    <p>Usuário: admin / Senha: admin123 (para acesso admin)</p>
    <p>Usuário: user / Senha: user123 (para acesso user)</p>
    <p><button (click)="logout()">Sair</button></p>
  `,
  styleUrls: []
})
export class LoginComponent implements OnInit {
  username = '';
  password = '';
  errorMessage: string | null = null;
  returnUrl: string | null = null;

  constructor(
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  ngOnInit(): void {
    this.route.queryParams.subscribe(params => {
      this.returnUrl = params['returnUrl'] || null;
    });
  }

  onLogin(): void {
    this.errorMessage = null;
    this.authService.login(this.username, this.password).subscribe(success => {
      if (success) {
        if (this.returnUrl) {
          this.router.navigateByUrl(this.returnUrl);
        } else {
          this.router.navigate(['/home']);
        }
      } else {
        this.errorMessage = 'Usuário ou senha inválidos.';
      }
    });
  }

  logout(): void {
    this.authService.logout();
    this.router.navigate(['/home']);
  }
}

```

### **6. `app.component.html` (Navegação)**

```html
<h1>Aplicação de Exemplo com Guards</h1>
<nav>
  <a routerLink="/home">Home</a> |
  <a routerLink="/login">Login</a> |
  <a routerLink="/admin">Área Admin</a>
</nav>

<hr>

<router-outlet></router-outlet>

```

Neste exemplo:

- A `AuthGuard` verifica primeiro se o usuário está logado usando `authService.isAuthenticated()`. Se não estiver, ele é redirecionado para `/login` com a URL original como `returnUrl`.
- Se o usuário estiver logado, a guard verifica se a rota que está sendo acessada (`/admin`) requer uma role específica (`data: { requiredRole: 'admin' }`).
- Se o usuário não tiver a role necessária, ele é redirecionado para `/access-denied`.
- A `login.component.ts` utiliza o `returnUrl` para redirecionar o usuário de volta para a página que ele tentou acessar após um login bem-sucedido.

Isso demonstra um fluxo completo de autenticação e autorização usando `CanActivate`.

---

Gedê, espero que esta explicação detalhada sobre `CanActivate` te ajude a dominar o uso de guards de rota no Angular\! Se tiver mais alguma dúvida ou quiser aprofundar em algum ponto, é só chamar a A.R.I.A.\!