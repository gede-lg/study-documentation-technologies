# CanActivateFn

Claro, Gedê\! Preparei uma explicação extremamente detalhada sobre as Guardas de Rota Funcionais (`CanActivateFn`) no Angular, conforme você solicitou.

Vamos mergulhar fundo neste conceito essencial para a proteção de rotas em aplicações Angular modernas.

---

### **Título: Desvendando o `CanActivateFn`: O Guia Definitivo para Guardas de Rota Funcionais no Angular**

---

### **Introdução**

No ecossistema Angular, o controle de acesso às rotas é uma necessidade fundamental para a maioria das aplicações. Precisamos garantir que apenas usuários autorizados possam acessar determinadas páginas, como painéis de administração, perfis de usuário ou conteúdo restrito. Tradicionalmente, isso era feito com "Route Guards" baseados em classes que implementavam a interface `CanActivate`. No entanto, com a evolução do Angular e a introdução de APIs mais funcionais e baseadas em injeção de dependência simplificada, surgiu uma abordagem mais moderna e elegante: o `CanActivateFn`. Esta é uma função simples que cumpre o mesmo papel, mas com menos código, maior flexibilidade e melhor "tree-shaking".

---

### **Sumário**

Este guia completo irá explorar em profundidade o `CanActivateFn`. Começaremos com os conceitos fundamentais por trás da proteção de rotas, passaremos pela sintaxe e uso prático da função, e detalharemos seus parâmetros e os tipos de retorno possíveis. Além disso, discutiremos os elementos associados, como o uso da função `inject` para injetar dependências, e as melhores práticas para cenários comuns, como autenticação e autorização baseada em papéis (roles). Ao final, você terá um entendimento sólido e prático para implementar guardas de rota robustas e eficientes em suas aplicações Angular.

---

### **Conceitos Fundamentais**

### O que é um Route Guard?

Um "Route Guard" (Guarda de Rota) no Angular é um mecanismo que permite ou impede a navegação para uma determinada rota com base em uma lógica específica. Ele atua como um porteiro ou um interceptador para o roteador do Angular. Antes de o roteador completar a navegação para uma rota, ele executa as guardas associadas a ela para verificar se a transição é permitida.

### O Propósito do `CanActivateFn`

O `CanActivateFn` é um tipo de função que define a lógica de um guarda de rota. Seu propósito principal é responder a uma pergunta simples: "**O usuário pode ativar esta rota neste momento?**".

A resposta a essa pergunta é dada através do valor de retorno da função, que pode ser:

- **Síncrono:** Um `boolean` simples (`true` para permitir, `false` para bloquear).
- **Redirecionamento:** Um `UrlTree`, que instrui o roteador a navegar para outra rota.
- **Assíncrono:** Um `Observable<boolean | UrlTree>` ou `Promise<boolean | UrlTree>`, que permite lógicas complexas, como fazer uma chamada HTTP para verificar o status de autenticação do usuário antes de decidir se a navegação é permitida.

A abordagem funcional (`CanActivateFn`) foi introduzida no Angular v14.2 e se tornou a forma preferencial de criar guardas, pois elimina a necessidade de criar uma classe e um `Injectable` separado, simplificando o código e melhorando a otimização do "bundle" final da aplicação (tree-shaking).

---

### **Sintaxe e Uso**

A `CanActivateFn` é, em sua essência, uma função que você exporta e associa a uma rota na sua configuração de roteamento.

### Sintaxe Básica

A assinatura da função é a seguinte:

```tsx
type CanActivateFn = (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot
) =>
  | boolean
  | UrlTree
  | Observable<boolean | UrlTree>
  | Promise<boolean | UrlTree>;

```

Vamos detalhar os parâmetros:

- `route: ActivatedRouteSnapshot`: Um snapshot (uma fotografia instantânea) da rota que está sendo ativada. Contém informações como os parâmetros da URL (`params`), os parâmetros de consulta (`queryParams`) e os dados estáticos (`data`) associados à rota.
- `state: RouterStateSnapshot`: Um snapshot do estado completo do roteador no momento. É útil para entender de onde o usuário está vindo e para onde está tentando ir em um contexto mais amplo da árvore de rotas.

### Exemplo de Código Prático

Vamos criar uma guarda de autenticação simples. O objetivo é permitir o acesso a uma rota apenas se um `AuthService` indicar que o usuário está logado.

**1. O Serviço de Autenticação (`auth.service.ts`)**

Primeiro, um serviço simples para simular o estado de autenticação.

```tsx
// src/app/auth.service.ts
import { Injectable } from '@angular/core';
import { of, Observable } from 'rxjs';
import { delay } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private isLoggedIn = false;

  // Simula uma verificação de login assíncrona
  checkAuthentication(): Observable<boolean> {
    console.log('Verificando autenticação...');
    // Em um app real, aqui seria uma chamada HTTP para um endpoint /me ou /status
    return of(this.isLoggedIn).pipe(delay(500));
  }

  login(): void {
    this.isLoggedIn = true;
  }

  logout(): void {
    this.isLoggedIn = false;
  }
}

```

**2. A Guarda Funcional (`auth.guard.ts`)**

Agora, a nossa `CanActivateFn`. Note o uso da função `inject` para obter instâncias de serviços.

```tsx
// src/app/auth.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { map, take } from 'rxjs/operators';
import { AuthService } from './auth.service';

// Exportamos a função diretamente
export const authGuard: CanActivateFn = (route, state) => {
  // Injetamos os serviços necessários DENTRO da função
  const authService = inject(AuthService);
  const router = inject(Router);

  // Usamos o serviço para verificar a autenticação
  return authService.checkAuthentication().pipe(
    take(1), // Pegamos apenas a primeira emissão para evitar subscriptions abertas
    map(isAuthenticated => {
      if (isAuthenticated) {
        return true; // Usuário autenticado, permite o acesso
      } else {
        console.log('Acesso negado. Redirecionando para /login');
        // Usuário não autenticado, cria uma UrlTree para redirecionar para a página de login
        return router.createUrlTree(['/login']);
      }
    })
  );
};

```

**3. Configuração das Rotas (`app.routes.ts`)**

Finalmente, aplicamos a guarda na definição da rota que queremos proteger.

```tsx
// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { DashboardComponent } from './dashboard/dashboard.component';
import { LoginComponent } from './login/login.component';
import { authGuard } from './auth.guard'; // Importamos nossa guarda

export const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [authGuard] // Aplicamos a guarda aqui!
  },
  { path: '', redirectTo: '/home', pathMatch: 'full' }
];

```

Neste exemplo, qualquer tentativa de navegar para `/dashboard` irá primeiro executar a função `authGuard`. A função, por sua vez, usará o `AuthService` para verificar o status de login. Se o usuário estiver logado, a navegação prossegue. Caso contrário, ele será redirecionado para a rota `/login`.

---

### **Parâmetros da Função (`route` e `state`)**

Como mencionado, a `CanActivateFn` recebe dois parâmetros que fornecem o contexto da navegação.

| Parâmetro | Tipo | Descrição |
| --- | --- | --- |
| `route` | `ActivatedRouteSnapshot` | Oferece um snapshot da rota que está **prestes a ser ativada**. É útil para acessar informações específicas da rota de destino. |
| `state` | `RouterStateSnapshot` | Representa o estado completo da árvore de rotas. É útil para obter informações sobre a URL completa ou a rota da qual o usuário está vindo. |

### Propriedades úteis de `ActivatedRouteSnapshot`

| Propriedade | Tipo | Descrição | Exemplo de Uso |
| --- | --- | --- | --- |
| `params` | `Params` | Um objeto com os parâmetros da rota (ex: `/user/:id`). | `const userId = route.params['id'];` |
| `queryParams` | `Params` | Um objeto com os parâmetros de consulta da URL (ex: `/search?q=angular`). | `const searchTerm = route.queryParams['q'];` |
| `data` | `Data` | Um objeto com dados estáticos definidos na configuração da rota. | `const requiredRole = route.data['role'];` |
| `url` | `UrlSegment[]` | Um array dos segmentos da URL da rota. | `const path = route.url.join('/');` |
| `routeConfig` | `Route \| null` | A configuração original da rota como definida no array de rotas. | `const originalPath = route.routeConfig?.path;` |

### Propriedades úteis de `RouterStateSnapshot`

| Propriedade | Tipo | Descrição | Exemplo de Uso |
| --- | --- | --- | --- |
| `url` | `string` | A URL completa para a qual o usuário está tentando navegar. | `console.log(`Tentando acessar: ${state.url}`);` |
| `root` | `ActivatedRouteSnapshot` | O snapshot da raiz da árvore de rotas. | - |

---

### **Restrições de Uso**

Embora o `CanActivateFn` seja extremamente poderoso e flexível, existem alguns pontos a serem considerados:

1. **Injeção de Dependência:** A injeção de dependência via `inject()` **só funciona dentro de um contexto de injeção**. Isso significa que você pode chamá-la diretamente dentro da função da guarda, mas não pode, por exemplo, chamá-la dentro de um callback de um `setTimeout` que não esteja gerenciado pelo Angular. A regra é simples: chame `inject()` no topo da sua função de guarda.
2. **Estado Interno:** Por serem apenas funções, as guardas funcionais não possuem estado interno (propriedades de classe). Se você precisa manter algum estado, ele deve residir em um serviço injetável, o que já é a melhor prática de qualquer forma. A guarda baseada em classe permitia ter estado, mas isso era frequentemente um anti-padrão.
3. **Versões do Angular:** As guardas funcionais são a abordagem recomendada a partir da versão 14.2. Em projetos mais antigos, você ainda encontrará a abordagem baseada em classes (`class MyGuard implements CanActivate`). Embora a abordagem de classe ainda funcione, a funcional é preferível para novos desenvolvimentos.

---

### **Elementos Associados**

Para que o `CanActivateFn` funcione, ele depende de alguns outros elementos-chave do Angular.

| Elemento | Tipo | Propósito e Uso | Sintaxe Específica |
| --- | --- | --- | --- |
| `inject()` | Função | A função `inject` é a chave para usar serviços dentro de uma guarda funcional. Ela permite obter uma instância de um provedor (como um serviço ou o `Router`) dentro do contexto de execução da guarda. | `const myService = inject(MyService);` |
| `Router` | Classe | O serviço `Router` do Angular é essencial para realizar redirecionamentos. Não podemos simplesmente retornar uma string de URL; precisamos criar uma `UrlTree` usando o roteador. | `const router = inject(Router);`\<br\>`return router.createUrlTree(['/some-path']);` |
| `UrlTree` | Classe | É um objeto que representa uma URL parseada. Quando uma guarda retorna uma `UrlTree`, ela está instruindo o roteador a cancelar a navegação atual e iniciar uma nova navegação para a URL representada por essa árvore. | `router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });` |
| `ActivatedRouteSnapshot` | Classe | Como já visto, fornece informações sobre a rota de destino. É crucial para guardas que dependem de parâmetros ou dados da rota (ex: autorização baseada em papéis). | `const requiredRole = route.data['requiredRole'];` |
| `RouterStateSnapshot` | Classe | Fornece o contexto geral da navegação, sendo especialmente útil para passar a URL de origem para a página de login, permitindo um redirecionamento de volta após a autenticação. | `const returnUrl = state.url;` |

---

### **Melhores Práticas e Casos de Uso**

### Caso de Uso 1: Guarda de Autenticação (Já visto)

O caso mais comum: verificar se o usuário está logado. Se não estiver, redirecionar para a página de login, idealmente passando a URL que ele tentou acessar para que possa ser redirecionado de volta após o login.

```tsx
// auth.guard.ts (versão melhorada)
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isAuthenticated()) { // Supondo um método síncrono para simplificar
    return true;
  }

  // Redireciona para o login, passando a URL de retorno
  return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
};

```

### Caso de Uso 2: Autorização Baseada em Papéis (Roles)

Verificar se o usuário logado tem a permissão (o "papel" ou "role") necessária para acessar uma rota. Isso é feito passando o papel necessário através da propriedade `data` na configuração da rota.

**Configuração da Rota (`app.routes.ts`)**

```tsx
// src/app/app.routes.ts
import { AdminPanelComponent } from './admin-panel/admin-panel.component';
import { adminGuard } from './admin.guard';

export const routes: Routes = [
  // ... outras rotas
  {
    path: 'admin',
    component: AdminPanelComponent,
    canActivate: [adminGuard],
    data: { requiredRole: 'ADMIN' } // Dado estático com o papel necessário
  }
];

```

**Guarda de Admin (`admin.guard.ts`)**

```tsx
// src/app/admin.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from './auth.service'; // Supondo que o AuthService tenha as roles do usuário

export const adminGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  // Pega o papel necessário dos dados da rota
  const requiredRole = route.data['requiredRole'];
  const userRole = authService.getCurrentUserRole(); // Método hipotético

  if (userRole === requiredRole) {
    return true; // O usuário tem o papel correto
  }

  // Se não tiver, redireciona para uma página de "acesso negado" ou para a home
  return router.createUrlTree(['/unauthorized']);
};

```

### Caso de Uso 3: Bloquear Navegação com Dados Não Salvos

Usar uma guarda `CanDeactivateFn` (um conceito irmão) para perguntar ao usuário se ele tem certeza que quer sair de uma página com um formulário não salvo. O conceito é muito similar.

---

### **Exemplo Completo: Aplicação com Múltiplas Guardas**

Vamos ver como múltiplas guardas podem ser encadeadas em uma única rota. O roteador as executará em ordem.

**1. Guarda de Feature Flag (`feature-flag.guard.ts`)**
Esta guarda verifica se uma funcionalidade específica está habilitada na aplicação.

```tsx
// src/app/feature-flag.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { FeatureFlagService } from './feature-flag.service';

export const featureFlagGuard: CanActivateFn = (route, state) => {
  const featureFlagService = inject(FeatureFlagService);
  const router = inject(Router);
  const requiredFeature = route.data['featureFlag'];

  if (!requiredFeature || featureFlagService.isFeatureEnabled(requiredFeature)) {
    return true;
  }

  // Feature desabilitada, redireciona
  alert('Esta funcionalidade está temporariamente desabilitada.');
  return router.createUrlTree(['/home']);
};

```

**2. Configuração de Rotas com Guardas Encadeadas**

```tsx
// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { SpecialFeatureComponent } from './special-feature/special-feature.component';
import { authGuard } from './auth.guard';
import { adminGuard } from './admin.guard';
import { featureFlagGuard } from './feature-flag.guard';

export const routes: Routes = [
  // ...
  {
    path: 'special-feature',
    component: SpecialFeatureComponent,
    canActivate: [
      authGuard,       // 1. Primeiro, verifica se está logado
      adminGuard,      // 2. Depois, verifica se é admin
      featureFlagGuard // 3. Por último, verifica se a feature está ativa
    ],
    data: {
      requiredRole: 'ADMIN',
      featureFlag: 'superCoolFeature'
    }
  }
];

```

Neste cenário, para acessar `/special-feature`, o usuário precisa:

1. Estar autenticado (`authGuard` deve retornar `true`).
2. Ter o papel 'ADMIN' (`adminGuard` deve retornar `true`).
3. A `superCoolFeature` precisa estar habilitada (`featureFlagGuard` deve retornar `true`).

Se qualquer uma dessas guardas falhar (retornar `false` ou uma `UrlTree`), a navegação é interrompida e as guardas subsequentes na lista não são executadas.

---

### **Tópicos Relacionados para Aprofundamento**

- **`CanActivateChildFn`**: Muito similar ao `CanActivateFn`, mas é executado para **rotas filhas**. É útil para aplicar uma mesma verificação a um grupo de rotas aninhadas (ex: `/admin/users`, `/admin/settings`) sem precisar decorar cada uma individualmente.
- **`CanDeactivateFn`**: Guarda que decide se é permitido **sair** de uma rota. Perfeito para cenários de "formulário não salvo".
- **`ResolveFn`**: Não é uma guarda, mas uma função que pode buscar dados necessários para uma rota **antes** que ela seja ativada. Útil para pré-carregar dados e evitar telas de loading no componente.
- **`CanMatchFn`**: Uma guarda mais recente (Angular v14.1) que permite decidir condicionalmente se uma rota pode sequer ser "casada" (matched) com uma URL, útil para cenários de roteamento dinâmico complexo.
- **Injeção de Dependência em Profundidade**: Estudar mais sobre o `InjectionContext` e como a função `inject()` funciona por baixo dos panos para um entendimento mais profundo.

Espero que esta explicação detalhada tenha sido clara e útil para você, Gedê\! Se tiver qualquer outra dúvida, pode perguntar.