# CanMatchFn

Olá, Gedê\! Como sua Assistente Rápida para Idiotas Atarefados (A.R.I.A.), preparei uma explicação extremamente detalhada sobre o `CanMatchFn` no contexto de rotas do Angular, exatamente como você pediu. Vamos mergulhar fundo neste recurso poderoso\!

---

### **Título: Dominando o `CanMatchFn` no Angular: Roteamento Condicional e Dinâmico**

### **Introdução**

No ecossistema de roteamento do Angular, controlar o acesso e a lógica de navegação é fundamental. Tradicionalmente, guardas de rota como `CanActivate` e `CanLoad` (agora obsoleto) eram as ferramentas principais. No entanto, o Angular introduziu uma guarda mais flexível e poderosa: `CanMatch`. Esta guarda, implementada através de uma função com a assinatura `CanMatchFn`, permite decidir não apenas *se* uma rota pode ser acessada, mas *se* uma rota específica deve sequer ser considerada (dar "match") durante o processo de resolução de URL. Isso abre um leque de possibilidades para cenários de roteamento mais complexos e dinâmicos, como *feature flags*, testes A/B ou a exibição de componentes diferentes para a mesma URL com base em permissões.

### **Sumário**

Esta explicação detalha a guarda de rota `CanMatch` do Angular, implementada como uma `CanMatchFn`. Abordaremos seu propósito fundamental de permitir que o roteador do Angular ignore condicionalmente uma configuração de rota durante o processo de casamento de URL. Exploraremos sua sintaxe, os parâmetros que recebe (`route` e `segments`), e os tipos de dados que pode retornar. Veremos casos de uso práticos, como controle de acesso por perfil e *feature toggles*, comparando-a com outras guardas de rota e destacando suas vantagens, especialmente em substituir o antigo `CanLoad` para o carregamento de módulos sob demanda (*lazy loading*).

### **Conceitos Fundamentais**

O propósito central do `CanMatchFn` é **prevenir que o roteador do Angular sequer considere uma rota como uma candidata válida para a URL atual**.

Pense no processo de roteamento do Angular como uma busca sequencial. Quando você navega para uma URL, o roteador percorre sua lista de configurações de rotas, de cima para baixo, tentando encontrar a primeira que "casa" com a URL.

- **Sem `CanMatch`**: O casamento é puramente baseado no `path` da rota. Se o `path` corresponde à URL, a rota é escolhida, e só então guardas como `CanActivate` são executadas para verificar permissões.
- **Com `CanMatch`**: Antes mesmo de verificar o `path`, o Angular executa a(s) função(ões) `CanMatchFn` associadas à rota.
    - Se **todas** as funções `CanMatchFn` retornarem `true`, a rota é considerada uma candidata válida, e o processo de casamento de `path` continua.
    - Se **qualquer** `CanMatchFn` retornar `false`, o roteador **imediatamente descarta essa rota e continua a busca pela próxima** na lista de configurações.

Essa diferença é crucial. `CanMatch` não bloqueia a navegação como o `CanActivate`; ele a torna "invisível" para o processo de casamento, permitindo que outra rota, talvez com o mesmo `path`, seja escolhida.

**A principal vantagem é o controle sobre o carregamento de módulos em *lazy loading***. Se uma `CanMatchFn` em uma rota de *lazy loading* retorna `false`, o *bundle* de JavaScript daquele módulo **não será baixado**, economizando banda e melhorando a performance inicial. Isso torna o `CanMatch` o substituto direto e mais poderoso para o obsoleto `CanLoad`.

### **Sintaxe e Uso**

`CanMatch` é uma propriedade dentro de um objeto `Route` que aceita um array de funções ou tokens de injeção de dependência. A função deve ter a assinatura `CanMatchFn`.

**`CanMatchFn` (Type Alias):**

```tsx
type CanMatchFn = (route: Route, segments: UrlSegment[]) =>
  Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;

```

**Exemplo de Configuração de Rota:**

```tsx
// app.routes.ts
import { Routes } from '@angular/router';
import { adminGuard } from './guards/admin.guard';

export const routes: Routes = [
  {
    path: 'dashboard',
    // A função 'adminGuard' será executada antes de tentar casar esta rota.
    canMatch: [adminGuard],
    loadComponent: () => import('./admin-dashboard/admin-dashboard.component').then(c => c.AdminDashboardComponent),
  },
  {
    path: 'dashboard', // Mesmo path!
    loadComponent: () => import('./user-dashboard/user-dashboard.component').then(c => c.UserDashboardComponent),
  },
];

```

Neste exemplo, se `adminGuard` retornar `false`, o roteador ignorará a primeira rota `/dashboard` e tentará casar a segunda, que não tem guardas e levará ao `UserDashboardComponent`.

### **Parâmetros da Função `CanMatchFn`**

A função `CanMatchFn` recebe dois argumentos principais, que são essenciais para tomar decisões lógicas.

| Parâmetro | Tipo | Descrição Detalhada |
| --- | --- | --- |
| `route` | `Route` | Representa o objeto de configuração da rota que está sendo avaliada. É o mesmo objeto onde você definiu o `path`, `component`, `canMatch`, etc. É útil para acessar dados estáticos (`data`), o próprio `path`, ou outras configurações da rota para tomar uma decisão. |
| `segments` | `UrlSegment[]` | É um array dos segmentos da URL que o roteador está tentando casar. Por exemplo, para a URL `/admin/users/1`, os segmentos seriam `['admin', 'users', '1']`. Isso permite inspecionar a URL diretamente para uma lógica de casamento customizada, algo que não é facilmente possível com `CanActivate`. |

### **Valores de Retorno**

A flexibilidade do `CanMatchFn` também se reflete nos tipos de valores que ele pode retornar.

| Tipo de Retorno | Descrição |
| --- | --- |
| `boolean` | O retorno mais simples. `true` permite que a rota seja considerada, `false` a descarta. |
| `UrlTree` | Se um `UrlTree` é retornado, a navegação atual é cancelada e uma nova navegação para a URL representada pelo `UrlTree` é iniciada. Essencialmente, é um redirecionamento programático. Você pode criar um `UrlTree` usando a injeção do `Router` (`router.parseUrl('/login')`). |
| `Observable<boolean \| UrlTree>` | Para cenários assíncronos, como uma chamada HTTP para verificar permissões. O `Observable` deve emitir um dos valores acima (`boolean` ou `UrlTree`) e então completar. |
| `Promise<boolean \| UrlTree>` | Similar ao `Observable`, para operações assíncronas baseadas em `Promise`. |

### **Restrições de Uso**

Apesar de poderoso, o `CanMatch` não é a solução para todos os cenários de guarda de rota.

- **Quando não usar:** Se você precisa de acesso aos parâmetros da rota (ex: `/user/:id`), o `CanMatch` não é a melhor escolha. Ele é executado **antes** da rota ser completamente casada e ativada, então o `ActivatedRouteSnapshot` (que contém os parâmetros) ainda não está disponível. Neste caso, o `CanActivate` é a guarda correta, pois ele é executado depois do casamento da rota e tem acesso completo aos parâmetros.
- **Rotas "Catch-all":** Tenha cuidado ao usar `CanMatch` em rotas genéricas de "catch-all" (`path: '**'`). A lógica precisa ser muito bem definida para garantir que não descarte a rota indevidamente, impedindo que a página "Não Encontrado" seja exibida.
- **Cenário único de acesso:** Se você tem apenas uma rota para um `path` e só precisa decidir se o usuário pode acessá-la ou não (sem uma alternativa para o mesmo `path`), o `CanActivate` é mais semântico e direto ao ponto. A lógica do `CanMatch` é realmente vantajosa quando há múltiplas rotas competindo pelo mesmo `path`.

### **Elementos Associados**

Para utilizar o `CanMatchFn` de forma eficaz, é importante entender os elementos com os quais ele interage.

- **`Route`**: A interface que define uma configuração de rota. É aqui que você adiciona a propriedade `canMatch`.
    - **Sintaxe:** `{ path: 'some-path', canMatch: [myGuardFn], ... }`
- **`UrlSegment`**: Representa um segmento de uma URL entre as barras.
    - **Propriedades úteis:** `path` (a string do segmento), `parameters` (os parâmetros de matriz, ex: `/path;id=1`).
- **`UrlTree`**: Uma representação estruturada (em árvore) de uma URL. Usado para realizar redirecionamentos.
    - **Criação:** Geralmente criado com `router.parseUrl('/redirect-path')`.
- **`Router`**: O serviço principal de roteamento do Angular, que pode ser injetado para criar um `UrlTree` para redirecionamento.
- **`inject()`**: Desde a introdução das APIs "standalone" no Angular, a função `inject()` é a maneira preferida de obter instâncias de serviços (como `AuthService` ou `Router`) dentro de uma guarda de rota funcional, sem a necessidade de classes.

### **Melhores Práticas e Casos de Uso**

### 1\. Controle de Acesso Baseado em Perfil (Role-Based Access)

Este é o caso de uso mais comum. Você pode ter um único `path` (`/dashboard`) que exibe um componente para administradores e outro para usuários padrão.

```tsx
// auth.service.ts
@Injectable({ providedIn: 'root' })
export class AuthService {
  isAdmin(): Observable<boolean> {
    // Lógica para verificar se o usuário é admin
    return of(true); // Simulação
  }
}

// admin.guard.ts
import { inject } from '@angular/core';
import { CanMatchFn } from '@angular/router';
import { AuthService } from './auth.service';

export const adminGuard: CanMatchFn = () => {
  return inject(AuthService).isAdmin();
};

// app.routes.ts
export const routes: Routes = [
  {
    path: 'dashboard',
    canMatch: [adminGuard],
    loadComponent: () => import('./admin-dashboard/admin-dashboard.component'),
  },
  {
    path: 'dashboard',
    loadComponent: () => import('./user-dashboard/user-dashboard.component'),
  },
];

```

### 2\. Feature Flags / Toggles

`CanMatch` é perfeito para habilitar ou desabilitar funcionalidades em desenvolvimento ou para testes A/B.

```tsx
// feature-flag.service.ts
@Injectable({ providedIn: 'root' })
export class FeatureFlagService {
  isFeatureEnabled(featureName: string): boolean {
    // Lógica para verificar se a feature está ativa (ex: vinda de uma API)
    const features = { 'new-profile-page': true };
    return features[featureName] ?? false;
  }
}

// feature.guard.ts
export const featureGuard = (featureName: string): CanMatchFn => {
  return () => {
    return inject(FeatureFlagService).isFeatureEnabled(featureName);
  };
};

// app.routes.ts
export const routes: Routes = [
  {
    path: 'profile',
    canMatch: [featureGuard('new-profile-page')],
    loadComponent: () => import('./new-profile/new-profile.component'),
  },
  {
    path: 'profile',
    loadComponent: () => import('./old-profile/old-profile.component'),
  },
];

```

### 3\. Substituindo `CanLoad`

`CanMatch` é o substituto canônico para o `CanLoad`. Qualquer lógica que impedia o carregamento de um módulo agora deve ser feita com `CanMatch`. A vantagem é que, se `CanMatch` falhar, o roteador pode tentar outra rota, algo que o `CanLoad` não permitia de forma tão elegante.

### **Exemplo Completo: Aplicação com Múltiplos Painéis**

Vamos imaginar um cenário onde temos uma rota `/reports`. Se o usuário for um `ADMIN`, ele verá um painel completo de relatórios (`AdminReportsComponent`). Se ele for um `MANAGER`, verá um painel mais limitado (`ManagerReportsComponent`). Se não for nenhum dos dois, mas estiver logado, verá uma mensagem de acesso negado (`AccessDeniedComponent`).

**1. Serviço de Autenticação (`auth.service.ts`)**

```tsx
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';

export type UserRole = 'ADMIN' | 'MANAGER' | 'USER';

@Injectable({ providedIn: 'root' })
export class AuthService {
  getCurrentUserRole(): Observable<UserRole> {
    // Em uma aplicação real, isso viria de uma API após o login.
    // Para este exemplo, vamos simular.
    return of('MANAGER');
  }

  isLoggedIn(): Observable<boolean> {
      return of(true); // Simula que o usuário está sempre logado
  }
}

```

**2. Guarda de Rota (`role.guard.ts`)**

```tsx
import { inject } from '@angular/core';
import { CanMatchFn } from '@angular/router';
import { map } from 'rxjs';
import { AuthService, UserRole } from './auth.service';

// Uma guarda de rota "factory" que cria uma CanMatchFn para um perfil específico.
export const hasRoleGuard = (allowedRole: UserRole): CanMatchFn => {
  return () => {
    const authService = inject(AuthService);
    return authService.getCurrentUserRole().pipe(
      map(userRole => userRole === allowedRole)
    );
  };
};

// Guarda para verificar se o usuário está apenas logado
export const isLoggedInGuard: CanMatchFn = () => {
    return inject(AuthService).isLoggedIn();
}

```

**3. Configuração das Rotas (`app.routes.ts`)**

```tsx
import { Routes } from '@angular/router';
import { hasRoleGuard, isLoggedInGuard } from './role.guard';

export const routes: Routes = [
  // Rota para o painel de ADMIN - será verificada primeiro.
  {
    path: 'reports',
    canMatch: [hasRoleGuard('ADMIN')],
    loadComponent: () =>
      import('./reports/admin-reports/admin-reports.component').then(c => c.AdminReportsComponent),
  },

  // Rota para o painel de MANAGER - só será tentada se a de ADMIN falhar.
  {
    path: 'reports',
    canMatch: [hasRoleGuard('MANAGER')],
    loadComponent: () =>
      import('./reports/manager-reports/manager-reports.component').then(c => c.ManagerReportsComponent),
  },

  // Rota para acesso negado - só será tentada se as de cima falharem.
  // Usamos isLoggedInGuard para garantir que apenas usuários logados vejam esta página.
  {
    path: 'reports',
    canMatch: [isLoggedInGuard],
    loadComponent: () =>
      import('./reports/access-denied/access-denied.component').then(c => c.AccessDeniedComponent),
  },

  // Outras rotas da sua aplicação...
  {
    path: '',
    redirectTo: 'reports',
    pathMatch: 'full'
  }
];

```

**Como funciona:**

1. O usuário navega para `/reports`.
2. O roteador avalia a primeira rota. Ele executa `hasRoleGuard('ADMIN')`. O `AuthService` retorna `MANAGER`, então a guarda retorna `false`. A rota é **descartada**, e o `AdminReportsComponent` **não é baixado**.
3. O roteador passa para a segunda rota. Ele executa `hasRoleGuard('MANAGER')`. O `AuthService` retorna `MANAGER`, então a guarda retorna `true`. A rota é **casada**\!
4. O `ManagerReportsComponent` é baixado e exibido. O roteador para sua busca.
5. Se o `AuthService` retornasse `USER`, ambas as duas primeiras guardas falhariam, e a terceira (`isLoggedInGuard`) retornaria `true`, exibindo o `AccessDeniedComponent`.

---

### **Tópicos Relacionados para Aprofundamento**

- **`CanActivateFn`**: Entenda a fundo a diferença entre `CanMatch` e `CanActivate` e quando usar cada um.
- **`ResolveFn` (Resolvers)**: Aprenda a pré-carregar dados para uma rota antes que o componente seja renderizado.
- **Roteamento Standalone**: Como configurar rotas em aplicações Angular modernas sem `ngModules`, utilizando `provideRouter`.
- **`UrlTree` e Redirecionamento Programático**: Explore como criar `UrlTree` complexos para redirecionamentos dinâmicos dentro das guardas.
- **Estratégias de Pré-carregamento de Módulos**: Investigue como o Angular pode pré-carregar módulos de *lazy loading* em segundo plano para melhorar a experiência do usuário.

Espero que esta explicação super detalhada tenha esclarecido tudo sobre o `CanMatchFn`, Gedê\! É uma ferramenta fantástica no seu arsenal de desenvolvedor Angular. Se tiver qualquer outra dúvida, pode me chamar\!