# Introdução

E aí, Gedê\! Beleza?
Com certeza\! A.R.I.A vai te ajudar a entender tudo sobre **Pipes no Angular**. Como você é desenvolvedor, sei que preza por clareza e exemplos práticos, então vamos nessa\!

---

## Introdução aos Pipes no Angular

No desenvolvimento frontend, a apresentação dos dados é tão crucial quanto a lógica por trás deles. Muitas vezes, os dados que recebemos do backend ou que manipulamos internamente precisam ser formatados antes de serem exibidos para o usuário. É exatamente aí que os **Pipes do Angular** entram em cena.

Pipes são uma ferramenta poderosa no Angular que permitem transformar dados diretamente nos templates, de forma simples e eficiente, sem a necessidade de escrever lógica complexa no componente. Eles são uma maneira declarativa de formatar valores para exibição, tornando seu código mais limpo, legível e reutilizável.

A relevância dos Pipes é enorme no dia a dia de um desenvolvedor Angular. Eles simplificam tarefas comuns como formatar datas, moedas, percentagens, ou até mesmo filtrar e ordenar listas, melhorando significativamente a experiência do usuário e a manutenção do código.

### Definição e Conceitos Fundamentais

Um **Pipe** no Angular é uma função que recebe um valor de entrada e retorna um valor transformado. O conceito é similar ao de um "encanamento" (pipe em inglês): você passa um valor por ele, e ele sai transformado do outro lado.

Os Pipes podem ser classificados em dois tipos principais:

- **Pipes Puros (Pure Pipes):** São os pipes padrão do Angular. Eles só são executados quando a entrada do pipe muda, ou seja, se o valor de entrada for um tipo primitivo (string, number, boolean) e ele for o mesmo, o pipe não é reexecutado. Se for um objeto, ele só é reexecutado se a *referência* do objeto mudar. Isso garante uma performance otimizada, pois evita re-renderizações desnecessárias.
- **Pipes Impuros (Impure Pipes):** São pipes que são executados a cada ciclo de detecção de mudanças do Angular, independentemente se a entrada mudou ou não. Isso pode ter um impacto na performance, por isso devem ser usados com cautela. Exemplos de Pipes Impuros embutidos são `AsyncPipe` e `JsonPipe`.

---

## Sumário

- **Sintaxe e Estrutura dos Pipes**
- **Pipes Embutidos (Built-in Pipes)**
    - Common Pipes
    - Pipes Parametrizados
    - Chaining Pipes
- **Pipes Customizados**
    - Criando um Pipe
    - Utilizando um Pipe Customizado
- **Restrições de Uso e Impacto na Performance**
- **Exemplos de Código Otimizados**
    - Formatando Datas e Moedas
    - Filtrando e Ordenando Listas (Pipes Customizados)
    - Usando AsyncPipe com Observables
- **Informações Adicionais**
    - Prós e Contras dos Pipes
    - Quando utilizar e quando evitar
- **Referências para Estudo Independente**

---

## Conteúdo Detalhado

### Sintaxe e Estrutura dos Pipes

A sintaxe para utilizar um Pipe no template do Angular é bem simples:

```html
{{ valor | nomeDoPipe }}

```

O `|` (pipe operator) indica que o valor à esquerda deve ser passado para o Pipe à direita.

Para Pipes que aceitam argumentos, a sintaxe é a seguinte:

```html
{{ valor | nomeDoPipe:arg1:arg2:... }}

```

Os argumentos são passados após o nome do Pipe, separados por dois pontos (`:`).

### Componentes Principais e Associados

O Angular vem com uma série de **Pipes Embutidos (Built-in Pipes)** que cobrem a maioria das necessidades comuns de formatação.

### Common Pipes

Alguns dos Pipes embutidos mais utilizados incluem:

- **`DatePipe`**: Formata um valor de data de acordo com as regras de localização.
    - **Função:** Transforma objetos `Date`, strings ISO 8601 ou milissegundos em um formato de data legível.
    - **Métodos/Propriedades:** Aceita um argumento de formato (string) e um argumento de timezone (string).
    - **Exemplos de formato:** `'short'`, `'long'`, `'dd/MM/yyyy'`, `'fullDate'`, etc.
- **`UpperCasePipe`**: Transforma o texto para maiúsculas.
    - **Função:** Converte todas as letras de uma string para maiúsculas.
    - **Exemplo:** `{{ 'Olá mundo' | uppercase }}` -\> "OLÁ MUNDO"
- **`LowerCasePipe`**: Transforma o texto para minúsculas.
    - **Função:** Converte todas as letras de uma string para minúsculas.
    - **Exemplo:** `{{ 'Olá Mundo' | lowercase }}` -\> "olá mundo"
- **`CurrencyPipe`**: Formata um número como uma string de moeda.
    - **Função:** Transforma um número em um formato monetário, com símbolo da moeda e casas decimais.
    - **Métodos/Propriedades:** Aceita argumentos para o código da moeda, display (símbolo, código, nome), e o número de dígitos (mínimo, máximo).
    - **Exemplo:** `{{ 1234.56 | currency:'BRL' }}` -\> "R$1.234,56"
- **`DecimalPipe`**: Formata um número decimal.
    - **Função:** Transforma um número para um formato decimal específico.
    - **Métodos/Propriedades:** Aceita um argumento para o formato dos dígitos (`'{minDigits}.{minFractionDigits}-{maxFractionDigits}'`).
    - **Exemplo:** `{{ 3.14159 | number:'1.2-2' }}` -\> "3.14"
- **`PercentPipe`**: Formata um número como uma string de percentagem.
    - **Função:** Transforma um número em uma string de percentagem.
    - **Métodos/Propriedades:** Aceita um argumento para o formato dos dígitos.
    - **Exemplo:** `{{ 0.75 | percent }}` -\> "75%"
- **`SlicePipe`**: Cria uma nova array ou string contendo um subconjunto dos itens.
    - **Função:** Extrai uma parte de uma string ou array.
    - **Métodos/Propriedades:** Aceita argumentos para o índice inicial (`start`) e o índice final (`end`).
    - **Exemplo:** `{{ 'abcdefg' | slice:0:3 }}` -\> "abc"
- **`JsonPipe`**: Converte um valor em uma string JSON.
    - **Função:** Converte um objeto JavaScript para sua representação em string JSON.
    - **Exemplo:** `{{ { nome: 'Gedê', idade: 23 } | json }}` -\> `{ "nome": "Gedê", "idade": 23 }`
- **`AsyncPipe`**: Permite o uso de Observables e Promises diretamente nos templates.
    - **Função:** Assina um Observable ou Promise e retorna o último valor emitido. Ele automaticamente se desinscreve quando o componente é destruído, prevenindo vazamento de memória.
    - **Exemplo:** `{{ meuObservable$ | async }}`

### Pipes Parametrizados

Muitos pipes aceitam parâmetros para controlar a saída da formatação. Os parâmetros são passados após o nome do pipe, separados por dois pontos (`:`).

Exemplo com `DatePipe` e `CurrencyPipe`:

```html
<p>Data de Hoje: {{ hoje | date:'dd/MM/yyyy HH:mm' }}</p>
<p>Valor do Produto: {{ preco | currency:'BRL':'symbol':'1.2-2' }}</p>

```

### Chaining Pipes (Encadeamento de Pipes)

Você pode encadear múltiplos pipes para aplicar várias transformações a um valor. A saída de um pipe se torna a entrada do próximo.

```html
<p>{{ 'Meu texto ENORME!' | lowercase | slice:0:10 }}</p>

```

Isso resultaria em "meu text".

### Pipes Customizados

Quando os pipes embutidos não atendem às suas necessidades específicas, você pode criar seus próprios **Pipes Customizados**.

### Criando um Pipe

Para criar um pipe customizado, você deve:

1. Criar uma classe.
2. Decorar a classe com `@Pipe({ name: 'nomeDoPipe' })`. O `name` é como você vai referenciar o pipe no template.
3. Implementar a interface `PipeTransform` e seu método `transform`.

Exemplo: Um pipe para reverter uma string.

```tsx
// src/app/pipes/reverse.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'reverse'
})
export class ReversePipe implements PipeTransform {
  transform(value: string): string {
    if (!value) {
      return '';
    }
    return value.split('').reverse().join('');
  }
}

```

### Utilizando um Pipe Customizado

Para usar um pipe customizado, você precisa declará-lo em um `NgModule`. Geralmente, é no `AppModule` ou em um módulo específico de "Shared" ou "Pipes".

```tsx
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { ReversePipe } from './pipes/reverse.pipe'; // Importe seu pipe

@NgModule({
  declarations: [
    AppComponent,
    ReversePipe // Declare seu pipe aqui
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

Depois de declarado, você pode usá-lo em qualquer template dentro do módulo onde foi declarado:

```html
<p>Texto Original: Hello World</p>
<p>Texto Invertido: {{ 'Hello World' | reverse }}</p>

```

Isso resultaria em "dlroW olleH".

### Restrições de uso

- **Pipes Puros:** Como mencionado, pipes puros não detectam mudanças dentro de objetos ou arrays, apenas a mudança na referência. Se você tem um array e adiciona/remove itens, mas a referência do array permanece a mesma, um pipe puro de filtro ou ordenação **não será reexecutado**. Nesses casos, você precisaria recriar o array (mutabilidade do objeto) para forçar a reexecução ou considerar um pipe impuro (com cautela).
- **Pipes Impuros:** Devem ser usados com moderação. A reexecução constante pode degradar a performance da sua aplicação, especialmente se o pipe realizar operações custosas. O `AsyncPipe` é um pipe impuro bem otimizado, pois ele gerencia subscrições e desinscrições, e é projetado para lidar com Observables.

---

## Exemplos de Código Otimizados

Vamos ver alguns exemplos práticos para o dia a dia de um desenvolvedor, Gedê.

```tsx
// src/app/app.component.ts
import { Component } from '@angular/core';
import { Observable, of } from 'rxjs';
import { delay } from 'rxjs/operators';

interface Produto {
  nome: string;
  preco: number;
  dataCadastro: Date;
  categoria: string;
}

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  dataAtual: Date = new Date();
  valorVenda: number = 1500.75;
  percentualDesconto: number = 0.25;
  textoLongo: string = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";

  produtos: Produto[] = [
    { nome: 'Laptop', preco: 4500.00, dataCadastro: new Date(2025, 0, 15), categoria: 'Eletrônicos' },
    { nome: 'Smartphone', preco: 2800.50, dataCadastro: new Date(2024, 11, 10), categoria: 'Eletrônicos' },
    { nome: 'Teclado Mecânico', preco: 350.00, dataCadastro: new Date(2025, 1, 20), categoria: 'Acessórios' },
    { nome: 'Mouse Gamer', preco: 180.00, dataCadastro: new Date(2025, 2, 5), categoria: 'Acessórios' },
    { nome: 'Monitor Ultrawide', preco: 1800.00, dataCadastro: new Date(2024, 10, 25), categoria: 'Eletrônicos' },
  ];

  dadosAssincronos$: Observable<string> = of('Carregando dados...').pipe(delay(2000));
}

```

```tsx
// src/app/pipes/filter-by-category.pipe.ts (Exemplo de pipe customizado de filtro)
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filterByCategory',
  pure: true // Este é um pipe puro, só reage se a referência do array ou da categoria mudar
})
export class FilterByCategoryPipe implements PipeTransform {
  transform(items: any[], category: string): any[] {
    if (!items || !category) {
      return items;
    }
    return items.filter(item => item.categoria.toLowerCase().includes(category.toLowerCase()));
  }
}

```

```tsx
// src/app/pipes/sort-by-price.pipe.ts (Exemplo de pipe customizado de ordenação)
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'sortByPrice',
  pure: true // Este também é um pipe puro
})
export class SortByPricePipe implements PipeTransform {
  transform(items: any[], order: 'asc' | 'desc' = 'asc'): any[] {
    if (!items || items.length === 0) {
      return items;
    }
    const sortedItems = [...items].sort((a, b) => { // Cria uma cópia para evitar mutação do array original
      if (order === 'asc') {
        return a.preco - b.preco;
      } else {
        return b.preco - a.preco;
      }
    });
    return sortedItems;
  }
}

```

```html
<h2>Exemplos de Pipes Embutidos</h2>
<hr>

<h3>Formatando Datas e Moedas</h3>
<p>Data Atual (formato curto): {{ dataAtual | date:'short' }}</p>
<p>Data Atual (formato brasileiro): {{ dataAtual | date:'dd/MM/yyyy HH:mm:ss' }}</p>
<p>Data do Cadastro do Produto (Mês e Ano): {{ produtos[0].dataCadastro | date:'MMMM yyyy' }}</p>
<p>Valor da Venda: {{ valorVenda | currency:'BRL':'symbol':'1.2-2' }}</p>
<p>Desconto Aplicado: {{ percentualDesconto | percent }}</p>

<h3>Outros Pipes Comuns</h3>
<p>Texto em Maiúsculas: {{ textoLongo | uppercase }}</p>
<p>Texto em Minúsculas (primeiras 20 letras): {{ textoLongo | lowercase | slice:0:20 }}...</p>
<p>Objeto Produto (JSON): <pre>{{ produtos[0] | json }}</pre></p>

---

<h2>Exemplos de Pipes Customizados</h2>
<hr>

<h3>Filtrando Produtos por Categoria (filterByCategory Pipe)</h3>
<p>Produtos de Eletrônicos:</p>
<ul>
  <li *ngFor="let produto of produtos | filterByCategory:'eletronicos'">
    {{ produto.nome }} - {{ produto.preco | currency:'BRL' }}
  </li>
</ul>

<h3>Ordenando Produtos por Preço (sortByPrice Pipe)</h3>
<p>Produtos por Preço (Crescente):</p>
<ul>
  <li *ngFor="let produto of produtos | sortByPrice:'asc'">
    {{ produto.nome }} - {{ produto.preco | currency:'BRL' }}
  </li>
</ul>
<p>Produtos por Preço (Decrescente):</p>
<ul>
  <li *ngFor="let produto of produtos | sortByPrice:'desc'">
    {{ produto.nome }} - {{ produto.preco | currency:'BRL' }}
  </li>
</ul>

---

<h2>Usando AsyncPipe com Observables</h2>
<hr>

<p>Dados assíncronos: {{ dadosAssincronos$ | async }}</p>
<p *ngIf="(dadosAssincronos$ | async) === 'Carregando dados...'">
  Aguarde, os dados estão sendo carregados...
</p>

```

**Observações sobre os exemplos:**

- Nos pipes customizados de filtro e ordenação, observe que eles são definidos como `pure: true`. Para que eles reajam a mudanças nos elementos internos do array, você precisaria criar uma **nova referência para o array** no componente (ex: `this.produtos = [...this.produtos];` ou `this.produtos = this.produtos.filter(...)`) após uma modificação, pois o pipe puro só detecta mudança na referência do objeto.
- No `sortByPricePipe`, usamos `[...items]` para criar uma cópia do array antes de ordená-lo. Isso é uma **boa prática** para evitar a mutação do array original, o que poderia causar efeitos colaterais indesejados em outras partes da aplicação.
- O `AsyncPipe` é um excelente exemplo de como lidar com dados assíncronos diretamente no template, simplificando o componente e evitando vazamentos de memória.

---

## Informações Adicionais

### Prós dos Pipes no Angular

- **Reutilização de Código:** A lógica de formatação é centralizada em um único lugar e pode ser aplicada em vários locais do template.
- **Legibilidade do Template:** O template fica mais limpo e declarativo, pois a lógica de transformação está encapsulada no pipe.
- **Performance Otimizada (Pipes Puros):** Pipes puros só são reexecutados quando a entrada muda, economizando ciclos de CPU e melhorando a performance.
- **Separation of Concerns:** Separa a lógica de apresentação da lógica do componente, promovendo um código mais organizado.
- **Facilidade de Teste:** Pipes são unidades de código isoladas e fáceis de testar.

### Contras dos Pipes no Angular

- **Pipes Impuros e Performance:** O uso excessivo ou incorreto de pipes impuros pode levar a problemas de performance, pois eles são reexecutados a cada ciclo de detecção de mudanças.
- **Complexidade de Lógica:** Pipes devem ser usados para transformações simples. Lógicas de negócio complexas ou que envolvem efeitos colaterais não devem ser implementadas em pipes.
- **Debug:** Debugar um pipe pode ser um pouco mais desafiador do que depurar uma função diretamente no componente, especialmente se houver encadeamento de pipes.

### Quando Utilizar Pipes

- **Formatação de Dados para Exibição:** Datas, moedas, números, percentagens, etc.
- **Transformações Simples de Strings:** Maiúsculas, minúsculas, truncamento, etc.
- **Filtro e Ordenação de Listas:** Para apresentações simples, especialmente com pipes puros que reagem a novas referências do array.
- **Assinatura de Observables ou Promises no Template:** O `AsyncPipe` é a ferramenta ideal para isso.

### Quando Evitar o Uso de Pipes

- **Lógica de Negócio Complexa:** Se a transformação envolve várias etapas, decisões complexas ou interações com serviços, é melhor mover essa lógica para o componente ou para um serviço.
- **Manipulação de DOM:** Pipes são para transformação de dados, não para manipulação direta do DOM.
- **Operaões com Efeitos Colaterais:** Pipes devem ser funções puras (exceto os impuros, mas mesmo assim, focadas em transformação, não em efeitos colaterais). Não devem alterar o estado da aplicação.
- **Filtro/Ordenação de Arrays Grandes e Frequentes:** Para arrays muito grandes ou que sofrem muitas modificações, um pipe puro de filtro/ordenação pode ser ineficiente se você não estiver criando uma nova referência do array. Nesses casos, considere implementar a lógica de filtro/ordenação no componente e passar o array já processado para o template.

---

## Referências para Estudo Independente

Para aprofundar seus conhecimentos em Pipes do Angular, recomendo as seguintes fontes:

- **Documentação Oficial do Angular - Pipes:**
    - [https://angular.io/guide/pipes](https://angular.io/guide/pipes)
    - [https://angular.io/api?query=pipe](https://angular.io/api?query=pipe) (Referência da API para pipes embutidos)
- **Artigos e Tutoriais (Buscas recomendadas):**
    - "Angular Pipes Tutorial"
    - "Custom Pipes in Angular"
    - "Angular Pure vs Impure Pipes"

Espero que esta explicação detalhada sobre Pipes no Angular tenha sido super útil para você, Gedê\! Se tiver mais alguma dúvida, pode mandar\! A.R.I.A está aqui para ajudar\!