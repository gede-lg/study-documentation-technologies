# HttpParams

Olá, Gedê\!

A.R.I.A. está pronta para te ajudar com uma explicação detalhada sobre `HttpParams` no Angular. Preparei um material bem completo para você, seguindo todos os pontos que pediu.

---

## **O Objeto `HttpParams` no Angular: Manipulando Parâmetros de URL com Eficiência**

---

### **Introdução**

No desenvolvimento de aplicações web, é muito comum precisarmos enviar dados para o servidor através da URL, seja para filtrar uma lista, paginar resultados ou passar informações de configuração. No Angular, o `HttpClient` é a ferramenta padrão para fazer requisições HTTP, e ele oferece o objeto `HttpParams` como uma forma segura e imutável de construir e manipular esses parâmetros de URL, também conhecidos como *query strings*.

### **Sumário**

Esta explicação irá cobrir os fundamentos do `HttpParams`, sua sintaxe e uso, detalhando cada uma de suas propriedades e métodos. Abordaremos as restrições de uso, melhores práticas e apresentaremos exemplos completos para ilustrar sua aplicação em cenários reais, como em requisições `GET` para APIs.

---

### **Conceitos Fundamentais**

O `HttpParams` é uma classe do pacote `@angular/common/http` que foi projetada para lidar com a complexidade e a imutabilidade dos parâmetros de requisição. Seu propósito principal é:

- **Imutabilidade:** Cada operação (como adicionar ou remover um parâmetro) retorna uma nova instância de `HttpParams`, garantindo que o objeto original permaneça inalterado. Isso evita efeitos colaterais indesejados em diferentes partes do seu código.
- **Segurança:** A classe automaticamente codifica os valores dos parâmetros (`URL-encoding`), tratando caracteres especiais como espaços, acentos e símbolos, para que sejam transmitidos corretamente pela URL sem causar erros.
- **Organização:** Ela oferece uma API clara e fluida para construir a *query string*, tornando o código mais legível e fácil de manter.

---

### **Sintaxe e Uso**

Você pode criar uma nova instância de `HttpParams` de duas maneiras:

1. **Instanciando a classe diretamente:**

<!-- end list -->

```tsx
import { HttpParams } from '@angular/common/http';

// Cria uma instância vazia
let params = new HttpParams();

// A partir de um objeto JavaScript
let paramsFromObject = new HttpParams({
  fromObject: { nome: 'Gedê', idade: '23' }
});

console.log(paramsFromObject.toString());
// Saída: nome=Ged%C3%AA&idade=23

```

1. **Usando um objeto para inicializar (recomendado para valores estáticos):**

<!-- end list -->

```tsx
import { HttpClient, HttpParams } from '@angular/common/http';

constructor(private http: HttpClient) {}

buscarUsuarios(pagina: number, tamanho: number) {
  let params = new HttpParams()
    .set('page', pagina.toString())
    .set('size', tamanho.toString());

  return this.http.get('<https://api.exemplo.com/usuarios>', { params });
}

```

---

### **Propriedades**

Embora `HttpParams` seja uma classe, ela não tem propriedades públicas que você precise acessar diretamente. Sua funcionalidade é exposta através de seus métodos imutáveis, que permitem a construção e manipulação dos parâmetros. A única propriedade que a inicialização pode receber é `fromObject` para criar a instância a partir de um objeto literal.

---

### **Métodos**

A API de `HttpParams` é construída em torno de métodos que retornam uma nova instância do objeto após cada operação. Vamos detalhar cada um deles:

| Método | Conceito | Exemplo de Uso |
| --- | --- | --- |
| `set(param, value)` | Define um novo valor para um parâmetro. Se o parâmetro já existir, seu valor é substituído. Se não, ele é adicionado. O método sempre retorna uma **nova** instância de `HttpParams`. | `let params = new HttpParams().set('nome', 'Luiz');` |
| `append(param, value)` | Adiciona um novo valor a um parâmetro. Se o parâmetro já existir, o novo valor é adicionado à lista de valores do parâmetro. Útil para arrays de valores, como `id=1&id=2`. Retorna uma **nova** instância. | `let params = new HttpParams().append('tags', 'java').append('tags', 'go');` |
| `delete(param, value?)` | Remove um parâmetro. Se `value` não for fornecido, remove o parâmetro e todos os seus valores. Se `value` for fornecido, remove apenas aquele valor específico do parâmetro. Retorna uma **nova** instância. | `let params = new HttpParams().set('id', '123').delete('id');` |
| `get(param)` | Retorna o primeiro valor de um parâmetro. Retorna `null` se o parâmetro não existir. | `const nome = params.get('nome');` |
| `getAll(param)` | Retorna todos os valores de um parâmetro como um array de strings. Retorna `null` se o parâmetro não existir. | `const tags = params.getAll('tags');` |
| `has(param)` | Retorna `true` se o parâmetro existir na lista, caso contrário, `false`. | `const existeNome = params.has('nome');` |
| `keys()` | Retorna um array com os nomes de todos os parâmetros existentes. | `const chaves = params.keys();` |
| `toString()` | Converte o objeto `HttpParams` em uma *query string* formatada e codificada, pronta para ser anexada à URL. | `const queryString = params.toString();` |

---

### **Restrições de Uso**

O `HttpParams` é ideal para requisições `GET`, onde os dados são passados pela URL. No entanto, ele **não deve** ser usado nos seguintes cenários:

- **Corpo da Requisição (`POST`, `PUT`, `PATCH`):** Para enviar dados no corpo da requisição (como um JSON), você deve passar o objeto diretamente para o método `post()`, `put()`, etc. O `HttpParams` foi projetado exclusivamente para a *query string*.
- **Dados sensíveis:** Por serem visíveis na URL, os parâmetros criados com `HttpParams` não são apropriados para dados sensíveis como senhas, tokens de autenticação ou informações pessoais. Nesses casos, o ideal é usar o corpo da requisição (`POST`) ou os *headers* da requisição.

---

### **Melhores Práticas e Casos de Uso**

- **Reuso e Composição:** A imutabilidade do `HttpParams` facilita o reuso. Você pode criar uma base de parâmetros e adicionar ou modificar novos parâmetros em diferentes partes do seu código sem afetar a base original.
- **Centralização de Lógica:** Crie um serviço para encapsular a lógica de construção dos parâmetros. Por exemplo, um serviço `SearchService` pode ter um método `buildSearchParams(filters)` que retorna um `HttpParams` já pronto, com a codificação e regras de negócio aplicadas.
- **Manipulação de Arrays:** Use o método `append()` para lidar com parâmetros que aceitam múltiplos valores.
- **Clareza e Legibilidade:** Sempre prefira usar `HttpParams` em vez de concatenar *strings* manualmente, pois ele cuida da codificação e torna seu código muito mais legível e seguro.

---

### **Exemplo Completo**

Vamos a um exemplo prático de como você, Gedê, pode usar `HttpParams` em um componente para buscar produtos, aplicando filtros e paginação.

```tsx
// src/app/produto.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ProdutoService {
  private readonly apiUrl = '<https://api.exemplo.com/produtos>';

  constructor(private http: HttpClient) { }

  buscarProdutos(filtros: { nome?: string, categoria?: string, pagina: number, tamanho: number }): Observable<any> {
    // 1. Inicia um novo HttpParams vazio
    let params = new HttpParams();

    // 2. Adiciona os parâmetros de paginação
    params = params.set('page', filtros.pagina.toString());
    params = params.set('size', filtros.tamanho.toString());

    // 3. Adiciona os filtros de forma condicional, usando a imutabilidade
    if (filtros.nome) {
      params = params.set('nome', filtros.nome);
    }
    if (filtros.categoria) {
      params = params.set('categoria', filtros.categoria);
    }

    // 4. Faz a requisição HTTP passando o objeto 'params' na configuração
    return this.http.get(this.apiUrl, { params: params });
  }
}

```

```tsx
// src/app/app.component.ts
import { Component, OnInit } from '@angular/core';
import { ProdutoService } from './produto.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  produtos: any[] = [];

  constructor(private produtoService: ProdutoService) {}

  ngOnInit() {
    this.carregarProdutos();
  }

  carregarProdutos() {
    const filtrosDeBusca = {
      nome: 'notebook',
      categoria: 'eletronicos',
      pagina: 1,
      tamanho: 10
    };

    this.produtoService.buscarProdutos(filtrosDeBusca).subscribe(
      (dados) => {
        this.produtos = dados.items;
        console.log('Produtos encontrados:', this.produtos);
      },
      (erro) => {
        console.error('Ocorreu um erro ao buscar os produtos:', erro);
      }
    );
  }
}

```

Nesse exemplo, a chamada para `http.get()` usará o objeto `params` para construir a URL completa com os parâmetros, resultando em algo como: `https://api.exemplo.com/produtos?page=1&size=10&nome=notebook&categoria=eletronicos`.

---

### **Para aprofundamento**

Se você quiser continuar a se aprofundar, Gedê, sugiro explorar os seguintes tópicos:

- ***Interceptors* no Angular:** Como usar *interceptors* para adicionar `HttpParams` globalmente a certas requisições (por exemplo, um token de API fixo).
- **Requisições com *headers*:** Aprofunde-se na classe `HttpHeaders` para entender como manipular cabeçalhos de requisição, que é tão importante quanto os parâmetros.
- **Tipagem de Requisições:** Como criar interfaces e classes para tipar corretamente os dados que você recebe do servidor, usando `Observable<T>`.

Espero que essa explicação tenha sido clara e útil para você. Se tiver mais alguma dúvida ou precisar de ajuda com outra coisa, é só me chamar\!