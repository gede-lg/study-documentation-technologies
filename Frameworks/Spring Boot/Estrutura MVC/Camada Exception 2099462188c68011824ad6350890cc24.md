# Camada Exception

---

## 1. Introdução

A “Camada Exception” em uma aplicação Spring MVC refere-se ao conjunto de mecanismos destinados a capturar, centralizar e manipular erros/exceções que ocorrem durante o fluxo de requisições HTTP. Em vez de propagar diretamente `NullPointerException`, `IllegalArgumentException` ou falhas de banco de dados até o cliente, essa camada prevê estratégias que:

- Encapsulam erros em respostas padronizadas;
- Separam a lógica de negócio do tratamento de erros;
- Permitem registro (logging) e monitoramento centralizados.

---

## 2. Sumário

1. Conceitos Fundamentais
2. Funcionamento Básico (Fluxo de Exceções)
3. Cenários de Restrição ou Não Aplicação
4. Componentes-Chave Associados
5. Melhores Práticas e Padrões de Uso
6. Sugestões para Aprofundamento

---

## 3. Conceitos Fundamentais

- **Propagação de Exceções**
    
    No Spring MVC, quando um método de um controlador ou de um serviço lança uma exceção, há dois caminhos principais:
    
    1. Deixar o Spring tratar como erro genérico (retornando 500 Internal Server Error).
    2. Interceptar a exceção em um ponto centralizado (a “camada Exception”) para mapear a resposta de forma específica.
- **Objetivo da Camada de Exceções**
    - **Uniformizar Respostas de Erro**: Evitar que cada controlador construa manualmente diferentes formatos de JSON ou páginas HTML de erro.
    - **Separação de Responsabilidade**: Controllers focam na lógica de negócio; a camada exception cuida exclusivamente de capturar e traduzir falhas.
    - **Reutilização e Manutenção**: Qualquer ajuste no formato de resposta de erro ou registro de log é centralizado, facilitando manutenção.
- **Por que isso importa?**
    - **Experiência do Consumidor (API/Front-end)**: Mensagens consistentes e claras ajudam no diagnóstico de problemas.
    - **Segurança**: Evita expor mensagens de stack trace para o cliente.
    - **Monitoramento**: Permite registrar um ponto único onde todas as exceções relevantes são logadas, possibilitando métricas e alertas.

---

## 4. Funcionamento Básico (Fluxo de Exceções)

1. **Requisição HTTP chega ao DispatcherServlet**
    
    O `DispatcherServlet`, componente central do Spring MVC, encaminha a chamada até um método de controlador (annotado por `@Controller` ou `@RestController`).
    
2. **Execução do Método de Controle**
    
    Se o método completar sem erros, retorna um modelo ou objeto que é convertido em resposta HTTP (JSON, HTML etc).
    
    Caso lance uma exceção não tratada, a pilha sobe até o mecanismo interno do Spring.
    
3. **Interceptação pelo HandlerExceptionResolver ou ControllerAdvice**
    - **HandlerExceptionResolver**: Interface que permite definir beans que interceptam exceções e retornam um `ModelAndView` ou `ResponseEntity`.
    - **@ControllerAdvice**: Classe global que declara métodos com `@ExceptionHandler` para tratar tipos específicos de exceções.
4. **Construção da Resposta de Erro**
    
    O método designado na camada exception captura o tipo de exceção, atribui um status HTTP (por exemplo, 400, 404, 500) e monta um objeto de resposta padronizado (por exemplo, uma estrutura JSON contendo código, mensagem de erro e timestamp).
    
5. **Envio ao Cliente**
    
    O `DispatcherServlet` recebe o retorno padronizado e devolve ao cliente, encerrando o fluxo.
    

---

## 5. Cenários de Restrição ou Não Aplicação

- **Aplicações Extremamente Simples**
    
    Se a aplicação só possui um ou dois pontos de entrada e não requer padronização rígida de erros, pode-se optar por tratamento pontual (dentro do método) ou deixar o Spring gerar o erro genérico. Contudo, a escalabilidade fica comprometida.
    
- **Ambientes Legacy Sem Spring MVC**
    
    Em sistemas herdados que adotam Servlets puros ou frameworks distintos, a camada de exception do Spring MVC não se aplica diretamente, pois a infraestrutura de interceptação difere.
    
- **Casos de Alto Desempenho, com Mínima Latência**
    
    Em cenários em que cada milissegundo conta (por exemplo, microserviços de altíssimo throughput), a sobrecarga mínima de resolver exceção pode ser relevante. Ainda assim, a maioria dos casos se beneficia mais da clareza do que perde em performance.
    

---

## 6. Componentes-Chave Associados

1. **`@ControllerAdvice`**
    - Classe anotada que age como um “conselheiro” global, capturando exceções lançadas por qualquer `@Controller` ou `@RestController`.
    - Permite agrupar vários métodos `@ExceptionHandler` em um único lugar.
2. **`@ExceptionHandler`**
    - Anotação aplicada a métodos dentro de `@ControllerAdvice` (ou em controllers isolados) para indicar quais exceções devem ser tratadas.
    - Recebe como parâmetro a classe da exceção a ser interceptada (por exemplo, `ResourceNotFoundException.class`).
3. **`ResponseEntity` ou `ResponseStatusException`**
    - **ResponseEntity<T>**: Estrutura que carrega payload (corpo de resposta) e status code customizado.
    - **ResponseStatusException**: Exceção que, quando lançada dentro do controller, já contém um código HTTP associado. A camada global pode interceptar e repassar esse status.
4. **`HandlerExceptionResolver` (Opcional)**
    - Interface para criar resolvers personalizados. Caso haja necessidade de lógica mais elaborada (por exemplo, switch dinâmico entre formatos JSON, XML ou HTML), implementa-se esta interface e registra-se no contexto Spring.
5. **DTO de Erro (Payload Padronizado)**
    - Classe simples (p. ex. `ErrorResponse`) contendo campos como `timestamp`, `status`, `mensagem` e, opcionalmente, `detalhes`. Serve para manter consistência das respostas.

---

## 7. Melhores Práticas e Padrões de Uso

1. **Centralize sempre que possível**
    - Crie uma ou duas classes com `@ControllerAdvice` em vez de espalhar `try/catch` por todos os controladores. Isso aumenta a legibilidade e manutenção.
2. **Diferencie Tipos de Exceções**
    - Use handlers específicos para exceções de domínio (por ex., `BusinessException` mapeado para 400 Bad Request) e um fallback genérico para exceções inesperadas (mapeado para 500 Internal Server Error).
3. **Mantenha o Payload de Erro Simples e Informativo**
    - Evite expor stack trace ou detalhes internos ao cliente. Inclua um código de erro legível (ex.: `"ERR-001"`), mensagem sucinta e, se necessário, um link para documentação de API.
4. **Logue o Contexto Completo do Erro**
    - No método de tratamento global, registre NO LADO DO SERVIDOR o stack trace completo e dados de contexto (URL, parâmetros, usuário). Do lado do cliente, envie apenas o payload padronizado.
5. **Documente os Códigos de Erro na API**
    - Utilize Swagger/OpenAPI para listar possíveis respostas de erro de cada endpoint. Isso auxilia quem consome a API a entender quais situações podem ocorrer.
6. **Não Abuse de Exceções para Fluxo de Lógica Normal**
    - Exceções devem retratar falhas ou condições inesperadas, não substituir verificações de validação (por ex., ao invés de lançar `NullPointerException` porque um campo veio nulo, prefira capturar previamente e retornar 400).

---

## 8. Sugestões para Aprofundamento

- **Leitura do Guia Oficial Spring**
    - Seção “Handling Errors in Spring Web Applications” (página oficial do Spring Docs).
- **OpenAPI/Swagger**
    - Como mapear respostas de erro nos arquivos de definição para gerar documentação automática.
- **Micrometer + Actuator**
    - Integração para métricas de falhas/erros, possibilitando monitoramento de quantos erros 4xx/5xx a aplicação está gerando.
- **Testes Automatizados**
    - Desenvolver cenários de testes de integração que forçam exceções (mockando serviços) e validam se a resposta HTTP e o payload seguem o padrão definido.
- **Customização Avançada**
    - Explorar `HandlerExceptionResolver` para gerar respostas condicionais (por exemplo, formatar erro como JSON ou XML conforme header “Accept”).
- **Fallback e Circuit Breaker**
    - Combinar tratamento de exceções com bibliotecas de resiliência (como Resilience4j) para oferecer fallback ou degradar funcionalidade em caso de falhas externas.

---

**Resumo Final:**

A camada de tratamento de exceções no Spring MVC visa capturar e traduzir erros em respostas HTTP amigáveis e padronizadas, mantendo a lógica de negócio livre de código específico de tratamento de falhas. Utiliza-se, sobretudo, `@ControllerAdvice` e `@ExceptionHandler` para criar um ponto único de interceptação. Seguindo boas práticas—como centralização, diferenciação de tipos de exceção, e logs adequados—assegura-se manutenção mais simples, maior consistência na API e melhor experiência para quem consome os endpoints.