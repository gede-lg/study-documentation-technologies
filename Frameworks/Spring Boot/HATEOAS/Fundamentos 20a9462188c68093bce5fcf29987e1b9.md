# Fundamentos

---

## Introdução

HATEOAS (Hypermedia as the Engine of Application State) é um dos pilares que elevam a maturidade de APIs RESTful para o nível 3 no Modelo de Richardson. Ao incorporar links hipermídia diretamente nas respostas, o cliente consegue navegar dinamicamente pela API sem conhecimento prévio de todas as URIs. Neste módulo, vamos contextualizar por que HATEOAS é relevante, como ele contribui para o desacoplamento entre cliente e servidor e qual o papel do Spring Boot em fornecer suporte pronto para uso.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#conceitos-fundamentais)
    
    1.1. O que é HATEOAS?
    
    1.2. Por que usar HATEOAS?
    
    1.3. Modelo de Maturidade de Richardson (Nível 3)
    
    1.4. Estrutura de uma Resposta HATEOAS
    
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    
    2.1. Dependências necessárias
    
    2.2. Objetos de representação: `EntityModel`, `CollectionModel`, `RepresentationModel`
    
    2.3. Construção de links com `WebMvcLinkBuilder`
    
    2.4. Exemplos de código comentados
    
    2.5. Variações de sintaxe (ex.: usando `RepresentationModelAssembler`)
    
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
    
    3.1. APIs simples, sem necessidade de navegação dinâmica
    
    3.2. Alto custo de performance ou payload excessivo
    
    3.3. Clientes restritos (p. ex., IoT com pouco processamento)
    
4. [Componentes Chave Associados](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#componentes-chave-associados)
    
    4.1. Dependência `spring-boot-starter-hateoas`
    
    4.2. Classe `Link` (org.springframework.hateoas.Link)
    
    4.3. Interface `RepresentationModel<T>`
    
    4.4. `EntityModel<T>` e `CollectionModel<T>`
    
    4.5. `RepresentationModelAssembler<T, D>`
    
    4.6. `WebMvcLinkBuilder` (métodos `linkTo`, `methodOn`)
    
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
    
    5.1. Separação de responsabilidades (Assembler vs. Controller)
    
    5.2. Uso de nomes semânticos para *rels* (ex.: `"self"`, `"update"`, `"delete"`)
    
    5.3. Paginação e links de navegação (próxima página, página anterior)
    
    5.4. Internacionalização de URIs, se necessário
    
6. [Exemplo Prático Completo](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#exemplo-pr%C3%A1tico-completo)
    
    6.1. Cenário: API de gerenciamento de “Produtos”
    
    6.2. Entidade JPA e repositório
    
    6.3. Controller retornando `EntityModel` e `CollectionModel`
    
    6.4. `ProductModelAssembler`
    
    6.5. Respostas JSON HATEOAS de exemplo
    
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sugest%C3%B5es-para-aprofundamento)
    
    7.1. Comparar HATEOAS com GraphQL ou OData
    
    7.2. Impacto na usabilidade da API (descobrimento automático)
    
    7.3. Ferramentas de teste (Postman, Spring REST Docs)
    

---

## Conceitos Fundamentais

### 1.1 O que é HATEOAS?

- **Definição**: HATEOAS significa **Hypermedia as the Engine of Application State**.
- **Propósito**: Em vez de expor URIs estáticas, a API fornece, junto aos dados, links hipermídia que orientam o cliente sobre quais ações são possíveis a partir daquele recurso.
- **Exemplo simplificado**:
    
    ```json
    {
      "id": 1,
      "nome": "Caneca",
      "preco": 25.00,
      "_links": {
        "self": { "href": "http://api.exemplo.com/produtos/1" },
        "atualizar": { "href": "http://api.exemplo.com/produtos/1", "method": "PUT" },
        "remover": { "href": "http://api.exemplo.com/produtos/1", "method": "DELETE" }
      }
    }
    
    ```
    

### 1.2 Por que usar HATEOAS?

- **Descobrimento de API**: O cliente “descobre” o que pode fazer a partir dos links retornados. Não precisa codificar todas as URIs antecipadamente.
- **Desacoplamento**: Caso a URI de um recurso mude, basta atualizar o link no servidor; o cliente permanece inalterado (contanto que respeite os `rels`).
- **Segurança e Evolução**: Permite evoluir a API sem quebrar versões antigas — ou, no mínimo, sinalizar claramente ao cliente quais ações estão disponíveis.

### 1.3 Modelo de Maturidade de Richardson (Nível 3 de REST)

- **Nível 0**: Arquitetura RPC-like (uma única URI, métodos distintos com payloads)
- **Nível 1**: Múltiplas URIs, mas sem uso de HTTP verbs adequados
- **Nível 2**: Uso correto de métodos HTTP (GET, POST, PUT, DELETE) e valor semântico de URIs
- **Nível 3 (HATEOAS)**: Além de tudo no Nível 2, cada recurso contém hipermídia para transições de estado (links).
- **Benefício**: Quanto mais próximo do Nível 3, mais aderente ao estilo REST puro, aumentando a flexibilidade para clientes genéricos.

### 1.4 Estrutura de uma Resposta HATEOAS

- **Dados**: O próprio recurso (por exemplo, um objeto `Produto`).
- **Links**: Objetos `{ "rel": "...", "href": "uri" }`, geralmente estruturados no campo `_links`.
- **Media Type (opcional)**: `application/hal+json` (HAL — Hypertext Application Language) ou outros padrões (ex.: Siren, JSON-LD).
- **Exemplo básico**:
    
    ```json
    {
      "id": 42,
      "nome": "Notebook",
      "preco": 3600.00,
      "_links": {
        "self": { "href": "http://api.exemplo.com/produtos/42" },
        "todos-produtos": { "href": "http://api.exemplo.com/produtos" }
      }
    }
    
    ```
    

---

## Sintaxe Detalhada e Uso Prático

### 2.1 Dependências necessárias

No `pom.xml` (Maven) ou `build.gradle` (Gradle), acrescente:

```xml
<!-- Para Maven -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>

```

```groovy
// Para Gradle
implementation 'org.springframework.boot:spring-boot-starter-hateoas'

```

> Observação: A partir do Spring Boot 2.2, o starter HATEOAS traz automaticamente as classes EntityModel, Link, WebMvcLinkBuilder, entre outras.
> 

---

### 2.2 Objetos de representação

- **`RepresentationModel<T>`**: Classe base abstrata para modelos que contêm links. Ex.: `public class ProdutoModel extends RepresentationModel<ProdutoModel> { ... }`.
- **`EntityModel<T>`**: Envolve uma entidade única. Ex.: `EntityModel<Produto>`.
- **`CollectionModel<T>`**: Container para múltiplas entidades (ou modelos). Ex.: `CollectionModel<EntityModel<Produto>>`.
- **Quando usar cada um?**
    - Use `EntityModel<T>` quando seu endpoint retorna um único recurso.
    - Use `CollectionModel<T>` quando retorna coleção de recursos.
    - Se você deseja customizar o modelo, crie uma classe que estenda `RepresentationModel<>`.

---

### 2.3 Construção de links com `WebMvcLinkBuilder`

A classe `WebMvcLinkBuilder` simplifica a criação de links baseados em controller e métodos:

```java
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

Link selfLink = linkTo(methodOn(ProdutoController.class)
    .buscarPorId(produto.getId()))
    .withSelfRel();

Link todosLink = linkTo(methodOn(ProdutoController.class)
    .listarTodos())
    .withRel("todos-produtos");

```

- **`linkTo(...)`**: Inicia um `LinkBuilder` baseado na referência ao controller ou requisição.
- **`methodOn(Controller.class).metodo(...)`**: Cria um “mock” de chamada para gerar a URI.
- **`.withSelfRel()`** ou **`.withRel("nome-rel")`**: Define o *rel* (relação semântica) do link.

---

### 2.4 Exemplos de código comentados

### 2.4.1 Entidade JPA e DTO (opcional)

```java
// Entidade JPA simples
@Entity
public class Produto {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String nome;
    private BigDecimal preco;
    // getters e setters omitidos para brevidade
}

```

> Em muitos cenários, recomenda-se mapear Produto → ProdutoDTO antes de envolver em HATEOAS, para não expor entidades diretamente.
> 

### 2.4.2 DTO simples

```java
public class ProdutoDTO {
    private Long id;
    private String nome;
    private BigDecimal preco;
    // getters e setters
}

```

### 2.4.3 Model (representação HATEOAS)

```java
import org.springframework.hateoas.RepresentationModel;

/**
 * Representação HATEOAS de um Produto.
 * Estende RepresentationModel para conter links.
 */
public class ProdutoModel extends RepresentationModel<ProdutoModel> {
    private Long id;
    private String nome;
    private BigDecimal preco;

    // Construtores, getters e setters
    public ProdutoModel() {}

    public ProdutoModel(Long id, String nome, BigDecimal preco) {
        this.id = id;
        this.nome = nome;
        this.preco = preco;
    }
    // getters e setters omitidos para brevidade
}

```

### 2.4.4 Assembler (fábrica de modelos com links)

```java
import org.springframework.hateoas.server.mvc.RepresentationModelAssemblerSupport;
import org.springframework.stereotype.Component;
import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

/**
 * ProdutoModelAssembler: converte Produto → ProdutoModel (com links).
 * Usa RepresentationModelAssemblerSupport para simplificar a criação.
 */
@Component
public class ProdutoModelAssembler
        extends RepresentationModelAssemblerSupport<Produto, ProdutoModel> {

    public ProdutoModelAssembler() {
        super(ProdutoController.class, ProdutoModel.class);
    }

    @Override
    public ProdutoModel toModel(Produto produto) {
        // Cria o modelo básico com campos
        ProdutoModel model = instantiateModel(produto);
        model.setId(produto.getId());
        model.setNome(produto.getNome());
        model.setPreco(produto.getPreco());

        // Adiciona link "self" apontando para GET /produtos/{id}
        model.add(
            linkTo(methodOn(ProdutoController.class)
                .buscarPorId(produto.getId()))
            .withSelfRel()
        );

        // Adiciona link para listar todos os produtos
        model.add(
            linkTo(methodOn(ProdutoController.class)
                .listarTodos())
            .withRel("todos-produtos")
        );

        return model;
    }
}

```

- **`RepresentationModelAssemblerSupport<Origem, Destino>`**: Classe abstrata que facilita casos comuns de conversão de entidade para Model.
- **`instantiateModel(produto)`**: Inicializa o `ProdutoModel`.
- **`model.add(link)`**: Adiciona hipermídia ao modelo.

### 2.4.5 Controller retornando `EntityModel` e `CollectionModel`

```java
import org.springframework.hateoas.*;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/produtos")
public class ProdutoController {

    private final ProdutoRepository repository;
    private final ProdutoModelAssembler assembler;

    public ProdutoController(ProdutoRepository repository,
                             ProdutoModelAssembler assembler) {
        this.repository = repository;
        this.assembler = assembler;
    }

    /**
     * GET /produtos
     * Retorna todos os produtos como CollectionModel<EntityModel<ProdutoModel>>.
     */
    @GetMapping
    public CollectionModel<ProdutoModel> listarTodos() {
        List<Produto> produtos = repository.findAll();

        // Converte cada Produto em ProdutoModel (com links)
        List<ProdutoModel> produtosModel = produtos.stream()
            .map(assembler::toModel)
            .collect(Collectors.toList());

        // Cria CollectionModel e adiciona link "self"
        return CollectionModel.of(produtosModel,
            linkTo(methodOn(ProdutoController.class).listarTodos())
            .withSelfRel()
        );
    }

    /**
     * GET /produtos/{id}
     * Retorna um único ProdutoModel envolto em EntityModel (já contém links).
     */
    @GetMapping("/{id}")
    public ResponseEntity<ProdutoModel> buscarPorId(@PathVariable Long id) {
        return repository.findById(id)
            .map(produto -> {
                ProdutoModel model = assembler.toModel(produto);
                return ResponseEntity.ok(model);
            })
            .orElse(ResponseEntity.notFound().build());
    }

    /**
     * POST /produtos
     * Cria um novo produto. No retorno, inclui link para o recurso criado.
     */
    @PostMapping
    public ResponseEntity<EntityModel<ProdutoModel>> criar(@RequestBody Produto produto) {
        Produto salvo = repository.save(produto);
        ProdutoModel model = assembler.toModel(salvo);

        return ResponseEntity
            .created(model.getRequiredLink(IanaLinkRelations.SELF).toUri())
            .body(EntityModel.of(model));
    }

    /**
     * PUT /produtos/{id}
     * Atualiza um produto existente.
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> atualizar(@PathVariable Long id,
                                       @RequestBody Produto dados) {
        return repository.findById(id)
            .map(produtoExistente -> {
                produtoExistente.setNome(dados.getNome());
                produtoExistente.setPreco(dados.getPreco());
                repository.save(produtoExistente);
                ProdutoModel model = assembler.toModel(produtoExistente);
                return ResponseEntity.ok(model);
            })
            .orElse(ResponseEntity.notFound().build());
    }

    /**
     * DELETE /produtos/{id}
     * Remove o produto e retorna HTTP 204 (No Content).
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> remover(@PathVariable Long id) {
        return repository.findById(id)
            .map(produto -> {
                repository.delete(produto);
                return ResponseEntity.noContent().<Void>build();
            })
            .orElse(ResponseEntity.notFound().build());
    }
}

```

- **`listarTodos()`**: Retorna `CollectionModel<ProdutoModel>`; cada `ProdutoModel` já contém seu link “self”.
- **`buscarPorId(...)`**: Usa `ResponseEntity<ProdutoModel>`, e o Assemblador já incluiu os links.
- **`criar(...)`**: Ao criar um recurso, devolve `201 Created` com a URI do recurso recém-criado (obtida via `model.getRequiredLink(IanaLinkRelations.SELF).toUri()`).
- **`IanaLinkRelations.SELF`**: Convenience para o *rel* `"self"` no padrão HAL.

---

### 2.5 Variações de sintaxe

- **Sem usar `RepresentationModelAssemblerSupport`**: é possível construir o modelo manualmente sem herdar de `RepresentationModelAssemblerSupport`.
- **Exemplo manual**:
    
    ```java
    @GetMapping("/{id}")
    public EntityModel<Produto> buscarManual(@PathVariable Long id) {
        Produto produto = repository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException());
    
        // Envolver a entidade direta em EntityModel
        EntityModel<Produto> model = EntityModel.of(produto);
    
        // Adicionar links manualmente
        Link self = linkTo(methodOn(ProdutoController.class)
            .buscarManual(id)).withSelfRel();
        model.add(self);
    
        return model;
    }
    
    ```
    
- **Uso de `PagedModel<T>` para paginação**: caso utilize `PagingAndSortingRepository`, o HATEOAS oferece integração automática com `PageableAssembler` para criar links de “próxima” e “anterior”.

---

## Cenários de Restrição ou Não Aplicação

### 3.1 APIs simples, sem necessidade de navegação dinâmica

- Quando a API é restrita a um único cliente bem definido (por exemplo, uma aplicação monolítica com front-end acoplado), HATEOAS pode ser redundante.
- APIs internas para microservices que não precisam de auto-descobrimento podem não justificar o overhead de links extras.

### 3.2 Alto custo de performance ou payload excessivo

- Cada modelo HATEOAS incorpora links adicionais, aumentando o tamanho da resposta. Se o cliente estiver em rede instável ou com restrições de largura de banda (ex.: dispositivos IoT), pode ser vantajoso omitir HATEOAS.
- Em cenários de altíssima frequência de chamadas onde cada byte conta (ex.: trading), o overhead dos links pode afetar a latência.

### 3.3 Clientes restritos (p.ex., IoT com pouco processamento)

- Dispositivos embarcados ou aplicativos muito leves podem não conseguir processar JSONs com muitos campos `_links`.
- Se o cliente não tiver um mecanismo de “seguir” links programaticamente, HATEOAS perde o propósito.

---

## Componentes Chave Associados

### 4.1 Dependência `spring-boot-starter-hateoas`

- **Artefato**:
    
    ```xml
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-hateoas</artifactId>
    </dependency>
    
    ```
    
- Fornece classes como `EntityModel`, `Link`, `WebMvcLinkBuilder`, `RepresentationModelAssembler`, estruturas de media types HAL e suporte a JSON e XML.

### 4.2 Classe `Link` (org.springframework.hateoas.Link)

- Representa um único link: contém `href` (URI), `rel` (relação semântica) e, opcionalmente, atributos como `type` ou `hreflang`.
- **Exemplo**:
    
    ```java
    Link link = Link.of("http://api.exemplo.com/produtos/1", "self");
    
    ```
    

### 4.3 Interface `RepresentationModel<T>`

- Classe base para todos os modelos que desejam conter links.
- Permite chamar `.add(Link...)` para incluir hipermídia.
- Qualquer classe que estenda `RepresentationModel<?>` torna-se “HATEOAS-enabled”.

### 4.4 `EntityModel<T>` e `CollectionModel<T>`

- **`EntityModel<T>`**: Invólucro para uma única entidade ou DTO.
    - Uso típico: `EntityModel.of(entidade, links...)`.
    - Quando serializado, acrescenta `_links` junto ao recurso.
- **`CollectionModel<T>`**: Container para listas de invólucros (ex.: `CollectionModel<EntityModel<Produto>>`).
    - Possui seus próprios links (ex.: `self`, `first`, `last`, `next`, `prev`).

### 4.5 `RepresentationModelAssembler<T, D>`

- Interface que define métodos para converter **entidade** (`T`) em **modelo HATEOAS** (`D`).
- Métodos principais:
    - `D toModel(T entity)`: retorna o modelo com links.
    - (Opcional) `CollectionModel<D> toCollectionModel(Iterable<? extends T> entities)`: converte múltiplas entidades em coleção de modelos.
- **`RepresentationModelAssemblerSupport`**: implementação base que auxilia no processo (já configurada com controller e classe de modelo).

### 4.6 `WebMvcLinkBuilder`

- Classes estáticas para gerar links baseados em controllers:
    - `linkTo(...)`: retorna `LinkBuilder`.
    - `methodOn(ClasseController.class).metodo(...)`: “mock” que sinaliza o endpoint desejado.
    - `.withSelfRel()`, `.withRel("nome-rel")`, `.withType("PUT")`, `.withTitle("descrição")`, etc.
- Permite criar links relativos ao contexto atual da aplicação, evitando “hardcode” de URIs.

---

## Melhores Práticas e Padrões de Uso

### 5.1 Separação de responsabilidades

- **Controller**: Recebe requisição, chama serviços/repositórios e delega ao Assembler.
- **Assembler** (`RepresentationModelAssembler`): Concentra toda lógica de conversão de entidades para modelos HATEOAS (evita duplicar código de criação de links no controller).

### 5.2 Uso de nomes semânticos para *rels*

- Adote relações padrão definidas por IANA, quando possível (ex.: `"self"`, `"next"`, `"prev"`).
- Para relações específicas de negócio, use nomes claros e consistentes (ex.: `"adicionar-carrinho"`, `"listar-produtos-similares"`).
- Documente os *rels* no README ou documentação da API.

### 5.3 Paginação e links de navegação

- Ao implementar endpoints paginados (por exemplo, usando `Pageable`), utilize `PagedModel<T>` ou `PagedResourcesAssembler<T>` para fornecer automaticamente links de navegação:
    
    ```java
    @GetMapping
    public PagedModel<EntityModel<ProdutoModel>> listarPaginado(
        Pageable pageable,
        PagedResourcesAssembler<Produto> assembler) {
    
        Page<Produto> pagina = repository.findAll(pageable);
        return assembler.toModel(pagina, produtoModelAssembler);
    }
    
    ```
    
    - Esse recurso adiciona `_links` como `"self"`, `"first"`, `"next"`, `"prev"`, `"last"` com base no `Pageable`.

### 5.4 Internacionalização de URIs (quando aplicável)

- Se seu serviço for multi-idioma, considere prefixar URIs com o locale (`/pt-br/produtos`, `/en-us/products`), mas valide se isso não conflita com HATEOAS — todos os links devem refletir o contexto atual de idioma.

---

## Exemplo Prático Completo

### 6.1 Cenário: API de gerenciamento de “Produtos”

Vamos criar um projeto mínimo que cobre:

- Entidade JPA (`Produto`)
- Repositório Spring Data JPA (`ProdutoRepository`)
- Assembler (`ProdutoModelAssembler`)
- Controller HATEOAS-enabled (`ProdutoController`)
- Respostas JSON no formato HAL

Por simplicidade, omitemos detalhes de configuração de banco de dados; assuma que o Spring Boot está configurado para conectar a um banco H2 em memória.

---

### 6.2 Entidade JPA e Repositório

```java
// Pacote: com.exemplo.produto.entity
@Entity
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private BigDecimal preco;

    // Construtores
    public Produto() {}

    public Produto(String nome, BigDecimal preco) {
        this.nome = nome;
        this.preco = preco;
    }

    // Getters e setters omitidos para brevidade
}

```

```java
// Pacote: com.exemplo.produto.repository
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProdutoRepository extends JpaRepository<Produto, Long> {
    // Métodos CRUD prontos para uso
}

```

---

### 6.3 Assembler (ProdutoModelAssembler)

```java
// Pacote: com.exemplo.produto.assembler
import com.exemplo.produto.controller.ProdutoController;
import com.exemplo.produto.entity.Produto;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.mvc.RepresentationModelAssemblerSupport;
import org.springframework.stereotype.Component;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@Component
public class ProdutoModelAssembler
        extends RepresentationModelAssemblerSupport<Produto, EntityModel<Produto>> {

    public ProdutoModelAssembler() {
        super(ProdutoController.class,
              (Class<EntityModel<Produto>>) (Class<?>) EntityModel.class);
    }

    @Override
    public EntityModel<Produto> toModel(Produto produto) {
        // Criação de EntityModel<Produto>
        EntityModel<Produto> model = EntityModel.of(produto);

        // Link "self" para GET /produtos/{id}
        model.add(
            linkTo(methodOn(ProdutoController.class)
                .buscarPorId(produto.getId()))
            .withSelfRel()
        );
        // Link para listar todos (GET /produtos)
        model.add(
            linkTo(methodOn(ProdutoController.class)
                .listarTodos())
            .withRel("todos-produtos")
        );
        // Exemplo: link para remover (DELETE /produtos/{id})
        model.add(
            linkTo(methodOn(ProdutoController.class)
                .remover(produto.getId()))
            .withRel("remover")
        );
        return model;
    }
}

```

> Observação: usamos EntityModel<Produto> diretamente em vez de criar uma classe ProdutoModel. Isso funciona, mas a best practice é separar a entidade do modelo de representação (para evitar expor campos internos).
> 

---

### 6.4 Controller HATEOAS-enabled

```java
// Pacote: com.exemplo.produto.controller
import com.exemplo.produto.assembler.ProdutoModelAssembler;
import com.exemplo.produto.entity.Produto;
import com.exemplo.produto.repository.ProdutoRepository;
import org.springframework.hateoas.*;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.List;
import java.util.stream.Collectors;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
@RequestMapping("/produtos")
public class ProdutoController {

    private final ProdutoRepository repository;
    private final ProdutoModelAssembler assembler;

    public ProdutoController(ProdutoRepository repository,
                             ProdutoModelAssembler assembler) {
        this.repository = repository;
        this.assembler = assembler;
    }

    @GetMapping
    public CollectionModel<EntityModel<Produto>> listarTodos() {
        List<EntityModel<Produto>> produtosModel = repository.findAll()
            .stream()
            .map(assembler::toModel)
            .collect(Collectors.toList());

        return CollectionModel.of(produtosModel,
            linkTo(methodOn(ProdutoController.class).listarTodos()).withSelfRel()
        );
    }

    @GetMapping("/{id}")
    public ResponseEntity<EntityModel<Produto>> buscarPorId(@PathVariable Long id) {
        return repository.findById(id)
            .map(produto -> ResponseEntity.ok(assembler.toModel(produto)))
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<EntityModel<Produto>> criar(@RequestBody Produto produto) {
        Produto salvo = repository.save(produto);
        EntityModel<Produto> model = assembler.toModel(salvo);

        // Gera URI do recurso criado
        URI uri = URI.create(model.getRequiredLink(IanaLinkRelations.SELF).getHref());
        return ResponseEntity.created(uri).body(model);
    }

    @PutMapping("/{id}")
    public ResponseEntity<EntityModel<Produto>> atualizar(
            @PathVariable Long id,
            @RequestBody Produto dados) {

        return repository.findById(id)
            .map(produtoExistente -> {
                produtoExistente.setNome(dados.getNome());
                produtoExistente.setPreco(dados.getPreco());
                Produto atualizado = repository.save(produtoExistente);
                return ResponseEntity.ok(assembler.toModel(atualizado));
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> remover(@PathVariable Long id) {
        return repository.findById(id)
            .map(produto -> {
                repository.delete(produto);
                return ResponseEntity.noContent().build();
            })
            .orElse(ResponseEntity.notFound().build());
    }
}

```

- **GET /produtos**
    - Retorna coleções de `EntityModel<Produto>`.
    - Exemplo de resposta JSON:
        
        ```json
        {
          "_embedded": {
            "produtoList": [
              {
                "id": 1,
                "nome": "Caneca",
                "preco": 25.0,
                "_links": {
                  "self": { "href": "http://localhost:8080/produtos/1" },
                  "todos-produtos": { "href": "http://localhost:8080/produtos" },
                  "remover": { "href": "http://localhost:8080/produtos/1" }
                }
              },
              {
                "id": 2,
                "nome": "Mouse",
                "preco": 80.0,
                "_links": {
                  "self": { "href": "http://localhost:8080/produtos/2" },
                  "todos-produtos": { "href": "http://localhost:8080/produtos" },
                  "remover": { "href": "http://localhost:8080/produtos/2" }
                }
              }
            ]
          },
          "_links": {
            "self": { "href": "http://localhost:8080/produtos" }
          }
        }
        
        ```
        
- **GET /produtos/{id}**
    - Retorna um único `EntityModel<Produto>`.
    - Exemplo de resposta JSON:
        
        ```json
        {
          "id": 1,
          "nome": "Caneca",
          "preco": 25.0,
          "_links": {
            "self": { "href": "http://localhost:8080/produtos/1" },
            "todos-produtos": { "href": "http://localhost:8080/produtos" },
            "remover": { "href": "http://localhost:8080/produtos/1" }
          }
        }
        
        ```
        
- **POST /produtos**
    - Corpo da requisição (JSON):
        
        ```json
        {
          "nome": "Teclado",
          "preco": 150.00
        }
        
        ```
        
    - Resposta HTTP 201 Created com cabeçalho `Location: http://localhost:8080/produtos/3` e corpo:
        
        ```json
        {
          "id": 3,
          "nome": "Teclado",
          "preco": 150.00,
          "_links": {
            "self": { "href": "http://localhost:8080/produtos/3" },
            "todos-produtos": { "href": "http://localhost:8080/produtos" },
            "remover": { "href": "http://localhost:8080/produtos/3" }
          }
        }
        
        ```
        

---

## Cenários de Restrição ou Não Aplicação

1. **APIs Internas Simples**
    - Se a API só servir um front-end bem definido (monolítico ou SPA), HATEOAS pode ser supérfluo. O front-end já conhece todas as URIs e não tem necessidade de descobrir links em tempo real.
2. **Dispositivos de Baixa Capacidade**
    - Em sistemas embarcados ou IoT, onde o JSON deve ser o menor possível, incluir `_links` pode tornar o payload impraticável.
3. **Performance Crítica / KB Limitados**
    - Em cenários de altíssima frequência de chamadas (alta performance), cada byte conta: o overhead de HATEOAS pode impactar a latência.
4. **Versionamento Altamente Rígido**
    - Se você tende a versionar a API via URI (ex.: `/v1/produtos`, `/v2/produtos`) e ocultar toda a evolução, a navegação dinâmica perde um pouco do sentido, porque o cliente pode depender de URIs fixas.

---

## Componentes Chave Associados

| Componente | Descrição |
| --- | --- |
| `spring-boot-starter-hateoas` | *Starter* que traz todas as dependências para usar HATEOAS no Spring Boot. |
| `Link` | Representa um link hipermídia. Contém `href`, `rel`, opcionalmente `type`, `title`, `hreflang`. |
| `RepresentationModel<T>` | Classe base para qualquer objeto que deseje agregar links. |
| `EntityModel<T>` | Invólucro para uma única entidade ou DTO. |
| `CollectionModel<T>` | Container para coleções de entidades/Modelos. |
| `PagedModel<T>` | Extensão de `CollectionModel` para paginação (contém `page`, `size` e links de navegação). |
| `RepresentationModelAssembler<T, D>` | Interface para converter entidade `T` → modelo HATEOAS `D`. |
| `RepresentationModelAssemblerSupport` | Classe base que já auxilia a implementar o conversor de forma mais concisa. |
| `WebMvcLinkBuilder` | Utilitário para gerar links baseados em controllers e métodos via `methodOn`. |
| `IanaLinkRelations` | Conveniência para gerar *rels* “padrão” (`self`, `next`, `prev`, etc.). |

---

## Melhores Práticas e Padrões de Uso

1. **Assembler Separado**
    - Centralize a lógica de criação de links em uma classe que implemente `RepresentationModelAssembler`. Evita duplicação em controllers.
2. **Nomes de *rels* Consistentes**
    - Adote padrões:
        - `"self"` para a URI do próprio recurso.
        - `"next"` / `"prev"` / `"first"` / `"last"` em contextos paginados.
        - Nomes de negócio: ex.: `"adicionar-ao-carrinho"`, `"atualizar-estoque"`.
    - Documente esses *rels* na documentação oficial da API ou em especificações OpenAPI (Swagger).
3. **Paginação**
    - Use `PagedResourcesAssembler<T>` ou retornar `PagedModel<EntityModel<T>>` para fornecer links automáticos de navegação (próxima página, página anterior).
    - Inclua metadados de paginação (totalElements, totalPages) para o cliente entender o contexto.
4. **Cuide do Tamanho dos JSONs**
    - Em endpoints que retornam coleções muito grandes, avalie se faz sentido incluir HATEOAS em todos os itens. Talvez paginar ou retornar apenas links sem detalhar todos os recursos.
5. **Versão da API**
    - Caso versões coexistam, garanta que cada versão tenha seus próprios assemblers e controllers, ou adapte a criação de links para refletir corretamente a versão (`/v1/...`, `/v2/...`).
6. **Mantenha Padrões de Nomeclatura**
    - Prefira nomes de métodos RESTful (ex.: `findAll`, `findById`, `save`, `delete`) que reflitam o comportamento e que facilitem a criação de links via `methodOn`.
7. **Documentação**
    - Integre com Spring REST Docs ou Swagger/OpenAPI para expor exemplos reais (incluindo `_links`) e facilitar testes e integração por terceiros.

---

## Exemplo Prático Completo

### 6.1 Cenário: API de “Produtos”

Imagine uma loja virtual que precisa expor **Produtos** via API RESTful. A partir desse módulo, queremos:

- Listar todos os produtos
- Buscar produto por ID
- Criar, atualizar e remover produtos
- Em cada resposta, incluir HATEOAS para orientar o cliente sobre próximas ações possíveis

A seguir, vamos construir passo a passo:

### 6.2 Entidade JPA e Repositório

```java
// Pacote: com.exemplo.produto.entity
@Entity
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private BigDecimal preco;

    public Produto() {}

    public Produto(String nome, BigDecimal preco) {
        this.nome = nome;
        this.preco = preco;
    }

    // getters e setters
}

```

```java
// Pacote: com.exemplo.produto.repository
import org.springframework.data.jpa.repository.JpaRepository;
import com.exemplo.produto.entity.Produto;

public interface ProdutoRepository extends JpaRepository<Produto, Long> {}

```

### 6.3 Assembler (Modelo HATEOAS)

```java
// Pacote: com.exemplo.produto.assembler
import com.exemplo.produto.controller.ProdutoController;
import com.exemplo.produto.entity.Produto;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.mvc.RepresentationModelAssemblerSupport;
import org.springframework.stereotype.Component;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@Component
public class ProdutoModelAssembler
        extends RepresentationModelAssemblerSupport<Produto, EntityModel<Produto>> {

    public ProdutoModelAssembler() {
        super(ProdutoController.class,
              (Class<EntityModel<Produto>>) (Class<?>) EntityModel.class);
    }

    @Override
    public EntityModel<Produto> toModel(Produto produto) {
        EntityModel<Produto> model = EntityModel.of(produto);

        // Link “self” para este produto
        model.add(linkTo(methodOn(ProdutoController.class)
                .buscarPorId(produto.getId()))
            .withSelfRel());

        // Link para listar todos os produtos
        model.add(linkTo(methodOn(ProdutoController.class)
                .listarTodos())
            .withRel("todos-produtos"));

        // Link para remoção
        model.add(linkTo(methodOn(ProdutoController.class)
                .remover(produto.getId()))
            .withRel("remover"));

        return model;
    }
}

```

### 6.4 Controller HATEOAS-Enabled

```java
// Pacote: com.exemplo.produto.controller
import com.exemplo.produto.assembler.ProdutoModelAssembler;
import com.exemplo.produto.entity.Produto;
import com.exemplo.produto.repository.ProdutoRepository;
import org.springframework.hateoas.*;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.List;
import java.util.stream.Collectors;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
@RequestMapping("/produtos")
public class ProdutoController {

    private final ProdutoRepository repository;
    private final ProdutoModelAssembler assembler;

    public ProdutoController(ProdutoRepository repository,
                             ProdutoModelAssembler assembler) {
        this.repository = repository;
        this.assembler = assembler;
    }

    @GetMapping
    public CollectionModel<EntityModel<Produto>> listarTodos() {
        List<EntityModel<Produto>> produtosModel = repository.findAll()
            .stream()
            .map(assembler::toModel)
            .collect(Collectors.toList());

        return CollectionModel.of(produtosModel,
            linkTo(methodOn(ProdutoController.class).listarTodos())
            .withSelfRel());
    }

    @GetMapping("/{id}")
    public ResponseEntity<EntityModel<Produto>> buscarPorId(@PathVariable Long id) {
        return repository.findById(id)
            .map(produto -> ResponseEntity.ok(assembler.toModel(produto)))
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<EntityModel<Produto>> criar(@RequestBody Produto produto) {
        Produto salvo = repository.save(produto);
        EntityModel<Produto> model = assembler.toModel(salvo);
        URI uri = URI.create(model.getRequiredLink(IanaLinkRelations.SELF).getHref());
        return ResponseEntity.created(uri).body(model);
    }

    @PutMapping("/{id}")
    public ResponseEntity<EntityModel<Produto>> atualizar(
            @PathVariable Long id,
            @RequestBody Produto dados) {
        return repository.findById(id)
            .map(produtoExistente -> {
                produtoExistente.setNome(dados.getNome());
                produtoExistente.setPreco(dados.getPreco());
                Produto atualizado = repository.save(produtoExistente);
                return ResponseEntity.ok(assembler.toModel(atualizado));
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> remover(@PathVariable Long id) {
        return repository.findById(id)
            .map(produto -> {
                repository.delete(produto);
                return ResponseEntity.noContent().build();
            })
            .orElse(ResponseEntity.notFound().build());
    }
}

```

---

### 6.5 Respostas JSON de Exemplo

1. **GET /produtos**
    
    ```json
    {
      "_embedded": {
        "produtoList": [
          {
            "id": 1,
            "nome": "Caneca",
            "preco": 25.0,
            "_links": {
              "self": {
                "href": "http://localhost:8080/produtos/1"
              },
              "todos-produtos": {
                "href": "http://localhost:8080/produtos"
              },
              "remover": {
                "href": "http://localhost:8080/produtos/1"
              }
            }
          },
          {
            "id": 2,
            "nome": "Mouse",
            "preco": 80.0,
            "_links": {
              "self": {
                "href": "http://localhost:8080/produtos/2"
              },
              "todos-produtos": {
                "href": "http://localhost:8080/produtos"
              },
              "remover": {
                "href": "http://localhost:8080/produtos/2"
              }
            }
          }
        ]
      },
      "_links": {
        "self": {
          "href": "http://localhost:8080/produtos"
        }
      }
    }
    
    ```
    
2. **GET /produtos/1**
    
    ```json
    {
      "id": 1,
      "nome": "Caneca",
      "preco": 25.0,
      "_links": {
        "self": {
          "href": "http://localhost:8080/produtos/1"
        },
        "todos-produtos": {
          "href": "http://localhost:8080/produtos"
        },
        "remover": {
          "href": "http://localhost:8080/produtos/1"
        }
      }
    }
    
    ```
    
3. **POST /produtos** (Requisição)
    
    ```json
    {
      "nome": "Teclado",
      "preco": 150.00
    }
    
    ```
    
    (Resposta HTTP 201 Created / Location: [http://localhost:8080/produtos/3](http://localhost:8080/produtos/3))
    
    ```json
    {
      "id": 3,
      "nome": "Teclado",
      "preco": 150.0,
      "_links": {
        "self": {
          "href": "http://localhost:8080/produtos/3"
        },
        "todos-produtos": {
          "href": "http://localhost:8080/produtos"
        },
        "remover": {
          "href": "http://localhost:8080/produtos/3"
        }
      }
    }
    
    ```
    

---

## Sugestões para Aprofundamento

1. **Comparar HATEOAS com GraphQL ou OData**
    - Entenda cenários onde um ou outro se encaixa melhor.
    - Avalie vantagens de hiperlinks (HATEOAS) vs. consulta flexível de campos (GraphQL).
2. **Impacto na Usabilidade e Autodescobrimento**
    - Estude como testes automatizados (Postman, Spring REST Docs) podem validar os links HATEOAS.
    - Verifique como clientes genéricos (HAL Browser, HAL Explorer) navegam automaticamente pelas rotas.
3. **Documentação com OpenAPI/Swagger**
    - Mostre exemplos HATEOAS em documentação Swagger.
    - Adicione exemplos de resposta que incluam `_links`.
4. **Performance e Monitoramento**
    - Utilize ferramentas de profiling para medir impacto do HATEOAS no payload.
    - Avalie estratégias de caching (ETags, Cache-Control) para minimizar custo de links dinâmicos.
5. **Aspectos de Segurança**
    - No caso de recursos protegidos, adicione links apenas se o usuário tiver permissão.
    - Exemplo: só exibir link “remover” se o usuário for admin (use `@PreAuthorize` ou lógica de negócio).

---

**Com isso, você tem uma visão completa dos fundamentos de HATEOAS no contexto de Spring Boot, desde a teoria até a aplicação prática com exemplos comentados e boas práticas.**