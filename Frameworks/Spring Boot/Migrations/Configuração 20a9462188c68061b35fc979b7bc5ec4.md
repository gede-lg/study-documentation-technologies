# Configuração

---

## Introdução

Flyway é uma ferramenta de versionamento e migração de banco de dados amplamente usada em projetos Java (e não só) para gerenciar alterações no esquema de forma controlada e reprodutível. Integrado ao Spring Boot, o Flyway permite aplicar scripts de migração automaticamente durante a inicialização da aplicação, garantindo que todos os ambientes (desenvolvimento, teste, homologação e produção) mantenham o esquema de dados em sincronia com o código.

Nesta explicação, abordaremos desde conceitos fundamentais até a configuração detalhada e um exemplo prático completo, mostrando como estruturar, organizar e executar migrações com Flyway em um projeto Spring Boot.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    
    2.1. Dependências no Maven/Gradle
    
    2.2. Estrutura de diretórios e nomenclatura de scripts
    
    2.3. Configuração em application.properties/application.yml
    
    2.4. Mecanismo de execução automática pelo Spring Boot
    
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#componentes-chave-associados)
    
    4.1. FlywayAutoConfiguration
    
    4.2. Propriedades de configuração (FlywayProperties)
    
    4.3. Classes e Interfaces principais (org.flywaydb.core.Flyway, MigrationResolver, Callback, etc.)
    
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
6. [Exemplo Prático Completo](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#exemplo-pr%C3%A1tico-completo)
    
    6.1. Pré-requisitos
    
    6.2. Estrutura de projeto
    
    6.3. application.properties de configuração
    
    6.4. Scripts de migração (SQL)
    
    6.5. Código Java para demonstração mínima (Domain + Repository)
    
    6.6. Execução e verificação
    
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sugest%C3%B5es-para-aprofundamento)

---

## Conceitos Fundamentais

- **Migração de Banco de Dados**
    - Refere-se ao processo de evoluir o esquema de banco de dados (tabelas, colunas, índices, procedimentos) ao longo do tempo, de forma controlada, versionada e auditável.
    - Evita discrepâncias entre versões de schema em diferentes ambientes (dev, teste, prod).
    - Substitui scripts pontuais desconectados, garantindo rastreabilidade das alterações.
- **Flyway**
    - Ferramenta de código aberto para gestão de migrações de banco de dados, criada pela Redgate.
    - Baseia-se em aplicar, em ordem crescente, arquivos de script (SQL ou Java) para evoluir o schema.
    - Mantém uma tabela interna (`flyway_schema_history` por padrão) que registra quais migrações já foram executadas, suas versões e datasets.
- **Integração com Spring Boot**
    - O Spring Boot detecta automaticamente a dependência do Flyway no classpath e executa migrações no momento de startup, antes de disponibilizar `DataSource`.
    - A configuração se dá via propriedades (`spring.flyway.*`) em `application.properties` ou `application.yml`.
    - Possibilita rodar migrações automáticas sem código adicional, bastando incluir os scripts na pasta correta.
- **Estratégia de Versionamento**
    - Cada script de migração possui um prefixo de versão (ex.: `V1__create_table.sql`, `V2__add_column.sql`).
    - O Flyway lê a versão do arquivo, compara com o histórico e, se ainda não aplicado, executa em ordem crescente.
    - Evita conflitos de múltiplos desenvolvedores, pois o esquema de versionamento é linear e incremental.

---

## Sintaxe Detalhada e Uso Prático

### 1. Dependências no Maven/Gradle

Para usar Flyway em um projeto Spring Boot, basta adicionar a dependência no gerenciador de builds:

**Maven** (`pom.xml`):

```xml
<dependencies>
    <!-- Dependência do Starter Flyway para Spring Boot -->
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
        <!-- Versão do Flyway (exemplo: 9.8.0). O Spring Boot pode gerenciar automaticamente a versão se for Starter. -->
        <version>9.8.0</version>
    </dependency>

    <!-- Driver JDBC do seu banco (exemplo: PostgreSQL) -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.6.0</version>
    </dependency>

    <!-- Dependência do Spring Boot Starter Data JPA (caso use JPA) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
</dependencies>

```

**Gradle** (`build.gradle`):

```groovy
dependencies {
    // Flyway Core
    implementation 'org.flywaydb:flyway-core:9.8.0'

    // Driver JDBC
    implementation 'org.postgresql:postgresql:42.6.0'

    // Spring Data JPA (se necessário)
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}

```

> Observação:
> 
> - Se estiver usando o `spring-boot-starter-jdbc` ou `spring-boot-starter-data-jpa`, o Spring Boot autoconfigura o `DataSource`.
> - Se usar o `spring-boot-starter-parent`, a versão do Flyway pode ser gerenciada pelo próprio BOM do Spring Boot, então pode omitir o `<version>`.

---

### 2. Estrutura de Diretórios e Nomenclatura de Scripts

Por convenção, o Flyway procura migrações SQL na pasta `classpath:db/migration`. Portanto, a estrutura de pastas no `src/main/resources` deve ser:

```
src
└─ main
   └─ resources
      └─ db
         └─ migration
             ├─ V1__create_table_usuario.sql
             ├─ V2__add_email_to_usuario.sql
             └─ V3__create_table_produto.sql

```

- **Prefixo de versão (`V`)**
    - Indica que é uma migração versionada.
    - Caso use `R` como prefixo, é para `Repeatable Migrations` (migrações repetíveis, reexecutadas quando o checksum mudar).
- **Formato do nome**
    
    ```
    V<versão>__<descrição>.sql
    
    ```
    
    - `<versão>`: números inteiros ou ponto para versões (ex.: `1`, `1.1`, `2.5`).
    - Dois underscores (`__`) separam a parte de versão da descrição.
    - `<descrição>`: texto legível descrevendo a mudança (ex.: `create_table_usuario`).
    - Extensão obrigatória: `.sql` (para migrações SQL nativas). Também é possível usar Java migrations, mas foge ao escopo “SQL puro”.
- **Ordem de execução**
    - O Flyway ordena as migrações por versão, em ordem crescente.
    - Se existirem migrações repetáveis (`R__descrição.sql`), elas serão executadas sempre que detectarem mudanças no arquivo (checksum diferente).

---

### 3. Configuração em application.properties / application.yml

Para que o Spring Boot detecte e execute o Flyway, configure as propriedades apropriadas. A forma mais comum é em `application.properties`:

```
# Configuração do DataSource
spring.datasource.url=jdbc:postgresql://localhost:5432/meubanco
spring.datasource.username=usuario_db
spring.datasource.password=senha_db
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do Flyway
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration     # Pasta padrão, pode omitir se usar esta estrutura
spring.flyway.baseline-on-migrate=true            # Caso já exista esquema e queira 'baseline' para evitar migrar do zero
spring.flyway.baseline-version=1                  # Versão inicial do baseline, se necessário
spring.flyway.table=flyway_schema_history         # Nome da tabela de histórico (padrão: flyway_schema_history)
spring.flyway.placeholder-replacement=true         # Habilita placeholders em SQL (se usar ${} nos scripts)
spring.flyway.placeholders.usuario=${spring.datasource.username}  # Exemplo de placeholder
# spring.flyway.schemas=public                     # Esquemas a serem gerenciados (em DBs que suportem schemas)

```

Em `application.yml`, seria equivalente:

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/meubanco
    username: usuario_db
    password: senha_db
    driver-class-name: org.postgresql.Driver

  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true
    baseline-version: 1
    table: flyway_schema_history
    placeholder-replacement: true
    placeholders:
      usuario: ${spring.datasource.username}
    # schemas: public

```

> Detalhes Importantes:
> 
> 1. `spring.flyway.enabled`: ativa ou desativa as migrações automáticas no momento do startup.
> 2. `spring.flyway.locations`: local onde Flyway buscará os scripts. Se não configurado, o padrão é `classpath:db/migration`.
> 3. `spring.flyway.baseline-on-migrate`: útil quando já há tabelas existentes (legado) e é preciso alinhar o Flyway ao estado atual sem reaplicar desde o início.
> 4. `spring.flyway.baseline-version`: versão atribuído ao estado atual do banco para marcar que migrações anteriores a essa versão não devem ser executadas.
> 5. `spring.flyway.table`: nome da tabela de meta-informação (por padrão, `flyway_schema_history`).
> 6. Placeholders: se você quiser usar variáveis nos scripts SQL, pode configurá-los e referenciá-los como `${usuario}` dentro dos arquivos `.sql`.

---

### 4. Mecanismo de Execução Automática pelo Spring Boot

- Ao inicializar a aplicação, o Spring Boot detecta a dependência do Flyway na classpath (por `flyway-core`).
- No contexto de `DataSource` configurado, o Spring Boot injeta um bean `FlywayAutoConfiguration` que:
    - Cria um objeto `Flyway` programaticamente (se não houver outro bean `Flyway`).
    - Configura propriedades a partir de `spring.flyway.*`.
    - Executa o método `flyway.migrate()` automaticamente antes de disponibilizar o `DataSource`.

Fluxo simplificado na inicialização:

1. Carregar propriedades de `application.properties` ou `application.yml`.
2. Configurar e instanciar `DataSource`.
3. Criar bean `Flyway` (via `FlywayAutoConfiguration`).
4. Invocar `flyway.migrate()`:
    - Verifica a tabela `flyway_schema_history`.
    - Compara as versões existentes nos arquivos `V*.sql`.
    - Executa, em sequência, as migrações cujas versões ainda não constem no histórico.
5. Depois de concluídas as migrações, o `DataSource` está pronto para uso pelas camadas de repositório ou JPA.

---

## Cenários de Restrição ou Não Aplicação

Existem situações em que usar Flyway pode não ser a melhor escolha ou exigir cuidado extra:

1. **Pequenos Projetos Simples**
    - Se o banco nunca mudará de esquema ou o time for minúsculo (um único desenvolvedor), gerenciar manualmente scripts pode parecer menos burocrático.
    - Entretanto, mesmo nesses casos, manter versionamento traz segurança e rastreabilidade.
2. **Migrações Baseadas em ORM (Esquema Gerado Automaticamente)**
    - Projetos que confiam exclusivamente no recurso `hibernate.hbm2ddl.auto` (p.ex.: `update` ou `create-drop`) podem não usar Flyway, pois o ORM cria/atualiza tabelas automaticamente.
    - **Limitação:** essa abordagem não gera scripts versionados, pode levar a inconsistências entre ambientes ou perda de dados em cenários complexos.
3. **Ambientes com Políticas de Acesso Restritas**
    - Em algumas empresas, o DBA não permite execuções automáticas de scripts via aplicação. Nesse caso, é preciso extrair os SQLs gerados pelo Flyway e obter aprovação manual antes de rodar.
    - Flyway possui modo “dry run” (gerar scripts sem executar) para atender a essa demanda.
4. **Banco de Dados Não Suportado pelo Flyway**
    - Flyway suporta a maioria dos bancos relacionais populares (PostgreSQL, MySQL, SQL Server, Oracle, etc.), mas se você usar um banco exótico ou não suportado, não conseguirá usar Flyway diretamente.
    - Alternativas: Liquibase (mais genérico em alguns casos) ou soluções próprias de migração.
5. **Estruturas de Multi-Tenant ou Arquiteturas Complexas de Sharding**
    - Quando há múltiplos schemas por cliente/tenant, a configuração de `schemas` do Flyway precisa ser adaptada para cada contexto de tenant.
    - É possível criar múltiplas instâncias de `Flyway` programaticamente, mas a configuração demanda mais cuidado.
6. **Operações destrutivas em Produção**
    - Scripts que incluem `DROP TABLE`, `DELETE` em massa ou alterações arriscadas devem ser revisados com cautela.
    - Em produção, muitas vezes há processos de aprovação (DBA), então a migração automática pode não ser desejada sem controle manual.

---

## Componentes Chave Associados

### 1. FlywayAutoConfiguration

- Classe do Spring Boot responsável por criar e configurar automaticamente o bean `Flyway`.
- Localizada em `org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration`.
- Baseia-se em `FlywayProperties` (que mapeia `spring.flyway.*`) e no `DataSource`.
- Ao detectar a presença de `flyway-core` e um `DataSource` configurado, registra um `FlywayMigrationInitializer` que, por sua vez, chama `flyway.migrate()`.

### 2. FlywayProperties

- Classe que mapeia as propriedades de configuração `spring.flyway.*`.
- Contém atributos como:
    - `enabled`: habilita migração automática.
    - `locations`: lista de locais de busca dos scripts (ex.: `classpath:db/migration`).
    - `baselineOnMigrate`, `baselineVersion`, `table`, `schemas`, `placeholders`, entre outros.
- Permite override de valores usando YAML ou `application.properties`.

### 3. Principais Classes e Interfaces do Flyway

- `org.flywaydb.core.Flyway`
    - Principal classe para configurar e executar migrações programaticamente (caso necessário).
    - Métodos fundamentais:
        - `migrate()`: executa todas as migrações necessárias.
        - `clean()`: remove todas as tabelas do schema (útil em testes, mas perigoso em produção).
        - `info()`: retorna o estado atual das migrações (já aplicadas, pendentes).
        - `validate()`: valida que as migrações aplicadas correspondem às do classpath (checando checksums).
- `MigrationResolver` e `MigrationExecutor`
    - Interfaces internas que resolvem e executam migrações. Normalmente não exigidas para uso cotidiano.
- `Callback`
    - Permite interceptar eventos do Flyway (ex.: antes de migrar, depois de migrar) para executar lógica customizada (logs, verificações, scripts adicionais).
    - Pode ser usado criando uma classe que implementa `org.flywaydb.core.api.callback.Callback` e registrando-a.
- `JavaMigration`
    - Interface para criar migrações em Java em vez de SQL. Pode ser útil para lógica que não se encaixa bem em SQL puro (ex.: transformações complexas).
    - Os arquivos de migração Java devem implementar `JavaMigration` e ficar em um pacote específico (configure `flyway.locations` para apontar para essa pasta).

---

## Melhores Práticas e Padrões de Uso

1. **Manter Scripts Pequenos e Atômicos**
    - Cada migração deve fazer apenas uma mudança clara (ex.: criar tabela, adicionar coluna, criar índice).
    - Evite combinar várias alterações em um único arquivo, facilitando rollback conceitual e revisão de histórico.
2. **Nomenclatura Descritiva**
    - Use descrições claras após a versão:
        
        ```
        V1__create_table_usuario.sql
        V2__add_email_to_usuario.sql
        V3__create_index_on_produto_nome.sql
        
        ```
        
    - Facilita entendimento do propósito de cada migração.
3. **Ricochetear Alterações de Tabela em Produção**
    - Evite alterar colunas que contenham dados críticos sem planejamento de downtime ou estratégia de migração zero-downtime.
    - Por exemplo, para mudar tipo de dado, pode ser necessário criar coluna temporária, migrar dados em batch e depois trocar nomes.
4. **Utilize Placeholders com Cuidado**
    - Se usar placeholders (`${}`) em scripts, documente bem quais valores são inseridos em cada ambiente (dev, teste, prod).
    - Exemplo:
        
        ```sql
        CREATE USER ${novo_usuario} WITH PASSWORD '${senha_usuario}';
        
        ```
        
    - Configure em `application.properties` ou por variáveis de ambiente.
5. **Versionamento Consistente entre Branches**
    - Em equipes com múltiplas branches de desenvolvimento, resolver conflitos de versão antecipadamente (ex.: se dois devs criarem `V4__algo.sql` e `V4__algo_outro.sql`, um precisará renomear).
    - Combine políticas de revisão de PR que revisem e ajustem números de versão caso necessário.
6. **Baseline em Sistemas Legados**
    - Caso o banco já existia antes de iniciar o Flyway, use `baselineOnMigrate = true` e defina `baselineVersion` (ex.: `1`).
    - Isso marca o estado atual do banco como a versão inicial, evitando reexecução de scripts históricos.
7. **Evite Script de `clean()` em Produção**
    - O Flyway permite executar `flyway.clean()` (que apaga tabelas). Deve ser usado apenas em ambientes de teste ou preparo inicial.
    - Nunca habilite `flyway.clean-on-validation-error` em produção sem saber exatamente o impacto.
8. **Teste Localmente Antes de Subir para CI/CD**
    - Configure pipelines de CI que executem `flyway.validate()` para garantir que não existem migrações faltando ou divergindo do histórico.
    - Em testes de integração, inicialize um banco temporário (ex.: Docker) e deixe o Flyway executar para validar a sequência completa.
9. **Documente Dependências Entre Migrações**
    - Se uma migração depende de outras tabelas ou dados (por exemplo, criação de FK que referencia outra tabela), garanta que a versão antecedente crie a estrutura necessária.
    - Inclua comentários no script SQL para indicar pré-requisitos.
10. **Use `Repeatable Migrations` para Objetos Dependentes de Estado**
    - Scripts prefixados com `R__descrição.sql` são reexecutados se seu checksum mudar.
    - Útil para criar ou atualizar objetos não versionados (ex.: views, funções PL/pgSQL) que requerem redeploy sempre que alterados.

---

## Exemplo Prático Completo

### 1. Pré-requisitos

- Java 17+ (ou 11+).
- Spring Boot 2.7.x ou 3.x.
- Banco de Dados PostgreSQL rodando localmente em `localhost:5432`.
- IDE de sua preferência.
- Maven (ou Gradle).

### 2. Estrutura de Projeto

```
meu-projeto-flyway
├─ src
│  ├─ main
│  │  ├─ java
│  │  │  └─ com
│  │  │     └─ exemplo
│  │  │        └─ migracao
│  │  │           ├─ MeuProjetoFlywayApplication.java
│  │  │           ├─ domain
│  │  │           │  └─ Usuario.java
│  │  │           └─ repository
│  │  │              └─ UsuarioRepository.java
│  │  └─ resources
│  │     ├─ application.properties
│  │     └─ db
│  │        └─ migration
│  │           ├─ V1__create_table_usuario.sql
│  │           └─ V2__add_email_to_usuario.sql
│  └─ test
│     └─ java
│        └─ com
│           └─ exemplo
│              └─ migracao
│                 └─ UsuarioRepositoryTests.java
└─ pom.xml

```

### 3. application.properties de Configuração

```
# ----- DataSource -----
spring.datasource.url=jdbc:postgresql://localhost:5432/migraflywaydb
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver

# ----- Hibernate (opcional, se usar JPA) -----
spring.jpa.hibernate.ddl-auto=none     # NÃO permitir que o Hibernate gere/atualize o esquema automaticamente
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ----- Flyway -----
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
spring.flyway.table=flyway_schema_history

# ----- Logs -----
logging.level.org.flywaydb=INFO

```

> Explicação:
> 
> - `spring.jpa.hibernate.ddl-auto=none`: desativa qualquer criação automática pelo Hibernate. A migração será feita exclusivamente pelo Flyway.
> - `baseline-on-migrate=true` e `baseline-version=1`: caso o banco já existisse, marcaríamos como versão 1, mas num projeto novo isso não será usado na primeira vez, pois não há tabela de histórico.

---

### 4. Scripts de Migração (SQL)

### V1__create_table_usuario.sql

```sql
-- Migração V1: Criação da tabela 'usuario'
CREATE TABLE usuario (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    data_criacao TIMESTAMP NOT NULL DEFAULT NOW()
);

```

### V2__add_email_to_usuario.sql

```sql
-- Migração V2: Adiciona coluna 'email' à tabela 'usuario'
ALTER TABLE usuario
ADD COLUMN email VARCHAR(150);

-- Preenchimento opcional de email para registros existentes (se necessário)
-- UPDATE usuario SET email = CONCAT(LOWER(nome), '@exemplo.com') WHERE email IS NULL;

```

> Observações:
> 
> - Após copiar esses arquivos para `src/main/resources/db/migration`, ao iniciar a aplicação, o Flyway criará a tabela `flyway_schema_history` e executará V1 e em seguida V2.
> - O comentário inicial (`- Migração V*`) não é obrigatório, mas ajuda no entendimento.

---

### 5. Código Java Básico para Demonstração

### MeuProjetoFlywayApplication.java

```java
package com.exemplo.migracao;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MeuProjetoFlywayApplication {
    public static void main(String[] args) {
        SpringApplication.run(MeuProjetoFlywayApplication.class, args);
    }
}

```

### Domain: Usuario.java

```java
package com.exemplo.migracao.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.LocalDateTime;

@Entity
@Table(name = "usuario")
public class Usuario {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;

    private String email;        // criado pela migração V2

    private LocalDateTime dataCriacao;

    // Construtores
    public Usuario() { }

    public Usuario(String nome, String email) {
        this.nome = nome;
        this.email = email;
        this.dataCriacao = LocalDateTime.now();
    }

    // Getters e Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public LocalDateTime getDataCriacao() { return dataCriacao; }
    public void setDataCriacao(LocalDateTime dataCriacao) { this.dataCriacao = dataCriacao; }
}

```

### Repository: UsuarioRepository.java

```java
package com.exemplo.migracao.repository;

import com.exemplo.migracao.domain.Usuario;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UsuarioRepository extends JpaRepository<Usuario, Long> {
    // métodos CRUD padrões herdados de JpaRepository
}

```

---

### 6. Execução e Verificação

1. **Criar o Banco**
    - Assegure-se de que o banco `migraflywaydb` existe no PostgreSQL:
        
        ```bash
        psql -U postgres -c "CREATE DATABASE migraflywaydb;"
        
        ```
        
2. **Build e Run da Aplicação**
    - No terminal, execute:
        
        ```bash
        mvn clean spring-boot:run
        
        ```
        
    - Ou, se usar Gradle:
        
        ```bash
        ./gradlew bootRun
        
        ```
        
3. **Verificar Logs do Flyway**
    - No console, deve aparecer algo como:
        
        ```
        ...
        INFO  ... org.flywaydb.core.internal.command.DbMigrationAspect - Migrating schema "public" to version "1"
        INFO  ... org.flywaydb.core.internal.command.DbMigration - Successfully applied migration V1__create_table_usuario.sql
        INFO  ... org.flywaydb.core.internal.command.DbMigrationAspect - Migrating schema "public" to version "2"
        INFO  ... org.flywaydb.core.internal.command.DbMigration - Successfully applied migration V2__add_email_to_usuario.sql
        
        ```
        
4. **Inspecionar o Banco**
    - Conecte-se ao PostgreSQL e cheque as tabelas:
        
        ```sql
        \dt
        
        ```
        
        Deve listar `usuario` e `flyway_schema_history`.
        
    - Verifique o conteúdo de `flyway_schema_history`:
        
        ```sql
        SELECT version, description, installed_on, success FROM flyway_schema_history ORDER BY version;
        
        ```
        
        Resultado esperado:
        
        ```
         version |     description          |       installed_on         | success
        ---------+---------------------------+----------------------------+---------
         1       | create_table_usuario      | 2025-06-05 21:XX:XX+00     | t
         2       | add_email_to_usuario      | 2025-06-05 21:XX:XX+00     | t
        
        ```
        

---

## Sugestões para Aprofundamento

- **Documentação Oficial do Flyway**
    - [https://flywaydb.org/documentation/](https://flywaydb.org/documentation/)
    - Explica em detalhes tópicos avançados como callbacks, Java migrations, integração com CI/CD, etc.
- **Guias do Spring Boot sobre Flyway**
    - [https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-execute-flyway-database-migrations-on-startup](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-execute-flyway-database-migrations-on-startup)
    - Traz exemplos e melhores práticas do Spring Boot.
- **Flyway vs Liquibase**
    - Pesquisar comparativos para entender quando usar Flyway ou Liquibase, especialmente em cenários empresariais com DBAs rigorosos.
- **Integração com Docker**
    - Criar um container com banco de dados e deixar Flyway aplicar migrações via rede.
    - Uso de `flyway.docker-image` para automação de implantação.
- **Migrations Java**
    - Em cenários onde parte da lógica de migração requer manipulação no código, crie classes que implementem `org.flywaydb.core.api.migration.JavaMigration`.
- **Testes de Migração**
    - Escrever testes de integração (por exemplo, com Testcontainers) que inicializem um banco temporário e apliquem todas as migrações, validando o estado final do esquema.

---

> Resumo Final:
> 
> 
> Este guia apresentou desde os conceitos básicos de migração de banco de dados com Flyway até a configuração detalhada no contexto de um projeto Spring Boot. Foram exibidas boas práticas, cenários de restrição e um exemplo prático completo, permitindo que você estruture seu projeto para evoluir o schema de forma segura e rastreável.
>