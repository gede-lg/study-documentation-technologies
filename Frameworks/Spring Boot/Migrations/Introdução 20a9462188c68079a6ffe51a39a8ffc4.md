# Introdução

---

## 1. Introdução

Database Migration é o processo de manter o esquema (estrutura) do banco de dados versionado e sincronizado entre diferentes ambientes (desenvolvimento, testes e produção). Em aplicações Spring Boot com Java, isso garante que alterações no esquema sejam aplicadas de forma automática e consistente, evitando divergências entre máquinas da equipe ou ambientes de deploy.

---

## 2. Sumário

1. Conceitos Fundamentais
2. Por que é Crucial
3. Ferramentas Comuns em Spring Boot
4. Cenários de Restrição ou Não Aplicação
5. Componentes-Chave Associados
6. Melhores Práticas e Padrões de Uso
7. Exemplo Prático Simplificado
8. Sugestões para Aprofundamento

---

## 3. Conceitos Fundamentais

- **Versionamento de Banco de Dados:**
    - Assim como o código-fonte, o esquema do banco de dados também evolui ao longo do tempo (novas tabelas, colunas, índices, etc.).
    - Cada alteração é representada por um “script de migration” associado a uma versão ou timestamp.
- **Objetivo Principal:**
    - Garantir que todas as instâncias do banco estejam na mesma versão de esquema.
    - Facilitar rollbacks e auditoria de mudanças feitas no banco.
- **Problemas que Resolve:**
    - Evitar o clássico “Funciona na minha máquina, mas quebra em produção”.
    - Rastrear quem, quando e por que uma determinada mudança no esquema foi aplicada.
    - Automatizar a execução em pipelines de CI/CD, eliminando ajustes manuais.

---

## 4. Por que é Crucial

1. **Consistência Entre Ambientes**
    - Desenvolvedores e servidores de produção funcionam sempre com o mesmo modelo de dados.
2. **Automação e Segurança**
    - Alterações são executadas no momento certo, sem intervenção manual, reduzindo erros humanos.
3. **Histórico de Mudanças**
    - Cada script de migration fica registrado, permitindo auditoria e, se necessário, rollback para versões anteriores.
4. **Integração com CI/CD**
    - Em pipelines de build e deploy, o mecanismo de migration aplica novos scripts antes de iniciar a aplicação, garantindo que o banco esteja pronto.

---

## 5. Ferramentas Comuns em Spring Boot

- **Flyway**
    - Abordagem baseada em arquivos SQL ou Java que seguem um padrão de nomenclatura (ex.: V1__create_table.sql, V2__add_column.sql).
    - O Spring Boot detecta e executa automaticamente as versões novas ao iniciar a aplicação.
- **Liquibase**
    - Trabalha com arquivos em XML, YAML, JSON ou SQL chamados “change sets”.
    - Oferece controle granular (tags, contextos, rollbacks mais sofisticados) e integração nativa com Spring Boot.
- **Funcionamento Genérico (ambos):**
    1. Detectam, na pasta de migrations, quais scripts ainda não foram aplicados.
    2. Registram em tabela interna (metadata) a versão aplicada, evitando repetições.
    3. Executam, em sequência, apenas as versões que faltam.

---

## 6. Cenários de Restrição ou Não Aplicação

- **Aplicações Pouco Dinâmicas ou Monolíticas Simples**
    - Projetos muito pequenos, com equipe de apenas uma pessoa, que não sofrem alterações frequentes no esquema, podem optar por scripts manuais.
- **Banco de Dados Somente de Leitura ou Exclusivamente Analítico**
    - Se o esquema nunca muda (por exemplo, Data Warehouses estáticos), não há necessidade de migration.
- **Ambientes Legados com Políticas de Alteração Rigorosas**
    - Organizações que exigem processos manuais de homologação de scripts de DDL podem não adotar migrations automáticos diretamente; ainda assim, vale a pena manter os scripts organizados.

---

## 7. Componentes-Chave Associados

1. **Tabelas de Controle (Metadata Table)**
    - Flyway e Liquibase mantêm uma tabela interna (como `flyway_schema_history` ou `databasechangelog`) para registrar cada migration aplicado:
        - Versão (por exemplo, “1.2.0” ou “20250605.1”)
        - Descrição (breve texto sobre a mudança)
        - Data e hora da aplicação
        - Status (executado com sucesso ou falha)
2. **Scripts de Migration**
    - **Flyway:** normalmente nomeados com prefixo `V` seguido de número sequencial ou timestamp.
    - **Liquibase:** “changeLog” principal que referencia vários “changeSet” com identificadores únicos.
3. **Configurações em `application.properties` (ou `application.yml`)**
    - Indicar localização das migrations (ex.: `classpath:db/migration`)
    - Parâmetros de credenciais do banco (URL, usuário, senha)
    - Propriedades específicas, como falhar a inicialização se houver pending migrations (ex.: `spring.flyway.fail-on-missing-locations=true`)
4. **API do Spring Boot Starter**
    - Ao incluir a dependência `spring-boot-starter-data-jdbc` ou `spring-boot-starter-data-jpa`, juntamente com `flyway-core` ou `liquibase-core`, a aplicação executa migrations automaticamente quando é inicializada.

---

## 8. Melhores Práticas e Padrões de Uso

1. **Escrita de Scripts Pequenos e Focados**
    - Cada migration deve tratar apenas de uma única mudança de esquema (ex.: criar tabela, alterar tipo de coluna).
    - Facilita auditoria e rollback, se necessário.
2. **Padronizar Convenções de Nome**
    - Adotar um padrão para prefixos de versão (ex.: `V2025_06_05__criar_tabela_usuarios.sql`).
    - Em Liquibase, usar `id` significativo para cada `changeSet` (ex.: `id="20250605-create-users-table"`).
3. **Separar Dados de Referência de Dados Transacionais**
    - Scripts que inserem “dados fixos” (como tabelas de lookup) podem residir em pastas distintas (por ex.: `data/seed`).
    - Permitir reuso em ambientes de teste.
4. **Testar Migrations em Ambiente de QA Antes de Produção**
    - Em pipelines de CI, provisionar um banco limpo, aplicar todas as migrations e rodar testes de integração.
    - Detectar falhas de scripts antes de atingir o cliente final.
5. **Evitar Mudanças Irreversíveis em Produção**
    - Renomear ou remover colunas só após garantir que todas as referências (código, relatórios) foram ajustadas.
    - Se for inevitável, criar coluna nova, migrar dados gradualmente e, somente depois, dropar a antiga.
6. **Manter Backup ou Snapshots Antes de Grandes Alterações**
    - Embora as ferramentas auxiliem, manter sempre um plano de contingência (dump de esquema/dados).

---

## 9. Exemplo Prático Simplificado (Visão Geral)

> Este exemplo mostra apenas o fluxo geral, sem detalhes de sintaxe de código.
> 
1. **Criação de uma Migration Inicial**
    - Definir script de criação de esquema básico (tabela de usuários, roles, etc.).
    - Nomear como `V1__create_base_schema.sql`.
2. **Adição de Nova Coluna em Tabela Existente**
    - Criar um segundo script `V2__add_phone_column_to_users.sql`.
    - Este arquivo descreve “ALTER TABLE users ADD COLUMN phone VARCHAR(20)”.
3. **Configuração no Spring Boot**
    - Certificar que existem dependências de Flyway (ou Liquibase) no `pom.xml` (ou `build.gradle`).
    - Ajustar no `application.properties`:
        - Localização dos scripts (`spring.flyway.locations=classpath:db/migration`)
        - Credenciais do banco de dados.
4. **Execução Automática**
    - Ao iniciar a aplicação, o Spring Boot detecta que as versões 1 e 2 ainda não foram aplicadas.
    - Flyway cria a tabela de controle e executa, em ordem, `V1` e `V2`.
    - Se tudo correr bem, a aplicação segue carregando normalmente.
    - Caso haja algum erro (ex.: coluna já existe), a inicialização falha, exibindo mensagem clara sobre qual migration falhou.
5. **Deploy em Ambientes Diferentes**
    - Em cada ambiente (dev, staging, prod), basta iniciar a aplicação.
    - Qualquer migration pendente será aplicado de forma idempotente.

---

## 10. Cenários de Restrição ou Não Aplicação

- Projetos extremamente simples, sem equipe, que nunca mudam o esquema, podem dispensar migrations (basta script SQL manual antes do deploy).
- Bancos de dados somente leitura, usados para data analytics estáticos, não requerem versionamento dinâmico.
- Organizações que ainda seguem processos manuais de homologação podem adotar migrations apenas como “source of truth” dos scripts, mas executar manualmente em portais de DBA.

---

## 11. Sugestões para Aprofundamento

- **Comparar Flyway vs. Liquibase:**
    - Analisar documentação oficial de cada um para entender trade-offs de features (rollback, contexts, changeSets).
- **Automação de Pipelines CI/CD:**
    - Incorporar testes de migration no GitLab CI, Jenkins ou GitHub Actions, garantindo que nenhum script quebre o build.
- **Estratégias de Branching e Migrations em Equipe:**
    - Planejar como lidar com migrations simultâneas em diferentes branches (evitar conflitos de versão).
- **Refinamento de Rollback:**
    - Muitos projetos não utilizam rollback automático; estudar como implementar rollbacks seguros em Liquibase.
- **Performance e Volume de Dados:**
    - Em bancos muito grandes, mudanças de coluna podem bloquear tabelas. Avaliar ferramentas complementares (pt-online-schema-change, etc.) para migrações “online”.

---

**Conclusão:**

Database Migration em Spring Boot com Java, via Flyway ou Liquibase, é um pilar para manter a consistência e a rastreabilidade das mudanças de esquema em qualquer projeto. Mesmo em projetos pequenos, adotar uma estratégia de versionamento de banco ajuda a evitar surpresas desagradáveis no processo de deploy e a manter a equipe alinhada.