# Introdução

---

## Introdução

O **Content Negotiation** é o processo pelo qual um servidor e um cliente negociam o formato de representação de dados trocados em uma requisição HTTP. No contexto do Spring Boot (Java), isso significa que a aplicação pode responder em diferentes formatos (por exemplo, JSON, XML, YAML etc.) conforme especificado pelo cliente, geralmente através dos cabeçalhos HTTP `Accept` e `Content-Type`.

Este recurso é importante pois:

- Facilita a interoperabilidade entre sistemas heterogêneos (clientes que esperam JSON, outros que preferem XML).
- Permite versões alternativas de uma mesma API sem duplicação de código.
- Torna o design de RESTful APIs mais flexível e aderente aos padrões HTTP.

---

## Sumário

1. [Conceitos Fundamentais](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#conceitos-fundamentais)
2. [Sintaxe Detalhada e Uso Prático](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sintaxe-detalhada-e-uso-pr%C3%A1tico)
    1. Configuração Padrão de Message Converters
    2. Uso de Anotações (`@RequestMapping`, `@GetMapping` com `produces` e `consumes`)
    3. Configuração Customizada (registrando conversores adicionais)
3. [Cenários de Restrição ou Não Aplicação](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#cen%C3%A1rios-de-restri%C3%A7%C3%A3o-ou-n%C3%A3o-aplica%C3%A7%C3%A3o)
4. [Componentes Chave Associados](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#componentes-chave-associados)
    1. `HttpMessageConverter` e Implementações Padrão
    2. Anotações de Mapeamento (`@RequestMapping`, `@GetMapping`, `@PostMapping`)
    3. Propriedades de Configuração no `application.properties` / `application.yml`
5. [Melhores Práticas e Padrões de Uso](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#melhores-pr%C3%A1ticas-e-padr%C3%B5es-de-uso)
    1. Versionamento de API via Header
    2. Formatos Alternativos (JSON, XML, YAML)
    3. Priorização de Converters
6. [Exemplo Prático Completo](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#exemplo-pr%C3%A1tico-completo)
    1. Projeto Simplificado
    2. Código de Controller com Endpoints JSON e XML
    3. Testes de Cliente (curl / Postman)
7. [Sugestões para Aprofundamento](https://chatgpt.com/c/6840f1f3-77c8-8013-a875-660be37d61b4#sugest%C3%B5es-para-aprofundamento)

---

## Conceitos Fundamentais

- **Content Negotiation (CN):** mecanismo de negociação de formato entre cliente e servidor. O cliente envia, via cabeçalhos HTTP, quais formatos aceita (`Accept: application/json, application/xml`) e o servidor responde conforme um formato compatível.
- **Accept Header:** especifica o(s) MIME Type(s) que o cliente aceita. Exemplo:
    - `Accept: application/json`
    - `Accept: application/xml;q=0.9, application/json;q=0.8` (prefere XML, caso disponível)
- **Content-Type Header:** em requisições que enviam corpo (POST/PUT), indica o formato do payload enviado pelo cliente (por exemplo, `Content-Type: application/json`).
- **HttpMessageConverter:** interface do Spring que converte objetos Java em representação HTTP (JSON, XML, CSV etc.) e vice-versa. Alguns conversores são registrados automaticamente pelo Spring (como o Jackson para JSON).
- **Producing vs Consuming:**
    - **`produces`** em anotações de mapeamento indica quais formatos esse endpoint pode fornecer.
    - **`consumes`** indica quais formatos o endpoint consegue receber.

**Importância e Propósito:**

1. **Flexibilidade:** Um único endpoint pode servir múltiplos formatos, sem duplicar lógica.
2. **Interoperabilidade:** Sistemas externos podem consumir as APIs usando o formato que melhor se encaixa nas suas bibliotecas/linguagens.
3. **Aderência a padrões REST:** Respeitar cabeçalhos HTTP torna a aplicação mais padronizada e “idiomática” dentro do ecossistema RESTful.

---

## Sintaxe Detalhada e Uso Prático

### 1. Configuração Padrão de Message Converters

Por padrão, o Spring Boot registra automaticamente diversos converters (quando as dependências estão no classpath):

- **Jackson2 (`MappingJackson2HttpMessageConverter`)** para JSON
- **Jackson XML (`MappingJackson2XmlHttpMessageConverter`)** para XML, se a dependência `com.fasterxml.jackson.dataformat:jackson-dataformat-xml` estiver presente
- **String/HTML (`StringHttpMessageConverter`)**
- **Byte Array (`ByteArrayHttpMessageConverter`)**

> Observação:
> 
> - Para suportar XML, adicione no `pom.xml` ou `build.gradle`:
>     
>     ```xml
>     <!-- Exemplo pom.xml -->
>     <dependency>
>         <groupId>com.fasterxml.jackson.dataformat</groupId>
>         <artifactId>jackson-dataformat-xml</artifactId>
>     </dependency>
>     
>     ```
>     
> - O Spring Boot auto-configura `HttpMessageConverters` com base nas dependências do projeto.

---

### 2. Uso de Anotações com `produces` e `consumes`

### 2.1. Exemplo de Controller Simples

```java
package com.exemplo.contentnegotiation.controller;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/produtos")
public class ProdutoController {

    // 1) Endpoint padrão que aceita JSON e XML (retorna JSON por default)
    @GetMapping(value = "/{id}")
    public Produto buscaPorIdDefault(@PathVariable("id") Long id) {
        // Método simples de exemplo que retorna um Produto fixo
        return new Produto(id, "Produto Exemplo", 99.90);
    }

    // 2) Endpoint que força resposta em JSON
    @GetMapping(
        value = "/{id}/json",
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Produto buscaPorIdJson(@PathVariable("id") Long id) {
        return new Produto(id, "Produto JSON", 49.90);
    }

    // 3) Endpoint que força resposta em XML
    @GetMapping(
        value = "/{id}/xml",
        produces = MediaType.APPLICATION_XML_VALUE
    )
    public Produto buscaPorIdXml(@PathVariable("id") Long id) {
        return new Produto(id, "Produto XML", 29.90);
    }

    // 4) Endpoint que consome apenas XML
    @PostMapping(
        value = "/",
        consumes = MediaType.APPLICATION_XML_VALUE,
        produces = MediaType.APPLICATION_XML_VALUE
    )
    public Produto criaProdutoViaXml(@RequestBody Produto produto) {
        // Aqui, apenas retorna o mesmo objeto recebido, simulando persistência
        produto.setId(100L); // Exemplo de atribuição de ID
        return produto;
    }

    // 5) Endpoint que consome JSON e produz JSON
    @PostMapping(
        value = "/",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Produto criaProdutoViaJson(@RequestBody Produto produto) {
        produto.setId(101L);
        return produto;
    }
}

```

### 2.2. Classe `Produto`

```java
package com.exemplo.contentnegotiation.controller;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

// Anotação para indicar raiz do XML quando for serializado
@JacksonXmlRootElement(localName = "Produto")
public class Produto {
    private Long id;
    private String nome;
    private Double preco;

    // Construtor padrão (necessário para desserialização)
    public Produto() { }

    public Produto(Long id, String nome, Double preco) {
        this.id = id;
        this.nome = nome;
        this.preco = preco;
    }

    // Getters e Setters
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getNome() {
        return nome;
    }
    public void setNome(String nome) {
        this.nome = nome;
    }
    public Double getPreco() {
        return preco;
    }
    public void setPreco(Double preco) {
        this.preco = preco;
    }
}

```

### Comentários Sobre o Código

- **`@RestController`**: combina `@Controller` e `@ResponseBody`, indicando que os métodos retornam o corpo da resposta diretamente.
- **`@RequestMapping("/api/produtos")`**: mapeia todas as rotas desse controller para iniciarem com `/api/produtos`.
- **`@GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)`**: especifica que, para esse endpoint, a resposta será somente em JSON, independentemente do cabeçalho `Accept` (o cliente receberá JSON forçosamente).
- **`@GetMapping(value = "/{id}", produces = MediaType.APPLICATION_XML_VALUE)`**: análogo para forçar XML.
- **`@PostMapping(consumes = ..., produces = ...)`**: define que o método aceita (consome) o corpo apenas no formato declarado e produz resposta somente no formato declarado.

---

### 3. Configuração Customizada de Message Converters

Em alguns casos, é necessário registrar conversores adicionais ou alterar a ordem de prioridade. Isso pode ser feito estendendo `WebMvcConfigurer`.

```java
package com.exemplo.contentnegotiation.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // Exemplo: Adicionar (ou priorizar) conversor de XML antes do conversor de JSON
        MappingJackson2XmlHttpMessageConverter xmlConverter = new MappingJackson2XmlHttpMessageConverter();
        // Configurações adicionais no xmlConverter podem ser feitas aqui

        // Inserir no início da lista para ter prioridade
        converters.add(0, xmlConverter);
    }
}

```

**Explicação:**

- `extendMessageConverters(...)`: permite adicionar ou modificar a lista de conversores após a configuração padrão.
- Ao inserir o `MappingJackson2XmlHttpMessageConverter` na posição zero, damos prioridade ao XML sobre JSON, caso ambos sejam aceitáveis.

---

## Cenários de Restrição ou Não Aplicação

1. **APIs Internas Simples (Sem Múltiplos Formatos):**
    - Se a aplicação é consumida exclusivamente por um cliente que aceita apenas JSON, o Content Negotiation pode ser simplificado ou até desnecessário. Basta configurar o `produces = MediaType.APPLICATION_JSON_VALUE` nos endpoints.
2. **Performance Crítica em Alto Volume:**
    - Em sistemas com alto throughput, verificar qual conversor será utilizado pode adicionar overhead. Nesses cenários, é comum restringir a resposta a um único formato (por exemplo, sempre JSON).
3. **Legado ou Clientes Restritos:**
    - Se há clientes rígidos que só entendem um formato não suportado pelo Spring (por exemplo, CSV customizado), é necessário implementar conversores específicos ou evitar a negociação automática.
4. **Microserviços com Contratos Fixos:**
    - Quando cada microserviço tem um contrato bem definido (por exemplo, sempre JSON com camelCase), a negociação dinâmica via `Accept` pode não ser necessária, pois todos sabem de antemão o formato esperado.

---

## Componentes Chave Associados

### 1. `HttpMessageConverter`

- **O que é:** Interface responsável por converter o corpo da requisição/resposta entre objetos Java e representações HTTP.
- **Implementações Padrão no Spring Boot:**
    - `MappingJackson2HttpMessageConverter` (JSON)
    - `MappingJackson2XmlHttpMessageConverter` (XML, quando Jackson XML estiver no classpath)
    - `StringHttpMessageConverter` (texto simples)
    - `ByteArrayHttpMessageConverter` (binários)
    - `FormHttpMessageConverter` (formulários `application/x-www-form-urlencoded`)
- **Métodos Principais:**
    - `canRead(MediaType, Class<?>)`
    - `canWrite(MediaType, Class<?>)`
    - `read(Class<?>, HttpInputMessage)`
    - `write(Object, MediaType, HttpOutputMessage)`

### 2. Anotações de Mapeamento

- **`@RequestMapping`**: Mapear rotas genéricas (todos os métodos HTTP).
    
    ```java
    @RequestMapping(
        value    = "/exemplo",
        method   = RequestMethod.GET,
        produces = MediaType.APPLICATION_JSON_VALUE,
        consumes = MediaType.APPLICATION_JSON_VALUE
    )
    
    ```
    
- **`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`**: Anotações específicas para cada verbo, com atributos `produces` e `consumes`.
    
    ```java
    @GetMapping(
        value    = "/exemplo",
        produces = {"application/json", "application/xml"}
    )
    
    ```
    
    - **`produces`**: Define quais *Media Types* esse método consegue retornar.
    - **`consumes`**: Define quais *Media Types* ele aceita no corpo da requisição.

### 3. Propriedades de Configuração

No `application.properties` ou `application.yml`, é possível ajustar parâmetros de Content Negotiation:

- **Desabilitar Query Parameter (JSESSIONID style) para determinar formato:**
    
    ```
    spring.mvc.contentnegotiation.favor-parameter=false
    
    ```
    
- **Habilitar JSON-P preemptivo (caso o cliente não especifique `Accept`):**
    
    ```
    spring.mvc.contentnegotiation.favor-path-extension=false
    spring.mvc.contentnegotiation.favor-parameter=false
    spring.mvc.contentnegotiation.ignore-unknown-path-extensions=true
    spring.mvc.media-types.json=application/json
    spring.mvc.media-types.xml=application/xml
    
    ```
    
- **Definir o Media Type default quando `Accept` estiver ausente:**
    
    ```
    spring.mvc.contentnegotiation.default-content-type=application/json
    
    ```
    

---

## Melhores Práticas e Padrões de Uso

1. **Definir um Formato Padrão Claro:**
    - Use `spring.mvc.contentnegotiation.default-content-type` para garantir que, quando o cliente não enviar `Accept`, a resposta seja em JSON (ou outro formato escolhido).
    - Exemplo:
        
        ```
        spring.mvc.contentnegotiation.default-content-type=application/json
        
        ```
        
2. **Evitar Extensões de Caminho (Path Extension):**
    - Antigamente era comum usar `/recurso.json` ou `/recurso.xml`. Porém, isso pode conflitar com URLs reais e adicionar vulnerabilidades. Prefira negociar via cabeçalhos.
    - Desative com:
        
        ```
        spring.mvc.contentnegotiation.favor-path-extension=false
        
        ```
        
3. **Priorizar Cabeçalhos `Accept` sobre Query Parameters:**
    - A negociação via query param (ex.: `?format=xml`) pode ser conveniente, mas menos aderente aos padrões HTTP. Se for usada, documente claramente.
    - Para desabilitar:
        
        ```
        spring.mvc.contentnegotiation.favor-parameter=false
        
        ```
        
4. **Versionamento de API por Header (Opcional, mas Recomendada):**
    - Em vez de versionar a URL (`/v1/produtos`), você pode criar cabeçalhos customizados, como `Accept: application/vnd.exemplo.v2+json`.
    - Isso deixa a URL limpa e delega a responsabilidade do formato e versão ao cabeçalho.
5. **Testar Sempre com Clientes Reais (Postman/cURL):**
    - Verifique se a aplicação responde corretamente quando for solicitada via:
        
        ```bash
        curl -H "Accept: application/json" http://localhost:8080/api/produtos/1
        curl -H "Accept: application/xml"  http://localhost:8080/api/produtos/1
        
        ```
        
    - Simule também cenários em que o formato requisitado não esteja disponível (ex.: `Accept: text/csv`) para verificar respostas HTTP 406 (Not Acceptable).
6. **Documentar Formatos Oferecidos:**
    - Na documentação da API (Swagger/OpenAPI), especifique claramente quais endpoints suportam quais formatos (JSON, XML etc.).
    - Exemplo no `OpenAPI`:
        
        ```yaml
        paths:
          /api/produtos/{id}:
            get:
              produces:
                - application/json
                - application/xml
              responses:
                '200':
                  description: Recurso encontrado
                  content:
                    application/json:
                      schema:
                        $ref: '#/components/schemas/Produto'
                    application/xml:
                      schema:
                        $ref: '#/components/schemas/Produto'
        
        ```
        

---

## Exemplo Prático Completo

### 1. Estrutura de Projeto

```
content-negotiation-demo/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/exemplo/contentnegotiation/
│   │   │       ├── ContentNegotiationDemoApplication.java
│   │   │       ├── controller/
│   │   │       │   └── ProdutoController.java
│   │   │       ├── model/
│   │   │       │   └── Produto.java
│   │   │       └── config/
│   │   │           └── WebConfig.java
│   │   └── resources/
│   │       ├── application.properties
│   │       └── data.sql (opcional, para inserir dados iniciais)
│   └── test/
│       └── java/
│           └── com/exemplo/contentnegotiation/
│               └── ProdutoControllerTest.java
└── pom.xml

```

### 1.1. `pom.xml` (Dependências Importantes)

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" ...>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.exemplo</groupId>
    <artifactId>content-negotiation-demo</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <properties>
        <java.version>17</java.version>
        <spring.boot.version>3.0.0</spring.boot.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starter Web (inclui Jackson JSON) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>${spring.boot.version}</version>
        </dependency>

        <!-- Jackson Dataformat XML (suporte a XML) -->
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
        </dependency>

        <!-- Testes (JUnit, MockMvc) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Plugin do Spring Boot -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring.boot.version}</version>
            </plugin>
        </plugins>
    </build>
</project>

```

---

### 2. Configuração da Aplicação

### 2.1. `application.properties`

```
# Porta padrão
server.port=8080

# Forçar JSON como default quando Accept não for informado
spring.mvc.contentnegotiation.default-content-type=application/json

# Desabilitar extensão de caminho (.json/.xml)
spring.mvc.contentnegotiation.favor-path-extension=false
spring.mvc.contentnegotiation.favor-parameter=false

# Definir mapeamento de tipos para negociaçăo via query param (caso queira habilitar)
spring.mvc.media-types.json=application/json
spring.mvc.media-types.xml=application/xml

```

---

### 3. Classe Principal

```java
package com.exemplo.contentnegotiation;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ContentNegotiationDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(ContentNegotiationDemoApplication.class, args);
    }
}

```

---

### 4. Configuração de Converters (Opcional)

```java
package com.exemplo.contentnegotiation.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // Priorizar XML sobre JSON, inserindo o conversor de XML na posição 0
        MappingJackson2XmlHttpMessageConverter xmlConverter = new MappingJackson2XmlHttpMessageConverter();
        converters.add(0, xmlConverter);
    }
}

```

---

### 5. Model: `Produto.java`

```java
package com.exemplo.contentnegotiation.model;

import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

// Ao serializar em XML, a raiz será <Produto>
@JacksonXmlRootElement(localName = "Produto")
public class Produto {
    private Long id;
    private String nome;
    private Double preco;

    // Construtor para desserialização
    public Produto() {}

    public Produto(Long id, String nome, Double preco) {
        this.id = id;
        this.nome = nome;
        this.preco = preco;
    }

    // Getters e Setters
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getNome() {
        return nome;
    }
    public void setNome(String nome) {
        this.nome = nome;
    }
    public Double getPreco() {
        return preco;
    }
    public void setPreco(Double preco) {
        this.preco = preco;
    }
}

```

---

### 6. Controller: `ProdutoController.java`

```java
package com.exemplo.contentnegotiation.controller;

import com.exemplo.contentnegotiation.model.Produto;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/produtos")
public class ProdutoController {

    // Simula um “banco de dados” em memória
    private static final Map<Long, Produto> REPOSITORIO = new HashMap<>();

    static {
        REPOSITORIO.put(1L, new Produto(1L, "Notebook", 2500.00));
        REPOSITORIO.put(2L, new Produto(2L, "Smartphone", 1500.00));
    }

    /**
     * 1) Busca básica: aceita qualquer formato suportado (JSON ou XML).
     *    - Se o cliente enviar 'Accept: application/xml', retorna XML.
     *    - Se enviar 'Accept: application/json' ou não enviar, retorna JSON por default.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Produto> buscaPorId(@PathVariable("id") Long id) {
        Produto produto = REPOSITORIO.get(id);
        if (produto == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(produto);
    }

    /**
     * 2) Busca forçando retorno JSON, mesmo que 'Accept: application/xml' seja enviado.
     */
    @GetMapping(
        value = "/{id}/forcar-json",
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public ResponseEntity<Produto> buscaForcandoJson(@PathVariable("id") Long id) {
        Produto produto = REPOSITORIO.get(id);
        if (produto == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(produto);
    }

    /**
     * 3) Busca forçando retorno XML.
     */
    @GetMapping(
        value = "/{id}/forcar-xml",
        produces = MediaType.APPLICATION_XML_VALUE
    )
    public ResponseEntity<Produto> buscaForcandoXml(@PathVariable("id") Long id) {
        Produto produto = REPOSITORIO.get(id);
        if (produto == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(produto);
    }

    /**
     * 4) Criação de novo produto:
     *    - Se o cliente enviar JSON (Content-Type: application/json), mapeia para POJO e retorna JSON.
     *    - Se enviar XML (Content-Type: application/xml), mapeia para POJO e retorna XML.
     *    - Exemplo usa ResponseEntity para retornar o código HTTP 201 (Created).
     */
    @PostMapping(
        consumes = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE },
        produces = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE }
    )
    public ResponseEntity<Produto> criaProduto(@RequestBody Produto produto) {
        // Simula persistência, atribuindo ID incremental
        Long novoId = REPOSITORIO.size() + 1L;
        produto.setId(novoId);
        REPOSITORIO.put(novoId, produto);

        // Retorna 201 Created, com Location (opcional) e corpo com o recurso criado
        return ResponseEntity
                .created(null) // Em um caso real, poderia usar URI criada pelo ServletUriComponentsBuilder
                .body(produto);
    }
}

```

### Comentários do Controller

- **GET `/api/produtos/{id}`**:
    - Não especifica `produces`, portanto aceita qualquer formato que o servidor suporte.
    - Se `Accept: application/xml` vier, será atendido pelo conversor XML (desde que habilitado).
    - Se não houver reconciliamento entre o `Accept` e os `Media Types` suportados, o Spring retorna 406 (Not Acceptable).
- **GET `/api/produtos/{id}/forcar-json`**:
    - Mesmo que o cliente peça XML, o `produces = application/json` força a resposta para JSON.
- **GET `/api/produtos/{id}/forcar-xml`**:
    - Similar, mas força XML.
- **POST `/api/produtos`**:
    - `consumes` define que tanto JSON quanto XML são aceitos no corpo da requisição.
    - `produces` define que a resposta pode ser em JSON ou XML, de acordo com o `Accept` do cliente. Se `Accept` não informado, usa o default (`application/json`).

---

### 7. Testes de Cliente

### 7.1. Testando GET com curl

1. **Solicitando JSON (default)**
    
    ```bash
    curl -i http://localhost:8080/api/produtos/1
    
    ```
    
    - Cabeçalho de resposta:
        
        ```
        HTTP/1.1 200 OK
        Content-Type: application/json
        
        ```
        
    - Corpo (exemplo):
        
        ```json
        {
          "id": 1,
          "nome": "Notebook",
          "preco": 2500.0
        }
        
        ```
        
2. **Solicitando XML**
    
    ```bash
    curl -i -H "Accept: application/xml" http://localhost:8080/api/produtos/1
    
    ```
    
    - Cabeçalho de resposta:
        
        ```
        HTTP/1.1 200 OK
        Content-Type: application/xml
        
        ```
        
    - Corpo (exemplo):
        
        ```xml
        <Produto>
          <id>1</id>
          <nome>Notebook</nome>
          <preco>2500.0</preco>
        </Produto>
        
        ```
        
3. **Forçando JSON (mesmo com `Accept: application/xml`)**
    
    ```bash
    curl -i -H "Accept: application/xml" http://localhost:8080/api/produtos/1/forcar-json
    
    ```
    
    - Apesar do `Accept` solicitar XML, o servidor responde em JSON:
        
        ```
        HTTP/1.1 200 OK
        Content-Type: application/json
        
        ```
        
4. **Forçando XML (mesmo com `Accept: application/json`)**
    
    ```bash
    curl -i -H "Accept: application/json" http://localhost:8080/api/produtos/1/forcar-xml
    
    ```
    
    - Retorna XML, pois o endpoint foi definido com `produces=application/xml`:
        
        ```
        HTTP/1.1 200 OK
        Content-Type: application/xml
        
        ```
        

### 7.2. Testando POST com curl

1. **Criando via JSON**
    
    ```bash
    curl -i -X POST \
      -H "Content-Type: application/json" \
      -H "Accept: application/json" \
      -d '{"nome":"Mouse","preco":99.90}' \
      http://localhost:8080/api/produtos
    
    ```
    
    - Cabeçalho de resposta:
        
        ```
        HTTP/1.1 201 Created
        Content-Type: application/json
        
        ```
        
    - Corpo:
        
        ```json
        {
          "id": 3,
          "nome": "Mouse",
          "preco": 99.9
        }
        
        ```
        
2. **Criando via XML**
    
    ```bash
    curl -i -X POST \
      -H "Content-Type: application/xml" \
      -H "Accept: application/xml" \
      -d '<Produto><nome>Teclado</nome><preco>179.90</preco></Produto>' \
      http://localhost:8080/api/produtos
    
    ```
    
    - Cabeçalho de resposta:
        
        ```
        HTTP/1.1 201 Created
        Content-Type: application/xml
        
        ```
        
    - Corpo:
        
        ```xml
        <Produto>
          <id>4</id>
          <nome>Teclado</nome>
          <preco>179.9</preco>
        </Produto>
        
        ```
        

---

## Sugestões para Aprofundamento

- **Spring HATEOAS:** explorar hiperlinks e representação de recursos RESTful com múltiplos links, mantendo a flexibilidade de formatos.
- **Versionamento Avançado:** use cabeçalhos customizados como `Accept: application/vnd.exemplo.v1+json` para controlar versões.
- **Negociação via Query Parameters (quando aplicável):** embora não recomendada, pode ser útil em alguns cenários controlados.
- **YAML como Formato de Resposta:** adicione dependência `snakeyaml` e configure conversores para suportar YAML.
- **Análise de Performance:** benchmark de `HttpMessageConverters` para grandes volumes de dados, comparando JSON vs XML vs Protobuf.
- **Spring Cloud e Microserviços:** como o Content Negotiation se comporta em gateways (API Gateway), registrando converters globalmente.

---

**Conclusão:**

O Content Negotiation no Spring Boot habilita a API a servir múltiplos formatos de dados de maneira transparente e aderente aos padrões HTTP. Entender suas configurações (anotações `produces`/`consumes`, `HttpMessageConverters` e propriedades de negociação) é fundamental para criar APIs RESTful flexíveis, interoperáveis e facilmente consumíveis por diferentes clientes.