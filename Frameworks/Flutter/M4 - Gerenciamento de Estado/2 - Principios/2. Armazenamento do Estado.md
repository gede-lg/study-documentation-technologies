# Princípios do Gerenciamento de Estado no Flutter

O gerenciamento de estado no Flutter é um dos tópicos mais essenciais e também desafiadores ao desenvolver aplicações complexas. Ele se baseia em três princípios fundamentais:

1. **Representação do Estado**
2. **Armazenamento do Estado**
3. **Propagação do Estado usando reatividade**

Neste contexto, vamos focar no segundo princípio: **Armazenamento do Estado**. Esta parte do gerenciamento de estado é crucial, pois define onde e como os dados que representam o estado da aplicação são armazenados e gerenciados ao longo da execução.

## Armazenamento do Estado

### O que é e para que serve?

O Armazenamento do Estado refere-se à forma como os dados que representam o estado da aplicação são guardados. No Flutter, o estado pode ser qualquer coisa que represente a informação necessária para que a interface do usuário seja desenhada corretamente. Isso inclui desde uma simples flag booleana até listas complexas de objetos.

A principal função do armazenamento de estado é garantir que esses dados possam ser recuperados e manipulados de maneira eficiente, possibilitando que a interface do usuário seja atualizada de acordo com as mudanças no estado.

### Como funciona?

No Flutter, o armazenamento do estado pode ser realizado de diversas maneiras, dependendo da complexidade e das necessidades da aplicação. Ele pode ser armazenado de forma efêmera (ou local), como em variáveis dentro de widgets, ou de forma persistente, como em bancos de dados locais.

Existem duas abordagens principais:

1. **Armazenamento Ephemeral (ou local)**: O estado é armazenado dentro do widget e é resetado toda vez que o widget é reconstruído. Essa abordagem é útil para estados que mudam rapidamente e não precisam ser preservados entre reconstruções, como um campo de texto ou o estado de um botão de alternância.

2. **Armazenamento App-wide (ou global)**: O estado é armazenado de forma mais global, permitindo que diferentes partes da aplicação acessem e modifiquem o estado. Exemplos incluem o uso de `InheritedWidget`, `Provider`, `ValueNotifier`, ou até mesmo soluções como blocos ou cubits. Esse tipo de armazenamento é útil para estados que precisam ser compartilhados entre diferentes widgets ou partes da aplicação.

### Armazenamento de Estado Sem Pacotes

Em alguns casos, você pode optar por armazenar o estado sem a ajuda de pacotes externos, utilizando apenas as ferramentas nativas do Flutter, como `ValueNotifier`, `ChangeNotifier`, ou até mesmo simples variáveis locais. Isso é útil para manter a simplicidade do código ou quando você deseja um controle mais fino sobre o gerenciamento de estado.

Vamos considerar o exemplo fornecido:

#### Código Base: `FoodInfoState`, `FoodInfoStore`, e `GenericService`

```dart
// Exemplo de implementação de um armazenamento de estado básico sem pacotes

import 'package:flutter/material.dart';
import 'package:cal_ai/models/food_info_model.dart';

class FoodInfoStore extends ValueNotifier<FoodInfoState> {

  final FoodInfoService service;

  // Criando a instância privada estática
  static FoodInfoStore? _instance;

  // Construtor privado
  FoodInfoStore._internal(this.service) : super(InitialFoodInfoState());

  // Método factory para garantir o Singleton
  factory FoodInfoStore(FoodInfoService service) {
    _instance ??= FoodInfoStore._internal(service);
    return _instance!;
  }

  Future findAllFoodInfos() async {
    value = LoadingFoodInfoState();
    try {
      var foods = await service.findAll();
      value = SucessFoodInfoState(foodInfos: foods);
    } catch (e) {
      value = ErrorFoodInfoState(message: e.toString());
    }
  }

  Future findFoodInfo() async {
    value = LoadingFoodInfoState();
    try {
      var food = await service.findById("food");
      value = SucessSingleFoodInfoState(
        foodInfo: food ??= const FoodInfoModel(
          calories: 10,
          carbs: 1,
          food: '',
          protein: 1,
          fat: 1,
          score: 1,
        ),
      );
    } catch (e) {
      value = ErrorFoodInfoState(message: e.toString());
    }
  }
}
```

Neste exemplo, `FoodInfoStore` é um Singleton que armazena o estado de `FoodInfoState`. O estado é gerenciado utilizando o `ValueNotifier`, uma solução nativa do Flutter para notificar ouvintes sobre mudanças no valor armazenado. Esse exemplo demonstra como você pode armazenar o estado sem recorrer a pacotes de terceiros, utilizando apenas recursos nativos.

### Detalhes Cruciais para Estudos Futuros

Aqui estão alguns tópicos e conceitos que você deve explorar em estudos futuros para aprofundar seu entendimento sobre o armazenamento de estado no Flutter:

1. **`ValueNotifier` e `ChangeNotifier`**:
   - **O que são**: São classes nativas do Flutter que ajudam a gerenciar o estado e notificar os ouvintes sobre mudanças.
   - **Como funcionam**: `ValueNotifier` notifica seus ouvintes sempre que o valor que ele armazena é alterado. `ChangeNotifier` é mais geral e permite notificações personalizadas.
   - **Quando usar**: Use `ValueNotifier` quando o estado for simples e puder ser representado por um único valor. Use `ChangeNotifier` quando precisar de um controle mais refinado sobre as notificações.

2. **Gerenciamento de Estado Global**:
   - **InheritedWidget**: Um widget que pode passar dados para widgets descendentes na árvore de widgets.
   - **Provider**: Um pacote que facilita o uso de `InheritedWidget`, tornando o gerenciamento de estado mais fácil e escalável.

3. **Soluções de Armazenamento Persistente**:
   - **SharedPreferences**: Para armazenar pequenos dados persistentes, como configurações de usuário.
   - **Sqflite**: Para armazenar dados mais complexos em um banco de dados local.

4. **Abordagens de Gerenciamento de Estado**:
   - **StatefulWidget**: Útil para estados efêmeros.
   - **BLoC (Business Logic Component)**: Separa a lógica de negócios da interface do usuário, útil para projetos maiores.
   - **Riverpod e outras alternativas**: Explore alternativas ao `Provider` para projetos específicos.

### Considerações Finais

O armazenamento de estado é um dos pilares do gerenciamento de estado no Flutter, influenciando diretamente como os dados fluem na sua aplicação e como a interface do usuário reage a esses dados. Compreender as nuances do armazenamento de estado, tanto utilizando pacotes quanto com soluções nativas, é crucial para construir aplicações escaláveis e de alto desempenho.

Estude as ferramentas que o Flutter oferece, pratique com exemplos concretos, e explore diferentes abordagens para entender qual delas se adapta melhor às suas necessidades de desenvolvimento.