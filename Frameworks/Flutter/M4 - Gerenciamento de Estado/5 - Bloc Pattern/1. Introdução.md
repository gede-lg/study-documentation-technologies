# Bloc Pattern Nativo com Streams no Flutter

## Introdução

No desenvolvimento de aplicações Flutter, a gestão eficiente do estado é fundamental para garantir uma interface de usuário responsiva e escalável. O **Bloc Pattern** (Business Logic Component) é uma das arquiteturas mais populares para separar a lógica de negócios da interface, promovendo uma estrutura de código mais limpa e modular. Quando combinado com **Streams**, o Bloc Pattern nativo no Flutter oferece uma abordagem robusta para gerenciar estados de maneira reativa.

## Sumário

1. [O que é e para que serve?](#o-que-é-e-para-que-serve)
2. [Como funciona?](#como-funciona)
3. [Sintaxe de uso](#sintaxe-de-uso)
    - [Parâmetros e Subparâmetros](#parâmetros-e-subparâmetros)
4. [Restrições de uso](#restrições-de-uso)
5. [Quando utilizar?](#quando-utilizar)
6. [Propriedades](#propriedades)
    - [Tabela de Propriedades](#tabela-de-propriedades)
7. [Métodos](#métodos)
    - [Tabela de Métodos](#tabela-de-métodos)
8. [Exemplos de Código](#exemplos-de-código)
9. [Considerações Finais](#considerações-finais)

---

## O que é e para que serve?

### O que é?

O **Bloc Pattern Nativo com Streams no Flutter** é uma arquitetura de gerenciamento de estado que utiliza Streams para gerenciar e distribuir eventos e estados na aplicação. O padrão Bloc promove a separação clara entre a lógica de negócios e a interface do usuário, facilitando a manutenção e escalabilidade do código.

### Para que serve?

O Bloc Pattern serve para:

- **Gerenciar o estado da aplicação de forma eficiente:** Mantendo o estado centralizado e reativo.
- **Separar lógica de negócios da interface do usuário:** Melhorando a legibilidade e manutenção do código.
- **Facilitar testes unitários:** A lógica isolada permite testes mais fáceis e confiáveis.
- **Promover reutilização de código:** Componentes de lógica podem ser reutilizados em diferentes partes da aplicação.

## Como funciona?

O Bloc Pattern utiliza três componentes principais:

1. **Events (Eventos):** Representam ações que ocorrem na aplicação, como cliques de botões ou respostas de API.
2. **Bloc:** Recebe eventos, processa a lógica de negócios e emite novos estados.
3. **States (Estados):** Representam o estado atual da aplicação, refletindo as mudanças resultantes dos eventos processados pelo Bloc.

A comunicação entre esses componentes é feita através de **Streams**, que permitem a emissão e escuta de eventos e estados de maneira assíncrona e reativa.

### Fluxo de Funcionamento

1. **Interface do Usuário (UI):** Envia um evento para o Bloc.
2. **Bloc:** Recebe o evento, processa a lógica de negócios e emite um novo estado.
3. **UI:** Escuta o fluxo de estados e atualiza a interface de acordo com o estado recebido.

## Sintaxe de uso

A implementação do Bloc Pattern nativo com Streams no Flutter envolve a criação de classes para eventos, estados e o próprio Bloc. A seguir, detalharemos a sintaxe básica para cada um desses componentes.

### Passo a Passo

1. **Definição dos Eventos:**

```dart
// Definindo eventos para o Bloc
abstract class CounterEvent {}

class Increment extends CounterEvent {}

class Decrement extends CounterEvent {}
```

2. **Definição dos Estados:**

```dart
// Definindo estados para o Bloc
class CounterState {
  final int count;

  CounterState(this.count);
}
```

3. **Implementação do Bloc:**

```dart
import 'dart:async';

// Implementando o Bloc
class CounterBloc {
  // StreamController para eventos
  final _eventController = StreamController<CounterEvent>();
  Sink<CounterEvent> get eventSink => _eventController.sink;

  // StreamController para estados
  final _stateController = StreamController<CounterState>();
  Stream<CounterState> get stateStream => _stateController.stream;

  int _count = 0;

  CounterBloc() {
    // Escutando eventos e mapeando para estados
    _eventController.stream.listen(_mapEventToState);
  }

  void _mapEventToState(CounterEvent event) {
    if (event is Increment) {
      _count++;
    } else if (event is Decrement) {
      _count--;
    }
    // Emitindo novo estado
    _stateController.sink.add(CounterState(_count));
  }

  void dispose() {
    _eventController.close();
    _stateController.close();
  }
}
```

4. **Uso no Widget:**

```dart
import 'package:flutter/material.dart';

class CounterPage extends StatefulWidget {
  @override
  _CounterPageState createState() => _CounterPageState();
}

class _CounterPageState extends State<CounterPage> {
  final CounterBloc _bloc = CounterBloc();

  @override
  void dispose() {
    _bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(title: Text('Bloc Pattern Nativo')),
        body: StreamBuilder<CounterState>(
          stream: _bloc.stateStream,
          initialData: CounterState(0),
          builder: (context, snapshot) {
            return Center(
              child: Text(
                'Contador: ${snapshot.data!.count}',
                style: TextStyle(fontSize: 24),
              ),
            );
          },
        ),
        floatingActionButton: Column(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            FloatingActionButton(
              onPressed: () => _bloc.eventSink.add(Increment()),
              child: Icon(Icons.add),
              tooltip: 'Incrementar',
            ),
            SizedBox(height: 10),
            FloatingActionButton(
              onPressed: () => _bloc.eventSink.add(Decrement()),
              child: Icon(Icons.remove),
              tooltip: 'Decrementar',
            ),
          ],
        ));
  }
}
```

### Parâmetros e Subparâmetros

#### Bloc

- **eventSink:** Sink para adicionar eventos ao Bloc.
- **stateStream:** Stream para ouvir os estados emitidos pelo Bloc.

#### StreamController

- **StreamController\<T\>:** Controla o fluxo de dados do tipo T.
    - **sink:** Para adicionar dados ao stream.
    - **stream:** Para ouvir os dados emitidos.

#### StreamBuilder

- **stream:** A stream que o `StreamBuilder` deve escutar.
- **initialData:** Dados iniciais a serem exibidos antes de qualquer dado ser emitido pela stream.
- **builder:** Função que constrói o widget com base nos dados da stream.

## Restrições de uso

Apesar das vantagens, o Bloc Pattern com Streams possui algumas restrições:

- **Curva de aprendizado:** Pode ser complexo para desenvolvedores iniciantes entenderem conceitos de Streams e blocos.
- **Boilerplate:** Requer a criação de múltiplas classes e boilerplate de código, o que pode aumentar a complexidade inicial.
- **Gestão de Recursos:** É necessário gerenciar adequadamente o ciclo de vida dos StreamControllers para evitar vazamentos de memória.
- **Sobrecarga para Projetos Simples:** Para aplicações muito simples, o Bloc Pattern pode ser excessivamente complexo.

## Quando utilizar?

O Bloc Pattern nativo com Streams é mais adequado para:

- **Aplicações de médio a grande porte:** Onde a gestão de estado se torna complexa.
- **Projetos que exigem alta escalabilidade:** Facilita a manutenção e expansão do código.
- **Equipes que valorizam separação de responsabilidades:** Mantém a lógica de negócios separada da UI.
- **Necessidade de testes robustos:** A lógica isolada facilita a criação de testes unitários.

Em projetos simples ou protótipos, outras abordagens de gerenciamento de estado podem ser mais adequadas devido à menor complexidade.

## Propriedades

### Tabela de Propriedades

| Propriedade    | Descrição                                         | Sintaxe de Uso                        |
| -------------- | ------------------------------------------------- | ------------------------------------- |
| `eventSink`    | Sink para adicionar eventos ao Bloc.              | `bloc.eventSink.add(Event())`         |
| `stateStream`  | Stream para escutar os estados emitidos pelo Bloc.| `bloc.stateStream.listen((state) {})` |
| `_count`       | Variável interna para armazenar o contador.       | `int _count = 0;`                      |
| `_eventController` | StreamController para eventos.                | `final _eventController = StreamController<CounterEvent>();` |
| `_stateController` | StreamController para estados.                | `final _stateController = StreamController<CounterState>();` |

## Métodos

### Tabela de Métodos

| Método        | Descrição                                                        | Sintaxe de Uso                        |
| ------------- | ---------------------------------------------------------------- | ------------------------------------- |
| `dispose()`   | Fecha os StreamControllers para liberar recursos.               | `bloc.dispose();`                     |
| `_mapEventToState` | Método privado que mapeia eventos para novos estados.        | `_mapEventToState(Event event)`       |

## Exemplos de Código

### Exemplo Completo de Bloc Pattern Nativo com Streams

A seguir, um exemplo completo de implementação do Bloc Pattern para um contador simples.

#### Definição dos Eventos

```dart
// counter_event.dart
abstract class CounterEvent {}

class Increment extends CounterEvent {}

class Decrement extends CounterEvent {}
```

#### Definição dos Estados

```dart
// counter_state.dart
class CounterState {
  final int count;

  CounterState(this.count);
}
```

#### Implementação do Bloc

```dart
// counter_bloc.dart
import 'dart:async';
import 'counter_event.dart';
import 'counter_state.dart';

class CounterBloc {
  // StreamController para eventos
  final _eventController = StreamController<CounterEvent>();
  Sink<CounterEvent> get eventSink => _eventController.sink;

  // StreamController para estados
  final _stateController = StreamController<CounterState>();
  Stream<CounterState> get stateStream => _stateController.stream;

  int _count = 0;

  CounterBloc() {
    // Escutando eventos e mapeando para estados
    _eventController.stream.listen(_mapEventToState);
  }

  void _mapEventToState(CounterEvent event) {
    if (event is Increment) {
      _count++;
    } else if (event is Decrement) {
      _count--;
    }
    // Emitindo novo estado
    _stateController.sink.add(CounterState(_count));
  }

  void dispose() {
    _eventController.close();
    _stateController.close();
  }
}
```

#### Uso no Widget

```dart
// main.dart
import 'package:flutter/material.dart';
import 'counter_bloc.dart';
import 'counter_event.dart';
import 'counter_state.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
        title: 'Bloc Pattern Nativo com Streams',
        home: CounterPage());
  }
}

class CounterPage extends StatefulWidget {
  @override
  _CounterPageState createState() => _CounterPageState();
}

class _CounterPageState extends State<CounterPage> {
  final CounterBloc _bloc = CounterBloc();

  @override
  void dispose() {
    _bloc.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(title: Text('Bloc Pattern Nativo')),
        body: StreamBuilder<CounterState>(
          stream: _bloc.stateStream,
          initialData: CounterState(0),
          builder: (context, snapshot) {
            return Center(
              child: Text(
                'Contador: ${snapshot.data!.count}',
                style: TextStyle(fontSize: 24),
              ),
            );
          },
        ),
        floatingActionButton: Column(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            FloatingActionButton(
              onPressed: () => _bloc.eventSink.add(Increment()),
              child: Icon(Icons.add),
              tooltip: 'Incrementar',
            ),
            SizedBox(height: 10),
            FloatingActionButton(
              onPressed: () => _bloc.eventSink.add(Decrement()),
              child: Icon(Icons.remove),
              tooltip: 'Decrementar',
            ),
          ],
        ));
  }
}
```

### Explicação do Código

1. **Eventos (`counter_event.dart`):** Definem as ações possíveis (`Increment` e `Decrement`).
2. **Estados (`counter_state.dart`):** Representam o estado atual do contador.
3. **Bloc (`counter_bloc.dart`):**
    - **StreamControllers:** Gerenciam os fluxos de eventos e estados.
    - **Construtor:** Escuta os eventos e mapeia para novos estados.
    - **Método `_mapEventToState`:** Atualiza o contador com base no evento recebido e emite o novo estado.
    - **Método `dispose`:** Fecha os StreamControllers para evitar vazamentos de memória.
4. **Widget (`main.dart`):**
    - **StreamBuilder:** Escuta o fluxo de estados e atualiza a interface do usuário.
    - **FloatingActionButtons:** Enviam eventos de incremento e decremento ao Bloc.

## Considerações Finais

O **Bloc Pattern Nativo com Streams no Flutter** é uma poderosa arquitetura para gerenciamento de estado, especialmente em aplicações de complexidade média a alta. Sua abordagem reativa, baseada em Streams, permite uma gestão eficiente e escalável do estado, promovendo uma separação clara entre a lógica de negócios e a interface do usuário.

Embora possa introduzir uma certa complexidade inicial e requerer uma compreensão sólida de Streams e arquitetura reativa, os benefícios em termos de manutenção, testabilidade e escalabilidade tornam o Bloc Pattern uma escolha sólida para muitos projetos Flutter.

Para desenvolvedores que buscam uma solução de gerenciamento de estado mais simplificada, bibliotecas como `Provider` ou `Riverpod` podem ser alternativas mais acessíveis. No entanto, para projetos que demandam uma estrutura robusta e modular, o Bloc Pattern nativo com Streams permanece uma das melhores opções disponíveis.