# **ProxyProvider no Flutter**

## **Introdução**

O Flutter é amplamente utilizado para desenvolver aplicativos móveis por sua abordagem de widgets declarativos. Um dos conceitos importantes ao criar aplicativos escaláveis e bem organizados é a injeção de dependências. O pacote **Provider**, amplamente utilizado na comunidade Flutter, oferece diversas ferramentas para facilitar esse processo, entre elas o **ProxyProvider**.

O **ProxyProvider** é uma solução poderosa para gerenciar e compartilhar dependências que dependem de outras dependências dentro do mesmo contexto. Ele ajuda a criar dependências dinâmicas e permite que os widgets reajam automaticamente a mudanças em objetos do provedor.

---

## **Sumário**

1. **O que é e para que serve?**
2. **Como funciona?**
3. **Sintaxe de uso**
    - Descrição de parâmetros
4. **Restrições de uso**
5. **Quando utilizar?**
6. **Propriedades do ProxyProvider**
7. **Métodos principais**
8. **Exemplos práticos**
9. **Categorias de widget mais apropriadas**
10. **Conclusão**

---

## **1. O que é e para que serve?**

O **ProxyProvider** é um tipo de provedor oferecido pelo pacote **Provider** no Flutter. Ele é usado para criar e gerenciar dependências cuja criação depende de outros valores ou objetos fornecidos pelo contexto do Provider.

### **Para que serve?**

- **Gerenciar dependências dinâmicas:** Permite criar objetos que dependem de mudanças em outros objetos gerenciados pelo Provider.
- **Propagação de atualizações automáticas:** Quando o objeto do qual a dependência depende é atualizado, o **ProxyProvider** automaticamente reflete essas mudanças.
- **Facilitar injeção de dependências:** Evita a criação manual de objetos dependentes em cascata.

---

## **2. Como funciona?**

O **ProxyProvider** escuta automaticamente mudanças em provedores de dependências declarados anteriormente e cria uma nova instância ou atualiza o objeto que fornece. Ele é reavaliado sempre que os objetos de que depende são alterados.

Por exemplo:

- Você tem um serviço `AuthService` que depende de `ApiClient`.
- Com o **ProxyProvider**, pode declarar que `AuthService` deve ser recriado sempre que `ApiClient` for alterado.

---

## **3. Sintaxe de uso**

### **Exemplo básico**

```dart
MultiProvider(
  providers: [
    Provider<ApiClient>(create: (_) => ApiClient()),
    ProxyProvider<ApiClient, AuthService>(
      update: (context, apiClient, previousAuthService) =>
          AuthService(apiClient),
    ),
  ],
  child: MyApp(),
)
```

### **Descrição detalhada de parâmetros**

#### **`create`**

- **O que faz?** Cria o objeto inicial fornecido pelo Provider.
- **Parâmetros esperados:**
    - **Tipo esperado:** `BuildContext`
    - **Obrigatório:** Sim
- **Função:** Definir o objeto que será criado no início.

#### **`update`**

- **O que faz?** Atualiza o objeto gerenciado pelo **ProxyProvider** quando alguma dependência muda.
- **Parâmetros esperados:**
    - **`context`**: Contexto da árvore de widgets.
    - **`value`**: A dependência externa usada na criação do objeto.
    - **`previous`**: O estado anterior do objeto gerenciado pelo ProxyProvider.
- **Obrigatório:** Sim
- **Função:** Retorna o novo objeto baseado nas dependências.

#### **`child`**

- **O que faz?** Define o widget descendente que consumirá os objetos do Provider.
- **Parâmetros esperados:**
    - **Tipo esperado:** Widget
    - **Opcional:** Sim

#### **`builder`** (caso `ProxyProvider.value`)

- **O que faz?** Permite modificar diretamente valores.
- **Parâmetros esperados:**
    - **Tipo esperado:** Contexto + dependências.
    - **Opcional:** Sim

---

## **4. Restrições de uso**

1. **Dependências devem ser configuradas em ordem**: Sempre declare os objetos que serão usados no **ProxyProvider** antes dele no `MultiProvider`.
2. **Compatível apenas com objetos observáveis**: É mais útil para objetos que requerem escuta ativa.
3. **Evitar

**dependências circulares**: Certifique-se de que o fluxo de dependências não se torne um ciclo.

---

## **5. Quando utilizar?**

Use o **ProxyProvider** quando:

- Um serviço ou classe depende de outro objeto gerenciado por um Provider.
- Precisa compartilhar instâncias de objetos entre widgets sem recriá-los manualmente.
- Deseja que atualizações em um objeto atualizem automaticamente outro.

### **Exemplos de casos práticos:**

- **Serviços dependentes:** Um `AuthService` que depende de um `ApiClient`.
- **Modelos interdependentes:** Um `CartModel` que depende de um `UserModel`.
- **Gerenciamento dinâmico de temas:** Alterar o tema do app com base em configurações de um provedor.

---

## **6. Propriedades do ProxyProvider**

|Propriedade|Descrição|Sintaxe de Uso|
|---|---|---|
|`create`|Inicializa o objeto gerenciado pelo Provider.|`create: (context) => MyObject()`|
|`update`|Atualiza o objeto gerenciado com base nas mudanças nas dependências.|`update: (context, dependency, previous) => ...`|
|`dispose`|Método chamado quando o objeto é removido da árvore de widgets.|`dispose: (context, myObject) { ... }`|
|`child`|Widget descendente que consome o objeto do ProxyProvider.|`child: MyWidget()`|
|`lazy`|Define se o objeto deve ser criado apenas quando solicitado.|`lazy: true/false`|
|`builder`|Fornece uma maneira de construir dinamicamente os valores.|`builder: (context, dependencies) => ...`|

---

## **7. Métodos principais**

|Método|Descrição|Sintaxe de Uso|
|---|---|---|
|`ProxyProvider.of`|Acessa o objeto gerenciado no contexto atual.|`final authService = ProxyProvider.of<AuthService>(context);`|
|`listen`|Escuta mudanças em dependências e notifica os widgets consumidores.|`listen: (context, dependency, previous) { ... }`|
|`notifyListeners`|Notifica os consumidores manualmente sobre mudanças no objeto gerenciado.|`myObject.notifyListeners()`|

---

## **8. Exemplos práticos**

### **Exemplo 1: `AuthService` com `ApiClient`**

```dart
class ApiClient {
  // Classe fictícia para comunicação com API
  void fetchData() {
    print("Fetching data...");
  }
}

class AuthService {
  final ApiClient apiClient;

  AuthService(this.apiClient);

  void login() {
    apiClient.fetchData();
    print("User logged in!");
  }
}

void main() {
  runApp(
    MultiProvider(
      providers: [
        Provider<ApiClient>(create: (_) => ApiClient()),
        ProxyProvider<ApiClient, AuthService>(
          update: (context, apiClient, previousAuthService) =>
              AuthService(apiClient),
        ),
      ],
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: LoginScreen(),
    );
  }
}

class LoginScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final authService = Provider.of<AuthService>(context);

    return Scaffold(
      appBar: AppBar(title: Text("Login")),
      body: Center(
        child: ElevatedButton(
          onPressed: authService.login,
          child: Text("Login"),
        ),
      ),
    );
  }
}
```

### **Exemplo 2: Carregamento Dinâmico de Configurações**

```dart
class Settings {
  final bool darkMode;

  Settings(this.darkMode);
}

class ThemeService {
  final Settings settings;

  ThemeService(this.settings);

  ThemeData get theme => settings.darkMode ? ThemeData.dark() : ThemeData.light();
}

void main() {
  runApp(
    MultiProvider(
      providers: [
        Provider<Settings>(create: (_) => Settings(false)),
        ProxyProvider<Settings, ThemeService>(
          update: (context, settings, previous) => ThemeService(settings),
        ),
      ],
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final themeService = Provider.of<ThemeService>(context);

    return MaterialApp(
      theme: themeService.theme,
      home: HomeScreen(),
    );
  }
}
```

---

## **9. Categorias de Widget Mais Apropriadas**

|Categoria|Relevância|
|---|---|
|**Async**|ProxyProvider ajuda a gerenciar dependências assíncronas, como serviços.|
|**Layout**|Útil em aplicativos que precisam de configurações dinâmicas.|
|**Material Components**|Aplicações baseadas em Material Design com lógica de dependência complexa.|

---

## **10. Conclusão**

O **ProxyProvider** é uma ferramenta versátil para gerenciar dependências dinâmicas no Flutter, permitindo que widgets reajam automaticamente a mudanças em objetos compartilhados. Ele simplifica o desenvolvimento de aplicativos escaláveis e mantém o código limpo e organizado.

### **Pontos-chave:**

- Use quando dependências forem interligadas.
- Siga as restrições de ordem de dependências no `MultiProvider`.
- Implemente o `update` para gerenciar as instâncias de objetos dinamicamente.

Com um entendimento sólido do **ProxyProvider**, você pode criar aplicativos robustos e escaláveis, onde dependências complexas são gerenciadas de maneira elegante e eficiente.