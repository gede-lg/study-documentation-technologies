# Migrations no SQLite do Flutter

## Introdução

No desenvolvimento de aplicativos Flutter que utilizam bancos de dados SQLite, é comum a necessidade de gerenciar mudanças na estrutura do banco de dados ao longo do tempo. Essas mudanças podem incluir a criação de novas tabelas, alteração de colunas existentes ou remoção de tabelas obsoletas. Para lidar com essas modificações de forma organizada e segura, utilizamos o conceito de **migrations**.

## Sumário

1. [O que são migrations e para que servem?](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#o-que-s%C3%A3o-migrations-e-para-que-servem)
2. [Como funcionam as migrations no SQLite do Flutter](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#como-funcionam-as-migrations-no-sqlite-do-flutter)
3. [Sintaxe de uso](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#sintaxe-de-uso)
4. [Restrições de uso](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#restri%C3%A7%C3%B5es-de-uso)
5. [Quando utilizar migrations?](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#quando-utilizar-migrations)
6. [Criando migrations para upgrades e downgrades](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#criando-migrations-para-upgrades-e-downgrades)
7. [Exemplos de código](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#exemplos-de-c%C3%B3digo)
8. [Considerações finais](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb#considera%C3%A7%C3%B5es-finais)

## O que são migrations e para que servem?

**Migrations** são scripts ou conjuntos de instruções que gerenciam alterações incrementais na estrutura do banco de dados. Elas permitem que você evolua o esquema do banco de dados de forma controlada, garantindo que todos os usuários do aplicativo tenham a estrutura correta, independentemente da versão que estavam usando anteriormente.

**Finalidade das migrations:**

- **Evolução incremental:** Permitem adicionar novas funcionalidades sem quebrar o aplicativo para os usuários existentes.
- **Controle de versão do banco:** Mantêm um histórico das mudanças aplicadas ao banco de dados.
- **Automatização:** Automatizam o processo de atualização do esquema do banco de dados durante upgrades ou downgrades do aplicativo.

## Como funcionam as migrations no SQLite do Flutter

No Flutter, utilizando o pacote **sqflite**, as migrations são implementadas através das funções de callback fornecidas pelo método `openDatabase`:

- `onCreate`: Chamado quando o banco de dados é criado pela primeira vez.
- `onUpgrade`: Chamado quando a versão do banco de dados é incrementada.
- `onDowngrade`: Chamado quando a versão do banco de dados é decrementada.

Essas funções recebem o objeto `Database` e a versão atual e nova do banco, permitindo que você execute comandos SQL para modificar a estrutura do banco conforme necessário.

## Sintaxe de uso

Ao utilizar o `openDatabase`, você pode especificar as funções de callback:

```dart
openDatabase(
  path,
  version: versão_do_banco,
  onCreate: _onCreate,
  onUpgrade: _onUpgrade,
  onDowngrade: _onDowngrade,
  onConfigure: _onConfigure,
);
```

### Parâmetros:

- **path** (`String`): Caminho onde o banco de dados será armazenado. Obrigatório.
- **version** (`int`): Versão atual do banco de dados. Obrigatório.
- **onCreate** (`Future<void> Function(Database, int)`): Função chamada na criação do banco. Opcional.
- **onUpgrade** (`Future<void> Function(Database, int, int)`): Função chamada no upgrade do banco. Opcional.
- **onDowngrade** (`Future<void> Function(Database, int, int)`): Função chamada no downgrade do banco. Opcional.
- **onConfigure** (`Future<void> Function(Database)`): Função chamada antes de qualquer outra coisa. Opcional.

### Descrição dos parâmetros:

- **`onCreate`**: Recebe o `Database` e a versão inicial. Deve conter as instruções para criar as tabelas iniciais.
- **`onUpgrade`**: Recebe o `Database`, a versão antiga e a nova versão. Deve conter as instruções para atualizar o esquema do banco.
- **`onDowngrade`**: Recebe o `Database`, a versão antiga e a nova versão. Deve conter as instruções para reverter mudanças no banco.
- **`onConfigure`**: Usado para configurações iniciais, como habilitar chaves estrangeiras.

## Restrições de uso

- **Transações**: Recomenda-se utilizar batch ou transações para garantir que todas as operações sejam executadas com sucesso ou revertidas em caso de falha.
- **Versões sequenciais**: As versões do banco de dados devem ser números inteiros e incrementais.
- **Gerenciamento de estado**: Deve-se gerenciar corretamente o estado do banco para evitar múltiplas conexões simultâneas.

## Quando utilizar migrations?

- **Alterações no esquema**: Sempre que houver alterações na estrutura das tabelas, colunas, índices, etc.
- **Novas funcionalidades**: Ao adicionar novas tabelas ou relacionamentos que suportam novas funcionalidades do aplicativo.
- **Correções de bugs**: Para corrigir problemas existentes no esquema do banco de dados.

## Criando migrations para upgrades e downgrades

Para ordenar a execução dos SQLs durante upgrades ou downgrades, podemos criar classes que implementam uma interface de `Migration` e definem os métodos `create`, `upgrade` e `downgrade`.

### Passos para criar migrations:

1. **Definir uma interface `Migration`**:
    
    ```dart
    abstract class Migration {
      void create(Batch batch);
      void upgrade(Batch batch);
      void downgrade(Batch batch);
    }
    ```
    
2. **Implementar classes de migrations**:
    
    - Cada classe representa uma versão específica do banco de dados.
    
    ```dart
    class MigrationV1 implements Migration {
      @override
      void create(Batch batch) {
        // Código para criar as tabelas iniciais
      }
    
      @override
      void upgrade(Batch batch) {
        // Código para atualizar a partir de versões anteriores
      }
    
      @override
      void downgrade(Batch batch) {
        // Código para reverter mudanças
      }
    }
    ```
    
3. **Gerenciar as migrations**:
    
    - Criar uma fábrica que retorna as migrations necessárias com base nas versões.
    
    ```dart
    class SqfliteMigrationFactory {
      List<Migration> getCreateMigration() => [MigrationV1(), MigrationV2()];
    
      List<Migration> getUpgradeMigration(int oldVersion) {
        var migrations = <Migration>[];
        switch (oldVersion) {
          case 1:
            migrations.add(MigrationV2());
            break;
        }
        return migrations;
      }
    
      List<Migration> getDowngradeMigration(int oldVersion) {
        // Implementação similar para downgrades
      }
    }
    ```
    
4. **Aplicar as migrations nos callbacks**:
    
    - Utilizar os métodos `batch` para executar as migrations em lote.
    
    ```dart
    Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
      final batch = db.batch();
      var migrations = SqfliteMigrationFactory().getUpgradeMigration(oldVersion);
      for (var migration in migrations) {
        migration.upgrade(batch);
      }
      await batch.commit();
    }
    ```
    

## Exemplos de código

### Classe de conexão com o banco de dados

```dart
class SqfliteConnectionFactory {
  static SqfliteConnectionFactory? _instance;
  Database? _db;
  final _lock = Lock();
  static const int _VERSION = 2;
  static const String _DATABASE_NAME = 'TODO_LIST_PROVIDER';

  SqfliteConnectionFactory._();

  factory SqfliteConnectionFactory() {
    _instance ??= SqfliteConnectionFactory._();
    return _instance!;
  }

  Future<Database> openConnection() async {
    var databasePath = join(await getDatabasesPath(), _DATABASE_NAME);

    if (_db == null) {
      await _lock.synchronized(() async {
        _db ??= await openDatabase(
          databasePath,
          version: _VERSION,
          onConfigure: _onConfigure,
          onCreate: _onCreate,
          onUpgrade: _onUpgrade,
          onDowngrade: _onDowngrade,
        );
      });
    }

    return _db!;
  }

  void closeConnection() {
    _db?.close();
    _db = null;
  }

  Future<void> _onConfigure(Database db) async {
    await db.execute("PRAGMA foreign_keys = ON");
  }

  Future<void> _onCreate(Database db, int version) async {
    final batch = db.batch();
    var migrations = SqfliteMigrationFactory().getCreateMigration();
    for (var migration in migrations) {
      migration.create(batch);
    }
    await batch.commit();
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    final batch = db.batch();
    var migrations = SqfliteMigrationFactory().getUpgradeMigration(oldVersion);
    for (var migration in migrations) {
      migration.upgrade(batch);
    }
    await batch.commit();
  }

  Future<void> _onDowngrade(Database db, int oldVersion, int newVersion) async {
    final batch = db.batch();
    var migrations = SqfliteMigrationFactory().getDowngradeMigration(oldVersion);
    for (var migration in migrations) {
      migration.downgrade(batch);
    }
    await batch.commit();
  }
}
```

### Implementação das migrations

#### MigrationV1

```dart
class MigrationV1 implements Migration {
  @override
  void create(Batch batch) {
    batch.execute('''
      CREATE TABLE IF NOT EXISTS todo(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        descricao VARCHAR(500),
        data_hora DATETIME,
        finalizado INTEGER
      )
    ''');
  }

  @override
  void upgrade(Batch batch) {
    // Se não houver alterações, pode deixar vazio ou repetir o create
  }

  @override
  void downgrade(Batch batch) {
    batch.execute('DROP TABLE IF EXISTS todo');
  }
}
```

#### MigrationV2

```dart
class MigrationV2 implements Migration {
  @override
  void create(Batch batch) {
    batch.execute('''
      CREATE TABLE IF NOT EXISTS usuario(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        nome VARCHAR(50),
        data_nascimento DATETIME,
        senha VARCHAR(12)
      )
    ''');
  }

  @override
  void upgrade(Batch batch) {
    batch.execute('''
      ALTER TABLE todo ADD COLUMN prioridade INTEGER DEFAULT 0
    ''');
  }

  @override
  void downgrade(Batch batch) {
    batch.execute('''
      ALTER TABLE todo DROP COLUMN prioridade
    ''');
    batch.execute('DROP TABLE IF EXISTS usuario');
  }
}
```

## Considerações finais

- **Boas práticas**:
    
    - **Versão controlada**: Mantenha controle rigoroso das versões do banco de dados.
    - **Backups**: Considere implementar backups antes de aplicar migrations críticas.
    - **Testes**: Teste as migrations em um ambiente seguro antes de liberar para produção.
- **Ferramentas auxiliares**:
    
    - Pacotes como `moor` ou `drift` podem auxiliar no gerenciamento de bancos de dados no Flutter.
- **Gerenciamento de erros**:
    
    - Implemente tratamentos de exceção para lidar com possíveis falhas durante as migrations.

## Conclusão

As migrations são essenciais para manter a integridade e evolução do banco de dados em aplicativos Flutter que utilizam SQLite. Ao implementar um sistema de migrations bem estruturado, você garante que todos os usuários tenham uma experiência consistente, independentemente das atualizações que seu aplicativo venha a receber.

Lembre-se de sempre planejar cuidadosamente as alterações no banco de dados e testar exaustivamente as migrations para evitar problemas em produção.