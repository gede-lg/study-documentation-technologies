# Manipulando Banco de Dados SQLite no Flutter

## Sumário

1. [Introdução ao SQLite no Flutter](#introdução-ao-sqlite-no-flutter)
2. [Manipulando Dados com SQLite](#manipulando-dados-com-sqlite)
   - [.insert()](#insert)
   - [.update()](#update)
   - [.delete()](#delete)
   - [.query()](#query)
   - [.rawInsert()](#rawinsert)
   - [.rawUpdate()](#rawupdate)
   - [.rawDelete()](#rawdelete)
   - [.rawQuery()](#rawquery)
3. [Exemplos Práticos](#exemplos-práticos)
4. [Considerações Finais](#considerações-finais)

## Introdução ao SQLite no Flutter

O SQLite é um sistema de gerenciamento de banco de dados relacional leve e autônomo, amplamente utilizado em aplicativos móveis devido à sua eficiência e simplicidade. No Flutter, o pacote **sqflite** permite a integração com bancos de dados SQLite, oferecendo uma maneira robusta de armazenar e recuperar dados localmente.

Este guia detalha como manipular dados em um banco de dados SQLite usando o Flutter, focando nos métodos essenciais para operações CRUD (Create, Read, Update, Delete). Serão explorados os métodos `.insert()`, `.update()`, `.delete()`, `.query()` e suas variantes "raw", com explicações detalhadas de sintaxe, parâmetros e exemplos de código em Português do Brasil.

## Manipulando Dados com SQLite

Antes de iniciar, certifique-se de adicionar as dependências necessárias no arquivo `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  sqflite: ^2.0.0+3
  path: ^1.8.0
```

Importe os pacotes em seu arquivo Dart:

```dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
```

### .insert()

O método `.insert()` insere uma nova linha em uma tabela do banco de dados.

**Sintaxe:**

```dart
Future<int> insert(
  String table,
  Map<String, Object?> values, {
  String? nullColumnHack,
  ConflictAlgorithm? conflictAlgorithm,
})
```

**Parâmetros:**

- `table`: Nome da tabela.
- `values`: Mapa com os dados a serem inseridos (coluna: valor).
- `nullColumnHack`: (Opcional) Coluna que permite valor nulo.
- `conflictAlgorithm`: (Opcional) Estratégia para resolver conflitos (ex.: `ConflictAlgorithm.replace`).

**Exemplo:**

```dart
int id = await db.insert(
  'usuarios',
  {'nome': 'João', 'idade': 25},
  conflictAlgorithm: ConflictAlgorithm.replace,
);
```

### .update()

O método `.update()` atualiza linhas existentes na tabela.

**Sintaxe:**

```dart
Future<int> update(
  String table,
  Map<String, Object?> values, {
  String? where,
  List<Object?>? whereArgs,
  ConflictAlgorithm? conflictAlgorithm,
})
```

**Parâmetros:**

- `table`: Nome da tabela.
- `values`: Mapa com os dados a serem atualizados.
- `where`: (Opcional) Condição para selecionar as linhas.
- `whereArgs`: (Opcional) Argumentos para a condição `where`.
- `conflictAlgorithm`: (Opcional) Estratégia para resolver conflitos.

**Exemplo:**

```dart
int count = await db.update(
  'usuarios',
  {'idade': 26},
  where: 'nome = ?',
  whereArgs: ['João'],
);
```

### .delete()

O método `.delete()` remove linhas da tabela.

**Sintaxe:**

```dart
Future<int> delete(
  String table, {
  String? where,
  List<Object?>? whereArgs,
})
```

**Parâmetros:**

- `table`: Nome da tabela.
- `where`: (Opcional) Condição para selecionar as linhas.
- `whereArgs`: (Opcional) Argumentos para a condição `where`.

**Exemplo:**

```dart
int count = await db.delete(
  'usuarios',
  where: 'idade < ?',
  whereArgs: [18],
);
```

### .query()

O método `.query()` recupera dados da tabela.

**Sintaxe:**

```dart
Future<List<Map<String, Object?>>> query(
  String table, {
  bool? distinct,
  List<String>? columns,
  String? where,
  List<Object?>? whereArgs,
  String? groupBy,
  String? having,
  String? orderBy,
  int? limit,
  int? offset,
})
```

**Parâmetros:**

- `table`: Nome da tabela.
- `distinct`: (Opcional) Se verdadeiro, retorna valores distintos.
- `columns`: (Opcional) Colunas a serem retornadas.
- `where`: (Opcional) Condição para selecionar as linhas.
- `whereArgs`: (Opcional) Argumentos para a condição `where`.
- `groupBy`: (Opcional) Agrupa os resultados.
- `having`: (Opcional) Condição para grupos.
- `orderBy`: (Opcional) Ordena os resultados.
- `limit`: (Opcional) Limita o número de resultados.
- `offset`: (Opcional) Desloca o ponto de início dos resultados.

**Exemplo:**

```dart
List<Map<String, dynamic>> usuarios = await db.query(
  'usuarios',
  columns: ['nome', 'idade'],
  where: 'idade > ?',
  whereArgs: [18],
  orderBy: 'idade DESC',
);
```

### .rawInsert()

O método `.rawInsert()` executa uma instrução SQL INSERT direta.

**Sintaxe:**

```dart
Future<int> rawInsert(String sql, [List<Object?>? arguments])
```

**Parâmetros:**

- `sql`: Instrução SQL.
- `arguments`: (Opcional) Argumentos para a instrução SQL.

**Exemplo:**

```dart
int id = await db.rawInsert(
  'INSERT INTO usuarios(nome, idade) VALUES(?, ?)',
  ['Maria', 22],
);
```

### .rawUpdate()

O método `.rawUpdate()` executa uma instrução SQL UPDATE direta.

**Sintaxe:**

```dart
Future<int> rawUpdate(String sql, [List<Object?>? arguments])
```

**Exemplo:**

```dart
int count = await db.rawUpdate(
  'UPDATE usuarios SET idade = ? WHERE nome = ?',
  [23, 'Maria'],
);
```

### .rawDelete()

O método `.rawDelete()` executa uma instrução SQL DELETE direta.

**Sintaxe:**

```dart
Future<int> rawDelete(String sql, [List<Object?>? arguments])
```

**Exemplo:**

```dart
int count = await db.rawDelete(
  'DELETE FROM usuarios WHERE nome = ?',
  ['Maria'],
);
```

### .rawQuery()

O método `.rawQuery()` executa uma instrução SQL SELECT direta.

**Sintaxe:**

```dart
Future<List<Map<String, Object?>>> rawQuery(String sql, [List<Object?>? arguments])
```

**Exemplo:**

```dart
List<Map<String, dynamic>> resultados = await db.rawQuery(
  'SELECT * FROM usuarios WHERE idade BETWEEN ? AND ?',
  [20, 30],
);
```

## Exemplos Práticos

### Configurando o Banco de Dados

**Passo 1: Inicializar o banco de dados**

```dart
Future<Database> initializeDatabase() async {
  String path = join(await getDatabasesPath(), 'usuarios.db');
  return openDatabase(
    path,
    version: 1,
    onCreate: (db, version) {
      return db.execute(
        'CREATE TABLE usuarios(id INTEGER PRIMARY KEY AUTOINCREMENT, nome TEXT, idade INTEGER)',
      );
    },
  );
}
```

### Operações CRUD

**Inserir um usuário:**

```dart
Future<void> inserirUsuario(Database db, String nome, int idade) async {
  await db.insert(
    'usuarios',
    {'nome': nome, 'idade': idade},
    conflictAlgorithm: ConflictAlgorithm.replace,
  );
}
```

**Atualizar um usuário:**

```dart
Future<void> atualizarUsuario(Database db, int id, String nome, int idade) async {
  await db.update(
    'usuarios',
    {'nome': nome, 'idade': idade},
    where: 'id = ?',
    whereArgs: [id],
  );
}
```

**Deletar um usuário:**

```dart
Future<void> deletarUsuario(Database db, int id) async {
  await db.delete(
    'usuarios',
    where: 'id = ?',
    whereArgs: [id],
  );
}
```

**Consultar usuários:**

```dart
Future<List<Usuario>> listarUsuarios(Database db) async {
  final List<Map<String, dynamic>> maps = await db.query('usuarios');

  return List.generate(maps.length, (i) {
    return Usuario(
      id: maps[i]['id'],
      nome: maps[i]['nome'],
      idade: maps[i]['idade'],
    );
  });
}
```

**Classe Modelo `Usuario`:**

```dart
class Usuario {
  final int id;
  final String nome;
  final int idade;

  Usuario({required this.id, required this.nome, required this.idade});

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'nome': nome,
      'idade': idade,
    };
  }
}
```

### Utilizando Métodos "Raw"

**Inserir usuário com `rawInsert()`:**

```dart
Future<void> inserirUsuarioRaw(Database db, String nome, int idade) async {
  await db.rawInsert(
    'INSERT INTO usuarios(nome, idade) VALUES(?, ?)',
    [nome, idade],
  );
}
```

**Atualizar usuário com `rawUpdate()`:**

```dart
Future<void> atualizarUsuarioRaw(Database db, int id, String nome, int idade) async {
  await db.rawUpdate(
    'UPDATE usuarios SET nome = ?, idade = ? WHERE id = ?',
    [nome, idade, id],
  );
}
```

**Deletar usuário com `rawDelete()`:**

```dart
Future<void> deletarUsuarioRaw(Database db, int id) async {
  await db.rawDelete(
    'DELETE FROM usuarios WHERE id = ?',
    [id],
  );
}
```

**Consultar usuários com `rawQuery()`:**

```dart
Future<List<Usuario>> listarUsuariosRaw(Database db) async {
  final List<Map<String, dynamic>> maps = await db.rawQuery('SELECT * FROM usuarios');

  return List.generate(maps.length, (i) {
    return Usuario(
      id: maps[i]['id'],
      nome: maps[i]['nome'],
      idade: maps[i]['idade'],
    );
  });
}
```

## Considerações Finais

A manipulação de dados com SQLite no Flutter utilizando o pacote `sqflite` é essencial para aplicativos que necessitam de armazenamento local robusto. Compreender os métodos e suas aplicações permite criar soluções eficientes e seguras.

**Dicas Importantes:**

- **Segurança:** Sempre use `?` e `whereArgs` ou `arguments` nos métodos brutos para evitar SQL Injection.
- **Desempenho:** Utilize transações (`db.transaction()`) quando executar múltiplas operações que dependem umas das outras.
- **Modelagem:** Considere criar classes modelo para facilitar a manipulação de dados.
- **Debugging:** Use `print()` para visualizar as consultas e resultados durante o desenvolvimento.

---

Com este conhecimento, você está pronto para implementar funcionalidades avançadas de banco de dados em seus aplicativos Flutter. Pratique e experimente diferentes cenários para dominar o uso do SQLite no Flutter.