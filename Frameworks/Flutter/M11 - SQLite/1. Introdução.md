# Introdução

O desenvolvimento de aplicativos móveis modernos frequentemente requer a capacidade de armazenar dados localmente no dispositivo do usuário. Isso é essencial para funcionalidades como manter dados disponíveis offline, melhorar a performance do aplicativo ou armazenar preferências do usuário. Neste contexto, o SQLite emerge como uma solução popular e eficiente para gerenciamento de bancos de dados locais.

Flutter, sendo um framework de desenvolvimento multiplataforma da Google, oferece diversas ferramentas para integrar o SQLite em seus aplicativos. Neste artigo, exploraremos detalhadamente como utilizar o SQLite no Flutter, desde os conceitos básicos até a implementação prática com exemplos de código.

# Sumário

1. [O que é SQLite e para que serve?](#1-o-que-é-sqlite-e-para-que-serve)
2. [Como usar SQLite no Flutter?](#2-como-usar-sqlite-no-flutter)
   - 2.1 [Configurando o projeto](#21-configurando-o-projeto)
   - 2.2 [Criando a classe de modelo](#22-criando-a-classe-de-modelo)
   - 2.3 [Implementando a classe de banco de dados](#23-implementando-a-classe-de-banco-de-dados)
3. [Sintaxe de uso](#3-sintaxe-de-uso)
   - 3.1 [Inserção de dados](#31-inserção-de-dados)
   - 3.2 [Leitura de dados](#32-leitura-de-dados)
   - 3.3 [Atualização de dados](#33-atualização-de-dados)
   - 3.4 [Exclusão de dados](#34-exclusão-de-dados)
4. [Restrições de uso](#4-restrições-de-uso)
5. [Quando utilizar?](#5-quando-utilizar)
6. [Considerações finais](#6-considerações-finais)

# 1. O que é SQLite e para que serve?

SQLite é um sistema de gerenciamento de banco de dados relacional (RDBMS) leve e autônomo, que não requer um servidor separado para operar. Ele é amplamente utilizado em aplicações que necessitam de um banco de dados embutido e não precisam da complexidade de um sistema cliente-servidor completo.

**Principais características do SQLite:**

- **Autônomo**: Não requer instalação ou configuração de um servidor de banco de dados separado.
- **Leve**: Ocupa pouco espaço em disco e consome poucos recursos de memória.
- **Portátil**: Compatível com diversas plataformas, incluindo Android e iOS.
- **Confiável**: Suporta transações ACID (Atomicidade, Consistência, Isolamento e Durabilidade).

**Para que serve?**

- **Armazenamento local de dados**: Ideal para aplicativos que precisam armazenar dados no dispositivo do usuário.
- **Operações offline**: Permite que o aplicativo funcione sem conexão à internet.
- **Persistência de dados**: Mantém informações importantes, como preferências do usuário, histórico, cache, entre outros.

# 2. Como usar SQLite no Flutter?

Para utilizar o SQLite no Flutter, geralmente utilizamos o pacote **sqflite**, que é um plugin Flutter popular para trabalhar com bancos de dados SQLite.

## 2.1 Configurando o projeto

1. **Adicionar dependência no pubspec.yaml:**

```yaml
dependencies:
  flutter:
    sdk: flutter
  sqflite: ^2.0.0+4
  path: ^1.8.0
```

2. **Importar os pacotes necessários no arquivo Dart:**

```dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
```

## 2.2 Criando a classe de modelo

Suponhamos que estamos criando um aplicativo de tarefas (to-do list). Primeiro, definimos uma classe `Task` que representará cada tarefa.

```dart
class Task {
  int? id;
  String title;
  String description;

  Task({this.id, required this.title, required this.description});

  // Converter um Task em um Map
  Map<String, dynamic> toMap() {
    var map = <String, dynamic>{
      'title': title,
      'description': description,
    };
    if (id != null) {
      map['id'] = id;
    }
    return map;
  }

  // Converter um Map em um Task
  factory Task.fromMap(Map<String, dynamic> map) {
    return Task(
      id: map['id'],
      title: map['title'],
      description: map['description'],
    );
  }
}
```

## 2.3 Implementando a classe de banco de dados

Criamos uma classe `DatabaseHelper` para gerenciar as operações do banco de dados.

```dart
class DatabaseHelper {
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  factory DatabaseHelper() => _instance;

  static Database? _database;

  DatabaseHelper._internal();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  // Inicializar o banco de dados
  Future<Database> _initDatabase() async {
    String path = join(await getDatabasesPath(), 'tasks.db');
    return await openDatabase(
      path,
      version: 1,
      onCreate: _onCreate,
    );
  }

  // Criar a tabela
  Future _onCreate(Database db, int version) async {
    await db.execute('''
      CREATE TABLE tasks(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT NOT NULL
      )
    ''');
  }

  // Métodos CRUD serão implementados aqui
}
```

# 3. Sintaxe de uso

## 3.1 Inserção de dados

Para inserir dados no banco, adicionamos um método `insertTask` na classe `DatabaseHelper`.

```dart
Future<int> insertTask(Task task) async {
  Database db = await database;
  return await db.insert('tasks', task.toMap());
}
```

**Uso:**

```dart
DatabaseHelper dbHelper = DatabaseHelper();
Task newTask = Task(title: 'Estudar Flutter', description: 'Aprender sobre SQLite');
await dbHelper.insertTask(newTask);
```

## 3.2 Leitura de dados

Para recuperar dados, implementamos um método `getTasks`.

```dart
Future<List<Task>> getTasks() async {
  Database db = await database;
  List<Map<String, dynamic>> maps = await db.query('tasks');
  return List.generate(maps.length, (i) {
    return Task.fromMap(maps[i]);
  });
}
```

**Uso:**

```dart
List<Task> tasks = await dbHelper.getTasks();
tasks.forEach((task) {
  print('Título: ${task.title}, Descrição: ${task.description}');
});
```

## 3.3 Atualização de dados

Método `updateTask` para atualizar uma tarefa existente.

```dart
Future<int> updateTask(Task task) async {
  Database db = await database;
  return await db.update(
    'tasks',
    task.toMap(),
    where: 'id = ?',
    whereArgs: [task.id],
  );
}
```

**Uso:**

```dart
Task updatedTask = Task(id: 1, title: 'Estudar Flutter', description: 'Aprender sobre Provider');
await dbHelper.updateTask(updatedTask);
```

## 3.4 Exclusão de dados

Método `deleteTask` para remover uma tarefa.

```dart
Future<int> deleteTask(int id) async {
  Database db = await database;
  return await db.delete(
    'tasks',
    where: 'id = ?',
    whereArgs: [id],
  );
}
```

**Uso:**

```dart
await dbHelper.deleteTask(1);
```

# 4. Restrições de uso

- **Assíncrono**: Todas as operações do sqflite são assíncronas, portanto, o uso de `async` e `await` é essencial.
- **Tipo de Dados**: O SQLite aceita tipos de dados limitados (INTEGER, REAL, TEXT, BLOB, NULL). Certifique-se de mapear corretamente os tipos do Dart para os tipos do SQLite.
- **Múltiplas Instâncias**: Evite múltiplas instâncias da conexão do banco de dados para prevenir problemas de concorrência.
- **Transações**: Para operações complexas, considere o uso de transações para garantir a integridade dos dados.

# 5. Quando utilizar?

- **Aplicativos Offline**: Quando o aplicativo precisa funcionar sem conexão à internet e requer armazenamento local de dados.
- **Persistência Local**: Para armazenar dados que não precisam ser sincronizados com um servidor remoto.
- **Desempenho**: Quando o acesso a dados locais é mais rápido e eficiente do que buscar dados de uma API remota.

# 6. Considerações finais

Integrar o SQLite em aplicativos Flutter é uma maneira poderosa de gerenciar dados localmente. Com o uso do pacote sqflite, podemos realizar operações de banco de dados de forma eficiente e segura. É importante seguir boas práticas, como evitar operações pesadas na thread principal e gerenciar adequadamente o ciclo de vida do banco de dados.

**Dicas adicionais:**

- **Moor (Drift)**: Considere o uso do pacote [Drift](https://drift.simonbinder.eu/) (anteriormente conhecido como Moor), que oferece uma camada de abstração sobre o sqflite, permitindo o uso de consultas SQL tipadas e geração automática de código.
- **Segurança**: Se os dados armazenados são sensíveis, considere implementar criptografia no banco de dados.
- **Migrações**: Planeje antecipadamente as migrações de banco de dados para acomodar mudanças futuras no esquema.

---

Esperamos que este guia tenha esclarecido como utilizar o SQLite no Flutter. Com estas informações, você está pronto para implementar um banco de dados local eficiente em seus aplicativos.