# Introdução ao SQLite no Flutter

O Flutter é um framework da Google para desenvolvimento de aplicativos móveis multiplataforma com alto desempenho. Para muitos aplicativos, é essencial armazenar dados localmente no dispositivo. Uma das soluções mais populares para isso é o SQLite, um sistema de gerenciamento de banco de dados relacional embutido. No Flutter, usamos o pacote `sqflite` para interagir com bancos de dados SQLite de forma fácil e eficiente.

Este guia fornecerá uma explicação minuciosa sobre o uso do SQLite no Flutter, focando nos métodos da classe `Database` fornecida pelo pacote `sqflite`. Abordaremos cada método detalhadamente, incluindo sua finalidade, como usá-lo, sintaxe, restrições e quando utilizá-lo. Além disso, forneceremos exemplos de código em Português do Brasil para ilustrar cada ponto.

# Sumário

1. [Configuração Inicial](#1-configuração-inicial)
2. [Métodos Principais da Classe Database](#2-métodos-principais-da-classe-database)
   - [openDatabase](#openDatabase)
   - [close](#close)
   - [execute](#execute)
   - [insert](#insert)
   - [query](#query)
   - [update](#update)
   - [delete](#delete)
   - [batch](#batch)
   - [transaction](#transaction)
   - [rawQuery](#rawQuery)
   - [rawInsert](#rawInsert)
   - [rawUpdate](#rawUpdate)
   - [rawDelete](#rawDelete)
   - [getVersion e setVersion](#getVersion-e-setVersion)
   - [onCreate, onUpgrade e onDowngrade](#onCreate-onUpgrade-e-onDowngrade)
3. [Considerações Finais](#3-considerações-finais)

# 1. Configuração Inicial

Antes de começarmos a utilizar o SQLite no Flutter, precisamos configurar nosso projeto para incluir o pacote `sqflite`. Além disso, usaremos o pacote `path` para auxiliar na obtenção do caminho correto para o banco de dados.

**Passos:**

1. **Adicionar dependências no `pubspec.yaml`:**

```yaml
dependencies:
  flutter:
    sdk: flutter
  sqflite: ^2.0.0+4
  path: ^1.8.0
```

2. **Importar os pacotes no arquivo Dart:**

```dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
```

3. **Abrir/Criar o banco de dados:**

Crie uma função que abra o banco de dados, especificando o caminho, a versão e os callbacks necessários.

```dart
Future<Database> abrirBancoDeDados() async {
  final databasePath = await getDatabasesPath();
  final path = join(databasePath, 'meu_banco.db');

  return openDatabase(
    path,
    version: 1,
    onCreate: (db, version) async {
      // Crie as tabelas iniciais
      await db.execute(
        'CREATE TABLE usuarios(id INTEGER PRIMARY KEY, nome TEXT, idade INTEGER)',
      );
    },
  );
}
```

# 2. Métodos Principais da Classe `Database`

A classe `Database` do pacote `sqflite` fornece uma série de métodos para manipulação de dados. Vamos explorar cada um deles detalhadamente.

## openDatabase

### O que é e para que serve?

O método `openDatabase` é utilizado para abrir (ou criar, se não existir) um banco de dados SQLite. Ele estabelece a conexão com o banco de dados e permite que você realize operações de leitura e escrita.

### Como fazer?

Use o método `openDatabase` fornecendo o caminho do banco de dados, a versão e os callbacks necessários para criação e atualização do esquema.

### Sintaxe de uso

```dart
Future<Database> openDatabase(
  String path, {
  int version,
  OnDatabaseCreateFn onCreate,
  OnDatabaseVersionChangeFn onUpgrade,
  OnDatabaseVersionChangeFn onDowngrade,
  OnDatabaseOpenFn onOpen,
  bool readOnly = false,
  bool singleInstance = true,
})
```

### Restrições de uso

- O caminho deve ser válido e acessível.
- Se `singleInstance` for `true`, o banco de dados será aberto como uma única instância para evitar conflitos.

### Quando utilizar?

Sempre que precisar abrir uma conexão com o banco de dados SQLite no Flutter.

## close

### O que é e para que serve?

O método `close` fecha a conexão com o banco de dados, liberando os recursos associados.

### Como fazer?

Chame `close()` na instância do `Database`.

### Sintaxe de uso

```dart
Future<void> close()
```

### Restrições de uso

- Após fechar o banco de dados, não é possível realizar operações nele até reabri-lo.
- Deve ser chamado quando o banco de dados não for mais necessário.

### Quando utilizar?

Para liberar recursos, especialmente em aplicativos que mantêm o banco de dados aberto por longos períodos.

## execute

### O que é e para que serve?

O método `execute` executa comandos SQL que não retornam resultados, como `CREATE`, `ALTER`, `DROP`, `INSERT`, `UPDATE`, ou `DELETE`.

### Como fazer?

Forneça uma string contendo o comando SQL e, opcionalmente, uma lista de argumentos para evitar injeção de SQL.

### Sintaxe de uso

```dart
Future<void> execute(String sql, [List<Object?>? arguments])
```

### Restrições de uso

- Não retorna nenhum resultado.
- Deve ser usado para comandos que modificam o esquema ou dados sem necessidade de retorno.

### Quando utilizar?

Ao criar ou modificar tabelas e quando inserir ou atualizar dados sem precisar do resultado imediato.

#### Exemplo

```dart
await db.execute(
  'CREATE TABLE produtos(id INTEGER PRIMARY KEY, nome TEXT, preco REAL)',
);
```

## insert

### O que é e para que serve?

Insere um novo registro em uma tabela especificada.

### Como fazer?

Use o método `insert` fornecendo o nome da tabela e um mapa de valores.

### Sintaxe de uso

```dart
Future<int> insert(
  String table,
  Map<String, Object?> values, {
  String? nullColumnHack,
  ConflictAlgorithm? conflictAlgorithm,
})
```

### Restrições de uso

- As chaves do mapa devem corresponder aos nomes das colunas na tabela.
- `nullColumnHack` pode ser usado para inserir linhas com valores nulos.

### Quando utilizar?

Sempre que precisar adicionar um novo registro à tabela.

#### Exemplo

```dart
Map<String, dynamic> novoUsuario = {
  'nome': 'Maria',
  'idade': 25,
};

int id = await db.insert(
  'usuarios',
  novoUsuario,
  conflictAlgorithm: ConflictAlgorithm.replace,
);
```

## query

### O que é e para que serve?

Recupera registros de uma tabela com base em critérios especificados.

### Como fazer?

Use o método `query` fornecendo o nome da tabela e, opcionalmente, condições e ordenação.

### Sintaxe de uso

```dart
Future<List<Map<String, Object?>>> query(
  String table, {
  bool? distinct,
  List<String>? columns,
  String? where,
  List<Object?>? whereArgs,
  String? groupBy,
  String? having,
  String? orderBy,
  int? limit,
  int? offset,
})
```

### Restrições de uso

- Use `whereArgs` em vez de concatenar valores na string `where` para evitar injeção de SQL.
- As colunas especificadas devem existir na tabela.

### Quando utilizar?

Para recuperar dados do banco de dados de forma segura e estruturada.

#### Exemplo

```dart
List<Map<String, dynamic>> usuarios = await db.query(
  'usuarios',
  columns: ['id', 'nome', 'idade'],
  where: 'idade > ?',
  whereArgs: [20],
  orderBy: 'idade DESC',
);
```

## update

### O que é e para que serve?

Atualiza registros existentes em uma tabela.

### Como fazer?

Use o método `update` fornecendo o nome da tabela, os novos valores e as condições para selecionar os registros a serem atualizados.

### Sintaxe de uso

```dart
Future<int> update(
  String table,
  Map<String, Object?> values, {
  String? where,
  List<Object?>? whereArgs,
  ConflictAlgorithm? conflictAlgorithm,
})
```

### Restrições de uso

- Sem um `where`, todas as linhas serão atualizadas.
- Use `whereArgs` para evitar injeção de SQL.

### Quando utilizar?

Quando precisar modificar registros existentes com novos valores.

#### Exemplo

```dart
int count = await db.update(
  'usuarios',
  {'idade': 26},
  where: 'nome = ?',
  whereArgs: ['Maria'],
);
```

## delete

### O que é e para que serve?

Remove registros de uma tabela com base em condições especificadas.

### Como fazer?

Use o método `delete` fornecendo o nome da tabela e as condições.

### Sintaxe de uso

```dart
Future<int> delete(
  String table, {
  String? where,
  List<Object?>? whereArgs,
})
```

### Restrições de uso

- Sem um `where`, todas as linhas serão excluídas.
- Use `whereArgs` para evitar injeção de SQL.

### Quando utilizar?

Para remover registros específicos ou limpar uma tabela.

#### Exemplo

```dart
int count = await db.delete(
  'usuarios',
  where: 'idade < ?',
  whereArgs: [18],
);
```

## batch

### O que é e para que serve?

Permite agrupar múltiplas operações (inserções, atualizações, exclusões) em um único lote, melhorando o desempenho.

### Como fazer?

Crie um objeto `Batch`, adicione operações e, em seguida, execute o batch.

### Sintaxe de uso

```dart
Batch batch = db.batch();
// Adicionar operações ao batch
batch.insert('usuarios', {'nome': 'João', 'idade': 30});
batch.update('usuarios', {'idade': 31}, where: 'nome = ?', whereArgs: ['João']);
batch.delete('usuarios', where: 'idade = ?', whereArgs: [31]);
// Executar o batch
await batch.commit();
```

### Restrições de uso

- As operações no batch são executadas de forma atômica.
- O resultado das operações pode ser obtido se especificado.

### Quando utilizar?

Quando precisar executar múltiplas operações que podem ser agrupadas para melhor desempenho.

## transaction

### O que é e para que serve?

Executa uma série de operações dentro de uma transação. Se uma das operações falhar, todas são revertidas.

### Como fazer?

Use o método `transaction` fornecendo uma função que recebe uma instância de `Transaction`.

### Sintaxe de uso

```dart
Future<T> transaction<T>(
  Future<T> Function(Transaction txn) action, {
  bool? exclusive,
})
```

### Restrições de uso

- Todas as operações dentro da transação devem usar o objeto `Transaction`.
- Evite operações que bloqueiem a transação por muito tempo.

### Quando utilizar?

Para garantir a integridade dos dados ao executar múltiplas operações dependentes.

#### Exemplo

```dart
await db.transaction((txn) async {
  await txn.insert('usuarios', {'nome': 'Carlos', 'idade': 28});
  await txn.update('usuarios', {'idade': 29}, where: 'nome = ?', whereArgs: ['Carlos']);
});
```

## rawQuery

### O que é e para que serve?

Executa uma consulta SQL bruta, permitindo comandos SQL complexos que não são suportados pelo método `query`.

### Como fazer?

Forneça a string SQL e, opcionalmente, uma lista de argumentos.

### Sintaxe de uso

```dart
Future<List<Map<String, Object?>>> rawQuery(
  String sql, [
  List<Object?>? arguments,
])
```

### Restrições de uso

- Maior risco de injeção de SQL; sempre use `?` e `arguments`.
- Não é recomendado para consultas simples.

### Quando utilizar?

Para executar consultas complexas que não podem ser realizadas com o método `query`.

#### Exemplo

```dart
List<Map> resultado = await db.rawQuery(
  'SELECT nome, COUNT(*) as total FROM usuarios GROUP BY nome HAVING total > 1',
);
```

## rawInsert

### O que é e para que serve?

Insere dados usando uma instrução SQL bruta.

### Como fazer?

Forneça a instrução SQL e, opcionalmente, uma lista de argumentos.

### Sintaxe de uso

```dart
Future<int> rawInsert(
  String sql, [
  List<Object?>? arguments,
])
```

### Restrições de uso

- Use com cuidado para evitar injeção de SQL.
- Preferível usar o método `insert` quando possível.

### Quando utilizar?

Quando precisar executar uma inserção complexa não suportada pelo método `insert`.

#### Exemplo

```dart
int id = await db.rawInsert(
  'INSERT INTO usuarios(nome, idade) VALUES(?, ?)',
  ['Fernando', 32],
);
```

## rawUpdate

### O que é e para que serve?

Atualiza dados usando uma instrução SQL bruta.

### Como fazer?

Forneça a instrução SQL e uma lista de argumentos.

### Sintaxe de uso

```dart
Future<int> rawUpdate(
  String sql, [
  List<Object?>? arguments,
])
```

### Restrições de uso

- Risco de injeção de SQL; use `?` e `arguments`.
- Use o método `update` quando possível.

### Quando utilizar?

Para atualizações complexas não suportadas pelo método `update`.

#### Exemplo

```dart
int count = await db.rawUpdate(
  'UPDATE usuarios SET idade = ? WHERE nome = ?',
  [33, 'Fernando'],
);
```

## rawDelete

### O que é e para que serve?

Exclui registros usando uma instrução SQL bruta.

### Como fazer?

Forneça a instrução SQL e uma lista de argumentos.

### Sintaxe de uso

```dart
Future<int> rawDelete(
  String sql, [
  List<Object?>? arguments,
])
```

### Restrições de uso

- Risco de injeção de SQL; use `?` e `arguments`.
- Prefira o método `delete` quando possível.

### Quando utilizar?

Para exclusões complexas não suportadas pelo método `delete`.

#### Exemplo

```dart
int count = await db.rawDelete(
  'DELETE FROM usuarios WHERE idade = ?',
  [33],
);
```

## getVersion e setVersion

### O que é e para que serve?

`getVersion` retorna a versão atual do banco de dados. `setVersion` define uma nova versão para o banco de dados.

### Como fazer?

Chame `getVersion()` ou `setVersion(novaVersao)` na instância do `Database`.

### Sintaxe de uso

```dart
Future<int> getVersion()
Future<void> setVersion(int version)
```

### Restrições de uso

- Usado para controle de versões do esquema do banco de dados.
- Alterações na versão podem disparar os callbacks `onUpgrade` ou `onDowngrade`.

### Quando utilizar?

Para verificar ou atualizar a versão do banco de dados, geralmente durante migrações.

#### Exemplo

```dart
int versaoAtual = await db.getVersion();
print('Versão atual do banco de dados: $versaoAtual');

await db.setVersion(2);
```

## onCreate, onUpgrade e onDowngrade

### O que é e para que serve?

São callbacks usados durante a abertura do banco de dados para criar ou atualizar o esquema conforme necessário.

- `onCreate`: chamado quando o banco de dados é criado pela primeira vez.
- `onUpgrade`: chamado quando a versão do banco de dados é aumentada.
- `onDowngrade`: chamado quando a versão do banco de dados é diminuída.

### Como fazer?

Defina funções para esses callbacks ao usar `openDatabase`.

### Sintaxe de uso

```dart
openDatabase(
  path,
  version: novaVersao,
  onCreate: (Database db, int version) async {
    // Código para criar o banco de dados
  },
  onUpgrade: (Database db, int oldVersion, int newVersion) async {
    // Código para atualizar o banco de dados
  },
  onDowngrade: (Database db, int oldVersion, int newVersion) async {
    // Código para reverter atualizações
  },
)
```

### Restrições de uso

- É importante gerenciar corretamente as migrações para evitar perda de dados.
- As funções devem ser assíncronas se realizarem operações no banco de dados.

### Quando utilizar?

Durante a configuração inicial do banco de dados e ao atualizar o esquema em novas versões do aplicativo.

#### Exemplo

```dart
onUpgrade: (Database db, int oldVersion, int newVersion) async {
  if (oldVersion < 2) {
    await db.execute('ALTER TABLE usuarios ADD COLUMN email TEXT');
  }
}
```

# 3. Considerações Finais

A integração do SQLite no Flutter através do pacote `sqflite` oferece uma maneira robusta e eficiente de armazenar dados localmente em aplicativos móveis. Compreender os métodos da classe `Database` é fundamental para manipular o banco de dados de forma segura e eficaz.

**Dicas Adicionais:**

- **Segurança:** Sempre use parâmetros nomeados (`?`) e `whereArgs` para evitar injeção de SQL.
- **Desempenho:** Utilize `batch` ou `transaction` para operações em massa ou críticas.
- **Boas Práticas:** Feche o banco de dados com `close()` quando ele não for mais necessário.
- **Migrações:** Planeje e teste cuidadosamente as migrações de esquema usando `onUpgrade` e `onDowngrade`.

**Exemplo Completo:**

```dart
Future<void> exemploCompleto() async {
  // Abrir o banco de dados
  final db = await abrirBancoDeDados();

  // Inserir um novo usuário
  await db.insert('usuarios', {'nome': 'Ana', 'idade': 22});

  // Atualizar a idade de um usuário
  await db.update(
    'usuarios',
    {'idade': 23},
    where: 'nome = ?',
    whereArgs: ['Ana'],
  );

  // Recuperar todos os usuários
  List<Map<String, dynamic>> usuarios = await db.query('usuarios');
  for (var usuario in usuarios) {
    print('Usuário: ${usuario['nome']}, Idade: ${usuario['idade']}');
  }

  // Deletar um usuário
  await db.delete(
    'usuarios',
    where: 'nome = ?',
    whereArgs: ['Ana'],
  );

  // Fechar o banco de dados
  await db.close();
}
```

Com este guia, esperamos que você tenha uma compreensão sólida de como utilizar o SQLite no Flutter e esteja pronto para implementar funcionalidades de armazenamento local em seus aplicativos.

# Referências

- [Documentação do sqflite](https://pub.dev/packages/sqflite)
- [SQLite Tutorial](https://www.sqlitetutorial.net/)
- [Guia de Início Rápido do Flutter](https://flutter.dev/docs)

---

Se você tiver alguma dúvida ou precisar de mais informações, sinta-se à vontade para perguntar!