### Estrutura de Pastas dentro da `lib` no Flutter baseada na Arquitetura Limpa

A organização da estrutura de pastas dentro da pasta `lib` no Flutter é crucial para manter a aplicação escalável, modular e de fácil manutenção. Seguindo os princípios da Arquitetura Limpa, a estrutura proposta a seguir visa dividir e suportar arquivos separados por responsabilidades claras. Cada pasta e subpasta desempenha um papel específico na organização do código, garantindo que a aplicação seja modular e que as dependências sejam bem gerenciadas.

#### Estrutura de Pastas Completa

```plaintext
lib/
│
├── core/
│   ├── config/
│   ├── errors/
│   ├── usecases/
│   ├── utils/
│   └── theme/
│
├── features/
│   ├── authentication/
│   │   ├── data/
│   │   │   ├── models/
│   │   │   ├── datasources/
│   │   │   └── repositories/
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   ├── repositories/
│   │   │   └── usecases/
│   │   └── presentation/
│   │       ├── bloc/
│   │       ├── screens/
│   │       └── widgets/
│   │
│   └── home/
│       ├── data/
│       ├── domain/
│       └── presentation/
│
└── shared/
    ├── components/
    ├── widgets/
    ├── styles/
    └── helpers/
```

### Descrição das Pastas

#### `core/`
- **O que é e para que serve?**  
  A pasta `core/` contém todos os elementos essenciais e comuns à aplicação inteira, que não pertencem a nenhuma feature específica. Isso inclui configuração global, manipulação de erros, casos de uso genéricos, temas e utilitários.
- **Quais tipos de arquivos devem ser armazenados dentro?**
  - `config/`: Arquivos de configuração (por exemplo, `env_config.dart`).
  - `errors/`: Classes de tratamento de erros e exceções globais.
  - `usecases/`: Implementação de casos de uso que podem ser reutilizados por várias features.
  - `utils/`: Funções e métodos utilitários que são usados em mais de uma feature.
  - `theme/`: Definições de tema, como cores, fontes e estilos globais.
- **Restrições de uso:**  
  Esta pasta deve conter apenas elementos reutilizáveis e globais. Evite colocar lógicas de negócio específicas de uma feature aqui.
- **Quando utilizar?**  
  Use a pasta `core/` quando precisar de recursos que são comuns a toda a aplicação e não pertencem a uma feature específica.

#### `features/`
- **O que é e para que serve?**  
  A pasta `features/` organiza a aplicação em funcionalidades específicas (ou módulos). Cada funcionalidade é autocontida e possui suas próprias subpastas para dados, domínio e apresentação.
- **Quais tipos de arquivos devem ser armazenados dentro?**
  - `data/`: Modelos, fontes de dados e implementações de repositórios.
  - `domain/`: Entidades, repositórios abstratos e casos de uso específicos da feature.
  - `presentation/`: Gerenciadores de estado (como BLoC ou Provider), telas (screens) e widgets específicos da feature.
- **Restrições de uso:**  
  Cada feature deve ser independente e autocontida. Evite a importação cruzada direta de classes entre features sem utilizar interfaces ou abstrações.
- **Quando utilizar?**  
  Use a pasta `features/` para segmentar a aplicação em módulos funcionais que podem ser desenvolvidos, testados e mantidos de forma independente.

#### `shared/`
- **O que é e para que serve?**  
  A pasta `shared/` contém elementos que são compartilhados entre várias features, como componentes de UI reutilizáveis, estilos comuns e helpers.
- **Quais tipos de arquivos devem ser armazenados dentro?**
  - `components/`: Componentes de UI complexos reutilizáveis.
  - `widgets/`: Widgets simples e reutilizáveis que não pertencem a uma feature específica.
  - `styles/`: Estilos de UI comuns, como temas específicos ou text styles.
  - `helpers/`: Funções de ajuda que são utilizadas em várias partes do código.
- **Restrições de uso:**  
  Não coloque lógicas de negócio dentro da pasta `shared/`. Apenas elementos reutilizáveis e que não pertencem a uma feature específica devem estar aqui.
- **Quando utilizar?**  
  Use a pasta `shared/` para armazenar elementos de UI e lógica que serão usados em múltiplas partes da aplicação.

### Exemplos de Código

#### `core/errors/failure.dart`

```dart
abstract class Failure {
  final String message;
  const Failure(this.message);
}

class ServerFailure extends Failure {
  const ServerFailure(String message) : super(message);
}

class CacheFailure extends Failure {
  const CacheFailure(String message) : super(message);
}
```

#### `features/authentication/data/models/user_model.dart`

```dart
import '../../domain/entities/user.dart';

class UserModel extends User {
  UserModel({required String id, required String name}) 
      : super(id: id, name: name);

  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id'],
      name: json['name'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
    };
  }
}
```

#### `features/authentication/presentation/bloc/auth_bloc.dart`

```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../domain/usecases/get_user.dart';

class AuthBloc extends Bloc<AuthEvent, AuthState> {
  final GetUser getUser;

  AuthBloc({required this.getUser}) : super(AuthInitial());

  @override
  Stream<AuthState> mapEventToState(AuthEvent event) async* {
    if (event is GetUserEvent) {
      yield AuthLoading();
      final failureOrUser = await getUser(event.id);
      yield failureOrUser.fold(
        (failure) => AuthError(message: _mapFailureToMessage(failure)),
        (user) => AuthLoaded(user: user),
      );
    }
  }

  String _mapFailureToMessage(Failure failure) {
    switch (failure.runtimeType) {
      case ServerFailure:
        return 'Problema com o servidor';
      case CacheFailure:
        return 'Erro no cache';
      default:
        return 'Erro desconhecido';
    }
  }
}
```

### Considerações Finais

1. **Modularidade:** A separação das pastas por responsabilidades garante que cada módulo do sistema seja autocontido e facilmente testável.
2. **Escalabilidade:** Com essa estrutura, a aplicação pode crescer de forma orgânica sem se tornar um monólito impossível de manter.
3. **Reutilização:** O uso das pastas `shared/` e `core/` garante que componentes e utilitários sejam reutilizados de maneira eficiente, evitando a duplicação de código.

Essa estrutura bem definida é essencial para projetos complexos e de longa duração, permitindo que novos desenvolvedores se integrem rapidamente ao projeto e que as alterações sejam feitas com segurança e clareza.