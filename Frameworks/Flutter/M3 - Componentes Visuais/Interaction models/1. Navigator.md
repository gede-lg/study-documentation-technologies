# Widget `Navigator` no Flutter

## O que é e para que serve?

O widget `Navigator` no Flutter é um dos componentes mais fundamentais e poderosos do framework. Ele gerencia um conjunto de widgets que formam uma pilha, onde cada widget na pilha representa uma "página" ou "tela" da interface do usuário. A navegação entre essas páginas é feita através do empilhamento e desempilhamento de widgets, o que permite mover-se entre diferentes telas de um aplicativo.

Em termos simples, o `Navigator` funciona como uma pilha de "rotas" (ou páginas), onde:

- **Empilhar (push)**: Adiciona uma nova rota (tela) no topo da pilha, o que exibe essa nova tela para o usuário.
- **Desempilhar (pop)**: Remove a rota do topo da pilha, retornando à tela anterior.

### Exemplos de uso prático

- **Navegação entre telas**: Usar o `Navigator` para navegar entre diferentes telas de um aplicativo.
- **Modais**: Apresentar uma nova tela de forma modal, como um diálogo ou formulário.
- **Navegação condicional**: Redirecionar o usuário para diferentes telas com base em condições lógicas, como a autenticação.

## Sintaxe de uso

A sintaxe básica para utilizar o `Navigator` é:

```dart
// Empilhando uma nova rota (navegando para uma nova tela)
Navigator.push(
  context,
  MaterialPageRoute(builder: (context) => NovaTela()),
);

// Desempilhando a rota atual (voltando para a tela anterior)
Navigator.pop(context);
```

Aqui está um exemplo simples de navegação entre duas telas:

```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: PrimeiraTela(),
    );
  }
}

class PrimeiraTela extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Primeira Tela')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              MaterialPageRoute(builder: (context) => SegundaTela()),
            );
          },
          child: Text('Ir para a Segunda Tela'),
        ),
      ),
    );
  }
}

class SegundaTela extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Segunda Tela')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.pop(context);
          },
          child: Text('Voltar para a Primeira Tela'),
        ),
      ),
    );
  }
}
```

## Restrições de uso

Embora o `Navigator` seja bastante versátil, existem algumas restrições e boas práticas a serem seguidas:

- **Contexto adequado**: Sempre utilize o contexto correto ao chamar `Navigator.push` ou `Navigator.pop`. Evite chamar o `Navigator` em contextos onde a navegação pode não estar disponível (como durante o processo de construção do widget).
- **Gestão de estado**: Em aplicativos complexos, gerenciar o estado de navegação pode ser desafiador. Utilize pacotes de gerenciamento de estado (como `Provider` ou `Bloc`) para manter a navegação clara e organizada.
- **Rotas nomeadas**: Para facilitar a navegação em grandes aplicativos, considere o uso de rotas nomeadas em vez de rotas anônimas.

## Quando utilizar?

Você deve utilizar o widget `Navigator` sempre que precisar de navegação em pilha em seu aplicativo. Isso inclui cenários como:

- Navegação entre diferentes telas do aplicativo.
- Apresentação de telas de forma modal (como diálogos).
- Implementação de fluxos de trabalho onde os usuários devem seguir uma sequência de telas.

## Tabela com todas as propriedades

| Propriedade                | Descrição                                                                 | Sintaxe de Uso                                      |
|----------------------------|---------------------------------------------------------------------------|----------------------------------------------------|
| `key`                      | Identificador da instância do Navigator.                                  | `Navigator(key: chave)`                            |
| `initialRoute`             | Define a rota inicial do Navigator.                                        | `Navigator(initialRoute: '/home')`                 |
| `onGenerateRoute`          | Função callback para gerar rotas dinamicamente.                            | `Navigator(onGenerateRoute: _gerarRota)`           |
| `onGenerateInitialRoutes`  | Função callback para gerar rotas iniciais dinamicamente.                   | `Navigator(onGenerateInitialRoutes: _gerarRotas)`  |
| `onUnknownRoute`           | Função callback quando a rota solicitada não é encontrada.                 | `Navigator(onUnknownRoute: _rotaDesconhecida)`     |
| `transitionDelegate`       | Define como as transições entre rotas são gerenciadas.                     | `Navigator(transitionDelegate: _minhaDelegate)`    |
| `observers`                | Lista de observadores para mudanças na pilha de rotas.                    | `Navigator(observers: [_meuObservador])`           |
| `reportsRouteUpdateToEngine` | Define se o Navigator deve reportar atualizações de rota ao motor Flutter. | `Navigator(reportsRouteUpdateToEngine: true)`      |
| `restorationScopeId`       | Define um identificador para restauração de estado.                       | `Navigator(restorationScopeId: 'restauração')`     |

## Tabela com principais métodos

| Método                    | Descrição                                                             | Sintaxe de Uso                                      |
|---------------------------|-----------------------------------------------------------------------|----------------------------------------------------|
| `push`                    | Empilha uma nova rota na pilha de navegação.                          | `Navigator.push(context, novaRota)`                |
| `pop`                     | Remove a rota do topo da pilha.                                       | `Navigator.pop(context)`                           |
| `pushReplacement`         | Substitui a rota atual pela nova rota.                                | `Navigator.pushReplacement(context, novaRota)`     |
| `pushAndRemoveUntil`      | Empilha uma nova rota e remove as anteriores até uma condição ser atendida. | `Navigator.pushAndRemoveUntil(context, novaRota, condicao)` |
| `popUntil`                | Remove rotas da pilha até que uma condição seja atendida.             | `Navigator.popUntil(context, condicao)`            |
| `canPop`                  | Verifica se a navegação pode ser desempilhada.                        | `Navigator.canPop(context)`                        |
| `maybePop`                | Tenta desempilhar a rota se possível.                                 | `Navigator.maybePop(context)`                      |
| `of`                      | Retorna o `NavigatorState` do contexto dado.                          | `Navigator.of(context)`                            |
| `restorablePush`          | Similar ao `push`, mas com suporte à restauração de estado.           | `Navigator.restorablePush(context, novaRota)`      |
| `restorablePopAndPushNamed` | Remove a rota atual e empilha uma nova rota nomeada com restauração de estado. | `Navigator.restorablePopAndPushNamed(context, rota)` |

## Categoria de widget em que mais se encaixa

O widget `Navigator` se encaixa principalmente na categoria **Interaction models**. Essa categoria engloba widgets que gerenciam a interação do usuário com diferentes partes da interface, incluindo navegação e fluxo de trabalho.

## Sub-categoria em que se encaixa

Dentro da categoria **Interaction models**, o `Navigator` se encaixa na sub-categoria **Routing & Navigation**, que inclui widgets e ferramentas que gerenciam o direcionamento e a navegação entre diferentes partes de um aplicativo.

---

Esse detalhamento fornece uma visão completa do `Navigator` no Flutter, cobrindo desde seu propósito e uso básico até as propriedades e métodos mais importantes, juntamente com exemplos práticos de código. Essa compreensão profunda permitirá que você utilize o `Navigator` de maneira eficaz em seus projetos Flutter.