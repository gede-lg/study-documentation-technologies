
## Introdução

No desenvolvimento de interfaces de usuário, é comum a necessidade de permitir que os usuários selecionem uma única opção dentre várias disponíveis. No Flutter, isso é facilitado pelo widget **Radio**, que oferece uma maneira intuitiva e estilizada para essa seleção exclusiva. Este artigo explora detalhadamente o widget Radio no Flutter, abordando sua funcionalidade, uso, propriedades, métodos e categorias de widgets relacionadas.

## Sumário

1. [O que é o Radio e para que serve?](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#o-que-%C3%A9-o-radio-e-para-que-serve)
2. [Como funciona o Radio no Flutter?](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#como-funciona-o-radio-no-flutter)
3. [Sintaxe de uso do Radio](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#sintaxe-de-uso-do-radio)
4. [Restrições de uso do Radio](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#restri%C3%A7%C3%B5es-de-uso-do-radio)
5. [Quando utilizar o Radio?](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#quando-utilizar-o-radio)
6. [Tabela de Propriedades do Radio](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#tabela-de-propriedades-do-radio)
7. [Tabela de Métodos do Radio](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#tabela-de-m%C3%A9todos-do-radio)
8. [Categorias de Widgets Relacionadas](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#categorias-de-widgets-relacionadas)
9. [Exemplos de Código](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#exemplos-de-c%C3%B3digo)
10. [Considerações Finais](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#considera%C3%A7%C3%B5es-finais)
11. [Referências](https://chatgpt.com/c/674a1610-256c-8003-9d8d-bf91af6995bb?model=o1-mini#refer%C3%AAncias)

## O que é o Radio e para que serve?

**Radio** é um widget do Flutter que permite aos usuários selecionar uma única opção de um conjunto de alternativas. É comumente utilizado em formulários, questionários ou qualquer interface onde a seleção exclusiva é necessária. Cada Radio representa uma opção, e quando um Radio é selecionado, os outros no mesmo grupo são desmarcados automaticamente, garantindo que apenas uma opção esteja ativa por vez.

**Finalidades do Radio:**

- **Seleção Exclusiva:** Permitir que o usuário escolha apenas uma opção dentre várias.
- **Interface Intuitiva:** Fornecer uma interface clara e fácil de entender para seleção de opções.
- **Consistência Visual:** Manter uma aparência consistente com os padrões de design do Flutter e do Material Design.

## Como funciona o Radio no Flutter?

O widget Radio no Flutter funciona em conjunto com o conceito de **estado** para gerenciar qual opção está atualmente selecionada. Ele utiliza três propriedades principais:

1. **value:** Representa o valor único associado a cada Radio. Geralmente, é um valor constante que identifica a opção.
2. **groupValue:** Representa o valor atualmente selecionado no grupo de Radion. Todos os Radion que compartilham o mesmo `groupValue` pertencem ao mesmo grupo.
3. **onChanged:** É uma função de callback que é chamada quando o Radio é selecionado. Ela recebe o novo valor selecionado, permitindo atualizar o estado do aplicativo.

Quando um Radio é selecionado, o `onChanged` é acionado com o `value` correspondente, e o `groupValue` é atualizado para refletir a seleção. Isso, por sua vez, faz com que todos os Radion no mesmo grupo atualizem seu estado visualmente.

## Sintaxe de uso do Radio

A criação de um widget Radio no Flutter envolve a utilização do construtor `Radio<T>`, onde `T` é o tipo de dado que o Radio irá manipular (por exemplo, `int`, `String`, `enum`, etc.). Abaixo, detalhamos cada parâmetro do Radio.

### Estrutura Básica

```dart
Radio<T>(
  value: T,
  groupValue: T,
  onChanged: void Function(T?)?,
  activeColor: Color?,
  fillColor: MaterialStateProperty<Color?>?,
  autofocus: bool,
  materialTapTargetSize: MaterialTapTargetSize,
  mouseCursor: MouseCursor?,
  visualDensity: VisualDensity?,
  splashRadius: double?,
  // ... outros parâmetros opcionais
)
```

### Descrição Completa dos Parâmetros

#### Parâmetros Obrigatórios

1. **`value` (`T`):**
    
    - **Descrição:** Valor associado a este Radio. Deve ser único dentro do grupo.
    - **Tipo:** Genérico `T` (pode ser `int`, `String`, `enum`, etc.).
    - **Obrigatório:** Sim.
2. **`groupValue` (`T`):**
    
    - **Descrição:** Valor que representa o estado selecionado do grupo de Radion. Quando `groupValue == value`, o Radio é marcado como selecionado.
    - **Tipo:** Genérico `T`.
    - **Obrigatório:** Sim.
3. **`onChanged` (`void Function(T?)?`):**
    
    - **Descrição:** Callback que é chamado quando o Radio é selecionado. Recebe o `value` do Radio selecionado.
    - **Tipo:** Função que recebe um valor do tipo `T` ou `null`.
    - **Obrigatório:** Sim (para que o Radio seja interativo).

#### Parâmetros Opcionais

1. **`activeColor` (`Color?`):**
    
    - **Descrição:** Cor do Radio quando está selecionado.
    - **Tipo:** `Color`.
    - **Obrigatório:** Não.
2. **`fillColor` (`MaterialStateProperty<Color?>?`):**
    
    - **Descrição:** Cor de preenchimento do Radio que pode depender do estado do widget.
    - **Tipo:** `MaterialStateProperty<Color?>`.
    - **Obrigatório:** Não.
3. **`autofocus` (`bool`):**
    
    - **Descrição:** Define se o Radio deve receber foco automaticamente.
    - **Tipo:** `bool`.
    - **Valor Padrão:** `false`.
    - **Obrigatório:** Não.
4. **`materialTapTargetSize` (`MaterialTapTargetSize`):**
    
    - **Descrição:** Define o tamanho da área de toque do Radio.
    - **Tipo:** `MaterialTapTargetSize`.
    - **Valores Possíveis:** `MaterialTapTargetSize.padded`, `MaterialTapTargetSize.shrinkWrap`.
    - **Valor Padrão:** Depende do tema.
    - **Obrigatório:** Não.
5. **`mouseCursor` (`MouseCursor?`):**
    
    - **Descrição:** Cursor do mouse quando está sobre o Radio.
    - **Tipo:** `MouseCursor`.
    - **Obrigatório:** Não.
6. **`visualDensity` (`VisualDensity?`):**
    
    - **Descrição:** Define a densidade visual do Radio.
    - **Tipo:** `VisualDensity`.
    - **Obrigatório:** Não.
7. **`splashRadius` (`double?`):**
    
    - **Descrição:** Raio do efeito de splash ao selecionar o Radio.
    - **Tipo:** `double`.
    - **Obrigatório:** Não.
8. **`toggleable` (`bool`):**
    
    - **Descrição:** Define se o Radio pode ser desmarcado quando selecionado novamente.
    - **Tipo:** `bool`.
    - **Valor Padrão:** `false`.
    - **Obrigatório:** Não.
9. **`focusNode` (`FocusNode?`):**
    
    - **Descrição:** Nó de foco para o Radio.
    - **Tipo:** `FocusNode`.
    - **Obrigatório:** Não.
10. **`semanticsLabel` (`String?`):**
    
    - **Descrição:** Rótulo semântico para acessibilidade.
    - **Tipo:** `String`.
    - **Obrigatório:** Não.
11. **`materialTapTargetSize` (`MaterialTapTargetSize?`):**
    
    - **Descrição:** Define o tamanho da área de toque.
    - **Tipo:** `MaterialTapTargetSize`.
    - **Obrigatório:** Não.

### Exemplo de Uso

```dart
Radio<int>(
  value: 1,
  groupValue: _selectedValue,
  onChanged: (int? value) {
    setState(() {
      _selectedValue = value!;
    });
  },
  activeColor: Colors.blue,
)
```

## Restrições de uso do Radio

Embora o widget Radio seja uma ferramenta poderosa para seleção exclusiva, existem algumas restrições e considerações a serem observadas:

1. **Necessidade de Estado:** O Radio depende de um estado externo (`groupValue`) para determinar qual opção está selecionada. Portanto, deve ser usado dentro de widgets que gerenciam estado, como `StatefulWidget`.
    
2. **Exclusividade de Grupo:** Todos os Radion que pertencem ao mesmo grupo devem compartilhar o mesmo `groupValue` e tipo de `value`. Misturar tipos ou valores pode levar a comportamentos inesperados.
    
3. **Acessibilidade:** É importante fornecer rótulos semânticos (`semanticsLabel`) para garantir que usuários com necessidades especiais possam interagir com os Radion de forma eficaz.
    
4. **Desempenho com Muitos Itens:** Se o grupo de Radion for muito grande, pode afetar o desempenho e a experiência do usuário. Nesses casos, considerar alternativas como listas selecionáveis.
    

## Quando utilizar o Radio?

O widget Radio deve ser utilizado em situações onde é necessário que o usuário selecione **apenas uma** opção dentre um conjunto de alternativas. Alguns cenários comuns incluem:

- **Formulários de Cadastro:** Selecionar gênero, status civil, etc.
- **Configurações de Preferências:** Escolher um tema, idioma ou configuração específica.
- **Questionários e Pesquisas:** Selecionar respostas únicas para perguntas.
- **Filtros de Pesquisa:** Escolher um critério de ordenação ou filtragem.

**Exemplos Práticos:**

- **Escolha de Forma de Pagamento:**
    
    - Opções como Cartão de Crédito, Boleto, PayPal, etc.
- **Seleção de Nível de Acesso:**
    
    - Usuário, Administrador, Moderador.
- **Preferência de Notificações:**
    
    - Todas as notificações, Apenas importantes, Nenhuma.

## Tabela de Propriedades do Radio

|Propriedade|Descrição|Sintaxe de Uso|
|---|---|---|
|`value`|Valor único associado ao Radio. Define qual opção representa este Radio.|`value: T`|
|`groupValue`|Valor atualmente selecionado no grupo de Radion.|`groupValue: T`|
|`onChanged`|Callback chamado quando o Radio é selecionado. Recebe o `value`.|`onChanged: (T? value) { ... }`|
|`activeColor`|Cor do Radio quando está selecionado.|`activeColor: Colors.blue`|
|`fillColor`|Cor de preenchimento do Radio baseada no estado do widget.|`fillColor: MaterialStateProperty.all(Colors.red)`|
|`autofocus`|Define se o Radio deve receber foco automaticamente.|`autofocus: true`|
|`materialTapTargetSize`|Define o tamanho da área de toque do Radio.|`materialTapTargetSize: MaterialTapTargetSize.padded`|
|`mouseCursor`|Cursor do mouse quando está sobre o Radio.|`mouseCursor: SystemMouseCursors.click`|
|`visualDensity`|Densidade visual do Radio.|`visualDensity: VisualDensity.compact`|
|`splashRadius`|Raio do efeito de splash ao selecionar o Radio.|`splashRadius: 24.0`|
|`toggleable`|Define se o Radio pode ser desmarcado quando selecionado novamente.|`toggleable: true`|
|`focusNode`|Nó de foco para o Radio.|`focusNode: FocusNode()`|
|`semanticsLabel`|Rótulo semântico para acessibilidade.|`semanticsLabel: 'Opção 1'`|

## Tabela de Métodos do Radio

O widget Radio em si não possui métodos públicos, pois é um widget Stateless. No entanto, os métodos relacionados ao Radio geralmente estão ligados ao gerenciamento de estado onde os Radion são utilizados. Abaixo estão alguns métodos comuns que você pode implementar ao usar o Radio:

|Método|Descrição|Sintaxe de Uso|
|---|---|---|
|`setState`|Atualiza o estado do widget quando uma opção é selecionada.|`setState(() { _selectedValue = value; });`|
|`build`|Constrói a interface do widget, incluindo os Radion.|`@override Widget build(BuildContext context) { ... }`|
|`initState`|Inicializa o estado do widget antes de ser construído.|`@override void initState() { super.initState(); }`|
|`dispose`|Libera recursos quando o widget é removido da árvore de widgets.|`@override void dispose() { super.dispose(); }`|

**Nota:** Esses métodos pertencem ao `State` do `StatefulWidget` que gerencia os Radion, e não diretamente ao widget Radio.

## Categorias de Widgets Relacionadas

O widget Radio no Flutter se encaixa em várias categorias de widgets devido à sua funcionalidade e características. Abaixo estão as categorias mais relevantes:

|Categoria|Descrição|
|---|---|
|**Input**|Widgets que permitem a entrada de dados pelo usuário, como formulários e seleções.|
|**Material Components**|Componentes de interface do Material Design, oferecendo aparência e comportamento consistentes.|
|**Interaction models**|Widgets que respondem a interações do usuário, como toques e gestos.|
|**Styling**|Widgets que controlam a aparência visual dos elementos da interface.|

**Explicação das Categorias:**

- **Input:** O Radio é um componente de entrada que permite aos usuários selecionar opções.
- **Material Components:** Como parte do Material Design, o Radio segue as diretrizes visuais e de interação do Material.
- **Interaction models:** O Radio responde a toques e gestos do usuário para alterar seu estado.
- **Styling:** Permite personalizar cores, tamanhos e outros aspectos visuais para se adequar ao design do aplicativo.

## Exemplos de Código

A seguir, apresentamos exemplos práticos de como utilizar o widget Radio no Flutter, incluindo diferentes cenários e personalizações.

### Exemplo Básico de Radio

Este exemplo demonstra como criar um grupo de Radion para selecionar uma opção entre três alternativas.

```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Exemplo de Radio no Flutter',
      home: Scaffold(
        appBar: AppBar(
          title: Text('Radio Example'),
        ),
        body: RadioExample(),
      ),
    );
  }
}

class RadioExample extends StatefulWidget {
  @override
  _RadioExampleState createState() => _RadioExampleState();
}

class _RadioExampleState extends State<RadioExample> {
  int _selectedValue = 1;

  void _handleRadioValueChange(int? value) {
    setState(() {
      _selectedValue = value!;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ListTile(
          title: Text('Opção 1'),
          leading: Radio<int>(
            value: 1,
            groupValue: _selectedValue,
            onChanged: _handleRadioValueChange,
            activeColor: Colors.green,
          ),
        ),
        ListTile(
          title: Text('Opção 2'),
          leading: Radio<int>(
            value: 2,
            groupValue: _selectedValue,
            onChanged: _handleRadioValueChange,
            activeColor: Colors.green,
          ),
        ),
        ListTile(
          title: Text('Opção 3'),
          leading: Radio<int>(
            value: 3,
            groupValue: _selectedValue,
            onChanged: _handleRadioValueChange,
            activeColor: Colors.green,
          ),
        ),
      ],
    );
  }
}
```

**Explicação:**

- **Estado Inicial:** `_selectedValue` inicia com `1`, selecionando a primeira opção.
- **Callback:** `_handleRadioValueChange` atualiza o estado quando um Radio é selecionado.
- **ListTile:** Cada Radio está associado a um ListTile para uma melhor disposição visual.

### Exemplo com Enum

Utilizar um `enum` para definir as opções do Radio pode tornar o código mais legível e organizado.

```dart
import 'package:flutter/material.dart';

enum Opcoes { opcao1, opcao2, opcao3 }

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Exemplo de Radio com Enum',
      home: Scaffold(
        appBar: AppBar(
          title: Text('Radio com Enum'),
        ),
        body: RadioEnumExample(),
      ),
    );
  }
}

class RadioEnumExample extends StatefulWidget {
  @override
  _RadioEnumExampleState createState() => _RadioEnumExampleState();
}

class _RadioEnumExampleState extends State<RadioEnumExample> {
  Opcoes _selectedOption = Opcoes.opcao1;

  void _handleRadioValueChange(Opcoes? value) {
    setState(() {
      _selectedOption = value!;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ListTile(
          title: Text('Opção 1'),
          leading: Radio<Opcoes>(
            value: Opcoes.opcao1,
            groupValue: _selectedOption,
            onChanged: _handleRadioValueChange,
            activeColor: Colors.red,
          ),
        ),
        ListTile(
          title: Text('Opção 2'),
          leading: Radio<Opcoes>(
            value: Opcoes.opcao2,
            groupValue: _selectedOption,
            onChanged: _handleRadioValueChange,
            activeColor: Colors.red,
          ),
        ),
        ListTile(
          title: Text('Opção 3'),
          leading: Radio<Opcoes>(
            value: Opcoes.opcao3,
            groupValue: _selectedOption,
            onChanged: _handleRadioValueChange,
            activeColor: Colors.red,
          ),
        ),
      ],
    );
  }
}
```

**Explicação:**

- **Enum `Opcoes`:** Define as opções disponíveis.
- **Estado Inicial:** `_selectedOption` inicia com `Opcoes.opcao1`.
- **Callback:** Atualiza o estado com a opção selecionada.

### Exemplo de Radio Personalizado com Temas

Este exemplo demonstra como personalizar o Radio utilizando o tema do Material.

```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Radio Personalizado',
      theme: ThemeData(
        primarySwatch: Colors.purple,
        radioTheme: RadioThemeData(
          fillColor: MaterialStateProperty.all(Colors.purple),
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: Text('Radio Personalizado'),
        ),
        body: RadioThemeExample(),
      ),
    );
  }
}

class RadioThemeExample extends StatefulWidget {
  @override
  _RadioThemeExampleState createState() => _RadioThemeExampleState();
}

class _RadioThemeExampleState extends State<RadioThemeExample> {
  String _selectedValue = 'A';

  void _handleRadioValueChange(String? value) {
    setState(() {
      _selectedValue = value!;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ListTile(
          title: Text('Opção A'),
          leading: Radio<String>(
            value: 'A',
            groupValue: _selectedValue,
            onChanged: _handleRadioValueChange,
          ),
        ),
        ListTile(
          title: Text('Opção B'),
          leading: Radio<String>(
            value: 'B',
            groupValue: _selectedValue,
            onChanged: _handleRadioValueChange,
          ),
        ),
        ListTile(
          title: Text('Opção C'),
          leading: Radio<String>(
            value: 'C',
            groupValue: _selectedValue,
            onChanged: _handleRadioValueChange,
          ),
        ),
      ],
    );
  }
}
```

**Explicação:**

- **Tema Personalizado:** Define `radioTheme` no `ThemeData` para alterar a cor de preenchimento.
- **Radion Herda do Tema:** Todos os Radion no aplicativo seguirão o tema definido, mantendo a consistência visual.

## Considerações Finais

O widget Radio no Flutter é uma ferramenta essencial para criar interfaces de usuário que requerem seleção exclusiva. Ao entender seu funcionamento, propriedades e como integrá-lo adequadamente ao gerenciamento de estado, é possível criar experiências de usuário intuitivas e eficientes. Além disso, a personalização através de temas e estilos permite que os Radion se alinhem perfeitamente ao design geral do aplicativo.

**Boas Práticas:**

- **Gerenciamento de Estado Adequado:** Utilize `StatefulWidget` ou gerenciadores de estado como `Provider`, `Bloc`, etc., para controlar o `groupValue`.
- **Acessibilidade:** Forneça rótulos semânticos e considere a navegabilidade via teclado para melhorar a acessibilidade.
- **Consistência Visual:** Mantenha a consistência no uso de cores e estilos para evitar confusão do usuário.

**Alternativas:**

- **ListTile com Radio:** Integrar Radion dentro de ListTiles facilita a criação de listas interativas e alinhadas.
- **RadioListTile:** Um widget que combina ListTile e Radio, simplificando a implementação de opções selecionáveis em listas.

## Referências

- [Documentação Oficial do Flutter - Radio](https://api.flutter.dev/flutter/material/Radio-class.html)
- [Material Design - Radio Buttons](https://material.io/components/radio-buttons)
- [Gerenciamento de Estado no Flutter](https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro)
- [RadioListTile - Flutter](https://api.flutter.dev/flutter/material/RadioListTile-class.html)

---

**Nota:** Sempre teste os widgets em diferentes dispositivos e cenários para garantir que se comportem conforme o esperado. A personalização e o design devem ser alinhados às necessidades específicas do aplicativo e às expectativas dos usuários.