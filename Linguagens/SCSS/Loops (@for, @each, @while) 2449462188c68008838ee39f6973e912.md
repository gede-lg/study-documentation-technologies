# Loops (@for, @each, @while)

Olá, Gedê\!

Entendido. Vou preparar uma explicação detalhada e completa sobre os loops no Sass, focando nos três principais tipos: `@for`, `@each`, e `@while`. A explicação será estruturada com base nos tópicos que você solicitou, incluindo exemplos de código práticos e melhores práticas.

---

# Automatizando o CSS com Loops no Sass

---

## Sumário

Esta explicação aprofundada sobre loops em Sass (`@for`, `@each`, `@while`) abordará os conceitos fundamentais por trás da automação na criação de estilos. Cobriremos a sintaxe, os casos de uso ideais, as restrições e as melhores práticas para cada tipo de loop, com exemplos práticos para ilustrar como gerar classes de forma eficiente, como classes de espaçamento e de grid. O objetivo é fornecer um guia completo para que você possa utilizar essas ferramentas para escrever CSS mais limpo, DRY (Don't Repeat Yourself) e escalável.

## Conceitos Fundamentais

Loops em Sass são ferramentas poderosas que permitem a repetição de um bloco de código CSS um número determinado de vezes. A principal vantagem é **automatizar tarefas repetitivas**, como a criação de classes utilitárias, a geração de breakpoints de grid ou a aplicação de estilos a elementos de uma lista. Em vez de escrever manualmente dezenas de classes, você pode usar um loop para fazer isso por você, economizando tempo e reduzindo a chance de erros.

Existem três tipos de loops no Sass, cada um com um propósito específico:

- **`@for`**: Ideal para loops que precisam de um contador numérico, como a criação de classes de espaçamento ou de tamanhos de fonte.
- **`@each`**: Perfeito para iterar sobre os itens de uma lista ou os pares chave-valor de um mapa. É excelente para gerar estilos para cores, tamanhos ou ícones.
- **`@while`**: Útil para cenários mais complexos onde a iteração continua enquanto uma condição específica for verdadeira.

## Loops (`@for`, `@each`, `@while`): Sintaxe e Uso

### `@for`

O loop `@for` é usado para repetir um bloco de código um número fixo de vezes, com base em um contador numérico. Ele tem duas variações:

1. **`through`**: O loop inclui o valor final na iteração. A sintaxe é: `@for $i from <início> through <fim>`.
2. **`to`**: O loop **não** inclui o valor final. A sintaxe é: `@for $i from <início> to <fim>`.

A variável `$i` é o contador do loop.

### Exemplo de Código com `@for`

Vamos criar classes de espaçamento (`.m-1`, `.m-2`, etc.) usando o loop `@for`.

```sass
// Usando `through` para incluir o valor final (5)
@for $i from 1 through 5 {
  .m-#{$i} {
    margin: #{$i * 5}px;
  }

  .p-#{$i} {
    padding: #{$i * 5}px;
  }
}

// O código Sass acima gera o seguinte CSS:
// .m-1 { margin: 5px; }
// .p-1 { padding: 5px; }
// .m-2 { margin: 10px; }
// .p-2 { padding: 10px; }
// ...
// .m-5 { margin: 25px; }
// .p-5 { padding: 25px; }

```

Neste exemplo, `$i` varia de 1 a 5, e para cada iteração, ele cria as classes `.m-#{$i}` e `.p-#{$i}`, onde `#{$i}` interpola a variável no nome da classe. A propriedade `margin` e `padding` recebe o valor de `$i` multiplicado por 5, gerando uma escala consistente de espaçamento.

---

### `@each`

O loop `@each` é ideal para iterar sobre os elementos de uma **lista** ou **mapa**.

### Iterando sobre uma Lista

A sintaxe básica para listas é: `@each $item in <lista>`.

### Exemplo de Código com `@each` (Lista)

Vamos criar classes para cores de fundo usando uma lista de cores.

```sass
$cores-tema: blue, green, red, yellow;

@each $cor in $cores-tema {
  .bg-#{$cor} {
    background-color: $cor;
  }
}

// O código Sass acima gera o seguinte CSS:
// .bg-blue { background-color: blue; }
// .bg-green { background-color: green; }
// .bg-red { background-color: red; }
// .bg-yellow { background-color: yellow; }

```

### Iterando sobre um Mapa

A sintaxe para mapas é: `@each $chave, $valor in <mapa>`.

### Exemplo de Código com `@each` (Mapa)

Vamos criar classes para tamanhos de fonte usando um mapa.

```sass
$font-sizes: (
  'small': 12px,
  'medium': 16px,
  'large': 20px
);

@each $size, $value in $font-sizes {
  .font-#{$size} {
    font-size: $value;
  }
}

// O código Sass acima gera o seguinte CSS:
// .font-small { font-size: 12px; }
// .font-medium { font-size: 16px; }
// .font-large { font-size: 20px; }

```

---

### `@while`

O loop `@while` é o mais flexível e, por isso, o menos usado. Ele executa um bloco de código **enquanto uma condição for verdadeira**. É crucial que a condição seja atualizada dentro do loop para evitar um loop infinito.

A sintaxe é: `@while <condição>`.

### Exemplo de Código com `@while`

Vamos criar uma lista de classes de espaçamento de forma similar ao `@for`, mas usando um `@while` para demonstrar sua lógica.

```sass
$i: 1;

@while $i <= 5 {
  .margin-#{$i} {
    margin: #{$i * 5}px;
  }
  // Aumentamos o contador para que a condição eventualmente se torne falsa
  $i: $i + 1;
}

// O código Sass acima gera o mesmo CSS que o exemplo com `@for`, mas a lógica é diferente.
// É um exemplo didático para mostrar o uso do `@while`.

```

Neste caso, `$i` é inicializado em 1. O loop continuará enquanto `$i` for menor ou igual a 5. A cada iteração, `$i` é incrementado em 1. Se `$i: $i + 1;` não fosse incluído, o loop seria infinito.

---

## Restrições de Uso e Melhores Práticas

### Restrições

- **Evite o uso excessivo de `@while`**: O loop `@while` é propenso a loops infinitos se a condição de saída não for bem definida. Na maioria dos casos, `@for` e `@each` são mais seguros e expressivos. Use `@while` apenas para lógica de loop mais complexa que não se encaixa nas outras duas opções.
- **Evite loops que gerem muito CSS**: Gerar centenas de classes com loops pode inflar o tamanho do seu arquivo CSS, afetando o desempenho da página. Use-os com moderação e apenas para classes que serão realmente utilizadas.

### Melhores Práticas e Casos de Uso

- **Classes Utilitárias**: Use `@for` e `@each` para gerar classes utilitárias de forma consistente, como espaçamentos (`.p-1`, `.m-2`), tamanhos de fonte (`.fs-1`, `.fs-2`), cores (`.bg-blue`), e grid de colunas (`.col-1`, `.col-2`, etc.).
- **Tema de Cores**: Use um mapa com `@each` para iterar sobre cores e gerar classes de cor de fundo, cor de texto e bordas. Isso facilita a mudança de tema no futuro, pois você só precisa editar o mapa de cores.
- **Integração com Mixins**: Combine loops com mixins para criar componentes reutilizáveis. Por exemplo, um mixin que gera diferentes breakpoints para um sistema de grid.
- **Interpolação de Strings**: Sempre use `#{$variável}` para inserir variáveis em nomes de classes ou propriedades. Isso garante que o Sass interprete a variável corretamente.
- **Comentários**: Adicione comentários para explicar a lógica do loop, especialmente se ele for complexo.

## Exemplo Completo: Sistema de Grid e Espaçamento

Aqui está um exemplo completo que combina `@for` e um mapa com `@each` para criar um sistema simples de grid e classes de espaçamento.

```sass
// VARIÁVEIS GLOBAIS
$grid-columns: 12;
$gutter: 20px;
$spacing-step: 8px; // Define o "passo" para as classes de espaçamento

// MAPA DE CORES
$cores-status: (
  'success': #28a745,
  'info': #17a2b8,
  'warning': #ffc107,
  'danger': #dc3545
);

// GERAÇÃO DE CLASSES DE GRID (LOOP @for)
@for $i from 1 through $grid-columns {
  .col-#{$i} {
    // A largura da coluna é calculada com base no número total de colunas
    width: (100% / $grid-columns) * $i;
    padding-left: $gutter / 2;
    padding-right: $gutter / 2;
  }
}

// GERAÇÃO DE CLASSES DE ESPAÇAMENTO (LOOP @for)
@for $i from 1 through 5 {
  $value: $i * $spacing-step;

  .m-#{$i} {
    margin: $value;
  }

  .p-#{$i} {
    padding: $value;
  }

  .mt-#{$i} {
    margin-top: $value;
  }

  .mb-#{$i} {
    margin-bottom: $value;
  }
}

// GERAÇÃO DE CLASSES DE COR (LOOP @each com mapa)
@each $status, $color in $cores-status {
  .bg-#{$status} {
    background-color: $color;
  }
  .text-#{$status} {
    color: $color;
  }
}

```

Este código Sass gera um conjunto robusto de classes utilitárias de forma automática e organizada. Se você precisar mudar o número de colunas, o espaçamento do `gutter` ou as cores, basta alterar as variáveis no início do arquivo, e o Sass fará o resto do trabalho.

---

## Tópicos Relacionados para Aprofundamento

Para continuar a sua jornada em Sass, sugiro explorar os seguintes tópicos, que complementam o uso de loops:

- **Mixins e Funções (`@mixin`, `@function`)**: Crie blocos de código reutilizáveis e funções que retornam valores para uso em loops ou em qualquer lugar do seu código Sass.
- **Mapeamento de Dados e Estruturas (`$map`)**: Aprenda a usar mapas para armazenar dados complexos de forma organizada, como configurações de tema, tamanhos de fonte e cores.
- **Diretivas de Controle de Fluxo (`@if`, `@else if`, `@else`)**: Combine loops com condicionais para criar lógica mais avançada, como gerar classes apenas em certas condições.
- **Parciais e Importação (`@import`)**: Organize seu código Sass em arquivos menores e mais gerenciáveis, o que é essencial ao usar loops para gerar código.