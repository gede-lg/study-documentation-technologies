# Criando Classes de Erro Customizadas em JavaScript: Uma An치lise Conceitual Profunda

## 游꿢 Introdu칞칚o e Defini칞칚o

### Defini칞칚o Conceitual

**Classes de erro customizadas** s칚o **specialized Error types** criadas para representar **domain-specific failure conditions** em JavaScript applications. Representam a **extens칚o e especializa칞칚o** do Error prototype para criar **hierarchies de exception types** que carregam **semantic meaning** espec칤fico para business domains.

Estas classes implementam o paradigma de **typed exception handling**, onde diferentes types de failures s칚o **categorized e handled** baseado em sua **nature e context**, enabling **precise error management strategies**.

### Contexto Hist칩rico e Motiva칞칚o

Custom error classes evolu칤ram da necessidade de **differentiate error types** em complex applications onde generic Error objects eram **insufficient** para proper error handling decisions. Inspiradas em exception hierarchies de linguagens como Java e C#, foram adaptadas para JavaScript's prototypal inheritance.

A **motiva칞칚o central** 칠 criar **semantic error types** que enable **intelligent error handling**, facilitate **debugging**, e provide **clear communication** sobre what went wrong e how to address it.

### Problema Fundamental que Resolve

Custom error classes resolvem challenges cr칤ticos de **error categorization**:

1. **Type-Based Handling:** Different handling strategies para different error types
2. **Rich Context:** Domain-specific properties e methods
3. **Clear Communication:** Self-documenting error types
4. **Hierarchical Organization:** Structured error taxonomies
5. **Debugging Enhancement:** Improved error identification e analysis

---

## 游늶 Sum치rio Conceitual

### Aspectos Te칩ricos Centrais

1. **Inheritance Hierarchy:** Building structured error type trees
2. **Semantic Typing:** Errors que carry domain meaning
3. **Context Encapsulation:** Rich error information em structured format
4. **Behavioral Extension:** Custom methods e properties
5. **Integration Patterns:** Seamless interaction com existing error handling

### Pilares Fundamentais

- **Type Safety:** instanceof checks enable precise handling
- **Information Richness:** Custom properties provide detailed context
- **Behavioral Extension:** Methods enable sophisticated error operations
- **Hierarchical Design:** Inheritance enables both specific e general handling
- **Standards Compliance:** Proper Error prototype inheritance

---

## 游 Fundamentos Te칩ricos

### Anatomia B치sica de Custom Error Classes

```javascript
// Basic custom error class structure
class CustomError extends Error {
    constructor(message, options = {}) {
        // Call parent constructor
        super(message);
        
        // Set error name (important para stack traces e debugging)
        this.name = this.constructor.name;
        
        // Custom properties
        this.code = options.code;
        this.timestamp = options.timestamp || new Date().toISOString();
        this.context = options.context || {};
        
        // Maintain proper stack trace (V8 engines)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}

// Testing basic functionality
try {
    throw new CustomError("Something went wrong", {
        code: "CUSTOM_001",
        context: { userId: 123 }
    });
} catch (error) {
    console.log(error instanceof CustomError); // true
    console.log(error instanceof Error); // true
    console.log(error.name); // "CustomError"
    console.log(error.code); // "CUSTOM_001"
}
```

### Domain-Specific Error Hierarchies

```javascript
// Base application error
class ApplicationError extends Error {
    constructor(message, options = {}) {
        super(message);
        this.name = this.constructor.name;
        
        // Core properties
        this.code = options.code || 'APP_ERROR';
        this.severity = options.severity || 'error';
        this.category = options.category || 'application';
        this.timestamp = new Date().toISOString();
        this.correlationId = options.correlationId || this.generateCorrelationId();
        
        // Context information
        this.context = options.context || {};
        this.component = options.component;
        this.operation = options.operation;
        
        // User-facing information
        this.userMessage = options.userMessage;
        this.isRetryable = options.isRetryable || false;
        
        // Stack trace handling
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    
    generateCorrelationId() {
        return `app_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Helper methods
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            severity: this.severity,
            category: this.category,
            timestamp: this.timestamp,
            correlationId: this.correlationId,
            context: this.context,
            component: this.component,
            operation: this.operation,
            userMessage: this.userMessage,
            isRetryable: this.isRetryable,
            stack: this.stack
        };
    }
    
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}

// Validation errors hierarchy
class ValidationError extends ApplicationError {
    constructor(message, field, value, rule, options = {}) {
        super(message, {
            ...options,
            code: options.code || 'VALIDATION_ERROR',
            category: 'validation',
            severity: 'warning'
        });
        
        this.field = field;
        this.value = value;
        this.rule = rule;
        this.isRetryable = true; // User can fix input
    }
    
    getFieldPath() {
        return this.field;
    }
    
    getFailedRule() {
        return this.rule;
    }
}

class RequiredFieldError extends ValidationError {
    constructor(field, options = {}) {
        super(
            `Field '${field}' is required`,
            field,
            undefined,
            'required',
            {
                ...options,
                code: 'REQUIRED_FIELD',
                userMessage: `Please provide a value for ${field}`
            }
        );
    }
}

class InvalidFormatError extends ValidationError {
    constructor(field, value, expectedFormat, options = {}) {
        super(
            `Field '${field}' has invalid format`,
            field,
            value,
            'format',
            {
                ...options,
                code: 'INVALID_FORMAT',
                userMessage: `Please check the format of ${field}`
            }
        );
        
        this.expectedFormat = expectedFormat;
    }
}

class RangeError extends ValidationError {
    constructor(field, value, min, max, options = {}) {
        super(
            `Field '${field}' is out of allowed range`,
            field,
            value,
            'range',
            {
                ...options,
                code: 'OUT_OF_RANGE',
                userMessage: `${field} must be between ${min} and ${max}`
            }
        );
        
        this.min = min;
        this.max = max;
    }
}

// Network errors hierarchy  
class NetworkError extends ApplicationError {
    constructor(message, options = {}) {
        super(message, {
            ...options,
            code: options.code || 'NETWORK_ERROR',
            category: 'network',
            isRetryable: options.isRetryable !== false // Default retryable
        });
        
        this.url = options.url;
        this.method = options.method;
        this.status = options.status;
        this.headers = options.headers;
        this.responseBody = options.responseBody;
    }
}

class HTTPError extends NetworkError {
    constructor(status, statusText, url, options = {}) {
        super(
            `HTTP ${status}: ${statusText}`,
            {
                ...options,
                code: `HTTP_${status}`,
                status: status,
                url: url,
                isRetryable: status >= 500 // 5xx errors s칚o retryable
            }
        );
        
        this.statusText = statusText;
    }
    
    isClientError() {
        return this.status >= 400 && this.status < 500;
    }
    
    isServerError() {
        return this.status >= 500;
    }
}

class TimeoutError extends NetworkError {
    constructor(url, timeout, options = {}) {
        super(
            `Request timed out after ${timeout}ms`,
            {
                ...options,
                code: 'REQUEST_TIMEOUT',
                url: url,
                isRetryable: true
            }
        );
        
        this.timeout = timeout;
    }
}

// Business logic errors
class BusinessError extends ApplicationError {
    constructor(message, options = {}) {
        super(message, {
            ...options,
            code: options.code || 'BUSINESS_ERROR',
            category: 'business',
            isRetryable: false // Business rules geralmente n칚o s칚o retryable
        });
        
        this.businessRule = options.businessRule;
        this.businessContext = options.businessContext;
    }
}

class InsufficientFundsError extends BusinessError {
    constructor(requiredAmount, availableAmount, options = {}) {
        super(
            `Insufficient funds: required ${requiredAmount}, available ${availableAmount}`,
            {
                ...options,
                code: 'INSUFFICIENT_FUNDS',
                businessRule: 'account_balance_check',
                userMessage: 'Insufficient funds to complete this transaction'
            }
        );
        
        this.requiredAmount = requiredAmount;
        this.availableAmount = availableAmount;
        this.shortfall = requiredAmount - availableAmount;
    }
}
```

### Advanced Custom Error Features

```javascript
// Enhanced custom error com advanced features
class AdvancedError extends Error {
    constructor(message, options = {}) {
        super(message);
        this.name = this.constructor.name;
        
        // Basic properties
        this.code = options.code;
        this.timestamp = new Date().toISOString();
        
        // Advanced features
        this.tags = options.tags || [];
        this.metadata = options.metadata || {};
        this.causedBy = options.causedBy; // Error chaining
        this.suggestions = options.suggestions || [];
        this.severity = options.severity || 'error';
        
        // Lifecycle tracking
        this.createdAt = Date.now();
        this.handledAt = null;
        this.handlerCount = 0;
        
        // Stack trace enhancement
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
        
        // Auto-enhancement baseado em context
        this.enhanceFromEnvironment();
    }
    
    // Error chaining support
    static chain(originalError, newMessage, options = {}) {
        return new this(newMessage, {
            ...options,
            causedBy: originalError,
            code: options.code || originalError.code
        });
    }
    
    // Add contextual information
    addContext(key, value) {
        if (!this.metadata) this.metadata = {};
        this.metadata[key] = value;
        return this;
    }
    
    // Add tags para categorization
    addTag(tag) {
        if (!this.tags.includes(tag)) {
            this.tags.push(tag);
        }
        return this;
    }
    
    // Add resolution suggestions
    addSuggestion(suggestion) {
        this.suggestions.push(suggestion);
        return this;
    }
    
    // Mark as handled
    markAsHandled(handlerName) {
        this.handledAt = Date.now();
        this.handlerCount++;
        this.addContext('lastHandler', handlerName);
        return this;
    }
    
    // Get error chain
    getErrorChain() {
        const chain = [this];
        let current = this.causedBy;
        
        while (current) {
            chain.push(current);
            current = current.causedBy;
        }
        
        return chain;
    }
    
    // Get root cause
    getRootCause() {
        let current = this;
        
        while (current.causedBy) {
            current = current.causedBy;
        }
        
        return current;
    }
    
    // Enhanced toString with chain information
    toString() {
        let result = `${this.name}: ${this.message}`;
        
        if (this.causedBy) {
            result += `\nCaused by: ${this.causedBy.toString()}`;
        }
        
        return result;
    }
    
    // Environment enhancement
    enhanceFromEnvironment() {
        if (typeof window !== 'undefined') {
            // Browser environment
            this.addContext('userAgent', navigator.userAgent);
            this.addContext('url', window.location.href);
            this.addContext('viewport', {
                width: window.innerWidth,
                height: window.innerHeight
            });
        } else if (typeof process !== 'undefined') {
            // Node.js environment
            this.addContext('nodeVersion', process.version);
            this.addContext('platform', process.platform);
            this.addContext('pid', process.pid);
        }
    }
    
    // Serialization com full context
    serialize() {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            timestamp: this.timestamp,
            tags: this.tags,
            metadata: this.metadata,
            suggestions: this.suggestions,
            severity: this.severity,
            lifecycle: {
                createdAt: this.createdAt,
                handledAt: this.handledAt,
                handlerCount: this.handlerCount
            },
            chain: this.getErrorChain().map(err => ({
                name: err.name,
                message: err.message,
                code: err.code
            })),
            stack: this.stack
        };
    }
}

// Specialized advanced error types
class RetryableError extends AdvancedError {
    constructor(message, options = {}) {
        super(message, {
            ...options,
            code: options.code || 'RETRYABLE_ERROR'
        });
        
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 1000;
        this.backoffMultiplier = options.backoffMultiplier || 2;
        this.retryCount = 0;
        
        this.addTag('retryable');
        this.addSuggestion('This error can be automatically retried');
    }
    
    shouldRetry() {
        return this.retryCount < this.maxRetries;
    }
    
    incrementRetry() {
        this.retryCount++;
        this.addContext(`retry_${this.retryCount}`, new Date().toISOString());
    }
    
    getNextRetryDelay() {
        return this.retryDelay * Math.pow(this.backoffMultiplier, this.retryCount);
    }
}

class CriticalError extends AdvancedError {
    constructor(message, options = {}) {
        super(message, {
            ...options,
            code: options.code || 'CRITICAL_ERROR',
            severity: 'critical'
        });
        
        this.requiresImmediateAttention = true;
        this.shouldTriggerAlert = true;
        
        this.addTag('critical');
        this.addTag('alert');
        this.addSuggestion('This error requires immediate attention');
        this.addSuggestion('Check system logs and notify administrators');
    }
}
```

---

## 游댌 An치lise Conceitual Profunda

### Factory Patterns para Error Creation

```javascript
// Error factory para consistent error creation
class ErrorFactory {
    constructor(config = {}) {
        this.defaultContext = config.defaultContext || {};
        this.errorMappings = config.errorMappings || new Map();
        this.interceptors = config.interceptors || [];
    }
    
    // Register error type mappings
    registerErrorType(code, ErrorClass) {
        this.errorMappings.set(code, ErrorClass);
        return this;
    }
    
    // Add error interceptors
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
        return this;
    }
    
    // Create error com automatic type resolution
    createError(code, message, options = {}) {
        const ErrorClass = this.errorMappings.get(code) || ApplicationError;
        
        const enhancedOptions = {
            ...this.defaultContext,
            ...options,
            code: code
        };
        
        let error = new ErrorClass(message, enhancedOptions);
        
        // Apply interceptors
        this.interceptors.forEach(interceptor => {
            error = interceptor(error) || error;
        });
        
        return error;
    }
    
    // Create validation error
    createValidationError(field, message, rule, options = {}) {
        return new ValidationError(message, field, options.value, rule, {
            ...this.defaultContext,
            ...options
        });
    }
    
    // Create network error
    createNetworkError(message, status, url, options = {}) {
        if (status) {
            return new HTTPError(status, message, url, {
                ...this.defaultContext,
                ...options
            });
        } else {
            return new NetworkError(message, {
                ...this.defaultContext,
                ...options,
                url: url
            });
        }
    }
    
    // Create business error
    createBusinessError(message, rule, options = {}) {
        return new BusinessError(message, {
            ...this.defaultContext,
            ...options,
            businessRule: rule
        });
    }
    
    // Chain errors
    chainError(originalError, newMessage, options = {}) {
        return AdvancedError.chain(originalError, newMessage, {
            ...this.defaultContext,
            ...options
        });
    }
}

// Global error factory instance
const errorFactory = new ErrorFactory({
    defaultContext: {
        component: 'MyApplication',
        version: '1.0.0'
    }
});

// Register common error types
errorFactory
    .registerErrorType('VALIDATION_ERROR', ValidationError)
    .registerErrorType('NETWORK_ERROR', NetworkError)
    .registerErrorType('BUSINESS_ERROR', BusinessError)
    .registerErrorType('CRITICAL_ERROR', CriticalError);

// Add logging interceptor
errorFactory.addInterceptor((error) => {
    console.log(`Error created: ${error.code} - ${error.message}`);
    return error;
});

// Usage examples
const validationError = errorFactory.createValidationError(
    'email', 
    'Invalid email format', 
    'format',
    { value: 'invalid-email' }
);

const networkError = errorFactory.createNetworkError(
    'Service unavailable', 
    503, 
    'https://api.example.com/users'
);
```

### Error Transformation Patterns

```javascript
// Error transformation e enhancement patterns
class ErrorTransformer {
    static transformFromHTTPResponse(response, originalError) {
        if (response.status >= 400 && response.status < 500) {
            return new HTTPError(
                response.status,
                response.statusText,
                response.url,
                {
                    causedBy: originalError,
                    responseBody: response.body,
                    headers: response.headers
                }
            );
        } else if (response.status >= 500) {
            return new RetryableError(
                `Server error: ${response.statusText}`,
                {
                    code: `HTTP_${response.status}`,
                    causedBy: originalError,
                    maxRetries: 3,
                    url: response.url
                }
            );
        }
        
        return originalError;
    }
    
    static transformFromDatabaseError(dbError) {
        switch (dbError.code) {
            case 'ECONNREFUSED':
                return new RetryableError(
                    'Database connection refused',
                    {
                        code: 'DB_CONNECTION_REFUSED',
                        causedBy: dbError,
                        maxRetries: 5,
                        retryDelay: 2000
                    }
                );
                
            case 'ER_DUP_ENTRY':
                return new BusinessError(
                    'Duplicate entry detected',
                    {
                        code: 'DUPLICATE_ENTRY',
                        causedBy: dbError,
                        businessRule: 'unique_constraint',
                        userMessage: 'This item already exists'
                    }
                );
                
            case 'ER_NO_SUCH_TABLE':
                return new CriticalError(
                    'Database table not found',
                    {
                        code: 'MISSING_TABLE',
                        causedBy: dbError
                    }
                );
                
            default:
                return new ApplicationError(
                    `Database error: ${dbError.message}`,
                    {
                        code: 'DATABASE_ERROR',
                        causedBy: dbError,
                        category: 'database'
                    }
                );
        }
    }
    
    static transformForUser(error) {
        // Transform technical errors para user-friendly messages
        if (error instanceof ValidationError) {
            return {
                type: 'validation',
                message: error.userMessage || error.message,
                field: error.field,
                canRetry: true
            };
        }
        
        if (error instanceof NetworkError) {
            if (error.isRetryable) {
                return {
                    type: 'network',
                    message: 'Connection problem. Please try again.',
                    canRetry: true
                };
            } else {
                return {
                    type: 'network',
                    message: 'Service is currently unavailable.',
                    canRetry: false
                };
            }
        }
        
        if (error instanceof BusinessError) {
            return {
                type: 'business',
                message: error.userMessage || 'Operation could not be completed.',
                canRetry: false
            };
        }
        
        // Generic fallback
        return {
            type: 'system',
            message: 'An unexpected error occurred. Please contact support.',
            canRetry: false,
            correlationId: error.correlationId
        };
    }
}

// Error enhancement middleware
class ErrorEnhancer {
    static enhance(error, context = {}) {
        // Add correlation ID if missing
        if (!error.correlationId) {
            error.correlationId = ErrorEnhancer.generateCorrelationId();
        }
        
        // Add timestamp if missing
        if (!error.timestamp) {
            error.timestamp = new Date().toISOString();
        }
        
        // Add context information
        if (context.userId) {
            error.addContext('userId', context.userId);
        }
        
        if (context.sessionId) {
            error.addContext('sessionId', context.sessionId);
        }
        
        if (context.requestId) {
            error.addContext('requestId', context.requestId);
        }
        
        // Add performance information
        if (context.startTime) {
            error.addContext('duration', Date.now() - context.startTime);
        }
        
        return error;
    }
    
    static generateCorrelationId() {
        return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
```

### Error Hierarchy Management

```javascript
// Comprehensive error hierarchy management
class ErrorHierarchyManager {
    constructor() {
        this.hierarchy = new Map();
        this.buildDefaultHierarchy();
    }
    
    buildDefaultHierarchy() {
        // Root level
        this.registerError(Error, null);
        
        // Application level
        this.registerError(ApplicationError, Error);
        
        // Domain categories
        this.registerError(ValidationError, ApplicationError);
        this.registerError(NetworkError, ApplicationError);
        this.registerError(BusinessError, ApplicationError);
        this.registerError(SystemError, ApplicationError);
        
        // Validation subcategories
        this.registerError(RequiredFieldError, ValidationError);
        this.registerError(InvalidFormatError, ValidationError);
        this.registerError(RangeError, ValidationError);
        
        // Network subcategories
        this.registerError(HTTPError, NetworkError);
        this.registerError(TimeoutError, NetworkError);
        this.registerError(ConnectionError, NetworkError);
        
        // Business subcategories
        this.registerError(InsufficientFundsError, BusinessError);
        this.registerError(AuthorizationError, BusinessError);
        this.registerError(BusinessRuleViolationError, BusinessError);
    }
    
    registerError(ErrorClass, ParentClass) {
        this.hierarchy.set(ErrorClass, ParentClass);
    }
    
    getParent(ErrorClass) {
        return this.hierarchy.get(ErrorClass);
    }
    
    getAncestors(ErrorClass) {
        const ancestors = [];
        let current = this.getParent(ErrorClass);
        
        while (current) {
            ancestors.push(current);
            current = this.getParent(current);
        }
        
        return ancestors;
    }
    
    isSubclassOf(ErrorClass, PotentialParent) {
        return this.getAncestors(ErrorClass).includes(PotentialParent);
    }
    
    getHierarchyTree() {
        const tree = {};
        
        for (const [ErrorClass, ParentClass] of this.hierarchy.entries()) {
            if (!ParentClass) {
                tree[ErrorClass.name] = this.buildSubtree(ErrorClass);
            }
        }
        
        return tree;
    }
    
    buildSubtree(ErrorClass) {
        const subtree = {
            class: ErrorClass,
            children: {}
        };
        
        for (const [ChildClass, ParentClass] of this.hierarchy.entries()) {
            if (ParentClass === ErrorClass) {
                subtree.children[ChildClass.name] = this.buildSubtree(ChildClass);
            }
        }
        
        return subtree;
    }
}

// Global hierarchy manager
const errorHierarchy = new ErrorHierarchyManager();

// Error handling router baseado em hierarchy
class ErrorHandlingRouter {
    constructor(hierarchyManager) {
        this.hierarchyManager = hierarchyManager;
        this.handlers = new Map();
    }
    
    registerHandler(ErrorClass, handler) {
        this.handlers.set(ErrorClass, handler);
        return this;
    }
    
    handle(error) {
        // Try exact match first
        const exactHandler = this.handlers.get(error.constructor);
        if (exactHandler) {
            return exactHandler(error);
        }
        
        // Walk up hierarchy para find handler
        const ancestors = this.hierarchyManager.getAncestors(error.constructor);
        
        for (const AncestorClass of ancestors) {
            const handler = this.handlers.get(AncestorClass);
            if (handler) {
                return handler(error);
            }
        }
        
        // No handler found
        throw new Error(`No handler found for error type: ${error.constructor.name}`);
    }
}

// Usage example
const errorRouter = new ErrorHandlingRouter(errorHierarchy);

errorRouter
    .registerHandler(ValidationError, (error) => {
        console.log(`Validation failed: ${error.field} - ${error.message}`);
        return { type: 'validation', field: error.field, message: error.message };
    })
    .registerHandler(NetworkError, (error) => {
        console.log(`Network error: ${error.message}`);
        if (error.isRetryable) {
            return { type: 'network', canRetry: true, delay: 1000 };
        }
        return { type: 'network', canRetry: false };
    })
    .registerHandler(BusinessError, (error) => {
        console.log(`Business rule violation: ${error.message}`);
        return { type: 'business', rule: error.businessRule, message: error.message };
    })
    .registerHandler(Error, (error) => {
        console.log(`Generic error: ${error.message}`);
        return { type: 'generic', message: 'An unexpected error occurred' };
    });
```

---

## 游꿢 Aplicabilidade e Contextos

### E-commerce Application Error System

```javascript
// Comprehensive e-commerce error system
class ECommerceError extends ApplicationError {
    constructor(message, options = {}) {
        super(message, {
            ...options,
            component: 'ecommerce'
        });
    }
}

class ProductError extends ECommerceError {
    constructor(message, productId, options = {}) {
        super(message, {
            ...options,
            category: 'product'
        });
        
        this.productId = productId;
    }
}

class ProductNotFoundError extends ProductError {
    constructor(productId, options = {}) {
        super(
            `Product with ID ${productId} not found`,
            productId,
            {
                ...options,
                code: 'PRODUCT_NOT_FOUND',
                userMessage: 'The requested product is not available'
            }
        );
    }
}

class ProductOutOfStockError extends ProductError {
    constructor(productId, requestedQuantity, availableQuantity, options = {}) {
        super(
            `Insufficient stock for product ${productId}`,
            productId,
            {
                ...options,
                code: 'PRODUCT_OUT_OF_STOCK',
                userMessage: 'This product is currently out of stock'
            }
        );
        
        this.requestedQuantity = requestedQuantity;
        this.availableQuantity = availableQuantity;
    }
}

class CartError extends ECommerceError {
    constructor(message, cartId, options = {}) {
        super(message, {
            ...options,
            category: 'cart'
        });
        
        this.cartId = cartId;
    }
}

class CartEmptyError extends CartError {
    constructor(cartId, options = {}) {
        super(
            `Cart ${cartId} is empty`,
            cartId,
            {
                ...options,
                code: 'CART_EMPTY',
                userMessage: 'Please add items to your cart before proceeding'
            }
        );
    }
}

class PaymentError extends ECommerceError {
    constructor(message, paymentId, options = {}) {
        super(message, {
            ...options,
            category: 'payment'
        });
        
        this.paymentId = paymentId;
    }
}

class PaymentDeclinedError extends PaymentError {
    constructor(paymentId, reason, options = {}) {
        super(
            `Payment ${paymentId} was declined: ${reason}`,
            paymentId,
            {
                ...options,
                code: 'PAYMENT_DECLINED',
                userMessage: 'Your payment was declined. Please try a different payment method.'
            }
        );
        
        this.declineReason = reason;
    }
}

class InsufficientFundsError extends PaymentError {
    constructor(paymentId, requiredAmount, availableAmount, options = {}) {
        super(
            `Insufficient funds for payment ${paymentId}`,
            paymentId,
            {
                ...options,
                code: 'INSUFFICIENT_FUNDS',
                userMessage: 'Insufficient funds to complete this purchase'
            }
        );
        
        this.requiredAmount = requiredAmount;
        this.availableAmount = availableAmount;
    }
}

// E-commerce service com comprehensive error handling
class ECommerceService {
    constructor() {
        this.errorFactory = new ErrorFactory({
            defaultContext: {
                component: 'ecommerce-service',
                version: '2.1.0'
            }
        });
        
        this.setupErrorMappings();
    }
    
    setupErrorMappings() {
        this.errorFactory
            .registerErrorType('PRODUCT_NOT_FOUND', ProductNotFoundError)
            .registerErrorType('PRODUCT_OUT_OF_STOCK', ProductOutOfStockError)
            .registerErrorType('CART_EMPTY', CartEmptyError)
            .registerErrorType('PAYMENT_DECLINED', PaymentDeclinedError)
            .registerErrorType('INSUFFICIENT_FUNDS', InsufficientFundsError);
    }
    
    async processOrder(orderData) {
        try {
            // Validate cart
            await this.validateCart(orderData.cartId);
            
            // Check product availability
            await this.checkProductAvailability(orderData.items);
            
            // Process payment
            const paymentResult = await this.processPayment(orderData.payment);
            
            // Create order
            const order = await this.createOrder(orderData, paymentResult);
            
            return order;
            
        } catch (error) {
            if (error instanceof ECommerceError) {
                // Enhanced e-commerce error com order context
                error.addContext('orderId', orderData.orderId);
                error.addContext('customerId', orderData.customerId);
                error.addContext('orderTotal', orderData.total);
                throw error;
            } else {
                // Transform generic errors
                throw this.errorFactory.chainError(
                    error,
                    'Order processing failed',
                    {
                        code: 'ORDER_PROCESSING_ERROR',
                        operation: 'processOrder'
                    }
                );
            }
        }
    }
    
    async validateCart(cartId) {
        const cart = await this.getCart(cartId);
        
        if (!cart) {
            throw new CartError(
                `Cart ${cartId} not found`,
                cartId,
                { code: 'CART_NOT_FOUND' }
            );
        }
        
        if (!cart.items || cart.items.length === 0) {
            throw new CartEmptyError(cartId);
        }
    }
    
    async checkProductAvailability(items) {
        for (const item of items) {
            const product = await this.getProduct(item.productId);
            
            if (!product) {
                throw new ProductNotFoundError(item.productId);
            }
            
            if (product.stock < item.quantity) {
                throw new ProductOutOfStockError(
                    item.productId,
                    item.quantity,
                    product.stock
                );
            }
        }
    }
    
    async processPayment(paymentData) {
        try {
            return await this.paymentGateway.process(paymentData);
        } catch (error) {
            if (error.code === 'DECLINED') {
                throw new PaymentDeclinedError(
                    paymentData.id,
                    error.reason
                );
            } else if (error.code === 'INSUFFICIENT_FUNDS') {
                throw new InsufficientFundsError(
                    paymentData.id,
                    paymentData.amount,
                    error.availableAmount
                );
            } else {
                throw new PaymentError(
                    `Payment processing failed: ${error.message}`,
                    paymentData.id,
                    { causedBy: error }
                );
            }
        }
    }
}
```

---

## 游닄 Conclus칚o

**Custom error classes** s칚o **cornerstone** de **sophisticated error handling** em JavaScript applications. Elas enable **type-safe error management**, **rich contextual information**, e **hierarchical error organization** que facilitam **debugging, monitoring, e user experience**.

**Pontos Cr칤ticos:**

- **Always extend Error properly** - maintain prototype chain e stack traces
- **Design hierarchical taxonomies** - enable both specific e general handling
- **Include rich context** - facilitate debugging e business logic decisions
- **Provide user-friendly messages** - improve end-user experience
- **Follow consistent patterns** - enable predictable error handling

Custom error classes transform **generic failures** em **semantic, actionable information** que supports **professional-grade error management** em **complex JavaScript applications**.
