# Error Propagation em JavaScript: Uma An√°lise Conceitual Profunda

## üéØ Introdu√ß√£o e Defini√ß√£o

### Defini√ß√£o Conceitual

**Error propagation** √© o **mechanism** pelo qual **exceptions** s√£o **transmitted through the call stack** de JavaScript applications, permitindo que **errors raised** em **lower-level functions** sejam **caught e handled** em **higher-level contexts**. Este processo representa a **upward flow** de **error information** atrav√©s de **execution contexts** at√© encontrar um **appropriate error handler**.

√â fundamentalmente um **stack-based error transmission system** que enable **separation of concerns** entre **error generation** e **error handling**, allowing **specialized components** to focus em suas **primary responsibilities** enquanto **delegating error management** para **appropriate handling layers**.

### Contexto Hist√≥rico e Motiva√ß√£o

Error propagation evoluiu da necessidade de **manage failures** em **complex application architectures** onde **errors** podem originar-se em **deeply nested function calls** mas precisam ser **handled** em **higher-level application logic**. Este pattern √© inspirado em **exception handling systems** de linguagens como Java e C++.

A **motiva√ß√£o central** √© **enable clean error handling architecture** onde **low-level components** podem **signal failures** without being **tightly coupled** ao **error handling strategy**, promoting **modularity e reusability**.

### Problema Fundamental que Resolve

Error propagation resolve challenges cr√≠ticos de **error management** em **complex applications**:

1. **Separation of Concerns:** Error generation vs. error handling responsibilities
2. **Centralized Error Management:** Handle similar errors em single locations
3. **Context Preservation:** Maintain error information atrav√©s de call stack
4. **Flexible Response:** Different handling strategies baseado em application layer
5. **Clean Code Architecture:** Avoid error handling boilerplate em every function

---

## üìã Sum√°rio Conceitual

### Aspectos Te√≥ricos Centrais

1. **Call Stack Traversal:** Errors bubble up atrav√©s de execution contexts
2. **Handler Resolution:** Finding appropriate catch blocks
3. **Context Preservation:** Maintaining error state durante propagation
4. **Transformation Layers:** Error modification durante propagation
5. **Termination Conditions:** When e where propagation stops

### Pilares Fundamentais

- **Automatic Propagation:** Uncaught errors naturally bubble up
- **Voluntary Catching:** try/catch blocks interrupt propagation
- **Context Enhancement:** Errors can be enriched durante propagation
- **Handler Hierarchy:** Multiple levels de error handling
- **Graceful Degradation:** Progressive error handling strategies

---

## üß† Fundamentos Te√≥ricos

### Basic Propagation Mechanics

```javascript
// Fundamental error propagation example
function deepFunction() {
    // Error originates aqui
    throw new Error("Deep error occurred");
}

function middleFunction() {
    // Error propagates through aqui
    deepFunction(); // Uncaught error continues upward
}

function topFunction() {
    try {
        middleFunction(); // Error reaches aqui
    } catch (error) {
        // Error propagation stops aqui
        console.log("Caught at top level:", error.message);
    }
}

// Demonstrating propagation path
topFunction(); // "Caught at top level: Deep error occurred"

// Without catch - propagation continues to global
function unhandledPropagation() {
    function level3() {
        throw new Error("Unhandled error");
    }
    
    function level2() {
        level3(); // Propagates up
    }
    
    function level1() {
        level2(); // Propagates up
    }
    
    level1(); // Propagates to global handler
}

// Global error handler
window.addEventListener('error', (event) => {
    console.log('Global handler caught:', event.error.message);
});

// unhandledPropagation(); // Would trigger global handler
```

### Async Error Propagation

```javascript
// Promise-based error propagation
async function asyncPropagationDemo() {
    // Error origination
    async function asyncDeepFunction() {
        throw new Error("Async deep error");
    }
    
    // Intermediate function
    async function asyncMiddleFunction() {
        await asyncDeepFunction(); // Error propagates via rejection
    }
    
    // Top-level handler
    try {
        await asyncMiddleFunction();
    } catch (error) {
        console.log("Async error caught:", error.message);
    }
}

// Promise chain propagation
function promiseChainPropagation() {
    Promise.resolve()
        .then(() => {
            throw new Error("Promise chain error");
        })
        .then(() => {
            // This won't execute
            console.log("This won't run");
        })
        .catch(error => {
            // Error propagates para nearest catch
            console.log("Promise error caught:", error.message);
        });
}

// Mixed sync/async propagation
async function mixedPropagation() {
    function syncError() {
        throw new Error("Sync error in async context");
    }
    
    try {
        syncError(); // Sync error em async function
    } catch (error) {
        console.log("Mixed error caught:", error.message);
    }
}

// Event-based error propagation
class EventBasedPropagation extends EventTarget {
    async processData(data) {
        try {
            await this.validateData(data);
            await this.transformData(data);
            await this.saveData(data);
        } catch (error) {
            // Propagate via events
            this.dispatchEvent(new CustomEvent('error', {
                detail: { error, context: 'processData', data }
            }));
            throw error; // Also propagate via exception
        }
    }
    
    async validateData(data) {
        if (!data) {
            throw new Error("Data validation failed");
        }
    }
    
    async transformData(data) {
        // Transformation logic
    }
    
    async saveData(data) {
        // Save logic
    }
}

const processor = new EventBasedPropagation();
processor.addEventListener('error', (event) => {
    console.log('Event-based error:', event.detail.error.message);
});
```

### Error Transformation Durante Propagation

```javascript
// Error enhancement e transformation durante propagation
class PropagationEnhancer {
    static enhance(originalError, context) {
        // Create enhanced error mantendo original
        const enhancedError = new Error(originalError.message);
        enhancedError.name = originalError.name;
        enhancedError.originalError = originalError;
        
        // Add propagation context
        enhancedError.propagationPath = [
            ...(originalError.propagationPath || []),
            {
                function: context.functionName,
                timestamp: Date.now(),
                context: context.additionalInfo
            }
        ];
        
        return enhancedError;
    }
    
    static wrapFunction(fn, functionName) {
        return function(...args) {
            try {
                const result = fn.apply(this, args);
                
                // Handle promise returns
                if (result && typeof result.then === 'function') {
                    return result.catch(error => {
                        const enhanced = PropagationEnhancer.enhance(error, {
                            functionName,
                            additionalInfo: { args: args.length }
                        });
                        throw enhanced;
                    });
                }
                
                return result;
            } catch (error) {
                const enhanced = PropagationEnhancer.enhance(error, {
                    functionName,
                    additionalInfo: { args: args.length }
                });
                throw enhanced;
            }
        };
    }
}

// Usage example
const databaseLayer = {
    connect: PropagationEnhancer.wrapFunction(
        function() {
            throw new Error("Connection failed");
        },
        'database.connect'
    ),
    
    query: PropagationEnhancer.wrapFunction(
        function(sql) {
            this.connect(); // Will enhance error
            return "query result";
        },
        'database.query'
    )
};

const businessLayer = {
    getUser: PropagationEnhancer.wrapFunction(
        function(userId) {
            return databaseLayer.query(`SELECT * FROM users WHERE id = ${userId}`);
        },
        'business.getUser'
    )
};

const apiLayer = {
    handleRequest: PropagationEnhancer.wrapFunction(
        function(request) {
            return businessLayer.getUser(request.userId);
        },
        'api.handleRequest'
    )
};

// Demonstrating enhanced propagation
try {
    apiLayer.handleRequest({ userId: 123 });
} catch (error) {
    console.log("Enhanced error caught:");
    console.log("Message:", error.message);
    console.log("Propagation path:", error.propagationPath);
}
```

### Selective Error Handling e Re-throwing

```javascript
// Sophisticated error handling com selective catching
class SelectiveErrorHandler {
    constructor() {
        this.handlers = new Map();
        this.middlewares = [];
    }
    
    // Register specific error handlers
    registerHandler(errorType, handler) {
        this.handlers.set(errorType, handler);
        return this;
    }
    
    // Add middleware para error processing
    addMiddleware(middleware) {
        this.middlewares.push(middleware);
        return this;
    }
    
    // Handle error with potential re-throwing
    async handleError(error, context = {}) {
        // Apply middlewares
        let processedError = error;
        for (const middleware of this.middlewares) {
            processedError = await middleware(processedError, context);
        }
        
        // Try specific handlers
        for (const [ErrorType, handler] of this.handlers.entries()) {
            if (processedError instanceof ErrorType || 
                processedError.name === ErrorType.name ||
                processedError.code === ErrorType) {
                
                const result = await handler(processedError, context);
                
                // Handler can indicate to continue propagation
                if (result && result.rethrow) {
                    throw result.error || processedError;
                }
                
                return result;
            }
        }
        
        // No handler found - re-throw para continue propagation
        throw processedError;
    }
    
    // Wrap function com selective handling
    wrapWithHandling(fn, context = {}) {
        return async (...args) => {
            try {
                return await fn.apply(this, args);
            } catch (error) {
                return await this.handleError(error, {
                    ...context,
                    args,
                    function: fn.name
                });
            }
        };
    }
}

// Custom error types
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
    }
}

class NetworkError extends Error {
    constructor(message, status) {
        super(message);
        this.name = 'NetworkError';
        this.status = status;
    }
}

class BusinessError extends Error {
    constructor(message, code) {
        super(message);
        this.name = 'BusinessError';
        this.code = code;
    }
}

// Setup selective handler
const errorHandler = new SelectiveErrorHandler();

// Add logging middleware
errorHandler.addMiddleware(async (error, context) => {
    console.log(`[${new Date().toISOString()}] Error in ${context.function}:`, error.message);
    return error;
});

// Register specific handlers
errorHandler
    .registerHandler(ValidationError, async (error, context) => {
        console.log(`Validation failed for field: ${error.field}`);
        // Don't re-throw - handle locally
        return { handled: true, result: null };
    })
    .registerHandler(NetworkError, async (error, context) => {
        if (error.status >= 500) {
            console.log("Server error - will retry");
            // Re-throw para upper level retry logic
            return { rethrow: true };
        } else {
            console.log("Client error - handled locally");
            return { handled: true, result: { error: "Request failed" } };
        }
    })
    .registerHandler(BusinessError, async (error, context) => {
        console.log(`Business rule violation: ${error.code}`);
        // Transform e re-throw
        const transformedError = new Error(`Business rule failed: ${error.message}`);
        return { rethrow: true, error: transformedError };
    });

// Application layers com selective handling
class ApplicationService {
    constructor() {
        this.errorHandler = errorHandler;
    }
    
    async processRequest(data) {
        const wrappedValidate = this.errorHandler.wrapWithHandling(
            this.validateData.bind(this),
            { layer: 'validation' }
        );
        
        const wrappedProcess = this.errorHandler.wrapWithHandling(
            this.processBusinessLogic.bind(this),
            { layer: 'business' }
        );
        
        const wrappedSave = this.errorHandler.wrapWithHandling(
            this.saveToDatabase.bind(this),
            { layer: 'persistence' }
        );
        
        try {
            await wrappedValidate(data);
            const result = await wrappedProcess(data);
            await wrappedSave(result);
            return result;
        } catch (error) {
            // Only errors que weren't handled locally reach aqui
            console.log("Unhandled error reached top level:", error.message);
            throw error;
        }
    }
    
    async validateData(data) {
        if (!data.email) {
            throw new ValidationError("Email is required", "email");
        }
        if (!data.name) {
            throw new ValidationError("Name is required", "name");
        }
    }
    
    async processBusinessLogic(data) {
        if (data.age < 18) {
            throw new BusinessError("Age restriction violated", "MIN_AGE");
        }
        return { processed: data, timestamp: Date.now() };
    }
    
    async saveToDatabase(data) {
        // Simulate network error
        if (Math.random() > 0.5) {
            throw new NetworkError("Database connection failed", 503);
        }
        return { id: Math.random(), ...data };
    }
}
```

---

## üîç An√°lise Conceitual Profunda

### Propagation Control Patterns

```javascript
// Advanced propagation control mechanisms
class PropagationController {
    constructor() {
        this.interceptors = [];
        this.boundaries = new Set();
        this.transformers = new Map();
    }
    
    // Add propagation interceptor
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
        return this;
    }
    
    // Define error boundaries
    addBoundary(boundaryName, handler) {
        this.boundaries.add({ name: boundaryName, handler });
        return this;
    }
    
    // Add error transformers
    addTransformer(condition, transformer) {
        this.transformers.set(condition, transformer);
        return this;
    }
    
    // Create controlled propagation wrapper
    createPropagationWrapper(fn, options = {}) {
        return async (...args) => {
            const context = {
                functionName: fn.name,
                args,
                options,
                startTime: Date.now()
            };
            
            try {
                return await fn.apply(this, args);
            } catch (error) {
                return await this.controlPropagation(error, context);
            }
        };
    }
    
    async controlPropagation(error, context) {
        let currentError = error;
        
        // Apply interceptors
        for (const interceptor of this.interceptors) {
            const result = await interceptor(currentError, context);
            if (result.stop) {
                return result.value;
            }
            if (result.transform) {
                currentError = result.error;
            }
        }
        
        // Check transformers
        for (const [condition, transformer] of this.transformers.entries()) {
            if (await condition(currentError, context)) {
                currentError = await transformer(currentError, context);
            }
        }
        
        // Check boundaries
        for (const boundary of this.boundaries) {
            if (await boundary.handler(currentError, context)) {
                console.log(`Error stopped at boundary: ${boundary.name}`);
                return null; // Stop propagation
            }
        }
        
        // Continue propagation
        throw currentError;
    }
}

// Usage example
const controller = new PropagationController();

// Add logging interceptor
controller.addInterceptor(async (error, context) => {
    console.log(`[INTERCEPTOR] ${context.functionName}: ${error.message}`);
    return { transform: false, stop: false };
});

// Add retry interceptor para specific errors
controller.addInterceptor(async (error, context) => {
    if (error.name === 'NetworkError' && context.retryCount < 3) {
        console.log(`Retrying ${context.functionName} (attempt ${(context.retryCount || 0) + 1})`);
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        try {
            context.retryCount = (context.retryCount || 0) + 1;
            const fn = context.originalFunction || (() => {
                throw error; // Fallback
            });
            const result = await fn.apply(this, context.args);
            return { stop: true, value: result };
        } catch (retryError) {
            if (context.retryCount >= 3) {
                return { transform: true, error: new Error(`Max retries exceeded: ${retryError.message}`) };
            }
            return { transform: true, error: retryError };
        }
    }
    
    return { transform: false, stop: false };
});

// Add error boundary para validation errors
controller.addBoundary('validation-boundary', async (error, context) => {
    if (error.name === 'ValidationError') {
        console.log("Validation error stopped at boundary");
        return true; // Stop propagation
    }
    return false;
});

// Add transformer para business errors
controller.addTransformer(
    async (error, context) => error.name === 'BusinessError',
    async (error, context) => {
        return new Error(`Business logic failed in ${context.functionName}: ${error.message}`);
    }
);
```

### Error Propagation em Complex Architectures

```javascript
// Multi-layer architecture com sophisticated error propagation
class ArchitectureLayer {
    constructor(name, controller) {
        this.name = name;
        this.controller = controller;
        this.middleware = [];
    }
    
    addMiddleware(middleware) {
        this.middleware.push(middleware);
        return this;
    }
    
    async execute(operation, context = {}) {
        let currentContext = {
            ...context,
            layer: this.name,
            startTime: Date.now()
        };
        
        // Apply pre-middleware
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                currentContext = await middleware.pre(currentContext);
            }
        }
        
        try {
            const result = await operation(currentContext);
            
            // Apply post-middleware
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    await middleware.post(result, currentContext);
                }
            }
            
            return result;
        } catch (error) {
            // Apply error middleware
            for (const middleware of this.middleware) {
                if (middleware.error) {
                    error = await middleware.error(error, currentContext);
                }
            }
            
            // Enhanced error com layer information
            error.layer = this.name;
            error.layerContext = currentContext;
            
            throw error;
        }
    }
}

// Create architectural layers
const presentationLayer = new ArchitectureLayer('presentation', controller);
const businessLayer = new ArchitectureLayer('business', controller);
const dataLayer = new ArchitectureLayer('data', controller);

// Add layer-specific middleware
presentationLayer.addMiddleware({
    pre: async (context) => {
        console.log(`[PRESENTATION] Starting operation: ${context.operation}`);
        return context;
    },
    error: async (error, context) => {
        console.log(`[PRESENTATION] Error occurred: ${error.message}`);
        
        // Convert technical errors para user-friendly messages
        if (error.name === 'ValidationError') {
            error.userMessage = "Please check your input and try again";
        } else if (error.name === 'NetworkError') {
            error.userMessage = "Service is temporarily unavailable";
        } else {
            error.userMessage = "An unexpected error occurred";
        }
        
        return error;
    }
});

businessLayer.addMiddleware({
    pre: async (context) => {
        console.log(`[BUSINESS] Processing business logic: ${context.operation}`);
        return { ...context, businessContext: true };
    },
    error: async (error, context) => {
        console.log(`[BUSINESS] Business error: ${error.message}`);
        
        // Add business context para error
        error.businessRule = context.rule;
        error.businessData = context.data;
        
        return error;
    }
});

dataLayer.addMiddleware({
    pre: async (context) => {
        console.log(`[DATA] Accessing data: ${context.operation}`);
        return { ...context, dataSource: 'database' };
    },
    error: async (error, context) => {
        console.log(`[DATA] Data access error: ${error.message}`);
        
        // Transform data errors
        if (error.code === 'ECONNREFUSED') {
            error = new Error('Database connection unavailable');
            error.name = 'DatabaseError';
            error.isRetryable = true;
        }
        
        return error;
    }
});

// Application service using layers
class LayeredApplicationService {
    async processUserRequest(userData) {
        try {
            // Presentation layer
            const validatedData = await presentationLayer.execute(
                async (context) => {
                    if (!userData.email) {
                        throw new ValidationError('Email is required', 'email');
                    }
                    return userData;
                },
                { operation: 'validateUserInput', data: userData }
            );
            
            // Business layer
            const processedData = await businessLayer.execute(
                async (context) => {
                    if (validatedData.age < 18) {
                        throw new BusinessError('Age restriction', 'MIN_AGE');
                    }
                    return { ...validatedData, processed: true };
                },
                { operation: 'processBusinessRules', data: validatedData, rule: 'age_validation' }
            );
            
            // Data layer
            const savedData = await dataLayer.execute(
                async (context) => {
                    // Simulate database operation
                    if (Math.random() > 0.8) {
                        const error = new Error('Connection refused');
                        error.code = 'ECONNREFUSED';
                        throw error;
                    }
                    return { id: Math.random(), ...processedData };
                },
                { operation: 'saveUserData', data: processedData }
            );
            
            return savedData;
            
        } catch (error) {
            // Top-level error handling
            console.log('=== TOP LEVEL ERROR ===');
            console.log('Layer:', error.layer);
            console.log('Message:', error.message);
            console.log('User Message:', error.userMessage);
            console.log('Business Rule:', error.businessRule);
            console.log('Is Retryable:', error.isRetryable);
            
            throw error;
        }
    }
}

// Testing layered error propagation
const service = new LayeredApplicationService();

async function testLayeredPropagation() {
    try {
        await service.processUserRequest({ name: 'John', age: 16 });
    } catch (error) {
        console.log('Final error handling completed');
    }
}
```

### Monitoring e Observability Durante Propagation

```javascript
// Error propagation monitoring system
class PropagationMonitor {
    constructor() {
        this.traces = new Map();
        this.statistics = {
            totalErrors: 0,
            propagationPaths: new Map(),
            handlingPoints: new Map()
        };
        this.observers = [];
    }
    
    addObserver(observer) {
        this.observers.push(observer);
        return this;
    }
    
    startTrace(traceId, context) {
        this.traces.set(traceId, {
            id: traceId,
            startTime: Date.now(),
            context,
            path: [],
            handled: false
        });
        
        this.notifyObservers('trace-started', this.traces.get(traceId));
    }
    
    recordPropagation(traceId, location, error) {
        const trace = this.traces.get(traceId);
        if (!trace) return;
        
        const step = {
            location,
            timestamp: Date.now(),
            error: {
                name: error.name,
                message: error.message,
                code: error.code
            }
        };
        
        trace.path.push(step);
        
        // Update statistics
        const pathKey = trace.path.map(s => s.location).join(' -> ');
        this.statistics.propagationPaths.set(
            pathKey,
            (this.statistics.propagationPaths.get(pathKey) || 0) + 1
        );
        
        this.notifyObservers('propagation-step', { trace, step });
    }
    
    recordHandling(traceId, handler, outcome) {
        const trace = this.traces.get(traceId);
        if (!trace) return;
        
        trace.handled = true;
        trace.handler = handler;
        trace.outcome = outcome;
        trace.endTime = Date.now();
        trace.duration = trace.endTime - trace.startTime;
        
        // Update statistics
        this.statistics.totalErrors++;
        this.statistics.handlingPoints.set(
            handler,
            (this.statistics.handlingPoints.get(handler) || 0) + 1
        );
        
        this.notifyObservers('error-handled', trace);
    }
    
    notifyObservers(event, data) {
        this.observers.forEach(observer => {
            if (observer[event]) {
                observer[event](data);
            }
        });
    }
    
    getStatistics() {
        return {
            ...this.statistics,
            averagePropagationDepth: this.calculateAveragePropagationDepth(),
            mostCommonPaths: this.getMostCommonPaths(),
            topHandlers: this.getTopHandlers()
        };
    }
    
    calculateAveragePropagationDepth() {
        const depths = Array.from(this.traces.values())
            .map(trace => trace.path.length);
        
        return depths.length > 0 
            ? depths.reduce((sum, depth) => sum + depth, 0) / depths.length 
            : 0;
    }
    
    getMostCommonPaths() {
        return Array.from(this.statistics.propagationPaths.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
    }
    
    getTopHandlers() {
        return Array.from(this.statistics.handlingPoints.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
    }
}

// Create monitor instance
const monitor = new PropagationMonitor();

// Add console observer
monitor.addObserver({
    'trace-started': (trace) => {
        console.log(`üîç Error trace started: ${trace.id}`);
    },
    'propagation-step': ({ trace, step }) => {
        console.log(`üìà Error propagated to: ${step.location} (${step.error.name})`);
    },
    'error-handled': (trace) => {
        console.log(`‚úÖ Error handled by: ${trace.handler} (${trace.duration}ms)`);
    }
});

// Monitored function wrapper
function createMonitoredFunction(fn, location) {
    return async (...args) => {
        const traceId = `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        try {
            monitor.startTrace(traceId, { function: fn.name, location, args });
            return await fn.apply(this, args);
        } catch (error) {
            monitor.recordPropagation(traceId, location, error);
            throw error;
        }
    };
}

// Monitored error handler wrapper
function createMonitoredHandler(handler, handlerName) {
    return async (error, ...args) => {
        const traceId = error.traceId || `unknown_${Date.now()}`;
        
        try {
            const result = await handler(error, ...args);
            monitor.recordHandling(traceId, handlerName, 'success');
            return result;
        } catch (handlingError) {
            monitor.recordHandling(traceId, handlerName, 'failed');
            throw handlingError;
        }
    };
}

// Example usage com monitoring
const monitoredService = {
    deepFunction: createMonitoredFunction(
        function() {
            throw new Error("Deep monitored error");
        },
        'service.deepFunction'
    ),
    
    middleFunction: createMonitoredFunction(
        async function() {
            return await this.deepFunction();
        },
        'service.middleFunction'
    ),
    
    topFunction: createMonitoredFunction(
        async function() {
            return await this.middleFunction();
        },
        'service.topFunction'
    )
};

// Monitored error handlers
const monitoredHandlers = {
    globalHandler: createMonitoredHandler(
        async (error) => {
            console.log("Global handler processing:", error.message);
            return { handled: true };
        },
        'globalHandler'
    ),
    
    specificHandler: createMonitoredHandler(
        async (error) => {
            console.log("Specific handler processing:", error.message);
            return { handled: true, specific: true };
        },
        'specificHandler'
    )
};

// Test monitored propagation
async function testMonitoredPropagation() {
    try {
        await monitoredService.topFunction();
    } catch (error) {
        await monitoredHandlers.globalHandler(error);
    }
    
    // Print monitoring statistics
    console.log('\n=== MONITORING STATISTICS ===');
    console.log(JSON.stringify(monitor.getStatistics(), null, 2));
}
```

---

## üéØ Aplicabilidade e Contextos

### Web Application Error Propagation

```javascript
// Complete web application error propagation system
class WebApplicationErrorSystem {
    constructor() {
        this.monitor = new PropagationMonitor();
        this.controller = new PropagationController();
        this.setupGlobalHandlers();
        this.setupUnhandledRejectionHandler();
    }
    
    setupGlobalHandlers() {
        // Global error handler
        window.addEventListener('error', (event) => {
            this.handleGlobalError(event.error, {
                type: 'global',
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });
        
        // Global unhandled promise rejection handler
        window.addEventListener('unhandledrejection', (event) => {
            this.handleGlobalError(event.reason, {
                type: 'unhandled-promise'
            });
        });
    }
    
    setupUnhandledRejectionHandler() {
        // Prevent default browser handling
        window.addEventListener('unhandledrejection', (event) => {
            event.preventDefault();
        });
    }
    
    async handleGlobalError(error, context) {
        console.log('üö® Global error handler triggered');
        console.log('Error:', error.message);
        console.log('Context:', context);
        
        // Send para error reporting service
        await this.reportError(error, context);
        
        // Display user-friendly error message
        this.displayErrorToUser(error);
    }
    
    async reportError(error, context) {
        try {
            // Simulate error reporting service
            const errorReport = {
                timestamp: new Date().toISOString(),
                message: error.message,
                stack: error.stack,
                context,
                userAgent: navigator.userAgent,
                url: window.location.href
            };
            
            console.log('üìä Error reported:', errorReport);
            
            // Could send para logging service
            // await fetch('/api/errors', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify(errorReport)
            // });
        } catch (reportingError) {
            console.error('Failed to report error:', reportingError);
        }
    }
    
    displayErrorToUser(error) {
        // Create user-friendly error display
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-notification';
        errorDiv.innerHTML = `
            <div class="error-content">
                <h3>Oops! Something went wrong</h3>
                <p>We're sorry, but something unexpected happened. Please try again.</p>
                <button onclick="this.parentElement.parentElement.remove()">Dismiss</button>
            </div>
        `;
        
        // Style (would normally be em CSS)
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #f5c6cb;
            z-index: 10000;
            max-width: 300px;
        `;
        
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (errorDiv.parentElement) {
                errorDiv.remove();
            }
        }, 5000);
    }
}

// API Client com sophisticated error propagation
class APIClient {
    constructor(baseURL, errorSystem) {
        this.baseURL = baseURL;
        this.errorSystem = errorSystem;
        this.interceptors = [];
    }
    
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
        return this;
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        const traceId = `api_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        try {
            // Apply request interceptors
            let requestOptions = options;
            for (const interceptor of this.interceptors) {
                if (interceptor.request) {
                    requestOptions = await interceptor.request(requestOptions);
                }
            }
            
            const response = await fetch(url, requestOptions);
            
            if (!response.ok) {
                const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
                error.name = 'HTTPError';
                error.status = response.status;
                error.response = response;
                error.traceId = traceId;
                throw error;
            }
            
            let result = await response.json();
            
            // Apply response interceptors
            for (const interceptor of this.interceptors) {
                if (interceptor.response) {
                    result = await interceptor.response(result);
                }
            }
            
            return result;
            
        } catch (error) {
            // Enhance error com API context
            error.traceId = traceId;
            error.endpoint = endpoint;
            error.url = url;
            
            // Apply error interceptors
            for (const interceptor of this.interceptors) {
                if (interceptor.error) {
                    error = await interceptor.error(error);
                }
            }
            
            throw error;
        }
    }
}

// Business service layer
class UserService {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    
    async getUser(userId) {
        try {
            return await this.apiClient.request(`/users/${userId}`);
        } catch (error) {
            // Add business context
            error.businessOperation = 'getUser';
            error.userId = userId;
            
            // Transform specific errors
            if (error.status === 404) {
                const userNotFoundError = new Error(`User ${userId} not found`);
                userNotFoundError.name = 'UserNotFoundError';
                userNotFoundError.userId = userId;
                userNotFoundError.originalError = error;
                throw userNotFoundError;
            }
            
            throw error;
        }
    }
    
    async updateUser(userId, userData) {
        try {
            return await this.apiClient.request(`/users/${userId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(userData)
            });
        } catch (error) {
            // Add update context
            error.businessOperation = 'updateUser';
            error.userId = userId;
            error.userData = userData;
            
            // Transform validation errors
            if (error.status === 400) {
                const validationError = new Error('User data validation failed');
                validationError.name = 'UserValidationError';
                validationError.userId = userId;
                validationError.validationData = userData;
                validationError.originalError = error;
                throw validationError;
            }
            
            throw error;
        }
    }
}

// UI Components com error handling
class UserComponent {
    constructor(userService, errorSystem) {
        this.userService = userService;
        this.errorSystem = errorSystem;
    }
    
    async loadUser(userId) {
        try {
            const user = await this.userService.getUser(userId);
            this.displayUser(user);
        } catch (error) {
            this.handleUserLoadError(error, userId);
        }
    }
    
    async saveUser(userId, userData) {
        try {
            const updatedUser = await this.userService.updateUser(userId, userData);
            this.displaySuccessMessage('User updated successfully');
            return updatedUser;
        } catch (error) {
            this.handleUserSaveError(error, userId, userData);
        }
    }
    
    handleUserLoadError(error, userId) {
        if (error.name === 'UserNotFoundError') {
            this.displayError(`User ${userId} not found. Please check the user ID.`);
        } else if (error.name === 'HTTPError' && error.status >= 500) {
            this.displayError('Server error. Please try again later.');
        } else if (error.name === 'NetworkError') {
            this.displayError('Network connection problem. Please check your internet connection.');
        } else {
            this.displayError('Failed to load user. Please try again.');
            // Let it propagate para global handler
            throw error;
        }
    }
    
    handleUserSaveError(error, userId, userData) {
        if (error.name === 'UserValidationError') {
            this.displayValidationErrors(error.validationData);
        } else if (error.name === 'HTTPError' && error.status === 403) {
            this.displayError('You do not have permission to update this user.');
        } else {
            this.displayError('Failed to save user. Please try again.');
            // Let it propagate para global handler
            throw error;
        }
    }
    
    displayUser(user) {
        console.log('Displaying user:', user);
    }
    
    displayError(message) {
        console.log('Error displayed to user:', message);
    }
    
    displayValidationErrors(validationData) {
        console.log('Validation errors displayed:', validationData);
    }
    
    displaySuccessMessage(message) {
        console.log('Success message:', message);
    }
}

// Initialize complete system
const errorSystem = new WebApplicationErrorSystem();
const apiClient = new APIClient('https://api.example.com', errorSystem);

// Add API interceptors
apiClient
    .addInterceptor({
        request: async (options) => {
            console.log('üîÑ API Request interceptor:', options);
            return options;
        },
        response: async (response) => {
            console.log('‚úÖ API Response interceptor:', response);
            return response;
        },
        error: async (error) => {
            console.log('‚ùå API Error interceptor:', error.message);
            return error;
        }
    });

const userService = new UserService(apiClient);
const userComponent = new UserComponent(userService, errorSystem);

// Test complete error propagation
async function testCompleteSystem() {
    console.log('=== Testing Complete Error Propagation System ===');
    
    // This will trigger various levels de error handling
    await userComponent.loadUser('nonexistent-user');
    await userComponent.saveUser('123', { invalidData: true });
}
```

---

## üìö Conclus√£o

**Error propagation** √© **fundamental mechanism** que enable **sophisticated error management** em **complex JavaScript applications**. Permite **separation of concerns** entre **error generation** e **error handling**, facilitando **maintainable**, **debuggable**, e **resilient** application architectures.

**Pontos Cr√≠ticos:**

- **Understand propagation paths** - trace como errors flow atrav√©s do application
- **Implement selective handling** - catch e handle errors em appropriate levels
- **Maintain error context** - preserve important information durante propagation
- **Design error boundaries** - control where e como errors s√£o handled
- **Monitor error patterns** - track propagation paths para identify improvement opportunities

Error propagation, quando **properly managed**, transforms **chaotic error scenarios** em **controlled**, **predictable** error handling workflows que **enhance application reliability** e **user experience**.