## Funções Aninhadas no Dart

### O que é e para que serve?

Funções aninhadas, também conhecidas como funções locais, são funções definidas dentro de outras funções. Em Dart, essas funções podem ser utilizadas para encapsular lógica que só é relevante no contexto da função pai, promovendo uma melhor organização do código e ajudando a evitar poluição do escopo global. Elas são úteis para dividir tarefas complexas em sub-tarefas menores e mais gerenciáveis, mantendo o código mais legível e modular.

### Sintaxe de uso

A sintaxe para declarar uma função aninhada em Dart é simples. Uma função aninhada é definida dentro do corpo de outra função:

```dart
void main() {
  void outerFunction() {
    print('This is the outer function.');

    void nestedFunction() {
      print('This is the nested function.');
    }

    nestedFunction();
  }

  outerFunction();
}
```

Neste exemplo, `nestedFunction` é uma função aninhada dentro de `outerFunction`. Quando `outerFunction` é chamada, ela executa `nestedFunction`.

### Restrições de uso

- **Escopo**: Funções aninhadas só podem ser acessadas dentro do escopo da função que as contém. Elas não podem ser chamadas fora desse escopo.
- **Visibilidade**: Funções aninhadas têm acesso às variáveis e parâmetros da função pai, mas a função pai não tem acesso direto às variáveis da função aninhada.
- **Recursão**: Funções aninhadas podem ser recursivas, mas devem ser usadas com cuidado para evitar loops infinitos.

### Quando utilizar?

- **Encapsulamento de Lógica**: Use funções aninhadas para encapsular lógica que só faz sentido dentro do contexto de uma função específica.
- **Redução de Escopo Global**: Funções aninhadas ajudam a reduzir a poluição do escopo global, mantendo o escopo mais limpo e organizado.
- **Legibilidade**: Dividir uma tarefa complexa em funções aninhadas pode aumentar a legibilidade do código, tornando-o mais fácil de entender e manter.
- **Evitar Repetição**: Se uma lógica específica é usada várias vezes dentro de uma função, encapsulá-la em uma função aninhada evita a repetição de código.

### Exemplos Adicionais

#### Exemplo 1: Função Aninhada com Acesso a Variáveis da Função Pai

```dart
void main() {
  void calculate(int a, int b) {
    int result;

    void add() {
      result = a + b;
    }

    add();
    print('The sum is $result');
  }

  calculate(5, 3);
}
```

Neste exemplo, a função `add` é aninhada dentro da função `calculate` e tem acesso aos parâmetros `a` e `b` de `calculate`.

#### Exemplo 2: Função Aninhada com Recursão

```dart
void main() {
  void outerFunction() {
    print('Starting outer function.');

    void nestedFunction(int count) {
      if (count > 0) {
        print('Nested function call with count: $count');
        nestedFunction(count - 1);
      }
    }

    nestedFunction(3);
  }

  outerFunction();
}
```

Neste exemplo, `nestedFunction` chama a si mesma recursivamente até que `count` seja zero.

### Informações Adicionais

- **Closures**: Funções aninhadas em Dart podem capturar variáveis do escopo da função pai, criando closures. Isso permite que a função aninhada mantenha acesso às variáveis da função pai mesmo após a execução desta.
  
  ```dart
  void main() {
    Function makeAdder(int addBy) {
      return (int i) => addBy + i;
    }

    var add2 = makeAdder(2);
    print(add2(3)); // 5
  }
  ```

Neste exemplo, a função retornada pelo `makeAdder` captura a variável `addBy`, formando uma closure.

Utilizar funções aninhadas pode trazer vários benefícios em termos de organização e clareza do código, mas deve ser feito de maneira consciente para evitar complicações desnecessárias.