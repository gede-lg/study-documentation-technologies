
Em **Dart**, o conceito de _Futures_ (também conhecidas como _futuras_) é fundamental para lidar com operações assíncronas de maneira organizada e expressiva. Operações assíncronas são todas aquelas em que o programa não precisa (e nem deve) ficar “parado” esperando pela conclusão de uma tarefa. Exemplos comuns de operações assíncronas incluem:

- Chamadas a serviços remotos (APIs).
- Leitura/escrita em disco.
- Processamentos demorados (como análises complexas de dados).

O _Future_ em Dart representa o resultado (ou potencial erro) de uma operação que ainda não foi concluída. É como se fosse uma “promessa” de que, quando a operação terminar, haverá um valor ou ocorrerá uma exceção.

## Sumário

1. [O que é e para que serve?](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#o-que-%C3%A9-e-para-que-serve)
2. [Como funciona?](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#como-funciona)
3. [Sintaxe de uso](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#sintaxe-de-uso)
    - [Detalhamento de parâmetros](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#detalhamento-de-par%C3%A2metros)
4. [Principais construtores](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#principais-construtores)
5. [Restrições de uso](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#restri%C3%A7%C3%B5es-de-uso)
6. [Quando utilizar?](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#quando-utilizar)
7. [Propriedades](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#propriedades)
8. [Métodos](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#m%C3%A9todos)
9. [Exemplos de código](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047?model=o1#exemplos-de-c%C3%B3digo)

---

## O que é e para que serve?

Um objeto da classe **`Future`** em Dart é uma representação de um resultado que estará disponível em algum momento no futuro. Esse resultado pode ser de dois tipos:

1. Um valor retornado com sucesso.
2. Um erro/exceção.

De forma prática, você utiliza _Futures_ sempre que a sua operação não puder ser resolvida imediatamente (por exemplo, buscar dados em uma API). Em vez de bloquear a thread principal (impedindo que o restante do programa rode), o Dart retorna imediatamente um _Future_ que, quando concluído, fornecerá o valor desejado ou lançará uma exceção.

---

## Como funciona?

Quando você chama uma função que retorna um _Future_, esse _Future_ é criado e logo em seguida:

1. **Imediatamente**: o fluxo do seu programa continua, sem esperar a função finalizar.
2. **Quando a operação terminar** (pode ser milissegundos depois ou muito mais tempo):
    - O _Future_ é completado com o valor (se tudo deu certo).
    - OU o _Future_ é completado com um erro/exceção (se algo deu errado).

Você pode então **“escutar”** a conclusão desse _Future_ usando:

- **Métodos de callback**: `then`, `catchError`, `whenComplete`
- **`async`/`await`**: que transforma o código em um fluxo mais sequencial, porém assíncrono.

> **Dica**: O uso de `async`/`await` é recomendado por deixar o código mais legível e fácil de manter.

---

## Sintaxe de uso

A sintaxe de uso de um _Future_ pode variar conforme o estilo de programação. Aqui vão duas formas principais: através de métodos de callback ou com `async/await`.

### Sintaxe com métodos de callback

```dart
Future<int> buscarNumero() {
  // Retorna um Future que, após 2 segundos, conclui com o valor 42
  return Future.delayed(Duration(seconds: 2), () => 42);
}

void exemploCallback() {
  buscarNumero().then((valor) {
    print('O valor é $valor');
  }).catchError((erro) {
    print('Ocorreu um erro: $erro');
  }).whenComplete(() {
    print('Operação finalizada.');
  });
}
```

1. `then((valor) => ...)`
    - Chamado quando o _Future_ é completado com sucesso, recebendo o valor resultante.
2. `catchError((erro) => ...)`
    - Chamado se ocorrer algum erro durante a execução do _Future_.
3. `whenComplete(() => ...)`
    - Chamado sempre, independente de sucesso ou erro. É útil para limpeza de recursos.

### Sintaxe com `async/await`

```dart
Future<int> buscarNumero() async {
  // Simulação de processo assíncrono
  await Future.delayed(Duration(seconds: 2));
  return 42;
}

void exemploAsyncAwait() async {
  try {
    var valor = await buscarNumero();
    print('O valor é $valor');
  } catch (e) {
    print('Ocorreu um erro: $e');
  } finally {
    print('Operação finalizada.');
  }
}
```

1. Para usar `async/await`, a função que contém `await` deve ser marcada com `async`.
2. `await` pausa a execução até que o _Future_ seja concluído.
3. `try/catch/finally` funciona de forma semelhante ao código síncrono.

### Detalhamento de parâmetros

- **`Future.delayed`**:
    
    - Parâmetro **obrigatório**: `Duration`.
    - Parâmetro **opcional**: uma função de callback (`() => T`) que produz o valor de conclusão.
    - **Tipo**: `Future<T>` (onde `T` é o tipo retornado pela callback, ou `void` caso não retorne nada).
- **`then`**:
    
    - Parâmetro **obrigatório**: função de callback que recebe o valor de sucesso do _Future_.
    - Parâmetro **opcional**: função `onError` que pode capturar o erro, mas é menos usado quando se utiliza `catchError`.
- **`catchError`**:
    
    - Parâmetro **obrigatório**: função que recebe o erro.
    - Parâmetros **opcionais**: `test`, que permite filtrar qual erro capturar.
- **`whenComplete`**:
    
    - Parâmetro **obrigatório**: função callback sem parâmetros e sem retorno (tipo `void`).
- **`async`** e **`await`**:
    
    - `async` não recebe parâmetros; é uma _keyword_ que marca a função como assíncrona.
    - `await` também é uma _keyword_ que recebe o _Future_ a ser aguardado.

---

## Principais construtores

A classe `Future` em Dart fornece alguns construtores úteis:

1. **`Future.value(T value)`**  
    Cria um _Future_ já completado com o valor especificado.
    
    ```dart
    Future<int> futuro = Future.value(10);
    ```
    
2. **`Future.error(Object error, [StackTrace? stackTrace])`**  
    Cria um _Future_ já completado com um erro.
    
    ```dart
    Future<int> futuroErro = Future.error('Algo deu errado');
    ```
    
3. **`Future.delayed(Duration duration, [T? computation()])`**  
    Retorna um _Future_ que será completado após o tempo especificado. Opcionalmente, pode executar uma função `computation` que retorna o valor do _Future_.
    
    ```dart
    Future<int> futuroAtrasado = Future.delayed(Duration(seconds: 2), () => 42);
    ```
    
4. **`Future.sync(T computation())`**  
    Cria um _Future_ executando a função de forma síncrona se possível. Se a função lança um erro, o _Future_ é completado com erro. Caso contrário, o valor é retornado.
    
    ```dart
    Future<int> futuroSync = Future.sync(() => 100);
    ```
    
5. **`Future.any(Iterable<Future<T>> futures)`**  
    Retorna um _Future_ que será completado com o primeiro _Future_ da lista que completar com sucesso ou erro.
    
    ```dart
    Future<int> futuroMaisRapido = Future.any([
      Future.delayed(Duration(seconds: 1), () => 1),
      Future.delayed(Duration(seconds: 2), () => 2),
    ]);
    ```
    
6. **`Future.wait(Iterable<Future<T>> futures, {bool eagerError = false, void Function(T successValue)? cleanUp})`**  
    Retorna um _Future_ que será completado apenas quando _todos_ os _Futures_ na lista forem concluídos. Ele retorna uma lista com os resultados na mesma ordem dos _Futures_.
    
    ```dart
    Future<List<int>> todos = Future.wait([
      Future.delayed(Duration(seconds: 1), () => 1),
      Future.delayed(Duration(seconds: 2), () => 2),
    ]);
    ```
    

---

## Restrições de uso

1. **Thread principal**: O Dart não bloqueia a thread principal (no caso de Flutter, a _UI thread_) aguardando operações assíncronas. Portanto, se você precisa de algo imediatamente disponível, considere se faz sentido ou não ser `Future`.
2. **Isolados**: Para computações muito pesadas, você pode considerar usar _Isolates_, pois eles rodam em paralelo. Entretanto, _Futures_ não fazem esse processamento em outra _thread_ automaticamente; elas apenas agendam para o _event loop_ do Dart.
3. **Sequência de chamadas**: Evite criar _Futures_ em cascata sem necessidade. Em muitos casos, usar `async/await` simplifica o fluxo.

---

## Quando utilizar?

- **Acesso a rede**: APIs HTTP, sockets e qualquer acesso à internet.
- **Leitura e escrita em disco**: operações de I/O.
- **Operações que podem demorar**: qualquer tarefa que não retorne imediatamente.
- **Código que depende da finalização de outro código**: quando você só pode continuar depois que algo é calculado ou recuperado.

Em geral, sempre que a tarefa não puder ser resolvida de forma síncrona, o uso de _Future_ (ou um tipo assíncrono equivalente, como _Stream_) é o mais adequado.

---

## Propriedades

Abaixo está uma tabela com **todas** as propriedades principais de `Future`. Algumas propriedades são getters que retornam valores internos para manipulação interna da linguagem, não sendo normalmente utilizadas diretamente no seu dia-a-dia. Ainda assim, seguem listadas:

|Propriedade|Descrição|Sintaxe de uso|
|---|---|---|
|**`FutureOr`**|_FutureOr_ não é propriamente uma propriedade de _Future_, mas sim um tipo que indica que algo pode ser tanto um _Future_ como um valor síncrono.|-|
|**`isCompleted`** (interno)|Não existe no _Future_ de forma exposta publicamente. Ele é usado internamente para verificar se o _Future_ já foi concluído.|-|
|**`_value`** (privado)|Valor interno do _Future_ (quando concluído com sucesso). É privado, então não é acessível externamente.|-|
|**`_error`** (privado)|Armazena o erro interno do _Future_ (quando concluído com erro). Também é privado.|-|
|**`_completionCallbacks`** (privado)|Lista interna de callbacks a serem chamados na conclusão do _Future_. Também não é acessível externamente.|-|

> **Observação**: A classe `Future` do Dart não expõe publicamente muitas propriedades. Geralmente manipulamos objetos `Future` por meio de seus métodos (como `then`, `catchError`, etc.), não através de propriedades. A tabela acima reflete isso: a maior parte do estado interno de _Future_ é privada.

---

## Métodos

Abaixo está uma tabela com **todos** os métodos mais importantes da classe `Future` (alguns são estáticos, outros de instância). Vale lembrar que métodos privados ou específicos a implementações internas não são expostos para uso comum.

|Método|Descrição|Sintaxe de uso|
|---|---|---|
|**`then<R>(FutureOr<R> onValue(T value), {Function? onError})`**|Executa uma função quando o _Future_ for completado com sucesso, retornando um novo _Future_. Em caso de erro, se fornecido `onError`, o erro pode ser tratado nesse ponto.|`future.then((valor) { ... }, onError: (e) { ... });`|
|**`catchError(Function onError, {bool Function(Object error)? test})`**|Permite capturar o erro produzido pelo _Future_. Se a função `test` for fornecida, apenas os erros que satisfizerem essa função serão capturados.|`future.catchError((erro) { ... }, test: (e) => e is CustomError);`|
|**`whenComplete(FutureOr<void> action())`**|Executa uma ação (síncrona ou assíncrona) ao finalizar o _Future_, independente de sucesso ou erro. Retorna um novo _Future_ que é completado após a ação fornecida.|`future.whenComplete(() { ... });`|
|**`timeout(Duration timeLimit, {FutureOr<T> onTimeout()?})`**|Se o _Future_ não completar dentro de `timeLimit`, ele é completado com erro `TimeoutException`, a não ser que seja especificado `onTimeout`, que então é executado quando ocorre o tempo limite.|`future.timeout(Duration(seconds: 3), onTimeout: () => 0);`|
|**`asStream()`**|Converte um _Future_ para um _Stream_ que emite um único evento (o valor do _Future_) e depois fecha. Se o _Future_ falhar, o _Stream_ emitirá um erro.|`Stream<T> stream = future.asStream();`|
|**`Future.value(T value)`**|Cria um _Future_ já completado com o valor especificado.|`Future<int> futuro = Future.value(42);`|
|**`Future.error(Object error, [StackTrace? stackTrace])`**|Cria um _Future_ já completado com o erro especificado.|`Future.error('Algo deu errado');`|
|**`Future.delayed(Duration duration, [T? computation()?])`**|Cria um _Future_ que será completado depois de um tempo. Se for fornecida a função `computation`, o valor retornado por ela será o valor do _Future_.|`Future.delayed(Duration(seconds: 2), () => 42);`|
|**`Future.sync(T computation())`**|Cria um _Future_ executando a função de forma síncrona, se possível. Se a função lança exceção, o _Future_ é concluído com erro.|`Future.sync(() => 100);`|
|**`Future.any(Iterable<Future<T>> futures)`**|Retorna um _Future_ que é completado com o resultado ou erro do primeiro _Future_ da lista fornecida que completar.|`Future.any([fut1, fut2, fut3]);`|
|**`Future.wait(Iterable<Future<T>> futures, {bool eagerError = false, void Function(T successValue)? cleanUp})`**|Retorna um _Future_ que será completado apenas após todos os _Futures_ da lista concluírem. Caso `eagerError` seja `true`, o _Future_ retorna erro assim que um deles falhar. O `cleanUp` é chamado para cada valor completado com sucesso, caso um erro ocorra antes de todos terminarem.|`Future.wait([fut1, fut2, fut3], eagerError: true, cleanUp: (val) { ... });`|

---

## Exemplos de código

### Exemplo 1: Usando `then`, `catchError` e `whenComplete`

```dart
Future<String> buscarUsuario(int id) {
  // Simulação de API que retorna o nome do usuário
  return Future.delayed(Duration(seconds: 1), () {
    if (id == 0) {
      throw Exception('ID inválido');
    }
    return 'Usuário $id';
  });
}

void exemploThenCatchWhenComplete() {
  buscarUsuario(1)
    .then((usuario) {
      print('Usuário encontrado: $usuario');
    })
    .catchError((erro) {
      print('Erro ao buscar usuário: $erro');
    })
    .whenComplete(() {
      print('Operação finalizada.');
    });
}
```

### Exemplo 2: Usando `async`/`await`

```dart
Future<String> buscarEndereco(String cep) async {
  // Simulação de requisição a uma API de CEP
  await Future.delayed(Duration(seconds: 2));
  if (cep == '00000-000') {
    throw Exception('CEP não encontrado');
  }
  return 'Rua Fictícia, 123';
}

void exemploAsyncAwait() async {
  try {
    var endereco = await buscarEndereco('12345-678');
    print('Endereço: $endereco');
  } catch (e) {
    print('Erro ao buscar endereço: $e');
  } finally {
    print('Operação finalizada.');
  }
}
```

### Exemplo 3: Usando `Future.wait` para executar várias tarefas em paralelo

```dart
Future<int> tarefa1() async {
  await Future.delayed(Duration(seconds: 2));
  return 10;
}

Future<int> tarefa2() async {
  await Future.delayed(Duration(seconds: 3));
  return 20;
}

void exemploWait() async {
  var resultados = await Future.wait([tarefa1(), tarefa2()]);
  print('Resultados: $resultados'); // [10, 20]
}
```

### Exemplo 4: Usando `Future.any` para pegar a primeira resposta disponível

```dart
Future<int> tarefaLenta() async {
  await Future.delayed(Duration(seconds: 3));
  return 30;
}

Future<int> tarefaRapida() async {
  await Future.delayed(Duration(seconds: 1));
  return 10;
}

void exemploAny() async {
  var primeiroValor = await Future.any([tarefaLenta(), tarefaRapida()]);
  print('Primeiro valor recebido: $primeiroValor'); // Geralmente será 10
}
```

---

## Conclusão

- **Futures** são a forma de lidar com computações assíncronas em Dart.
- Elas permitem que seu código continue sendo executado enquanto tarefas complexas ocorrem em segundo plano.
- Você pode **“aguardar”** a conclusão de um _Future_ usando `then`/`catchError`/`whenComplete` ou pela abordagem mais moderna com `async`/`await`.
- Métodos e construtores como `Future.delayed`, `Future.any`, `Future.wait`, entre outros, trazem grande flexibilidade para orquestrar operações assíncronas.

**Em resumo,** se você quer garantir que seu app ou script Dart permaneça responsivo e não trave durante operações demoradas, vai precisar dominar o uso de _Futures_. A adoção do `async/await` torna o código mais próximo de uma lógica síncrona, porém sem bloquear a execução do programa.

> Espero que esta explicação detalhada tenha ajudado a compreender de forma abrangente como funcionam os _Futures_ em Dart, bem como seus principais usos, construtores, métodos e boas práticas!