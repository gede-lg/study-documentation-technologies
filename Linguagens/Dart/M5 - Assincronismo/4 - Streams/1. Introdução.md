
## Introdução

No desenvolvimento de aplicações Flutter (que utiliza a linguagem Dart), o manuseio de dados de forma assíncrona é algo essencial. Muitas vezes precisamos ouvir atualizações de alguma fonte (por exemplo, uma API, banco de dados em tempo real ou eventos do usuário) e reagir a essas mudanças conforme elas ocorrem. É nesse cenário que a classe **`Stream`** se mostra extremamente útil.

Uma **`Stream`** (fluxo) nada mais é do que uma sequência de eventos assíncronos que podem ser processados conforme chegam. Em termos simples, podemos pensar em uma _"esteira"_ que transporta valores (eventos) ao longo do tempo e, a qualquer momento, podemos escutar (listen) essa esteira para receber os valores.

---

## Sumário

1. [O que é e para que serve?](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#o-que-%C3%A9-e-para-que-serve)
2. [Como funciona?](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#como-funciona)
3. [Sintaxe de uso](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#sintaxe-de-uso)
4. [Restrições de uso](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#restri%C3%A7%C3%B5es-de-uso)
5. [Quando utilizar?](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#quando-utilizar)
6. [Tabela de propriedades](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#tabela-de-propriedades)
7. [Tabela de métodos](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#tabela-de-m%C3%A9todos)
8. [Exemplos práticos](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#exemplos-pr%C3%A1ticos)
9. [Conclusão](https://chatgpt.com/c/676f63d0-6040-8003-b1c9-3c15a5bb7047#conclus%C3%A3o)

---

## O que é e para que serve?

- **O que é?**  
    A classe **`Stream`** representa uma fonte de dados que chega de forma assíncrona ao longo do tempo. Cada novo dado emitido pela stream é chamado de **evento**.
    
- **Para que serve?**  
    Serve para **observar** e **reagir** a eventos que ocorrem em momentos diferentes. Por exemplo, ler dados de um servidor, observar mudanças em um banco de dados (como o Firestore no Firebase), tratar eventos de cliques do usuário ou mesmo reproduzir listas de valores gerados de forma lazy (sob demanda).
    

---

## Como funciona?

A ideia central por trás de **`Stream`** é que você tem duas partes principais:

1. **Emissor** (_source_) – responsável por adicionar novos eventos na stream.
2. **Ouvinte** (_listener_) – quem escuta os eventos da stream e reage a eles.

Em Dart, podemos criar uma stream de várias maneiras. Uma das mais comuns em aplicações Flutter é por meio de um **`StreamController`**, que gerencia a adição de eventos e o fechamento (quando não há mais eventos).

Quando você chama `stream.listen(...)`, você se **inscreve** para receber dados sempre que eles chegarem. Caso a stream já tenha sido finalizada ou não possua mais eventos, a escuta também finalizará.

---

## Sintaxe de uso

### Declaração

```dart
// Declaração genérica da classe Stream:
abstract class Stream<T> {
  //...
}
```

- **`<T>`**: tipo genérico que representa o tipo de dado que a stream vai emitir (por exemplo, `String`, `int`, `MyCustomModel`, etc.).

### Exemplo básico de criação de uma stream (via StreamController)

```dart
import 'dart:async';

void main() {
  // Cria um StreamController de tipo String
  final controller = StreamController<String>();

  // Obtém a stream a partir do controller
  final Stream<String> minhaStream = controller.stream;

  // Escuta a stream
  minhaStream.listen((dado) {
    print("Recebi: $dado");
  });

  // Adiciona eventos na stream
  controller.add("Primeiro evento");
  controller.add("Segundo evento");

  // Fecha o controller quando não for mais necessário
  controller.close();
}
```

### Parâmetros relevantes

Quando criamos uma **`Stream`** diretamente (usando construtores ou métodos estáticos como `Stream.fromIterable`, `Stream.value`, `Stream.empty`, etc.) ou por meio de um `StreamController`, há alguns parâmetros importantes:

1. **Tipos de parâmetros esperados pela `Stream<T>`**
    
    - Genérico: **`T`** (tipo do dado que será emitido).
    - _Obrigatório_: Sempre deve existir um tipo, mesmo que seja `Stream<dynamic>`.
2. **No caso de uso de `StreamController`**
    
    - `sync: bool` (opcional) – se `true`, o controller é síncrono. O padrão é `false` para ser assíncrono.
    - No `StreamController`, podemos configurar `onListen`, `onCancel`, etc.
3. **Métodos para criar Streams** (exemplos):
    
    - `Stream.fromIterable(List<T> data)`: Cria uma stream a partir de uma lista.
    - `Stream.value(T value)`: Cria uma stream que emite um único valor.
    - `Stream.empty()`: Cria uma stream que não emite nenhum valor e finaliza imediatamente.
    - `Stream.error(Object error, [StackTrace? stackTrace])`: Cria uma stream que emite um erro.

Não há “parâmetros obrigatórios” na `Stream` em si (além do tipo genérico), pois cada forma de criar a stream pode ter seus próprios parâmetros específicos (como vimos acima).

---

## Restrições de uso

- Uma **`Stream`** só pode ser usada dentro do ecossistema do Dart/Flutter, obviamente.
    
- Streams podem ser:
    
    - **Single-subscription**: só podem ter **um** ouvinte por vez.
    - **Broadcast**: podem ter **múltiplos** ouvintes simultaneamente.
    - É importante entender esse comportamento antes de usar a stream, pois tentar escutar uma _single-subscription stream_ mais de uma vez causará erro.
- No caso de streams do tipo single-subscription, após o ouvinte ser cancelado ou o stream ser finalizado, não é possível escutá-la novamente (a não ser que seja recriada).
    

---

## Quando utilizar?

- **Leitura de dados assíncronos** de forma contínua, por exemplo, dados vindos de uma API de WebSocket.
- **Atualizações em tempo real** (dados de sensores, localização, banco de dados em tempo real).
- **Filtrar, transformar e manipular fluxos de eventos** em aplicações reativas.
- Em Flutter, com **`StreamBuilder`**, para reconstruir widgets sempre que houver novos dados na stream.

---

## Tabela de Propriedades

A classe `Stream` em Dart possui uma propriedade principal:

|Propriedade|Descrição|Sintaxe de uso|
|---|---|---|
|**isBroadcast**|Retorna um `bool` indicando se essa stream é do tipo _broadcast_ (ou seja, se aceita múltiplas inscrições/ouvintes simultaneamente).|`bool get isBroadcast;`|

> **Observação**: Embora sejam comuns métodos e construtores (como `asBroadcastStream()` para converter em broadcast), a _única_ propriedade diretamente exposta na classe `Stream` é `isBroadcast`.

---

## Tabela de Métodos

A classe `Stream<T>` possui diversos métodos para tratamento de dados, filtros, transformações e manipulações. A seguir, listamos **todos** eles:

|Método|Descrição|Sintaxe de uso|
|---|---|---|
|**any**|Retorna um `Future<bool>` que completa com `true` se ao menos um dos eventos satisfizer a condição fornecida (função de teste). Caso contrário, `false`.|`Future<bool> any(bool Function(T element) test)`|
|**asyncExpand**|Permite “expandir” cada evento em uma nova stream de eventos. Para cada evento, a função de callback retorna uma nova `Stream`.|`Stream<S> asyncExpand<S>(Stream<S>? Function(T event) convert)`|
|**asyncMap**|Aplica uma função assíncrona a cada evento e retorna uma nova stream com o resultado de cada chamada.|`Stream<S> asyncMap<S>(FutureOr<S> Function(T event) convert)`|
|**cast**|Realiza um cast da stream para outro tipo genérico. Útil quando se tem `Stream<dynamic>` e quer explicitamente converte-la para outro tipo.|`Stream<R> cast<R>()`|
|**contains**|Retorna um `Future<bool>` que completa com `true` se a stream emite algum valor que seja igual ao valor especificado.|`Future<bool> contains(Object? needle)`|
|**distinct**|Cria uma nova stream que só emite eventos quando o evento for diferente do último emitido. Pode receber uma função de comparação customizada.|`Stream<T> distinct([bool equals(T previous, T next)?])`|
|**drain**|Retorna um `Future<E>` que completa quando a stream é finalizada, descartando todos os eventos. Pode emitir um valor final caso desejado.|`Future<E> drain<E>([E? futureValue])`|
|**elementAt**|Retorna um `Future<T>` que completa com o valor do evento no índice especificado (primeiro evento é índice 0).|`Future<T> elementAt(int index)`|
|**every**|Retorna um `Future<bool>` que completa com `true` se todos os eventos satisfizerem a condição, `false` caso contrário.|`Future<bool> every(bool Function(T element) test)`|
|**expand**|Cria uma nova stream, expandindo cada evento em vários eventos, com base em uma função que retorna `Iterable<S>`.|`Stream<S> expand<S>(Iterable<S> Function(T element) convert)`|
|**first**|Retorna um `Future<T>` que completa com o primeiro evento emitido pela stream.|`Future<T> get first`|
|**firstWhere**|Retorna um `Future<T>` que completa com o primeiro evento que satisfizer a condição dada.|`Future<T> firstWhere(bool Function(T element) test, {T Function()? orElse})`|
|**fold**|Acumula valores a partir dos eventos da stream, usando uma função de agregação, e retorna um `Future<S>` com o resultado final após o término da stream.|`Future<S> fold<S>(S initialValue, S Function(S previous, T element) combine)`|
|**forEach**|Executa uma ação para cada evento da stream e retorna um `Future<void>` que completa quando a stream termina.|`Future<void> forEach(void Function(T element) action)`|
|**handleError**|Permite interceptar e tratar erros na stream, opcionalmente filtrando quais erros tratar.|`Stream<T> handleError(Function onError, {bool Function(dynamic error)? test})`|
|**isEmpty**|Retorna um `Future<bool>` que completa com `true` se a stream não emitir nenhum evento. Caso emita, completa com `false`.|`Future<bool> get isEmpty`|
|**join**|Retorna um `Future<String>` que concatena todos os eventos da stream (convertendo-os para `String`) usando um separador opcional.|`Future<String> join([String separator = ""])`|
|**last**|Retorna um `Future<T>` que completa com o último evento emitido pela stream antes de ela terminar.|`Future<T> get last`|
|**lastWhere**|Retorna um `Future<T>` que completa com o último evento que satisfizer a condição dada.|`Future<T> lastWhere(bool Function(T element) test, {T Function()? orElse})`|
|**length**|Retorna um `Future<int>` que completa com o número total de eventos emitidos pela stream.|`Future<int> get length`|
|**listen**|Permite escutar a stream. Recebe callbacks para eventos de dados, erros e quando a stream é finalizada. É o método principal para inscrição na stream.|StreamSubscription listen( void Function(T event)? onData, { Function? onError, void Function()? onDone, bool? cancelOnError } )|
|**map**|Transforma cada evento da stream em um novo valor, retornando uma nova stream.|`Stream<S> map<S>(S Function(T event) convert)`|
|**pipe**|Envia todos os eventos da stream atual para um `StreamConsumer`. Por exemplo, para escrever em um arquivo, outro sink, etc.|`Future<void> pipe(StreamConsumer<T> streamConsumer)`|
|**reduce**|Similar ao `fold`, mas usa o primeiro evento como valor inicial para a agregação. Retorna um `Future<T>` com o resultado final.|`Future<T> reduce(T Function(T previous, T element) combine)`|
|**single**|Retorna um `Future<T>` que completa com o único evento da stream, caso a stream emita exatamente um evento e finalize. Caso emita mais de um, ocorre erro.|`Future<T> get single`|
|**singleWhere**|Retorna um `Future<T>` que completa com o único evento que satisfizer a condição dada. Se houver mais de um evento que satisfaça, ocorre erro.|`Future<T> singleWhere(bool Function(T element) test, {T Function()? orElse})`|
|**skip**|Cria uma nova stream que ignora os primeiros _n_ eventos da stream original.|`Stream<T> skip(int count)`|
|**skipWhile**|Cria uma nova stream que ignora eventos enquanto a condição dada for verdadeira. Quando a condição for falsa pela primeira vez, todos os eventos subsequentes são emitidos normalmente.|`Stream<T> skipWhile(bool Function(T element) test)`|
|**take**|Cria uma nova stream que emite apenas os primeiros _n_ eventos da stream original, finalizando em seguida.|`Stream<T> take(int count)`|
|**takeWhile**|Cria uma nova stream que emite eventos enquanto a condição dada for verdadeira. Assim que a condição se torna falsa, a stream finaliza.|`Stream<T> takeWhile(bool Function(T element) test)`|
|**timeout**|Impõe um limite de tempo para cada evento. Se o tempo for excedido, dispara um erro ou executa uma ação.|Stream timeout(Duration timeLimit, { void Function(EventSink sink)? onTimeout })|
|**toList**|Coleta todos os eventos da stream em uma lista e retorna um `Future<List<T>>` quando a stream termina.|`Future<List<T>> toList()`|
|**toSet**|Coleta todos os eventos da stream em um `Set<T>` e retorna um `Future<Set<T>>` quando a stream termina.|`Future<Set<T>> toSet()`|
|**transform**|Aplica um `StreamTransformer` para transformar a stream. É um mecanismo mais poderoso para aplicar transformações personalizadas.|`Stream<S> transform<S>(StreamTransformer<T, S> streamTransformer)`|
|**where**|Filtra os eventos da stream para aqueles que satisfizerem a condição dada. Retorna uma nova stream somente com eventos aprovados pelo filtro.|`Stream<T> where(bool Function(T event) test)`|

---

## Exemplos práticos

### 1. Exemplo de uso de `listen` e `map`

```dart
void exemploStreamMap() {
  final Stream<int> numeros = Stream.fromIterable([1, 2, 3, 4]);

  // Transformando cada número em string
  final Stream<String> numerosComoString = numeros.map((numero) => 'Número: $numero');

  numerosComoString.listen((texto) {
    print(texto);
  });
}
```

### 2. Exemplo de uso de `where` e `takeWhile`

```dart
void exemploStreamFiltro() {
  final Stream<int> numeros = Stream.fromIterable([1, 2, 3, 4, 5, 6]);

  final Stream<int> filtrado = numeros
      .where((numero) => numero % 2 == 0)  // Filtra apenas números pares
      .takeWhile((numero) => numero < 6);  // Pega enquanto for menor que 6

  filtrado.listen((numero) {
    print('Número par < 6: $numero');
  });
}
```

### 3. Exemplo simples de broadcast

```dart
void exemploBroadcast() {
  final controller = StreamController<int>.broadcast();

  // Inscrevendo dois ouvintes simultâneos
  controller.stream.listen((evento) => print('Ouvinte 1 recebeu: $evento'));
  controller.stream.listen((evento) => print('Ouvinte 2 recebeu: $evento'));

  controller.add(10);
  controller.add(20);
  controller.close();
}
```

### 4. Exemplo de uso em Flutter com `StreamBuilder`

```dart
import 'package:flutter/material.dart';
import 'dart:async';

class MeuWidgetStream extends StatelessWidget {
  final Stream<int> minhaStream = (() {
    final controller = StreamController<int>();
    int contador = 0;

    // Emite um valor a cada segundo
    Timer.periodic(Duration(seconds: 1), (timer) {
      contador++;
      controller.add(contador);
      if (contador == 5) {
        controller.close(); // Fecha a stream depois de 5 segundos
      }
    });

    return controller.stream;
  })();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Exemplo StreamBuilder'),
      ),
      body: Center(
        child: StreamBuilder<int>(
          stream: minhaStream,
          builder: (context, snapshot) {
            if (snapshot.hasError) {
              return Text('Erro: ${snapshot.error}');
            }
            if (!snapshot.hasData) {
              return CircularProgressIndicator();
            }
            return Text('Valor atual: ${snapshot.data}');
          },
        ),
      ),
    );
  }
}
```

---

## Conclusão

A classe **`Stream<T>`** é fundamental para lidar com dados assíncronos em Dart e Flutter, permitindo que você trabalhe de forma reativa e controlada sobre eventos que acontecem ao longo do tempo. Através dos métodos fornecidos (`map`, `where`, `asyncMap`, etc.) e das propriedades (`isBroadcast`), é possível construir pipelines de processamento de dados altamente flexíveis.

- Use `Stream` quando você precisar **reativar** seu aplicativo sempre que novos dados chegarem, sem bloquear a UI.
- Combine `Stream` com o `StreamBuilder` para atualizar widgets em tempo real.
- Mantenha em mente a diferença entre `single-subscription` e `broadcast`, para evitar erros de múltiplos ouvintes.


# Stream no Flutter

## Introdução

No desenvolvimento de aplicativos Flutter, o gerenciamento eficiente de dados assíncronos é essencial para criar experiências de usuário responsivas e fluidas. Uma das ferramentas mais poderosas para lidar com fluxos de dados contínuos é o **Stream**. Streams permitem que você receba e manipule sequências de eventos ou dados que chegam ao longo do tempo, facilitando a implementação de funcionalidades como atualizações em tempo real, comunicação entre componentes e muito mais.

## Sumário

1. [O que é e para que serve?](#o-que-é-e-para-que-serve)
2. [Como funciona?](#como-funciona)
3. [Sintaxe de uso](#sintaxe-de-uso)
4. [Restrições de uso](#restrições-de-uso)
5. [Quando utilizar?](#quando-utilizar)
6. [Propriedades das Streams](#propriedades-das-streams)
7. [Principais Métodos das Streams](#principais-métodos-das-streams)
8. [Exemplos de Código](#exemplos-de-código)
9. [Considerações Finais](#considerações-finais)

## O que é e para que serve?

### Definição

**Stream** é uma abstração para representar uma sequência de dados assíncronos que são emitidos ao longo do tempo. Diferente de um único valor assíncrono, como um `Future`, que retorna um único valor ou erro, uma Stream pode emitir múltiplos valores e erros ao longo de sua existência.

### Aplicações

Streams são amplamente utilizadas em diversas situações, incluindo:

- **Atualizações em tempo real:** Como dados de sensores, localização do usuário, ou atualizações de status.
- **Interação do usuário:** Eventos de cliques, toques, ou entrada de texto.
- **Comunicação entre componentes:** Como em arquiteturas reativas ou usando padrões como BLoC.
- **Processamento de dados contínuos:** Como leitura de arquivos grandes ou processamento de pacotes de rede.

## Como funciona?

Streams funcionam como uma série de eventos que são emitidos ao longo do tempo. Para consumir esses eventos, você se inscreve em uma Stream através de um **StreamSubscription**. A Stream gerencia a emissão de dados, erros e o encerramento do fluxo.

### Componentes Principais

1. **Fonte de Dados:** Origem dos dados que serão emitidos na Stream.
2. **Stream:** Representa o canal através do qual os dados são transmitidos.
3. **StreamSubscription:** Gerencia a escuta da Stream, permitindo receber eventos, erros e notificações de conclusão.
4. **Sink:** Ponto de entrada para adicionar dados à Stream.

### Fluxo de Trabalho

1. **Criação da Stream:** Define como os dados serão emitidos.
2. **Inscrição na Stream:** Um ou mais listeners se inscrevem para receber os dados.
3. **Emissão de Eventos:** Dados, erros ou notificações de conclusão são emitidos pela Stream.
4. **Processamento dos Eventos:** Listeners reagem aos eventos conforme são recebidos.
5. **Cancelamento da Inscrição:** Quando não são mais necessários, as inscrições podem ser canceladas para liberar recursos.

## Sintaxe de uso

A sintaxe para trabalhar com Streams no Flutter envolve a criação, manipulação e escuta de eventos. A seguir, apresentamos os principais componentes e como utilizá-los.

### Criação de uma Stream

Você pode criar uma Stream de várias maneiras, incluindo usando `StreamController`, métodos estáticos como `Stream.fromIterable`, ou construtores como `Stream.periodic`.

```dart
import 'dart:async';

// Usando StreamController
final controller = StreamController<int>();

// Adicionando dados à Stream
controller.sink.add(1);
controller.sink.add(2);
controller.sink.add(3);

// Fechando a Stream
controller.close();
```

### Escutando uma Stream

Para escutar uma Stream, você pode usar o método `listen` que retorna um `StreamSubscription`.

```dart
Stream<int> minhaStream = Stream.fromIterable([1, 2, 3]);

StreamSubscription<int> subscription = minhaStream.listen(
  (data) {
    print('Dados recebidos: $data');
  },
  onError: (error) {
    print('Erro: $error');
  },
  onDone: () {
    print('Stream concluída');
  },
);

// Cancelando a inscrição quando não for mais necessária
subscription.cancel();
```

### Utilizando Streams no Flutter Widgets

Widgets como `StreamBuilder` facilitam a integração de Streams na interface do usuário.

```dart
Stream<int> contadorStream = Stream.periodic(Duration(seconds: 1), (count) => count).take(10);

@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(title: Text('Contador com Stream')),
    body: Center(
      child: StreamBuilder<int>(
        stream: contadorStream,
        builder: (context, snapshot) {
          if (snapshot.hasData) {
            return Text('Contador: ${snapshot.data}');
          } else if (snapshot.hasError) {
            return Text('Erro: ${snapshot.error}');
          }
          return CircularProgressIndicator();
        },
      ),
    ),
  );
}
```

## Restrições de uso

Embora Streams sejam extremamente úteis, é importante estar ciente de suas limitações e restrições:

1. **Consumo de Recursos:** Streams contínuas podem consumir recursos significativos se não forem gerenciadas corretamente.
2. **Gerenciamento de Inscrições:** Esquecer de cancelar inscrições pode levar a vazamentos de memória.
3. **Complexidade:** Implementações avançadas com múltiplas Streams e transformações podem se tornar complexas.
4. **Ordem de Eventos:** A ordem em que os eventos são emitidos e recebidos pode não ser garantida em Streams concorrentes.

## Quando utilizar?

Streams são ideais em situações onde você precisa lidar com:

- **Dados em Tempo Real:** Como feeds de notícias, atualizações de status, ou notificações.
- **Eventos Assíncronos Múltiplos:** Como interações de usuário, respostas de APIs contínuas, ou atualizações de sensores.
- **Comunicação entre Componentes:** Especialmente em arquiteturas reativas ou usando padrões como BLoC.
- **Processamento de Fluxos de Dados Grandes:** Como leitura e processamento de grandes arquivos ou dados recebidos via rede.

## Propriedades das Streams

Abaixo está uma tabela com todas as propriedades relevantes das Streams no Flutter, incluindo a descrição e a sintaxe de uso.

| Propriedade         | Descrição                                                                 | Sintaxe de Uso                      |
|---------------------|---------------------------------------------------------------------------|-------------------------------------|
| `isBroadcast`       | Indica se a Stream é do tipo broadcast, permitindo múltiplas inscrições. | `stream.isBroadcast`                |
| `isEmpty`           | Verifica se a Stream não emite nenhum evento.                            | `await stream.isEmpty`              |
| `isFirst`           | Retorna o primeiro elemento emitido pela Stream.                        | `await stream.isFirst`              |
| `isSingle`          | Verifica se a Stream emite exatamente um elemento.                       | `await stream.isSingle`             |
| `length`            | Retorna o número de elementos emitidos pela Stream.                      | `await stream.length`               |
| `hashCode`          | Retorna o código hash da Stream.                                          | `stream.hashCode`                   |
| `runtimeType`       | Retorna o tipo em tempo de execução da Stream.                           | `stream.runtimeType`                |
| `hashCode`          | Retorna o código hash da Stream.                                          | `stream.hashCode`                   |
| `listen`            | Inscreve-se na Stream para receber eventos.                              | `stream.listen(listener)`           |
| `asBroadcastStream` | Transforma a Stream em broadcast.                                         | `stream.asBroadcastStream()`        |
| `handleError`       | Manipula erros emitidos pela Stream.                                      | `stream.handleError(errorHandler)`  |
| `timeout`           | Define um tempo limite para a Stream emitir eventos.                     | `stream.timeout(Duration(seconds: 5))` |
| `map`               | Transforma cada evento emitido pela Stream.                              | `stream.map((data) => transform(data))` |
| `where`             | Filtra eventos com base em uma condição.                                 | `stream.where((data) => condição)`  |

## Principais Métodos das Streams

A seguir, apresentamos uma tabela com os principais métodos disponíveis para manipulação de Streams no Flutter, incluindo a descrição e a sintaxe de uso.

| Método               | Descrição                                                                 | Sintaxe de Uso                                |
|----------------------|---------------------------------------------------------------------------|-----------------------------------------------|
| `listen`             | Inscreve-se na Stream para receber eventos.                              | `stream.listen(onData, onError, onDone, cancelOnError)` |
| `map`                | Transforma cada evento emitido pela Stream.                              | `stream.map((data) => transform(data))`       |
| `where`              | Filtra eventos com base em uma condição.                                 | `stream.where((data) => condição)`            |
| `handleError`        | Manipula erros emitidos pela Stream.                                      | `stream.handleError(errorHandler)`            |
| `asBroadcastStream`  | Converte a Stream para o tipo broadcast.                                 | `stream.asBroadcastStream()`                  |
| `first`              | Obtém o primeiro elemento emitido pela Stream.                           | `await stream.first`                          |
| `last`               | Obtém o último elemento emitido pela Stream.                             | `await stream.last`                           |
| `single`             | Obtém o único elemento emitido pela Stream.                              | `await stream.single`                         |
| `toList`             | Converte todos os elementos emitidos pela Stream em uma lista.           | `await stream.toList()`                       |
| `fold`               | Reduz os elementos da Stream a um único valor.                           | `await stream.fold(initial, (prev, elem) => ...)` |
| `reduce`             | Reduz os elementos da Stream a um único valor sem valor inicial.         | `await stream.reduce((prev, elem) => ...)`    |
| `timeout`            | Define um tempo limite para a Stream emitir eventos.                     | `stream.timeout(Duration(seconds: 5))`         |
| `debounce`           | Aguarda um período de inatividade antes de emitir o último evento.       | `stream.debounce(Duration(seconds: 1))`        |
| `distinct`           | Elimina eventos duplicados consecutivos.                                 | `stream.distinct()`                            |
| `expand`             | Expande cada evento em uma sequência de eventos.                         | `stream.expand((data) => sequencia)`           |
| `buffer`             | Agrupa eventos emitidos em buffers de um tamanho específico.             | `stream.bufferCount(5)`                         |

## Exemplos de Código

### Exemplo 1: Criando e Consumindo uma Stream Simples

```dart
import 'dart:async';

void main() {
  // Criação da Stream
  StreamController<String> controller = StreamController<String>();

  // Inscrição na Stream
  StreamSubscription<String> subscription = controller.stream.listen(
    (data) {
      print('Dado recebido: $data');
    },
    onError: (error) {
      print('Erro: $error');
    },
    onDone: () {
      print('Stream concluída');
    },
  );

  // Adicionando dados à Stream
  controller.sink.add('Olá');
  controller.sink.add('Mundo');
  controller.sink.add('Flutter');

  // Fechando a Stream
  controller.close();
}
```

**Saída:**
```
Dado recebido: Olá
Dado recebido: Mundo
Dado recebido: Flutter
Stream concluída
```

### Exemplo 2: Utilizando `StreamBuilder` no Flutter

```dart
import 'dart:async';
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  final Stream<int> contadorStream = Stream.periodic(Duration(seconds: 1), (count) => count + 1).take(10);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Contador com Stream',
      home: Scaffold(
        appBar: AppBar(title: Text('Contador com Stream')),
        body: Center(
          child: StreamBuilder<int>(
            stream: contadorStream,
            builder: (context, snapshot) {
              if (snapshot.hasError) {
                return Text('Erro: ${snapshot.error}');
              }
              switch (snapshot.connectionState) {
                case ConnectionState.none:
                  return Text('Não conectado à Stream');
                case ConnectionState.waiting:
                  return Text('Aguardando dados...');
                case ConnectionState.active:
                  return Text('Contador: ${snapshot.data}');
                case ConnectionState.done:
                  return Text('Contagem finalizada');
              }
            },
          ),
        ),
      ),
    );
  }
}
```

**Descrição:**

Este exemplo cria uma Stream que emite números incrementais a cada segundo, até atingir 10. O `StreamBuilder` escuta essa Stream e atualiza a interface do usuário com o valor atual do contador. Quando a Stream é concluída, uma mensagem de finalização é exibida.

### Exemplo 3: Manipulando Erros em uma Stream

```dart
import 'dart:async';

void main() {
  // Criação da Stream com possíveis erros
  StreamController<int> controller = StreamController<int>();

  // Inscrição na Stream
  controller.stream.listen(
    (data) {
      print('Dado recebido: $data');
      if (data == 3) {
        throw Exception('Erro no dado 3');
      }
    },
    onError: (error) {
      print('Erro capturado: $error');
    },
    onDone: () {
      print('Stream concluída');
    },
  );

  // Adicionando dados à Stream
  controller.sink.add(1);
  controller.sink.add(2);
  controller.sink.add(3);
  controller.sink.add(4);

  // Fechando a Stream
  controller.close();
}
```

**Saída:**
```
Dado recebido: 1
Dado recebido: 2
Dado recebido: 3
Erro capturado: Exception: Erro no dado 3
Dado recebido: 4
Stream concluída
```

**Descrição:**

Neste exemplo, a Stream emite números inteiros. Quando o valor `3` é emitido, uma exceção é lançada, que é capturada pelo handler de erro, evitando que a aplicação quebre.

## Considerações Finais

Streams são uma ferramenta poderosa para o gerenciamento de dados assíncronos no Flutter, permitindo a construção de aplicativos reativos e eficientes. Ao dominar o uso de Streams, você pode implementar funcionalidades complexas com facilidade, melhorar a performance do seu aplicativo e proporcionar uma experiência de usuário mais fluida.

**Dicas Adicionais:**

- **Gerenciamento de Inscrições:** Sempre cancele suas inscrições em Streams quando elas não forem mais necessárias para evitar vazamentos de memória.
- **Transformações de Streams:** Utilize métodos como `map`, `where`, `debounce` e outros para manipular os dados conforme necessário.
- **Erros e Conclusões:** Implemente handlers de erro e conclusão para lidar adequadamente com situações inesperadas e liberar recursos.
- **Streams Broadcast:** Use Streams do tipo broadcast quando precisar de múltiplos listeners escutando a mesma Stream.

Com essas práticas, você estará bem equipado para utilizar Streams de maneira eficaz em seus projetos Flutter.