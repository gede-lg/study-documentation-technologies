Em Dart, tanto **Futures** quanto **Streams** são mecanismos para lidar com operações assíncronas, porém eles diferem principalmente na **quantidade** e na **forma** como os valores (eventos) são disponibilizados. Abaixo, listo algumas **diferenças de uso** que podem te ajudar a decidir quando empregar cada um:

---

## 1. Quantidade de valores emitidos

- **Future**:
    
    - Ideal para quando se espera **somente um valor** (ou resultado) ao final de uma operação assíncrona.
    - Assim que esse valor chega, o `Future` é completado e não emite mais nada.
- **Stream**:
    
    - Projetada para emitir **vários valores** ao longo do tempo, podendo ser ilimitados (ex.: eventos de usuário, pacotes de dados que chegam em série, etc.).
    - Continua emitindo até que seja finalizada ou cancelada.

### Exemplo de um Future:

```dart
Future<String> buscarDados() async {
  // Simula busca de dados
  await Future.delayed(Duration(seconds: 2));
  return "Dados recebidos!";
}
```

Esse método retorna apenas **um** resultado.

### Exemplo de uma Stream:

```dart
Stream<int> streamDeNumeros(int quantidade) async* {
  for (int i = 1; i <= quantidade; i++) {
    await Future.delayed(Duration(seconds: 1));
    yield i;
  }
}
```

Essa função gera **múltiplos** valores (um a cada segundo).

---

## 2. Controle de fluxo

- **Future**:
    
    - Não há necessidade de “cancelar” ou “pausar”, pois ele só produz um valor ou erro e finaliza.
    - É ótimo para operações pontuais: requisições HTTP simples, leituras de arquivo que retornam um único resultado, cálculos assíncronos, etc.
- **Stream**:
    
    - Permite **pausar**, **retomar** e **cancelar** a qualquer momento.
    - Esses controles são úteis em cenários onde pode haver muitos dados chegando de forma contínua (ex.: dados de sensor, input do usuário, WebSockets, etc.).

---

## 3. Maneira de consumir

- **Future**:
    
    - Consumido via `await` (em async/await) ou usando callbacks como `then`, `catchError`.
    - Ex.: `final resultado = await buscarDados();`
- **Stream**:
    
    - Geralmente consumido via **assinatura** (`listen`), que fornece um objeto do tipo `StreamSubscription`. Esse objeto dá controle sobre como os eventos serão processados.
    - Também pode ser consumido usando `await for` no Dart:
        
        ```dart
        await for (final valor in minhaStream) {
          print(valor);
        }
        ```
        
    - Em ambos os casos, os eventos podem continuar sendo emitidos ao longo do tempo.

---

## 4. Tratamento de erros

- **Future**:
    
    - Se algo falhar antes de fornecer o resultado, o `Future` é completado com erro.
    - Pode-se lidar com erros usando `try/catch` ou `catchError`.
- **Stream**:
    
    - Pode disparar **múltiplos erros** ao longo de sua duração.
    - O tratamento de erros pode acontecer via callback `onError` (caso se use `listen`) ou via `try/catch` com `await for`.

---

## 5. Cenários de uso

1. **Futures**
    
    - **Uma única operação** que eventualmente retorna um valor.
    - Ex.: baixar um arquivo (que, ao final, retorna um objeto ou status), realizar uma query no banco de dados, computar algo que não depende de eventos contínuos.
2. **Streams**
    
    - **Eventos contínuos ou uma sequência de valores**.
    - Ex.: série de dados de um sensor de temperatura, recebimento de mensagens de um socket, manipulação de cliques de usuário ou scroll em tempo real, dados de áudio/vídeo que chegam em pedaços, etc.

---

## 6. Exemplo comparativo

### Scenario 1: Capturar o resultado de uma requisição HTTP simples

- **Por que Future?**  
    A gente quer apenas **uma resposta** do servidor. É uma ação pontual.

```dart
Future<void> fazerRequisicao() async {
  try {
    final resposta = await http.get(Uri.parse('https://api.exemplo.com/dados'));
    print('Recebido: ${resposta.body}');
  } catch (e) {
    print('Erro na requisição: $e');
  }
}
```

### Scenario 2: Ler eventos de um WebSocket

- **Por que Stream?**  
    O WebSocket pode receber **várias mensagens ao longo do tempo**, e queremos monitorar continuamente.

```dart
void ouvirWebSocket(Stream<String> socketStream) {
  final subscription = socketStream.listen(
    (mensagem) => print('Mensagem recebida: $mensagem'),
    onError: (erro) => print('Erro no socket: $erro'),
    onDone: () => print('Conexão encerrada'),
  );

  // Podemos pausar, retomar ou cancelar a assinatura se necessário
  // subscription.pause();
  // subscription.resume();
  // subscription.cancel();
}
```

---

## 7. Performance e memória

- **Future**
    
    - Normalmente, não apresenta desafios relevantes de memória ou performance, pois é apenas um resultado que se completa uma vez.
- **Stream**
    
    - Precisamos gerenciar a assinatura (especialmente em streams que não finalizam sozinhas).
    - Se não gerenciarmos bem, podemos acabar com **acúmulo de dados** não processados ou manter stream aberta sem uso, causando vazamentos de memória ou consumo de recursos.

---

## 8. Resumo rápido

|Característica|Future|Stream|
|---|---|---|
|**Número de valores**|1 valor (ou erro)|Múltiplos valores (ou múltiplos erros)|
|**Forma de consumo**|`await future` ou `future.then()`|`stream.listen(...)`, `await for (var item in stream)`, `stream.forEach(...)`, etc.|
|**Controle (pausa/cancel)**|Normalmente não se aplica|Pode pausar, retomar e cancelar (`subscription.pause()`, `subscription.cancel()`, etc.)|
|**Ciclo de vida**|Completa ao retornar um valor ou um erro|Pode ser infinita ou finita; o fim é opcional (ou definido pela origem)|
|**Tratamento de erros**|`catchError` ou `try/catch`|`onError` dentro de `listen` ou `try/catch` usando `await for`|

---

## Conclusão

A escolha entre **Futures** e **Streams** depende essencialmente do **número de resultados** que você precisa receber (um vs. vários ao longo do tempo) e do **controle** que você necessita (como pausar ou cancelar).

- **Use Future** para situações pontuais: chamadas HTTP rápidas, cálculos que retornam um único valor, leituras de arquivo pontuais.
- **Use Stream** quando estiver lidando com dados em fluxo contínuo: eventos de UI, mensagens em tempo real, “chunks” de dados que chegam em sequência, etc.

Com isso em mente, fica mais claro **quando** cada um faz sentido na sua aplicação.