
#### **Sumário**

1. Introdução
2. O que é e para que serve?
3. Como funciona?
4. Sintaxe de uso
5. Restrições de uso
6. Quando utilizar?
7. Propriedades da classe `StreamController`
8. Métodos da classe `StreamController`
9. Exemplos práticos em Dart
10. Considerações finais

---

### **1. Introdução**

No Dart, a classe `StreamController` é uma das ferramentas principais para trabalhar com **Streams**, que são uma forma de gerenciar dados assíncronos de maneira eficiente. `StreamController` é amplamente utilizado para criar, controlar e manipular fluxos de eventos ou dados.

---

### **2. O que é e para que serve?**

A classe `StreamController` é uma ponte para criar e gerenciar uma **Stream** e seu **Sink** correspondente. Em termos simples:

- Uma **Stream** é usada para **ouvir** (ou observar) eventos.
- Um **Sink** é usado para **adicionar** (ou emitir) eventos.

Essa classe é útil quando você precisa de controle total sobre uma Stream, como criar eventos manualmente ou emitir dados para múltiplos ouvintes.

---

### **3. Como funciona?**

- O `StreamController` cria uma Stream e um Sink associados.
- Você usa o **Sink** para adicionar eventos (`add`, `addError`) ou fechar a Stream (`close`).
- O consumidor da Stream usa métodos como `listen` para responder aos eventos emitidos.
- É possível criar Streams **únicas** ou que permitam múltiplos ouvintes (broadcast).

**Fluxo de dados**:

1. O produtor adiciona eventos no Sink.
2. Os eventos são transmitidos pela Stream.
3. Os ouvintes reagem aos eventos na Stream.

---

### **4. Sintaxe de uso**

#### **Construtores**

##### **1. `StreamController()`**

Cria uma Stream não-broadcast (unicast), que aceita apenas um ouvinte.

##### **Parâmetros:**

|Parâmetro|Tipo|Descrição|Obrigatório?|
|---|---|---|---|
|`onListen`|`void Function()?`|Callback chamado quando a Stream começa a ser ouvida.|Não|
|`onPause`|`void Function()?`|Callback chamado quando a Stream é pausada.|Não|
|`onResume`|`void Function()?`|Callback chamado quando a Stream é retomada.|Não|
|`onCancel`|`FutureOr<void> Function()?`|Callback chamado quando a Stream é cancelada.|Não|
|`sync`|`bool`|Define se os eventos devem ser entregues sincronamente. O padrão é `false`.|Não|

##### **Sintaxe**:

```dart
var controller = StreamController<int>(
  onListen: () => print('Stream começou a ser ouvida.'),
  sync: true,
);
```

##### **2. `StreamController.broadcast()`**

Cria uma Stream que permite múltiplos ouvintes simultaneamente.

##### **Parâmetros:**

Os mesmos do construtor padrão, com os mesmos comportamentos.

##### **Sintaxe**:

```dart
var controller = StreamController<int>.broadcast(
  onListen: () => print('Stream começou a ser ouvida por vários ouvintes.'),
);
```

---

### **5. Restrições de uso**

1. **Unicast Streams** (criadas com `StreamController` padrão) aceitam apenas um ouvinte. Se mais de um tentar ouvir, ocorre um erro.
2. **Broadcast Streams** permitem múltiplos ouvintes, mas não armazenam eventos para ouvintes futuros (não possuem buffer).
3. Uma Stream deve ser fechada após o uso (`close`), caso contrário, pode causar vazamentos de memória.
4. Uma vez fechada, a Stream não pode ser reaberta.

---

### **6. Quando utilizar?**

- Quando você precisa criar eventos dinâmicos manualmente.
- Para criar Streams personalizadas que respondam a ações do usuário.
- Quando uma Stream precisa de múltiplos ouvintes (use `broadcast`).
- Para gerenciar comunicação assíncrona em sistemas reativos ou interfaces gráficas.

---

### **7. Propriedades da classe `StreamController`**

|Propriedade|Descrição|Sintaxe de uso|
|---|---|---|
|`stream`|A Stream associada ao controller.|`controller.stream`|
|`sink`|O Sink associado ao controller.|`controller.sink`|
|`hasListener`|Indica se a Stream possui pelo menos um ouvinte.|`controller.hasListener`|
|`isClosed`|Indica se o Sink foi fechado.|`controller.isClosed`|
|`isPaused`|Indica se a Stream está pausada.|`controller.isPaused`|

---

### **8. Métodos da classe `StreamController`**

|Método|Descrição|Sintaxe de uso|
|---|---|---|
|`add(event)`|Adiciona um evento à Stream.|`controller.add(42)`|
|`addError(error)`|Adiciona um evento de erro à Stream.|`controller.addError(Exception('Erro!'))`|
|`close()`|Fecha a Stream, indicando que não serão enviados mais eventos.|`controller.close()`|
|`addStream(source)`|Adiciona eventos de outra Stream a este controller.|`controller.addStream(otherStream)`|

---

### **9. Exemplos práticos em Dart**

#### **Exemplo 1: Criando uma Stream simples**

```dart
import 'dart:async';

void main() {
  var controller = StreamController<int>();

  controller.stream.listen((event) {
    print('Recebido: $event');
  });

  controller.add(1);
  controller.add(2);
  controller.add(3);

  controller.close();
}
```

#### **Exemplo 2: Usando `StreamController.broadcast`**

```dart
import 'dart:async';

void main() {
  var controller = StreamController<int>.broadcast();

  controller.stream.listen((event) {
    print('Ouvinte 1 recebeu: $event');
  });

  controller.stream.listen((event) {
    print('Ouvinte 2 recebeu: $event');
  });

  controller.add(1);
  controller.add(2);

  controller.close();
}
```

---

### **10. Considerações finais**

O `StreamController` é uma poderosa ferramenta para gerenciar Streams personalizadas no Dart. Ele oferece flexibilidade e controle para lidar com eventos assíncronos, mas exige cuidado em sua implementação, especialmente no gerenciamento de memória. Use-o para criar arquiteturas reativas e eficientes em seus aplicativos.