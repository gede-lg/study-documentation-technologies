## Métodos no Dart

### O que é e para que serve?

Métodos em Dart são funções que são definidas dentro de uma classe. Eles são usados para definir o comportamento de uma classe, permitindo que os objetos da classe executem ações específicas. Os métodos podem manipular os dados dos objetos (campos ou propriedades) e executar operações.

Os métodos são uma parte essencial da programação orientada a objetos (OOP) em Dart, pois permitem encapsular a lógica de negócios dentro das classes e fornecer uma interface clara para interagir com os objetos.

### Sintaxe de Uso

A sintaxe para definir um método em Dart é simples e segue uma estrutura semelhante a outras linguagens de programação OOP. Aqui está um exemplo básico:

```dart
class Pessoa {
  String nome;
  int idade;

  // Construtor
  Pessoa(this.nome, this.idade);

  // Método
  void apresentar() {
    print('Olá, meu nome é $nome e eu tenho $idade anos.');
  }

  // Método com retorno
  int calcularAnoNascimento(int anoAtual) {
    return anoAtual - idade;
  }
}

void main() {
  Pessoa pessoa = Pessoa('Ana', 25);
  pessoa.apresentar(); // Saída: Olá, meu nome é Ana e eu tenho 25 anos.
  int anoNascimento = pessoa.calcularAnoNascimento(2024);
  print('Ano de nascimento: $anoNascimento'); // Saída: Ano de nascimento: 1999
}
```

### Restrições de Uso

Embora Dart seja bastante flexível, existem algumas restrições e considerações ao usar métodos:

1. **Visibilidade**: Por padrão, os métodos em Dart são públicos. Para tornar um método privado à biblioteca, prefixe-o com um sublinhado (`_`). Métodos privados não podem ser acessados fora da biblioteca onde foram definidos.

    ```dart
    class Exemplo {
      void metodoPublico() {
        print('Este é um método público.');
      }

      // Método privado
      void _metodoPrivado() {
        print('Este é um método privado.');
      }
    }
    ```

2. **Sobrecarga de Métodos**: Dart não suporta sobrecarga de métodos (definir vários métodos com o mesmo nome e diferentes parâmetros). Em vez disso, você pode usar parâmetros opcionais ou nomeados.

    ```dart
    class Calculadora {
      int somar(int a, [int b = 0, int c = 0]) {
        return a + b + c;
      }
    }

    void main() {
      Calculadora calc = Calculadora();
      print(calc.somar(1)); // Saída: 1
      print(calc.somar(1, 2)); // Saída: 3
      print(calc.somar(1, 2, 3)); // Saída: 6
    }
    ```

3. **Métodos Assíncronos**: Métodos que realizam operações assíncronas (como chamadas de rede ou operações de I/O) devem ser marcados com `async` e podem retornar `Future`.

    ```dart
    class Servico {
      Future<void> carregarDados() async {
        await Future.delayed(Duration(seconds: 2));
        print('Dados carregados.');
      }
    }

    void main() async {
      Servico servico = Servico();
      await servico.carregarDados(); // Espera até que os dados sejam carregados
    }
    ```

### Quando Utilizar?

1. **Encapsulamento de Comportamento**: Use métodos para encapsular o comportamento relacionado a uma classe. Isso ajuda a manter o código organizado e modular.

    ```dart
    class Banco {
      double saldo;

      Banco(this.saldo);

      void depositar(double quantia) {
        saldo += quantia;
        print('Depositou $quantia. Novo saldo: $saldo');
      }

      void sacar(double quantia) {
        if (quantia <= saldo) {
          saldo -= quantia;
          print('Sacou $quantia. Novo saldo: $saldo');
        } else {
          print('Saldo insuficiente.');
        }
      }
    }
    ```

2. **Reutilização de Código**: Métodos permitem reutilizar código, evitando duplicação. Isso é especialmente útil para operações repetitivas.

    ```dart
    class ConversorTemperatura {
      double celsiusParaFahrenheit(double celsius) {
        return (celsius * 9/5) + 32;
      }

      double fahrenheitParaCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5/9;
      }
    }

    void main() {
      ConversorTemperatura conversor = ConversorTemperatura();
      double tempF = conversor.celsiusParaFahrenheit(30);
      double tempC = conversor.fahrenheitParaCelsius(86);
      print('30°C em Fahrenheit é $tempF°F');
      print('86°F em Celsius é $tempC°C');
    }
    ```

3. **Interação com Objetos**: Métodos fornecem uma maneira de interagir com objetos, manipulando seus dados de maneira controlada e segura.

4. **Abstração e Modularidade**: Métodos ajudam a criar abstrações e dividir a lógica em componentes menores e mais gerenciáveis, facilitando a manutenção e evolução do código.


---
## Getter e Setter

Getters e Setters são funcionalidades fundamentais na linguagem de programação Dart, utilizadas para controlar o acesso e a modificação de propriedades de uma classe. Eles são parte importante do conceito de encapsulamento em programação orientada a objetos, ajudando a proteger os dados e garantir a integridade dos objetos.

### O que são Getters e Setters?

- **Getter**: É uma função especial que é usada para ler ou acessar o valor de uma propriedade de um objeto. Em Dart, um getter é definido usando a palavra-chave `get` seguida pelo nome que desejamos dar ao getter. Ele retorna o valor de uma propriedade privada ou calculada.
- **Setter**: É uma função especial usada para modificar ou definir o valor de uma propriedade de um objeto. Em Dart, um setter é definido usando a palavra-chave `set` seguida pelo nome que desejamos dar ao setter. Ele geralmente recebe um valor como argumento e o atribui a uma propriedade privada.

### Para que servem?

Getters e Setters servem para:

1. **Encapsulamento**: Eles ajudam a ocultar os detalhes de implementação de uma classe, expondo apenas propriedades e métodos necessários para o uso externo. Isso permite alterar a implementação interna sem afetar o código que usa a classe.
2. **Validação**: Antes de atribuir um valor a uma propriedade, podemos usar setters para validar esse valor, garantindo que a propriedade não receba dados inválidos.
3. **Controle de Acesso**: Eles permitem um controle mais refinado sobre como uma propriedade é acessada e modificada, podendo inclusive criar propriedades somente leitura ou somente escrita.

### Sintaxe de uso

Vamos ver como definir getters e setters em Dart:

```dart
class Pessoa {
  String _nome; // Propriedade privada

  Pessoa(this._nome);

  // Getter para _nome
  String get nome => _nome;

  // Setter para _nome
  void set nome(String novoNome) {
    if (novoNome.isNotEmpty) { // Validação simples
      _nome = novoNome;
    }
  }
}

void main() {
  var pessoa = Pessoa('João');
  print(pessoa.nome); // Acessa usando o getter

  pessoa.nome = 'Ana'; // Modifica usando o setter
  print(pessoa.nome);
}
```

Neste exemplo, a classe `Pessoa` tem uma propriedade privada `_nome`. O getter `nome` permite acessar o valor de `_nome`, e o setter `nome` permite modificar esse valor após uma simples validação.
### Conclusão

Métodos são fundamentais na programação orientada a objetos em Dart, permitindo encapsular comportamento, reutilizar código e interagir com objetos de maneira eficiente. Com uma compreensão clara da sintaxe, restrições e boas práticas, você pode escrever código Dart mais organizado, modular e fácil de manter.