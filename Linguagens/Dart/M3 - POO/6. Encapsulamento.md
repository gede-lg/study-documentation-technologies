Encapsulamento no Dart é um conceito fundamental na programação orientada a objetos, usado para restringir o acesso direto aos componentes de uma classe. Isso é feito para proteger os dados internos de uma classe e garantir que objetos sejam usados da maneira pretendida. Vamos explorar esse conceito em detalhes, abordando sua finalidade, níveis de visibilidade e sintaxe de uso no Dart.

### O que é Encapsulamento e para que serve?

Encapsulamento é a técnica de ocultar os detalhes internos de uma classe e expor apenas o necessário para o mundo exterior. Isso permite que o desenvolvedor controle como os dados de uma classe são acessados e modificados. O encapsulamento serve para:

- **Manter a integridade dos dados**: Restringindo o acesso direto às variáveis de classe, podemos garantir que os dados não sejam alterados de maneira inesperada ou inadequada.
- **Reduzir a complexidade do software**: Ao expor apenas o necessário, simplificamos a interface com a qual os outros componentes do software interagem.
- **Aumentar a reutilização**: Classes bem encapsuladas podem ser facilmente reutilizadas em diferentes partes do aplicativo ou até em novos projetos.

### Níveis de Visibilidade no Dart

O Dart define vários níveis de visibilidade para membros de classes (como campos, métodos e construtores), que são:

- **Público**: Se nenhum modificador de acesso é especificado, o membro é público e pode ser acessado de qualquer lugar.
- **Privado**: Membros privados são declarados com um sublinhado `_` antes do nome e só podem ser acessados dentro da mesma biblioteca em que são definidos. Não existe uma palavra-chave explícita para privado no Dart.
- **Protegido**: O Dart não tem um modificador de acesso protegido nativo, como em algumas outras linguagens. Porém, convenções e bibliotecas podem ser usadas para simular esse comportamento, como o uso de anotações `@protected` da biblioteca `meta`.

### Encapsulamento em Nível de Classe

No Dart, além de encapsular atributos e métodos, também é possível encapsular uma classe inteira, tornando-a **privada** para outras classes. Para isso, basta adicionar um underscore (`_`) ao nome da classe. Isso indica que essa classe só pode ser acessada dentro do arquivo onde foi definida, o que garante que seu uso fique restrito ao contexto específico daquele arquivo. Uma classe privada é útil quando você quer ocultar a implementação interna de algo que não deve ser usado fora do módulo atual.

### Sintaxe de Uso

A seguir, a sintaxe básica para definir membros privados e públicos em uma classe Dart, além de um exemplo de classe privada:

```dart
// Classe pública
class MinhaClasse {
  int _variavelPrivada; // Variável privada
  int variavelPublica; // Variável pública

  MinhaClasse(this._variavelPrivada, this.variavelPublica);

  // Método privado
  void _metodoPrivado() {
    print("Este é um método privado.");
  }

  // Método público
  void metodoPublico() {
    print("Este é um método público.");
    _metodoPrivado(); // Chamando método privado dentro da classe
  }
}

// Classe privada (com _ no nome)
class _ClassePrivada {
  void mostrarMensagem() {
    print("Esta é uma classe privada.");
  }
}
```

### Exemplos de Encapsulamento

Vamos considerar um exemplo onde encapsulamos os detalhes de uma classe `ContaBancaria`, com atributos e métodos privados:

```dart
class ContaBancaria {
  double _saldo; // Saldo é uma propriedade privada

  ContaBancaria(this._saldo);

  // Método para depositar dinheiro, garantindo que valores negativos não sejam aceitos
  void depositar(double valor) {
    if (valor > 0) {
      _saldo += valor;
      print("Depósito realizado. Saldo atual: $_saldo");
    } else {
      print("Valor inválido para depósito.");
    }
  }

  // Método para sacar dinheiro, garantindo que não seja possível sacar mais do que o saldo disponível
  void sacar(double valor) {
    if (valor > 0 && valor <= _saldo) {
      _saldo -= valor;
      print("Saque realizado. Saldo atual: $_saldo");
    } else {
      print("Saque inválido.");
    }
  }

  // Método público para consultar o saldo, sem permitir a modificação direta do saldo
  double consultarSaldo() {
    return _saldo;
  }
}
```

Neste exemplo, o saldo da conta bancária é mantido como uma variável privada, `_saldo`, para evitar que seja modificado diretamente de fora da classe. Métodos públicos `depositar`, `sacar` e `consultarSaldo` são fornecidos para interagir com o saldo de maneiras controladas.

### Classe Privada

Agora, veja um exemplo de como encapsular uma classe completa:

```dart
// Arquivo: pessoa.dart

// Classe privada (somente acessível dentro deste arquivo)
class _Pessoa {
  String nome;

  _Pessoa(this.nome);

  void mostrarNome() {
    print("O nome é $nome");
  }
}

// Classe pública (pode ser acessada fora deste arquivo)
class Funcionario {
  String cargo;
  
  Funcionario(this.cargo);

  void mostrarCargo() {
    print("O cargo é $cargo");
  }
}
```

No arquivo `main.dart`:

```dart
import 'pessoa.dart';

void main() {
  // Erro: A classe _Pessoa é privada e não pode ser acessada fora do arquivo pessoa.dart
  // _Pessoa pessoa = _Pessoa("Luiz");

  // Funciona, pois a classe Funcionario é pública
  Funcionario funcionario = Funcionario("Desenvolvedor");
  funcionario.mostrarCargo(); // O cargo é Desenvolvedor
}
```

### Considerações Adicionais

- **Getters e Setters**: O Dart oferece uma sintaxe simplificada para getters e setters, permitindo um controle mais refinado sobre como as propriedades são acessadas e modificadas.
- **Boas Práticas**: Mesmo que o Dart não tenha níveis rígidos de proteção de membros como outras linguagens, seguir boas práticas e encapsular dados corretamente melhora a manutenção e a segurança do código.

Encapsulamento, tanto no nível de atributos e métodos quanto no nível de classes, é crucial para manter a integridade dos dados e garantir que o código seja mais seguro, modular e fácil de manter.