# Função Closure no Go

## O que é e para que serve?

Uma **closure** em Go é uma função que captura e acessa variáveis fora de seu escopo imediato. Em outras palavras, uma closure é uma função anônima que pode referenciar variáveis de seu ambiente exterior. Esse conceito é útil quando se deseja que uma função mantenha um estado entre suas chamadas ou quando se deseja criar funções com comportamento personalizado de maneira dinâmica.

Closures são frequentemente usadas para encapsular lógica específica que deve operar sobre dados que não são passados diretamente como argumentos, mas que ainda precisam ser acessados e modificados pela função.

## Sintaxe de Uso

A sintaxe para criar uma closure em Go envolve a criação de uma função anônima dentro de outra função. A função anônima pode acessar e modificar as variáveis definidas na função exterior.

### Exemplo Básico

```go
package main

import "fmt"

func main() {
    adder := func() func(int) int {
        sum := 0
        return func(x int) int {
            sum += x
            return sum
        }
    }

    pos, neg := adder(), adder()
    for i := 0; i < 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
```

Neste exemplo, `adder` é uma função que retorna uma closure. A closure mantém o estado da variável `sum` entre as chamadas.

### Passo a Passo da Sintaxe

1. **Declaração da Função Externa**:
    ```go
    func adder() func(int) int {
    ```
    A função `adder` não recebe argumentos e retorna uma função que recebe um `int` e retorna um `int`.

2. **Declaração da Variável Capturada**:
    ```go
    sum := 0
    ```
    A variável `sum` é inicializada e será capturada pela closure.

3. **Definição e Retorno da Função Anônima**:
    ```go
    return func(x int) int {
        sum += x
        return sum
    }
    ```
    A função anônima captura a variável `sum`, modificando seu valor a cada chamada.

## Restrições de Uso

- **Escopo da Captura**: A closure só pode capturar variáveis que estão em escopos superiores à função anônima. Não pode capturar variáveis de escopos inferiores ou de outras closures.
- **Concorrência**: Ao usar closures em um ambiente concorrente, é importante garantir a segurança de acesso às variáveis capturadas para evitar condições de corrida (race conditions). Use mecanismos de sincronização, como mutexes, quando necessário.

### Exemplo com Goroutines

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup

    adder := func() func(int) int {
        sum := 0
        var mu sync.Mutex
        return func(x int) int {
            mu.Lock()
            defer mu.Unlock()
            sum += x
            return sum
        }
    }

    pos := adder()

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Println(pos(i))
        }(i)
    }

    wg.Wait()
}
```

Neste exemplo, o uso de um mutex (`mu`) garante que a variável `sum` seja modificada de forma segura quando acessada por múltiplas goroutines.

## Quando Utilizar?

- **Encapsulamento de Estado**: Use closures para encapsular estado que precisa ser mantido entre chamadas de função, como em contadores ou acumuladores.
- **Funções Personalizadas**: Utilize closures para gerar funções personalizadas com comportamento específico, como filtros ou mapeamentos em coleções.
- **Programação Funcional**: Em paradigmas de programação funcional, closures são usadas para criar funções de alta ordem e operadores de transformação de dados.

### Exemplo de Encapsulamento de Estado

```go
package main

import "fmt"

func main() {
    counter := func() func() int {
        count := 0
        return func() int {
            count++
            return count
        }
    }

    next := counter()

    fmt.Println(next()) // 1
    fmt.Println(next()) // 2
    fmt.Println(next()) // 3
}
```

Neste exemplo, `counter` retorna uma closure que mantém o estado da variável `count` entre chamadas, funcionando como um contador.

### Exemplo de Função Personalizada

```go
package main

import "fmt"

func main() {
    multiplier := func(factor int) func(int) int {
        return func(x int) int {
            return x * factor
        }
    }

    double := multiplier(2)
    triple := multiplier(3)

    fmt.Println(double(3)) // 6
    fmt.Println(triple(3)) // 9
}
```

Neste exemplo, `multiplier` retorna uma closure que multiplica o valor de entrada pelo `factor` fornecido, permitindo criar funções de multiplicação personalizadas.

## Conclusão

Closures em Go são uma ferramenta poderosa para capturar e manipular estado de variáveis fora do escopo imediato da função anônima. Elas são úteis em uma variedade de cenários, desde o encapsulamento de estado até a criação de funções personalizadas. Compreender e utilizar closures efetivamente pode levar a um código mais flexível e conciso.