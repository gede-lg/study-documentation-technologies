
## O que é e para que serve?

Composição de structs, também conhecida como embedded structs, é uma técnica em Go onde uma struct é incluída dentro de outra struct. Isso permite a reutilização de campos e métodos de uma struct dentro de outra, promovendo a composição sobre a herança. Em vez de utilizar a herança como em outras linguagens orientadas a objetos, Go favorece a composição para compartilhar funcionalidades entre tipos.

A composição de structs serve para:
- Reutilizar código de forma mais eficiente.
- Criar estruturas de dados mais complexas a partir de componentes menores.
- Promover a modularidade e a manutenção do código.

## Quando utilizar?

Utiliza-se composição de structs quando:
- Você deseja reutilizar campos e métodos de uma struct dentro de outra.
- Você quer criar um objeto mais complexo a partir de componentes menores.
- Deseja evitar a duplicação de código.
- Você precisa de um comportamento similar ao de herança, mas dentro do paradigma de composição.

## Sintaxe de uso

A sintaxe para composição de structs em Go é simples e direta. Você declara uma struct dentro de outra struct sem usar um nome para o campo. Isso cria uma "embedded struct".

### Exemplo de Composição de Structs com o Tema de Carro

Vamos criar uma struct `Carro` que possui um `Motor`, um `Chassi` e uma lista de `Roda`.

```go
package main

import "fmt"

// Definindo a struct Motor
type Motor struct {
    Potencia  int
    Tipo      string
}

// Definindo a struct Chassi
type Chassi struct {
    Numero   string
    Material string
}

// Definindo a struct Roda
type Roda struct {
    Tamanho int
    Marca   string
}

// Definindo a struct Carro que embute Motor, Chassi e uma lista de Roda
type Carro struct {
    Motor
    Chassi
    Rodas []Roda
}

func main() {
    // Criando um objeto Motor
    motor := Motor{
        Potencia:  150,
        Tipo:      "V8",
    }

    // Criando um objeto Chassi
    chassi := Chassi{
        Numero:   "ABC123",
        Material: "Aço",
    }

    // Criando uma lista de Rodas
    rodas := []Roda{
        {Tamanho: 18, Marca: "Michelin"},
        {Tamanho: 18, Marca: "Michelin"},
        {Tamanho: 18, Marca: "Michelin"},
        {Tamanho: 18, Marca: "Michelin"},
    }

    // Criando um objeto Carro
    carro := Carro{
        Motor:  motor,
        Chassi: chassi,
        Rodas:  rodas,
    }

    // Acessando campos do Carro
    fmt.Println("Potência do Motor:", carro.Potencia)
    fmt.Println("Tipo do Motor:", carro.Tipo)
    fmt.Println("Número do Chassi:", carro.Numero)
    fmt.Println("Material do Chassi:", carro.Material)
    fmt.Println("Rodas do Carro:")
    for i, roda := range carro.Rodas {
        fmt.Printf("  Roda %d: Tamanho %d, Marca %s\n", i+1, roda.Tamanho, roda.Marca)
    }
}
```

### Explicação do Exemplo

- Definimos três structs: `Motor`, `Chassi` e `Roda`.
- Em seguida, definimos a struct `Carro` que embute `Motor`, `Chassi` e inclui um slice de `Roda`.
- Criamos instâncias de `Motor`, `Chassi` e uma lista de `Rodas`.
- Criamos uma instância de `Carro` que inclui as instâncias de `Motor`, `Chassi` e `Rodas`.
- Acessamos os campos diretamente na instância de `Carro` sem precisar referenciar explicitamente `Motor` ou `Chassi`.

## Restrições de uso

1. **Nome de Campos**: Se uma struct embutida tem campos com o mesmo nome que outra struct ou a struct que a contém, você deve desambiguar explicitamente qual campo está acessando.
    ```go
    type A struct {
        Name string
    }

    type B struct {
        Name string
    }

    type C struct {
        A
        B
    }

    func main() {
        c := C{}
        c.A.Name = "Nome em A"
        c.B.Name = "Nome em B"
        fmt.Println(c.A.Name) // Nome em A
        fmt.Println(c.B.Name) // Nome em B
    }
    ```

2. **Visibilidade dos Campos**: Campos embutidos são promovidos, mas respeitam as regras de exportação. Campos não exportados (começam com letra minúscula) só são acessíveis dentro do mesmo pacote.

3. **Métodos**: Métodos definidos em structs embutidas também são promovidos. Se houver métodos com o mesmo nome em structs diferentes, a chamada deve ser explicitamente desambigua.
    ```go
    type A struct {}

    func (a A) F() {
        fmt.Println("Método F em A")
    }

    type B struct {}

    func (b B) F() {
        fmt.Println("Método F em B")
    }

    type C struct {
        A
        B
    }

    func main() {
        c := C{}
        c.A.F() // Método F em A
        c.B.F() // Método F em B
    }
    ```

4. **Hierarquia**: A composição de structs não cria uma hierarquia de herança, mas promove uma relação de agregação e composição. Não há substituição de métodos ou campos como na herança.

## Conclusão

A composição de structs em Go é uma técnica poderosa que promove a reutilização de código e a criação de estruturas complexas de forma modular. Ao utilizar embedded structs, é possível criar tipos mais ricos e robustos sem a complexidade da herança. A compreensão e aplicação correta dessa técnica pode levar a um código mais limpo, organizado e fácil de manter.