
Em Go, structs são tipos de dados compostos que permitem agrupar variáveis (campos) e associar métodos a esses tipos. Quando usamos embutimento (embedding) em structs, podemos enfrentar ambiguidade tanto em campos quanto em métodos. Vamos explorar esses conceitos em detalhes, abordando como funciona o acesso e a sobreposição em casos de embutimento.

## Campos Ambíguos

### Acesso a campos?

Quando uma struct é embutida em outra, os campos da struct embutida podem ser acessados diretamente na struct que a contém. Isso proporciona uma espécie de "herança" onde os campos da struct embutida são promovidos para a struct contendo.

### Exemplo de Embutimento

```go
package main

import "fmt"

type Pessoa struct {
    Nome string
    Idade int
}

type Funcionario struct {
    Pessoa
    Cargo string
}

func main() {
    f := Funcionario{
        Pessoa: Pessoa{
            Nome: "João",
            Idade: 30,
        },
        Cargo: "Desenvolvedor",
    }

    // Acessando campos diretamente
    fmt.Println(f.Nome)  // João
    fmt.Println(f.Idade) // 30
    fmt.Println(f.Cargo) // Desenvolvedor
}
```

### Sobreposição de campos?

Sim, ocorre sobreposição quando há campos com o mesmo nome tanto na struct contendo quanto na struct embutida. Nesses casos, o campo na struct contendo tem prioridade.

### Exemplo de Ambiguidade
```go
package main

import "fmt"

type Pessoa struct {
    Nome string
}

type Funcionario struct {
    Pessoa
    Nome  string // Campo ambíguo
    Cargo string
}

func main() {
    f := Funcionario{
        Pessoa: Pessoa{
            Nome: "João",
        },
        Nome:  "Carlos", // Este campo sobrepõe o campo Nome de Pessoa
        Cargo: "Desenvolvedor",
    }

    // Acessando campos diretamente
    fmt.Println(f.Nome)      // Carlos
    fmt.Println(f.Pessoa.Nome) // João
}
```

Neste exemplo, `f.Nome` se refere ao campo `Nome` da struct `Funcionario`, enquanto `f.Pessoa.Nome` se refere ao campo `Nome` da struct `Pessoa`.

---
## Métodos Ambíguos

### Acesso a Metodos

Assim como com campos, os métodos da struct embutida são promovidos para a struct contendo. Isso permite chamar métodos da struct embutida diretamente na struct que a contém.

### Exemplo de Embutimento de Métodos

```go
package main

import "fmt"

type Pessoa struct {
    Nome string
}

func (p Pessoa) Saudacao() {
    fmt.Println("Olá, meu nome é", p.Nome)
}

type Funcionario struct {
    Pessoa
    Cargo string
}

func main() {
    f := Funcionario{
        Pessoa: Pessoa{
            Nome: "João",
        },
        Cargo: "Desenvolvedor",
    }

    // Chamando método diretamente
    f.Saudacao() // Olá, meu nome é João
}
```

### Sobreposição de Métodos?

Sim, ocorre sobreposição quando há métodos com o mesmo nome tanto na struct contendo quanto na struct embutida. O método na struct contendo tem prioridade.

### Exemplo de Ambiguidade de Métodos

```go
package main

import "fmt"

type Pessoa struct {
    Nome string
}

func (p Pessoa) Saudacao() {
    fmt.Println("Olá, meu nome é", p.Nome)
}

type Funcionario struct {
    Pessoa
    Cargo string
}

func (f Funcionario) Saudacao() {
    fmt.Println("Olá, eu sou um funcionário. Meu nome é", f.Nome)
}

func main() {
    f := Funcionario{
        Pessoa: Pessoa{
            Nome: "João",
        },
        Cargo: "Desenvolvedor",
    }

    // Chamando método diretamente
    f.Saudacao() // Olá, eu sou um funcionário. Meu nome é João
    f.Pessoa.Saudacao() // Olá, meu nome é João
}
```

Neste exemplo, `f.Saudacao()` chama o método `Saudacao` da struct `Funcionario`, enquanto `f.Pessoa.Saudacao()` chama o método `Saudacao` da struct `Pessoa`.
## Resolução de Ambiguidades

### Acessibilidade

Para acessar um campo ambíguo, é necessário usar o nome completo, incluindo a struct embutida. Isso elimina a ambiguidade e permite acessar o campo específico desejado.

### Boa Prática

Uma boa prática é evitar a ambiguidade de campos sempre que possível, mantendo os nomes dos campos únicos, ou estruturar o código de forma a minimizar a necessidade de acessar campos ambíguos.

### Resolução em Tempo de Compilação

Go detecta e reporta ambiguidades em tempo de compilação. Isso ajuda a evitar erros em tempo de execução e garante que o código esteja claro e explícito quanto ao acesso aos campos.
## Considerações Finais

Quando duas ou mais structs embutidas possuem campos com o mesmo nome, esses campos são considerados sobrepostos. Não há substituição ou exclusão de campos; em vez disso, cada campo mantém sua identidade e acessibilidade através do caminho completo.
### Evitando Ambiguidade

Para evitar ambiguidade, é recomendável:

1. **Nomear Campos e Métodos de Forma Única**: Evite usar os mesmos nomes para campos e métodos em structs embutidas.
2. **Acesso Explícito**: Quando a ambiguidade é inevitável, acesse os campos ou métodos de forma explícita usando a struct embutida.
3. **Revisão de Código**: Realize revisões de código para garantir que a ambiguidade não cause problemas de manutenção ou legibilidade.
