
Maps em Go são estruturas de dados versáteis e poderosas. Aqui está uma lista detalhada de todas as operações que você pode realizar em um map, juntamente com exemplos de código para cada operação.

>[!NOTE]
> # Operações Básicas

### Inserção de Elementos

Para adicionar um elemento a um map:

```go
myMap["foo"] = 42
```

### Recuperação de Elementos

Para recuperar um elemento de um map:

```go
value := myMap["foo"]
```

### Verificação de Existência

Para verificar se uma chave existe em um map:

```go
value, exists := myMap["foo"]
if exists {
    fmt.Println("Key exists with value:", value)
} else {
    fmt.Println("Key does not exist")
}
```

### Remoção de Elementos

Para remover um elemento de um map:

```go
delete(myMap, "foo")
```

### Tamanho do Map

Para obter o número de elementos em um map:

```go
size := len(myMap)
fmt.Println("Map size:", size)
```

### Iteração sobre um Map

Para iterar sobre todos os elementos de um map:

```go
for key, value := range myMap {
    fmt.Println("Key:", key, "Value:", value)
}
```


> [!NOTE]
> # Operações Avançadas


### Atualização de Valores

Para atualizar o valor de uma chave existente:

```go
myMap["foo"] = 43
```

### Merging de Dois Maps

Para combinar dois maps, você pode iterar sobre um e adicionar seus elementos ao outro:

```go
map1 := map[string]int{"a": 1, "b": 2}
map2 := map[string]int{"b": 3, "c": 4}

for key, value := range map2 {
    map1[key] = value
}

fmt.Println(map1) // Output: map[a:1 b:3 c:4]
```

### Copiando um Map

Para copiar um map para outro:

```go
original := map[string]int{"a": 1, "b": 2}
copy := make(map[string]int)

for key, value := range original {
    copy[key] = value
}

fmt.Println(copy) // Output: map[a:1 b:2]
```

### Comparação de Dois Maps

Para comparar se dois maps são iguais, você deve iterar sobre ambos e comparar cada par chave-valor:

```go
map1 := map[string]int{"a": 1, "b": 2}
map2 := map[string]int{"a": 1, "b": 2}
equal := true

if len(map1) != len(map2) {
    equal = false
} else {
    for key, value := range map1 {
        if value2, exists := map2[key]; !exists || value != value2 {
            equal = false
            break
        }
    }
}

fmt.Println("Maps are equal:", equal) // Output: Maps are equal: true
```

### Filtragem de Map

Para filtrar elementos de um map com base em uma condição:

```go
original := map[string]int{"a": 1, "b": 2, "c": 3}
filtered := make(map[string]int)

for key, value := range original {
    if value > 1 {
        filtered[key] = value
    }
}

fmt.Println(filtered) // Output: map[b:2 c:3]
```


> [!NOTE]
> # Restrições de Uso

- **Chaves Imutáveis**: O tipo das chaves deve ser comparável. Tipos como slices, maps e funções não podem ser usados como chaves.
- **Concorrência**: Maps não são seguros para uso concorrente. Se múltiplas goroutines precisarem acessar e modificar um map simultaneamente, é necessário sincronizar o acesso usando mecanismos como mutexes do pacote `sync`.

## Conclusão

Os maps em Go oferecem uma ampla gama de operações que facilitam a manipulação de dados de maneira eficiente e intuitiva. Entender essas operações e suas nuances permite que você utilize essa poderosa estrutura de dados de maneira eficaz em seus projetos.