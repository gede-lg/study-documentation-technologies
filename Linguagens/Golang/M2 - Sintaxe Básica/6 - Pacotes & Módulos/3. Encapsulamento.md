# Encapsulamento no Go

## O que é e para que serve?

Encapsulamento é um dos princípios fundamentais da programação orientada a objetos (OOP) e refere-se à restrição de acesso a certos componentes de um objeto, com o objetivo de proteger a integridade dos dados e evitar interações indesejadas. Em Go, embora a linguagem não suporte a OOP tradicional como em Java ou C#, ela implementa o conceito de encapsulamento através de visibilidade de nomes (exportados e não exportados).

### Para que serve?
- **Proteção de dados**: Restringir o acesso direto aos dados internos de um objeto ajuda a garantir que eles sejam modificados apenas por meio de métodos controlados.
- **Abstração**: Permitir que os usuários de um tipo interajam com ele sem precisar conhecer os detalhes internos de sua implementação.
- **Manutenção**: Facilitar a manutenção do código, pois as mudanças nos detalhes internos de uma implementação não afetam os usuários desse tipo.
- **Modularidade**: Melhorar a modularidade do código ao definir interfaces claras entre diferentes partes de um programa.

## Como funciona?

Em Go, o encapsulamento é alcançado utilizando a convenção de nomenclatura:
- **Exportado**: Nomes que começam com uma letra maiúscula são exportados e visíveis fora do pacote em que são definidos.
- **Não exportado**: Nomes que começam com uma letra minúscula são privados e visíveis apenas dentro do pacote em que são definidos.

## Sintaxe de uso

### Estruturas e Campos

Definindo uma estrutura com campos exportados e não exportados:

```go
package main

import "fmt"

// Pessoa é uma estrutura exportada
type Pessoa struct {
    Nome     string // Campo exportado
    idade    int    // Campo não exportado
}

// NovaPessoa é uma função exportada que cria uma nova pessoa
func NovaPessoa(nome string, idade int) *Pessoa {
    return &Pessoa{
        Nome:  nome,
        idade: idade,
    }
}

// Método exportado para obter a idade
func (p *Pessoa) GetIdade() int {
    return p.idade
}

// Método exportado para definir a idade
func (p *Pessoa) SetIdade(idade int) {
    if idade > 0 {
        p.idade = idade
    }
}

func main() {
    pessoa := NovaPessoa("João", 30)
    fmt.Println("Nome:", pessoa.Nome)          // Acesso permitido
    fmt.Println("Idade:", pessoa.GetIdade())   // Acesso permitido através de método
    pessoa.SetIdade(35)
    fmt.Println("Nova Idade:", pessoa.GetIdade())
}
```

### Funções e Métodos

Definindo funções e métodos com visibilidade controlada:

```go
package main

import "fmt"

// Carro é uma estrutura exportada
type Carro struct {
    Modelo string // Campo exportado
    ano    int    // Campo não exportado
}

// novaCarro é uma função não exportada que cria um novo carro
func novaCarro(modelo string, ano int) *Carro {
    return &Carro{
        Modelo: modelo,
        ano:    ano,
    }
}

// Método exportado para obter o ano
func (c *Carro) GetAno() int {
    return c.ano
}

// Método não exportado para definir o ano
func (c *Carro) setAno(ano int) {
    if ano > 0 {
        c.ano = ano
    }
}

func main() {
    carro := novaCarro("Fusca", 1970)
    fmt.Println("Modelo:", carro.Modelo) // Acesso permitido
    fmt.Println("Ano:", carro.GetAno())  // Acesso permitido através de método
}
```

## Restrições de uso

- **Visibilidade por Pacote**: Em Go, a visibilidade de um nome (seja uma função, variável ou estrutura) é restrita ao pacote. Nomes não exportados não podem ser acessados fora do pacote onde foram definidos.
- **Sem Modificadores de Acesso**: Go não possui modificadores de acesso como `private`, `protected`, ou `public` encontrados em outras linguagens orientadas a objetos. A visibilidade é determinada unicamente pela capitalização do nome.
- **Acesso Direto**: Campos não exportados não podem ser acessados diretamente fora do pacote, mas podem ser manipulados através de métodos exportados.

## Quando utilizar?

- **Proteção de dados internos**: Quando há a necessidade de garantir que os dados de uma estrutura não sejam alterados de forma direta e incontrolada.
- **Fornecer uma API clara**: Quando deseja expor apenas a interface necessária de um pacote ou tipo, escondendo detalhes de implementação.
- **Controlar o fluxo de dados**: Quando é necessário validar ou processar dados antes de armazená-los ou modificá-los dentro de uma estrutura.

## Exemplos adicionais

### Exemplo de um tipo com métodos para acesso controlado

```go
package main

import "fmt"

// ContaBancaria é uma estrutura exportada que representa uma conta bancária
type ContaBancaria struct {
    titular string
    saldo   float64
}

// NovaConta é uma função exportada que cria uma nova conta bancária
func NovaConta(titular string, saldoInicial float64) *ContaBancaria {
    return &ContaBancaria{
        titular: titular,
        saldo:   saldoInicial,
    }
}

// Método exportado para obter o saldo
func (c *ContaBancaria) GetSaldo() float64 {
    return c.saldo
}

// Método exportado para depositar dinheiro
func (c *ContaBancaria) Depositar(valor float64) {
    if valor > 0 {
        c.saldo += valor
    }
}

// Método exportado para sacar dinheiro
func (c *ContaBancaria) Sacar(valor float64) bool {
    if valor > 0 && valor <= c.saldo {
        c.saldo -= valor
        return true
    }
    return false
}

func main() {
    conta := NovaConta("Maria", 1000)
    fmt.Println("Saldo inicial:", conta.GetSaldo())

    conta.Depositar(500)
    fmt.Println("Saldo após depósito:", conta.GetSaldo())

    if conta.Sacar(200) {
        fmt.Println("Saldo após saque:", conta.GetSaldo())
    } else {
        fmt.Println("Saque falhou")
    }
}
```

Este exemplo mostra como o encapsulamento pode ser utilizado para controlar o acesso aos dados de uma conta bancária, permitindo depósitos e saques apenas através de métodos que garantem a integridade do saldo.

### Considerações finais

O encapsulamento em Go é simples e eficaz, baseado na convenção de nomenclatura de letras maiúsculas e minúsculas. Ele permite criar APIs claras e seguras, garantindo que os detalhes internos de uma implementação sejam escondidos e protegidos. A prática do encapsulamento é fundamental para escrever código Go que seja fácil de manter, entender e evoluir.