# Generics no Go

## O Que É e Para Que Serve?

Generics no Go permitem a definição de funções, tipos e estruturas que podem operar com qualquer tipo de dado, fornecendo maior flexibilidade e reusabilidade de código. Antes da introdução de generics, desenvolvedores frequentemente usavam a interface vazia `interface{}` e faziam type assertions, o que pode ser propenso a erros e menos eficiente. Com generics, é possível escrever código mais seguro e eficiente, especificando que funções ou tipos podem operar em qualquer tipo que atenda a certas restrições.

## Como Funciona?

Generics funcionam através do uso de parâmetros de tipo. Estes parâmetros são especificados entre colchetes `[]` e podem ser usados em funções, métodos, estruturas e interfaces. Ao definir um parâmetro de tipo, você pode aplicar restrições a ele, como garantir que ele implemente uma certa interface ou seja um tipo específico.

### Sintaxe de Uso

A sintaxe básica para definir generics em Go é a seguinte:

### Definindo Funções Genéricas

```go
func NomeDaFuncao[T any](parametro T) T {
    // implementação
    return parametro
}
```

### Definindo Estruturas Genéricas

```go
type NomeDaEstrutura[T any] struct {
    campo T
}
```

### Definindo Métodos Genéricos

```go
func (r Recebedor[T]) NomeDoMetodo(parametro T) T {
    // implementação
    return parametro
}
```

### Exemplo Completo

Vamos considerar um exemplo completo onde definimos uma função genérica, uma estrutura genérica e um método genérico.

#### Função Genérica

```go
// Função genérica que retorna o maior entre dois valores
func Max[T comparable](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

#### Estrutura Genérica

```go
// Estrutura genérica para uma pilha
type Stack[T any] struct {
    items []T
}

// Método para adicionar um item à pilha
func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

// Método para remover um item da pilha
func (s *Stack[T]) Pop() T {
    if len(s.items) == 0 {
        var zero T
        return zero
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}
```

### Uso dos Generics

```go
func main() {
    // Uso da função genérica
    fmt.Println(Max(3, 4))           // Saída: 4
    fmt.Println(Max("a", "b"))       // Saída: b

    // Uso da estrutura genérica
    stack := Stack[int]{}
    stack.Push(10)
    stack.Push(20)
    fmt.Println(stack.Pop())         // Saída: 20
    fmt.Println(stack.Pop())         // Saída: 10
}
```

## Restrições de Uso

- **Tipos Componíveis**: Os parâmetros de tipo podem ser restritos a tipos que implementam certas interfaces ou que são componentes de certos tipos.
  ```go
  type Constraint interface {
      Method()
  }

  func GenericFunc[T Constraint](param T) {
      param.Method()
  }
  ```

- **Operadores**: Alguns operadores (como `+`, `-`, `*`, `/`) só podem ser usados com tipos que suportam esses operadores.
  ```go
  func Add[T int | float64](a, b T) T {
      return a + b
  }
  ```

- **Uso com Structs**: Generics podem ser usados em structs, mas as instâncias dessas structs devem ser tipadas corretamente quando usadas.
  ```go
  type Pair[T any, U any] struct {
      first  T
      second U
  }
  ```

## Quando Utilizar?

- **Reusabilidade**: Quando você tem funções ou tipos que operam de maneira semelhante em múltiplos tipos de dados.
- **Segurança de Tipo**: Quando você quer evitar o uso de `interface{}` e type assertions, proporcionando segurança de tipo em tempo de compilação.
- **Eficiência**: Para evitar o overhead de conversões de tipo e garantir que o código seja eficiente.

### Exemplo Prático

Um exemplo prático de uso de generics é a implementação de uma função genérica que encontra o mínimo e o máximo em um slice.

```go
func MinMax[T comparable](slice []T) (T, T) {
    if len(slice) == 0 {
        var zero T
        return zero, zero
    }

    min, max := slice[0], slice[0]
    for _, v := range slice[1:] {
        if v < min {
            min = v
        }
        if v > max {
            max = v
        }
    }
    return min, max
}

func main() {
    numbers := []int{3, 1, 4, 1, 5, 9}
    min, max := MinMax(numbers)
    fmt.Printf("Min: %d, Max: %d\n", min, max)

    strings := []string{"apple", "orange", "banana"}
    minStr, maxStr := MinMax(strings)
    fmt.Printf("Min: %s, Max: %s\n", minStr, maxStr)
}
```

### Conclusão

Generics em Go são uma poderosa adição à linguagem, permitindo a criação de código mais flexível, reutilizável e seguro. Com a capacidade de definir funções, tipos e estruturas que operam em múltiplos tipos de dados, os desenvolvedores podem escrever bibliotecas e aplicações mais versáteis. A compreensão e o uso eficaz de generics são essenciais para tirar o máximo proveito do Go em projetos modernos.