
O pacote `encoding/json` do Go fornece funcionalidades para codificar e decodificar dados em JSON (JavaScript Object Notation). Este pacote é essencial para trabalhar com dados JSON em Go, sendo amplamente utilizado em desenvolvimento web, APIs e aplicações que requerem a troca de dados em formato JSON.

Abaixo, uma explicação detalhada sobre várias funções importantes desse pacote.

> [!NOTE]
> # Compact

### O que é e para que serve?

A função `Compact` compacta dados JSON, removendo todos os espaços em branco desnecessários, incluindo espaços, tabs e quebras de linha. Isso é útil para reduzir o tamanho de dados JSON, tornando a transmissão de dados mais eficiente.

### Sintaxe

```go
func Compact(dst *bytes.Buffer, src []byte) error
```

### Exemplos de Código

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
)

func main() {
    src := []byte(`{
        "name": "John",
        "age": 30,
        "city": "New York"
    }`)

    var dst bytes.Buffer
    err := json.Compact(&dst, src)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Compact JSON:", dst.String())
}
```

### Detalhes Importantes

- `dst` é um buffer onde os dados compactados serão escritos.
- `src` é um slice de bytes que contém os dados JSON originais.
- Retorna um erro caso o JSON de entrada seja inválido.

> [!NOTE]
> # HTMLEscape

### O que é e para que serve?
A função `HTMLEscape` escapa caracteres especiais em dados JSON para que possam ser incluídos de forma segura em HTML. Isso ajuda a prevenir ataques de Cross-Site Scripting (XSS) ao renderizar dados JSON em páginas web.

### Sintaxe

```go
func HTMLEscape(dst *bytes.Buffer, src []byte)
```

### Exemplos de Código

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
)

func main() {
    src := []byte(`{"name": "<script>alert('xss')</script>"}`)
    var dst bytes.Buffer
    json.HTMLEscape(&dst, src)
    fmt.Println("Escaped JSON:", dst.String())
}
```

### Detalhes Importantes

- `dst` é um buffer onde os dados escapados serão escritos.
- `src` é um slice de bytes que contém os dados JSON originais.
- Não retorna erro, pois o escapamento HTML sempre será bem-sucedido.

> [!NOTE]
> # Indent

### O que é e para que serve?

A função `Indent` formata dados JSON com indentação, adicionando espaços em branco para melhorar a legibilidade. Isso é útil para exibir JSON de forma organizada e fácil de ler.

### Sintaxe

```go
func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
```

### Exemplos de Código

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
)

func main() {
    src := []byte(`{"name":"John","age":30,"city":"New York"}`)
    var dst bytes.Buffer
    err := json.Indent(&dst, src, "", "    ")
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Indented JSON:", dst.String())
}
```

### Detalhes Importantes

- `dst` é um buffer onde os dados indentados serão escritos.
- `src` é um slice de bytes que contém os dados JSON originais.
- `prefix` é uma string adicionada no início de cada linha.
- `indent` é a string usada para indentação.
- Retorna um erro caso o JSON de entrada seja inválido.

> [!NOTE]
> # Marshal

### O que é e para que serve?

A função `Marshal` converte uma variável Go para JSON. É usada para serializar estruturas, mapas, slices e outros tipos em formato JSON.

### Sintaxe

```go
func Marshal(v any) ([]byte, error)
```

### Exemplos de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
    City string `json:"city"`
}

func main() {
    person := Person{Name: "John", Age: 30, City: "New York"}
    jsonData, err := json.Marshal(person)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("JSON Data:", string(jsonData))
}
```

### Detalhes Importantes

- `v` é a variável a ser serializada.
- Retorna um slice de bytes contendo os dados JSON e um erro caso ocorra algum problema durante a serialização.

> [!NOTE]
> # MarshalIndent

### O que é e para que serve?

A função `MarshalIndent` funciona de maneira similar a `Marshal`, mas formata o JSON resultante com indentação para melhorar a legibilidade.

### Sintaxe

```go
func MarshalIndent(v any, prefix, indent string) ([]byte, error)
```

### Exemplos de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
    City string `json:"city"`
}

func main() {
    person := Person{Name: "John", Age: 30, City: "New York"}
    jsonData, err := json.MarshalIndent(person, "", "    ")
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Indented JSON Data:", string(jsonData))
}
```

### Detalhes Importantes

- `v` é a variável a ser serializada.
- `prefix` é uma string adicionada no início de cada linha.
- `indent` é a string usada para indentação.
- Retorna um slice de bytes contendo os dados JSON formatados e um erro caso ocorra algum problema durante a serialização.

> [!NOTE]
> # Unmarshal

### O que é e para que serve?

A função `Unmarshal` converte dados JSON em uma variável Go. É usada para desserializar JSON em estruturas, mapas, slices e outros tipos.

### Sintaxe

```go
func Unmarshal(data []byte, v any) error
```

### Exemplos de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
    City string `json:"city"`
}

func main() {
    jsonData := []byte(`{"name":"John","age":30,"city":"New York"}`)
    var person Person
    err := json.Unmarshal(jsonData, &person)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Printf("Unmarshaled Person: %+v\n", person)
}
```

### Detalhes Importantes

- `data` é um slice de bytes contendo os dados JSON.
- `v` é um ponteiro para a variável onde os dados desserializados serão armazenados.
- Retorna um erro caso o JSON de entrada seja inválido ou não corresponda ao tipo da variável.

> [!NOTE]
> # Valid

### O que é e para que serve?

A função `Valid` verifica se um slice de bytes contém JSON válido. É útil para validar dados JSON antes de tentar desserializá-los.

### Sintaxe

```go
func Valid(data []byte) bool
```

### Exemplos de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

func main() {
    jsonData := []byte(`{"name":"John","age":30,"city":"New York"}`)
    isValid := json.Valid(jsonData)
    fmt.Println("Is JSON valid?", isValid)
}
```

### Detalhes Importantes

- `data` é um slice de bytes contendo os dados JSON.
- Retorna `true` se o JSON for válido e `false` caso contrário.

## Conclusão

O pacote `encoding/json` do Go oferece uma ampla gama de funções para trabalhar com dados JSON, desde compactação e formatação até serialização e desserialização. Utilizando essas funções, você pode manipular JSON de forma eficiente e segura em suas aplicações Go.