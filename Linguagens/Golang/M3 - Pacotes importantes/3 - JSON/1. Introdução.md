


## O que é e para que serve?

JSON (JavaScript Object Notation) é um formato leve de intercâmbio de dados que é fácil para os humanos lerem e escreverem, e fácil para máquinas analisarem e gerarem. JSON é frequentemente usado para transmitir dados em aplicativos web (por exemplo, entre um servidor e um cliente web).

No Go, o pacote `encoding/json` é utilizado para codificar (serializar) e decodificar (desserializar) dados JSON. Ele permite que desenvolvedores convertam dados entre tipos de dados Go e JSON de maneira eficiente e fácil.

- link: [encoding/JSON - Go Packages](https://pkg.go.dev/encoding/json#pkg-overview)
## Tudo que você precisa saber sobre o pacote `encoding/json`

### Importando o Pacote

Para usar o pacote `encoding/json`, você precisa importá-lo no seu código:

```go
import "encoding/json"
```

### Funções Principais

#### `json.Marshal`
Codifica valores Go em JSON. Esta função é usada para transformar tipos de dados Go em representações JSON.

**Sintaxe:**
```go
func Marshal(v interface{}) ([]byte, error)
```

**Exemplo:**
```go
type Pessoa struct {
    Nome  string
    Idade int
}

p := Pessoa{Nome: "João", Idade: 30}
jsonData, err := json.Marshal(p)
if err != nil {
    log.Fatal(err)
}
fmt.Println(string(jsonData))
```
Saída:
```json
{"Nome":"João","Idade":30}
```

#### `json.Unmarshal`
Decodifica dados JSON em valores Go. Esta função é usada para transformar JSON em tipos de dados Go.

**Sintaxe:**
```go
func Unmarshal(data []byte, v interface{}) error
```

**Exemplo:**
```go
jsonData := []byte(`{"Nome":"João","Idade":30}`)
var p Pessoa
err := json.Unmarshal(jsonData, &p)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("%+v\n", p)
```
Saída:
```
{Nome:João Idade:30}
```

### Tags JSON
As tags JSON são usadas para controlar como os campos de structs Go são codificados e decodificados para JSON.

**Exemplo:**
```go
type Pessoa struct {
    Nome  string `json:"nome"`
    Idade int    `json:"idade,omitempty"`
    Senha string `json:"-"`
}
```
- `json:"nome"`: Renomeia o campo "Nome" para "nome" no JSON.
- `json:"idade,omitempty"`: O campo "idade" será omitido do JSON se for vazio (zero valor).
- `json:"-"`: O campo "Senha" será completamente ignorado na codificação JSON.

### Tipos de Dados Suportados
O pacote `encoding/json` suporta os seguintes tipos de dados Go:
- Tipos básicos: `string`, `bool`, `int`, `float64`, etc.
- Arrays e slices
- Maps com chaves de tipo `string`
- Structs
- Pointers para qualquer um dos tipos acima

### Customização de Codificação e Decodificação
Você pode customizar a codificação e decodificação implementando as interfaces `json.Marshaler` e `json.Unmarshaler`.

**Exemplo:**
```go
type Pessoa struct {
    Nome  string
    Idade int
}

func (p Pessoa) MarshalJSON() ([]byte, error) {
    type Alias Pessoa
    return json.Marshal(&struct {
        Alias
        NomeMaiusculo string `json:"nome_maiusculo"`
    }{
        Alias:         (Alias)(p),
        NomeMaiusculo: strings.ToUpper(p.Nome),
    })
}

p := Pessoa{Nome: "João", Idade: 30}
jsonData, err := json.Marshal(p)
if err != nil {
    log.Fatal(err)
}
fmt.Println(string(jsonData))
```
Saída:
```json
{"Nome":"João","Idade":30,"nome_maiusculo":"JOÃO"}
```

### Tratamento de Erros
Sempre verifique os erros retornados pelas funções `json.Marshal` e `json.Unmarshal` para garantir que a codificação e decodificação ocorra corretamente.

**Exemplo:**
```go
jsonData, err := json.Marshal(p)
if err != nil {
    log.Fatalf("Erro ao codificar JSON: %s", err)
}

err = json.Unmarshal(jsonData, &p)
if err != nil {
    log.Fatalf("Erro ao decodificar JSON: %s", err)
}
```

### Trabalhando com JSON Raw Messages
O tipo `json.RawMessage` permite adiar a decodificação de JSON ou pré-processar uma mensagem JSON.

**Exemplo:**
```go
type Envelope struct {
    Tipo    string          `json:"tipo"`
    Conteudo json.RawMessage `json:"conteudo"`
}

var e Envelope
err := json.Unmarshal([]byte(`{"tipo":"pessoa","conteudo":{"Nome":"João","Idade":30}}`), &e)
if err != nil {
    log.Fatal(err)
}

switch e.Tipo {
case "pessoa":
    var p Pessoa
    err = json.Unmarshal(e.Conteudo, &p)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Pessoa: %+v\n", p)
}
```

### Codificação e Decodificação em Streams
Para codificar ou decodificar JSON diretamente de streams (como arquivos ou conexões de rede), use os tipos `json.Encoder` e `json.Decoder`.

**Exemplo:**
```go
// Encoder
file, _ := os.Create("pessoa.json")
encoder := json.NewEncoder(file)
p := Pessoa{Nome: "João", Idade: 30}
encoder.Encode(p)

// Decoder
file, _ = os.Open("pessoa.json")
decoder := json.NewDecoder(file)
var p Pessoa
decoder.Decode(&p)
fmt.Printf("%+v\n", p)
```

## Considerações Finais

O pacote `encoding/json` é uma ferramenta poderosa para trabalhar com JSON em Go. Ele fornece funções e interfaces para uma ampla variedade de operações, desde codificação e decodificação básicas até customizações avançadas. Compreender como utilizar estas funcionalidades pode facilitar significativamente o trabalho com dados JSON em suas aplicações Go.

### Recursos Adicionais
- [Documentação Oficial do Pacote encoding/json](https://pkg.go.dev/encoding/json)
- [Effective Go](https://golang.org/doc/effective_go.html)
- [JSON and Go](https://blog.golang.org/json-and-go) (Artigo do Blog Oficial de Go)