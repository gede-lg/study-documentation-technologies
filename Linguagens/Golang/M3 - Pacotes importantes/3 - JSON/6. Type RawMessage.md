
No Go, a manipulação de dados JSON é facilitada pelo pacote `encoding/json`, que fornece várias funcionalidades para codificação e decodificação de dados JSON. Entre as estruturas e funções importantes estão `RawMessage`, `MarshalJSON` e `UnmarshalJSON`. Vamos explorar cada uma dessas funcionalidades em detalhe.

### O Que é e Para Que Serve?

`RawMessage` é um tipo definido no pacote `encoding/json`. Ele representa um pedaço de dados JSON não processados. Usar `RawMessage` permite adiar a análise de parte dos dados JSON ou preservar a representação original do JSON sem alterá-la.

### Sintaxe de Uso

```go
type RawMessage []byte
```

### Restrições de Uso

- `RawMessage` é apenas um alias para `[]byte`, então ele não fornece métodos adicionais além dos métodos já disponíveis para `[]byte`.
- Não faz análise automática do JSON; é necessário usar `json.Unmarshal` para converter a mensagem bruta em um tipo Go específico.

### Quando Utilizar?

- Quando você deseja adiar a análise de parte do JSON até um momento posterior.
- Quando você precisa manipular ou transmitir dados JSON sem analisá-los completamente.
- Em casos onde a estrutura do JSON pode variar ou não é totalmente conhecida antecipadamente.

### Exemplo de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Message struct {
    Name json.RawMessage `json:"name"`
    Age  int             `json:"age"`
}

func main() {
    data := []byte(`{"name": {"first": "John", "last": "Doe"}, "age": 30}`)
    var msg Message
    err := json.Unmarshal(data, &msg)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Raw JSON Name:", string(msg.Name))
    
    var name map[string]string
    err = json.Unmarshal(msg.Name, &name)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Parsed Name:", name)
}
```

> [!NOTE] Método
> # MarshalJSON

### O Que é e Para Que Serve?

`MarshalJSON` é um método que permite definir como uma instância de `RawMessage` deve ser convertida em JSON. Ele é parte da interface `json.Marshaler`.

### Sintaxe de Uso

```go
func (m RawMessage) MarshalJSON() ([]byte, error)
```

### Restrições de Uso

- Como `RawMessage` já é um `[]byte`, seu método `MarshalJSON` geralmente só retorna os dados como estão.
- Não é frequentemente necessário redefinir esse método para `RawMessage`, pois o comportamento padrão já é apropriado.

### Quando Utilizar?

- Quando se deseja personalizar a serialização JSON de uma estrutura que inclui `RawMessage`.
- Em situações onde se precisa garantir que os dados JSON originais sejam preservados ao serem enviados.

### Exemplo de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Message struct {
    Name json.RawMessage `json:"name"`
    Age  int             `json:"age"`
}

func main() {
    msg := Message{
        Name: json.RawMessage(`{"first": "John", "last": "Doe"}`),
        Age:  30,
    }

    data, err := json.Marshal(msg)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Serialized JSON:", string(data))
}
```

> [!NOTE] Método
> # UnmarshalJSON

### O Que é e Para Que Serve?

`UnmarshalJSON` é um método que permite definir como uma instância de `RawMessage` deve ser populada a partir de dados JSON. Ele é parte da interface `json.Unmarshaler`.

### Sintaxe de Uso

```go
func (m *RawMessage) UnmarshalJSON(data []byte) error
```

### Restrições de Uso

- Este método é geralmente usado como está para `RawMessage`, pois simplesmente armazena os dados JSON brutos.
- O método espera um ponteiro para `RawMessage`, então deve ser chamado em uma variável que é um ponteiro para `RawMessage`.

### Quando Utilizar?

- Quando se precisa customizar a desserialização de JSON em uma estrutura que contém `RawMessage`.
- Quando se deseja armazenar a representação bruta de uma parte do JSON para posterior análise.

### Exemplo de Código

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Message struct {
    Name json.RawMessage `json:"name"`
    Age  int             `json:"age"`
}

func main() {
    data := []byte(`{"name": {"first": "John", "last": "Doe"}, "age": 30}`)
    var msg Message
    err := json.Unmarshal(data, &msg)
    if err != nil {
        fmt.Println("Error:", err)
    }

    fmt.Println("Raw JSON Name:", string(msg.Name))
}
```

## Considerações Finais

Usar `RawMessage` é útil em cenários onde a flexibilidade e o controle sobre a análise de dados JSON são necessários. Os métodos `MarshalJSON` e `UnmarshalJSON` proporcionam um controle adicional sobre como os dados são convertidos para e a partir de JSON. Compreender esses conceitos pode ser essencial para trabalhar com APIs complexas ou dados JSON dinâmicos.