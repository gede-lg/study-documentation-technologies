# Pacote `os` no Go

## O que é e para que serve?

O pacote `os` no Go fornece uma interface para funcionalidades do sistema operacional independentes da plataforma, permitindo que programas Go interajam com o sistema de arquivos, manipulem processos e realizem outras operações do sistema operacional. Ele é essencial para operações que envolvem arquivos, diretórios, variáveis de ambiente, e controle de processos.

## Principais Funcionalidades

### 1. Manipulação de Arquivos

#### Abertura de Arquivos

```go
file, err := os.Open("example.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close()
```

- `os.Open(name string) (*os.File, error)`: Abre um arquivo somente para leitura.
- `os.OpenFile(name string, flag int, perm os.FileMode) (*os.File, error)`: Abre um arquivo com as permissões especificadas.

#### Criação de Arquivos

```go
file, err := os.Create("example.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close()
```

- `os.Create(name string) (*os.File, error)`: Cria um arquivo novo ou trunca um arquivo existente.

#### Fechamento de Arquivos

```go
err := file.Close()
if err != nil {
    log.Fatal(err)
}
```

- `(*File).Close() error`: Fecha o arquivo, liberando qualquer recurso associado a ele.

#### Leitura e Escrita

```go
data := make([]byte, 100)
count, err := file.Read(data)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("read %d bytes: %q\n", count, data[:count])

_, err = file.Write([]byte("Hello, World!"))
if err != nil {
    log.Fatal(err)
}
```

- `(*File).Read(b []byte) (n int, err error)`: Lê até len(b) bytes do arquivo.
- `(*File).Write(b []byte) (n int, err error)`: Escreve len(b) bytes no arquivo.

### 2. Manipulação de Diretórios

#### Criação e Remoção de Diretórios

```go
err := os.Mkdir("example_dir", 0755)
if err != nil {
    log.Fatal(err)
}

err = os.Remove("example_dir")
if err != nil {
    log.Fatal(err)
}
```

- `os.Mkdir(name string, perm os.FileMode) error`: Cria um diretório com as permissões especificadas.
- `os.Remove(name string) error`: Remove um arquivo ou diretório.

#### Alteração de Diretório

```go
err := os.Chdir("/path/to/dir")
if err != nil {
    log.Fatal(err)
}
```

- `os.Chdir(dir string) error`: Muda o diretório de trabalho atual para dir.

### 3. Informações sobre Arquivos e Diretórios

#### Estatísticas de Arquivos

```go
fileInfo, err := os.Stat("example.txt")
if err != nil {
    log.Fatal(err)
}
fmt.Println("File Name:", fileInfo.Name())
fmt.Println("Size in bytes:", fileInfo.Size())
fmt.Println("Permissions:", fileInfo.Mode())
fmt.Println("Last Modified:", fileInfo.ModTime())
fmt.Println("Is Directory: ", fileInfo.IsDir())
```

- `os.Stat(name string) (os.FileInfo, error)`: Retorna informações sobre o arquivo especificado.
- `os.FileInfo`: Interface que descreve um arquivo e é retornada por Stat.

### 4. Variáveis de Ambiente

#### Leitura e Definição de Variáveis

```go
value := os.Getenv("HOME")
fmt.Println("HOME:", value)

err := os.Setenv("MY_VAR", "my_value")
if err != nil {
    log.Fatal(err)
}

os.Unsetenv("MY_VAR")
```

- `os.Getenv(key string) string`: Retorna o valor da variável de ambiente especificada.
- `os.Setenv(key, value string) error`: Define a variável de ambiente para o valor especificado.
- `os.Unsetenv(key string) error`: Remove a variável de ambiente especificada.

#### Listagem de Variáveis

```go
envVars := os.Environ()
for _, env := range envVars {
    fmt.Println(env)
}
```

- `os.Environ() []string`: Retorna uma cópia do ambiente como uma lista de strings no formato "key=value".

### 5. Processos

#### Execução de Comandos

```go
cmd := exec.Command("ls", "-l")
output, err := cmd.Output()
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Output: %s\n", output)
```

- `os/exec`: Pacote que fornece funções para executar comandos externos.
- `exec.Command(name string, arg ...string) *exec.Cmd`: Cria um comando para ser executado.

#### Controle de Processos

```go
procAttr := os.ProcAttr{
    Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},
}

proc, err := os.StartProcess("/bin/ls", []string{"-l"}, &procAttr)
if err != nil {
    log.Fatal(err)
}

state, err := proc.Wait()
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Process exited with state: %v\n", state)
```

- `os.StartProcess(name string, argv []string, attr *os.ProcAttr) (*os.Process, error)`: Inicia um novo processo.

### 6. Sinais

#### Manipulação de Sinais

```go
signalChan := make(chan os.Signal, 1)
signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)

sig := <-signalChan
fmt.Println("Received signal:", sig)
```

- `os/signal`: Pacote que fornece funções para manipular sinais recebidos pelo processo.
- `signal.Notify(c chan<- os.Signal, sig ...os.Signal)`: Redireciona sinais específicos para um canal.

## Exemplo de Uso Completo

Aqui está um exemplo que combina várias funcionalidades do pacote `os`:

```go
package main

import (
    "fmt"
    "log"
    "os"
    "os/signal"
    "syscall"
)

func main() {
    // Criação de um arquivo
    file, err := os.Create("example.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()

    // Escrita no arquivo
    _, err = file.Write([]byte("Hello, World!"))
    if err != nil {
        log.Fatal(err)
    }

    // Leitura do arquivo
    data := make([]byte, 100)
    file.Seek(0, 0)
    count, err := file.Read(data)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Read %d bytes: %s\n", count, data[:count])

    // Informações sobre o arquivo
    fileInfo, err := os.Stat("example.txt")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("File Name:", fileInfo.Name())
    fmt.Println("Size in bytes:", fileInfo.Size())
    fmt.Println("Permissions:", fileInfo.Mode())
    fmt.Println("Last Modified:", fileInfo.ModTime())
    fmt.Println("Is Directory: ", fileInfo.IsDir())

    // Manipulação de variáveis de ambiente
    home := os.Getenv("HOME")
    fmt.Println("HOME:", home)

    err = os.Setenv("MY_VAR", "my_value")
    if err != nil {
        log.Fatal(err)
    }

    // Listagem de variáveis de ambiente
    envVars := os.Environ()
    for _, env := range envVars {
        fmt.Println(env)
    }

    // Manipulação de sinais
    signalChan := make(chan os.Signal, 1)
    signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)

    fmt.Println("Waiting for signal")
    sig := <-signalChan
    fmt.Println("Received signal:", sig)
}
```

Este exemplo cobre criação e manipulação de arquivos, leitura e definição de variáveis de ambiente, e manipulação de sinais, mostrando a versatilidade e importância do pacote `os` no desenvolvimento de aplicações Go.

## Conclusão

O pacote `os` no Go é uma ferramenta poderosa que permite interagir com o sistema operacional de forma independente da plataforma. Com ele, é possível realizar operações fundamentais para qualquer aplicação, como manipulação de arquivos e diretórios, gerenciamento de variáveis de ambiente, execução de comandos externos e manipulação de sinais. Conhecer e entender este pacote é essencial para desenvolver aplicações robustas e eficientes em Go.